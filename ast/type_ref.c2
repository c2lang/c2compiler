/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import src_loc local;
import string_buffer;
import stdio;
import string;

public type TypeRefKind enum u8 {
    Builtin,
    User,
    StructMemberType,
}

fn const char* TypeRefKind.str(TypeRefKind k) {
    switch (k) {
    case Builtin:   return "builtin";
    case User:      return "user";
    case StructMemberType: return "structmemberfn";
    }
    return nil;
}

type TypeRefBits struct {
    u32 is_const : 1;
    u32 is_volatile : 1;
    u32 num_ptrs : 2;   // 0 = Foo, 1 = Foo*, 2 = Foo**
    u32 num_arrays : 2; // limit to 3-dimensional arrays
    u32 incr_array : 1;
    u32 kind : 2;   // TypeRefKind
    u32 has_prefix : 1;
    u32 builtin_kind : 4;   // only if builtin (!is_user)
}

public type Ref struct {
    SrcLoc loc;
    u32 name_idx;
    Decl* decl; // set during analysis, or during parsing for StructMemberType
}

static_assert(16, sizeof(Ref));

public fn const char* Ref.getName(const Ref* r) {
    return idx2name(r.name_idx);
}

// Member of VarDecl,Sizeof and ExplicitCast; is NOT a Type!
public type TypeRef struct @(opaque, aligned=8) {
    union {
        TypeRefBits flags;
        u32 flagBits;
    }
    union {
        u32 dest;       // index into TypePool. only used by user type, but must be 8-byte aligned anyways, so put here
        SrcLoc loc;     // for non-user types only
    }
    Ref[0] refs;    // tail-allocated. [1] if is_user/struct_member_fn, [2] if also has_prefix
    //Expr*[0] arrays; // tail-allocated. [1] if Foo[..], [2] if Foo[..][..], etc
}

// just a TypeRef with all possible tail-allocated fields
public type TypeRefHolder struct {
    u64 ref;    // to make TypeRef opaque
    Ref user;
    Ref prefix;
    Expr*[3] arrays;    // Note: in order of parsing: so [4][20] -> [4] [20]
}

public fn void TypeRefHolder.init(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flagBits = 0;
    r.dest = 0;
    // can leave other members uninitialized because flags and counts are zero
}

// note: returns dynamic size only!
fn u32 TypeRefHolder.getExtraSize(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.getExtraSize();
}

public fn void TypeRefHolder.setQualifiers(TypeRefHolder* h, u32 qualifiers) {
    TypeRef* r = (TypeRef*)&h.ref;
    if (qualifiers & QualType_Volatile) r.flags.is_volatile = 1;
    if (qualifiers & QualType_Const) r.flags.is_const = 1;
}

public fn void TypeRefHolder.setConst(TypeRefHolder* h) @(unused) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.is_const = 1;
}

public fn void TypeRefHolder.setVolatile(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.is_volatile = 1;
}

public fn bool TypeRefHolder.isPointer(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.flags.num_ptrs != 0;
}

public fn void TypeRefHolder.addPointer(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    assert(r.flags.num_ptrs != 3);
    r.flags.num_ptrs++;
}

public fn bool TypeRefHolder.isIncrArray(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.flags.incr_array;
}

public fn void TypeRefHolder.setIncrArray(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.incr_array = 1;
}

public fn u32 TypeRefHolder.getNumArrays(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.getNumArrays();
}

#if 0
public fn u32 TypeRefHolder.getNumPointers(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.getNumPointers();
}
#endif

public fn bool TypeRefHolder.isArray(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.flags.num_arrays != 0;
}

public fn void TypeRefHolder.addArray(TypeRefHolder* h, Expr* array) {
    TypeRef* r = (TypeRef*)&h.ref;
    assert(r.flags.num_arrays != 3);
    h.arrays[r.flags.num_arrays] = array;
    r.flags.num_arrays++;
}

public fn void TypeRefHolder.setBuiltin(TypeRefHolder* h, BuiltinKind kind, SrcLoc loc) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.builtin_kind = kind;
    r.loc = loc;
}

public fn void TypeRefHolder.setUser(TypeRefHolder* h, SrcLoc loc, u32 name_idx) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.kind = TypeRefKind.User;
    h.user.loc = loc;
    h.user.name_idx = name_idx;
    h.user.decl = nil;
}

public fn void TypeRefHolder.setStructMemberType(TypeRefHolder* h, Decl* fd) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.kind = TypeRefKind.StructMemberType;
    h.user.loc = 0;
    h.user.name_idx = 0;
    h.user.decl = fd;
}

public fn void TypeRefHolder.setPrefix(TypeRefHolder* h, SrcLoc loc, u32 name_idx) {
    TypeRef* r = (TypeRef*)&h.ref;
    // Note: moves previous user to prefix and makes this the user
    h.prefix = h.user;
    r.flags.has_prefix = 1;
    h.user.loc = loc;
    h.user.name_idx = name_idx;
    h.user.decl = nil;
}

public fn void TypeRefHolder.dump(const TypeRefHolder* h) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    const TypeRef* r = (TypeRef*)&h.ref;
    r.print(out, false);
    for (u32 i=0; i<r.getNumArrays(); i++) {
        out.add1('[');
        Expr* size = h.arrays[i];
        if (size) h.arrays[i].printLiteral(out);
        out.add1(']');
    }
    ast.flushDumpBuf(out);
}



fn void TypeRef.init(TypeRef* dest, const TypeRefHolder* h) {
    const TypeRef* r = (TypeRef*)&h.ref;
    *dest = *r; // copy base members

    // copy for tail-allocated info
    switch (r.getKind()) {
    case Builtin:
        break;
    case User:
        dest.refs[0] = h.user;
        if (r.hasPrefix()) dest.refs[1] = h.prefix;
        break;
    case StructMemberType:
        dest.refs[0] = h.user;
        break;
    }

    for (u32 i=0; i<r.flags.num_arrays; i++) {
        Expr** a = dest.getArray2(i);
        *a = h.arrays[i];
    }
}

fn bool TypeRef.matchesTemplate(const TypeRef* r, u32 template_arg) {
    if (r.flags.kind != TypeRefKind.User || r.flags.has_prefix) return false;
    return r.refs[0].name_idx == template_arg;
}

fn void TypeRef.instantiate(TypeRef* r, const TypeRef* r1, Instantiator* inst) {
    const TypeRef* r2 = inst.ref;
    if (r1.matchesTemplate(inst.template_name)) {
        // Note: keep the srcloc intact
        // TODO enforce no prefix in template functions
        r.flagBits = r2.flagBits;
        r.dest = r2.dest;
        if (r2.flags.kind == TypeRefKind.User) {
            r.refs[0].name_idx = r2.refs[0].name_idx;
            r.refs[0].loc = r1.refs[0].loc;     // location from instance?
            r.refs[0].decl = r2.refs[0].decl;
            if (r2.flags.has_prefix) {
                r.refs[1].name_idx = r2.refs[1].name_idx;
                r.refs[1].loc = r2.refs[1].loc;
                r.refs[1].decl = r2.refs[1].decl;
            }
        }
        r.flags.is_const |= r1.flags.is_const;
        r.flags.is_volatile |= r1.flags.is_volatile;
        r.flags.num_ptrs += r1.flags.num_ptrs;

        if (inst.used_opaque && r.flags.num_ptrs == 0) {
            inst.on_opaque(r.refs[0].loc, r.refs[0].decl);
        }
    } else {
        string.memcpy(r, r1, sizeof(TypeRef) + r1.getExtraSize());
    }
}

public fn void TypeRef.setDest(TypeRef* r, u32 dest) {
    assert(r.isUser());
    r.dest = dest;
}

fn u32 TypeRef.getExtraSize(const TypeRef* r) {
    // User, StructMemberType use Ref
    u32 numrefs = (r.flags.kind != TypeRefKind.Builtin) + r.flags.has_prefix;
    u32 extra = numrefs * sizeof(Ref);
    extra += r.flags.num_arrays * sizeof(Expr*);
    return extra;
}

/*
public fn u32 TypeRef.getMaxSizeNoArray() {
    return sizeof(TypeRef) + 2 * sizeof(Ref);
}
*/

fn void* TypeRef.getPointerAfter(const TypeRef* r) {
    return (u8*)r + sizeof(TypeRef) + r.getExtraSize();
}

public fn bool TypeRef.isConst(const TypeRef* r) {
    return r.flags.is_const;
}

public fn bool TypeRef.isVolatile(const TypeRef* r) {
    return r.flags.is_volatile;
}

public fn bool TypeRef.isUser(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.User;
}

fn bool TypeRef.isBuiltin(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.Builtin;
}

public fn bool TypeRef.isStructMemberFn(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.StructMemberType;
}

public fn bool TypeRef.isVoid(const TypeRef* r) {
    return r.isBuiltin() && r.flags.num_ptrs == 0 && r.getBuiltinKind() == BuiltinKind.Void;
}

public fn bool TypeRef.isConstCharPtr(const TypeRef* r) {
    return r.flags.is_const && r.isBuiltin() && r.flags.num_ptrs == 1 &&
           r.flags.num_arrays == 0 && r.getBuiltinKind() == BuiltinKind.Char;
}

public fn bool TypeRef.isU32(const TypeRef* r) {
    return r.isBuiltin() && r.flags.num_ptrs == 0 && r.flags.num_arrays == 0 && r.getBuiltinKind() == BuiltinKind.UInt32;
}

fn bool TypeRef.hasPrefix(const TypeRef* r) {
    return r.flags.has_prefix;
}

public fn bool TypeRef.isIncrArray(const TypeRef* r) {
    return r.flags.incr_array;
}

public fn bool TypeRef.isPointerTo(const TypeRef* r, u32 ptr_idx) {
    if (r.dest != ptr_idx || ptr_idx == 0) return false;
    return (r.flags.num_ptrs == 1 && r.flags.num_arrays == 0 && r.isUser());
}

public fn BuiltinKind TypeRef.getBuiltinKind(const TypeRef* r) {
    return (BuiltinKind)r.flags.builtin_kind;
}

public fn TypeRefKind TypeRef.getKind(const TypeRef* r) {
    return (TypeRefKind)r.flags.kind;
}

public fn SrcLoc TypeRef.getLoc(const TypeRef* r) {
    switch (r.getKind()) {
    case Builtin:
        break;
    case User:
        if (r.hasPrefix()) return r.refs[1].loc;
        else return r.refs[0].loc;
    case StructMemberType:
        //TODO
        //return r.user.decl.getLoc();
        break;
    }
    return r.loc;
}

public fn bool TypeRef.isPointer(const TypeRef* r) {
    return r.flags.num_ptrs != 0;
}

public fn u32 TypeRef.getNumPointers(const TypeRef* r) {
    return r.flags.num_ptrs;
}

public fn const Ref* TypeRef.getUser(const TypeRef* r) {
    if (r.isUser()) return &r.refs[0];
    return nil;
}

public fn const Ref* TypeRef.getStructMemberType(const TypeRef* r) {
    // Note: user should test kind before
    return &r.refs[0];
}

public fn const Decl* TypeRef.getUserDecl(const TypeRef* r) {
    if (r.isUser()) return r.refs[0].decl;
    return nil;
}

public fn const Ref* TypeRef.getPrefix(const TypeRef* r) {
    if (r.flags.has_prefix) return &r.refs[1];
    return nil;
}

public fn void TypeRef.setPrefix(TypeRef* r, Decl* d) {
    r.refs[1].decl = d;
}

public fn void TypeRef.setUser(TypeRef* r, Decl* d) {
    r.refs[0].decl = d;
}

public fn bool TypeRef.isArray(const TypeRef* r) {
    return r.flags.num_arrays != 0;
}

public fn u32 TypeRef.getNumArrays(const TypeRef* r) {
    return r.flags.num_arrays;
}

public fn Expr* TypeRef.getArray(const TypeRef* r, u32 idx) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** arrays = (Expr**)ptr;
    return arrays[idx];
}

public fn Expr** TypeRef.getArray2(TypeRef* r, u32 idx) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** arrays = (Expr**)ptr;
    return &arrays[idx];
}

fn void TypeRef.printLiteral(const TypeRef* r, string_buffer.Buf* out, bool print_prefix) {
    if (r.isConst()) out.add("const ");
    if (r.isVolatile()) out.add("volatile ");

    switch ((TypeRefKind)r.flags.kind) {
    case Builtin:
        out.add(builtinType_names[r.flags.builtin_kind]);
        break;
    case User:
        Decl* d = r.refs[0].decl;
        assert(d);
        if (print_prefix) {
            out.add(d.getFullName());
        } else {
            out.add(d.getName());
        }
        break;
    case StructMemberType:
        out.add("FN TODO");
        // TODO
        break;
    }

    for (u32 i=0; i<r.flags.num_ptrs; i++) out.add1('*');

    if (r.flags.incr_array) out.add("[+]");

    for (u32 i = 0; i < r.flags.num_arrays; i++) {
        out.add1('[');
        const Expr* a = r.getArray(i);
        // note: a can be nil, when[]
        if (a) a.printLiteral(out);
        out.add1(']');
    }
}

fn void TypeRef.print(const TypeRef* r, string_buffer.Buf* out, bool filled) {
    // eg. const test.Foo*[10]

    out.color(col_Error);
    if (r.isConst()) out.add("const ");
    if (r.isVolatile()) out.add("volatile ");

    switch ((TypeRefKind)r.flags.kind) {
    case Builtin:
        out.add(builtinType_names[r.flags.builtin_kind]);
        break;
    case User:
        if (r.flags.has_prefix) {
            out.add(idx2name(r.refs[1].name_idx));
            out.add1('.');
        }
        out.add(idx2name(r.refs[0].name_idx));
        break;
    case StructMemberType:
        out.add("fn ");
        assert(r.refs[0].decl);
        const FunctionDecl* fd = (FunctionDecl*)r.refs[0].decl;
        fd.printType(out);
        break;
    }

    for (u32 i=0; i<r.flags.num_ptrs; i++) out.add1('*');

    if (r.flags.incr_array) {
        out.add("[+]");
    }

    if (filled) {
        // Note: we can iterate normal way here, since we just print
        for (u32 i=0; i<r.flags.num_arrays; i++) {
            out.add1('[');
            const Expr* a = r.getArray(i);
            // note: a can be nil, when[]
            if (a) a.printLiteral(out);
            out.add1(']');
        }
    }
}

// Note: only use on filled TypeRef
public fn void TypeRef.dump(const TypeRef* r) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    r.print(out, true);
    ast.flushDumpBuf(out);
}

// Note: only use on filled TypeRef
public fn void TypeRef.dump_full(const TypeRef* r) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    out.add("TypeRef:\n");
    out.indent(1);
    out.add("flags:");
    if (r.flags.is_const) out.add(" const");
    out.print(" ptrs=%d", r.flags.num_ptrs);
    out.print(" kind=%s", TypeRefKind.str((TypeRefKind)r.flags.kind));
    out.print(" has_prefix=%d", r.flags.has_prefix);
    out.newline();
    out.indent(1);
    out.print("dest %d\n", r.dest);
    u32 num_refs = 0;
    if (r.isUser()) num_refs++;
    if (r.flags.has_prefix) num_refs++;
    for (u32 i=0; i<num_refs; i++) {
        out.indent(1);
        const Ref* ref = &r.refs[i];
        out.print("ref[%d] loc %d  name_idx %d  decl %p\n", i, ref.loc, ref.name_idx, ref.decl);
    }
    ast.flushDumpBuf(out);
}

public fn const char* TypeRef.diagName(const TypeRef* r) {
    local char[128] result;
    string_buffer.Buf buf.init(result, elemsof(result), false, false, 0);
    r.print(&buf, true);
    stdio.puts(result);
    return result;
}

