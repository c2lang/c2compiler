/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import src_loc local;
import string_buffer;

import string;

public type TypeRefKind enum u8 {
    Builtin,
    Void,
    User,
    Function,
}

fn const char* TypeRefKind.str(TypeRefKind k) {
    switch (k) {
    case Builtin:   return "builtin";
    case Void:      return "void";
    case User:      return "user";
    case Function:  return "function";
    }
    return nil;
}

type TypeRefBits struct {
    u32 is_const : 1;
    u32 is_volatile : 1;
    u32 num_args : 3; // limit to 7 template arguments
    u32 num_ptrs : 2;   // 0 = Foo, 1 = Foo*, 2 = Foo**
    u32 num_arrays : 2; // limit to 3-dimensional arrays
    u32 incr_array : 1;
    u32 kind : 2;   // TypeRefKind
    u32 has_prefix : 1;
    u32 builtin_kind : 4;   // only if builtin (!is_user)
}

public type Ref struct {
    SrcLoc loc;
    u32 name_idx;
    Decl* decl; // set during analysis, or during parsing for Function
}
static_assert(16, sizeof(Ref));

public fn const char* Ref.getName(const Ref* r) {
    return idx2name(r.name_idx);
}

// Member of VarDecl,Sizeof and ExplicitCast; is NOT a Type!
public type TypeRef struct @(opaque, aligned=8) {
    union {
        TypeRefBits flags;
        u32 flagBits;
    }
    union {
        u32 dest;       // index into TypePool. only used by user type, but must be 8-byte aligned anyways, so put here
        SrcLoc loc;     // for non-user types only
    }
    Ref[0] refs;    // tail-allocated. [1] if is_user/struct_member_fn, [2] if also has_prefix
    //Expr*[0] arrays; // tail-allocated. [1] if Foo[..], [2] if Foo[..][..], etc
    //Expr*[0] args; // tail-allocated. for template arguments
}

// just a TypeRef with all possible tail-allocated fields
public type TypeRefHolder struct {
    u64 ref;    // to make TypeRef opaque
    Ref user;
    Ref prefix;
    Expr*[3] arrays;    // Note: in order of parsing: so [4][20] -> [4] [20]
    Expr*[MaxTemplateArg] args;
}

public fn void TypeRefHolder.init(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flagBits = 0;
    r.dest = 0;
    // can leave other members uninitialized because flags and counts are zero
}

// note: returns dynamic size only!
fn u32 TypeRefHolder.getExtraSize(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.getExtraSize();
}

public fn void TypeRefHolder.setQualifiers(TypeRefHolder* h, u32 qualifiers) {
    TypeRef* r = (TypeRef*)&h.ref;
    if (qualifiers & QualType_Volatile) r.flags.is_volatile = 1;
    if (qualifiers & QualType_Const) r.flags.is_const = 1;
}

public fn void TypeRefHolder.setConst(TypeRefHolder* h) @(unused) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.is_const = 1;
}

public fn void TypeRefHolder.setVolatile(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.is_volatile = 1;
}

public fn bool TypeRefHolder.isPointer(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.flags.num_ptrs != 0;
}

public fn void TypeRefHolder.addPointer(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    assert(r.flags.num_ptrs != 3);
    r.flags.num_ptrs++;
}

public fn bool TypeRefHolder.isIncrArray(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.flags.incr_array;
}

public fn void TypeRefHolder.setIncrArray(TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.incr_array = 1;
}

public fn u32 TypeRefHolder.getNumArrays(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.getNumArrays();
}

#if 0
public fn u32 TypeRefHolder.getNumPointers(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.getNumPointers();
}
#endif

public fn bool TypeRefHolder.isArray(const TypeRefHolder* h) {
    TypeRef* r = (TypeRef*)&h.ref;
    return r.flags.num_arrays != 0;
}

public fn void TypeRefHolder.addArray(TypeRefHolder* h, Expr* array) {
    TypeRef* r = (TypeRef*)&h.ref;
    assert(r.flags.num_arrays != 3);
    h.arrays[r.flags.num_arrays] = array;
    r.flags.num_arrays++;
}

public fn bool TypeRefHolder.addArg(TypeRefHolder* h, Expr* arg) {
    TypeRef* r = (TypeRef*)&h.ref;
    if (r.flags.num_args >= MaxTemplateArg) return false;
    h.args[r.flags.num_args] = arg;
    r.flags.num_args++;
    return true;
}

public fn void TypeRefHolder.setBuiltin(TypeRefHolder* h, BuiltinKind kind, SrcLoc loc) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.builtin_kind = kind;
    r.loc = loc;
}

public fn void TypeRefHolder.setVoid(TypeRefHolder* h, SrcLoc loc) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.kind = TypeRefKind.Void;
    r.loc = loc;
}

public fn void TypeRefHolder.setUser(TypeRefHolder* h, SrcLoc loc, u32 name_idx) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.kind = TypeRefKind.User;
    h.user.loc = loc;
    h.user.name_idx = name_idx;
    h.user.decl = nil;
}

public fn void TypeRefHolder.setFunction(TypeRefHolder* h, Decl* fd) {
    TypeRef* r = (TypeRef*)&h.ref;
    r.flags.kind = TypeRefKind.Function;
    h.user.loc = 0;
    h.user.name_idx = 0;
    h.user.decl = fd;
}

public fn void TypeRefHolder.setPrefix(TypeRefHolder* h, SrcLoc loc, u32 name_idx) {
    TypeRef* r = (TypeRef*)&h.ref;
    // Note: moves previous user to prefix and makes this the user
    h.prefix = h.user;
    r.flags.has_prefix = 1;
    h.user.loc = loc;
    h.user.name_idx = name_idx;
    h.user.decl = nil;
}

public fn void TypeRefHolder.dump(const TypeRefHolder* h) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    const TypeRef* r = (TypeRef*)&h.ref;
    r.print(out, false);
    for (u32 i=0; i<r.getNumArrays(); i++) {
        out.add1('[');
        Expr* size = h.arrays[i];
        if (size) h.arrays[i].printLiteral(out);
        out.add1(']');
    }
    ast.flushDumpBuf(out);
}



fn void TypeRef.init(TypeRef* dest, const TypeRefHolder* h) {
    const TypeRef* r = (TypeRef*)&h.ref;
    *dest = *r; // copy base members

    // copy for tail-allocated info
    switch (r.getKind()) {
    case Builtin:
    case Void:
        break;
    case User:
        dest.refs[0] = h.user;
        if (r.hasPrefix()) dest.refs[1] = h.prefix;
        break;
    case Function:
        dest.refs[0] = h.user;
        break;
    }

    for (u32 i=0; i<r.flags.num_arrays; i++) {
        dest.setArray(i, h.arrays[i]);
    }
    for (u32 i = 0; i < r.flags.num_args; i++) {
        dest.setArg(i, h.args[i]);
    }
}

fn const TypeRef* TypeRef.matchesTemplate(const TypeRef* r1, Instantiator* inst) {
    if (r1.flags.kind != TypeRefKind.User || r1.flags.has_prefix) return nil;
    if (r1.refs[0].name_idx == inst.template_type_name) {
        if (!r1.flags.num_args) return (TypeRef*)&inst.template_type_ref;
        //return nil;  // will be expanded later
    }
    // TODO: support multiple arguments
    if (r1.refs[0].name_idx == inst.template_vars[0].name) return inst.ref;
    return nil;
}

fn bool TypeRef.instantiateCheck(const TypeRef* r1, const TypeRef* r2, Instantiator* inst) {
    if (!r2) return false;
    // Check for overflow:
    // r1 cannot have arguments but can have pointers and arrays
    // r2 can have arguments, pointers and arrays
    // TODO issue error messages using inst.on_error
    if (r1.flags.num_arrays + r2.flags.num_arrays > 3) return false;
    if (r1.flags.num_ptrs + r2.flags.num_ptrs > 3) return false;
    if (r1.flags.num_ptrs && r2.flags.num_arrays) return false;
    return true;
}

fn u32 TypeRef.instantiateExtraSize(const TypeRef* r1, Instantiator* inst) {
    if (const TypeRef* r2 = r1.matchesTemplate(inst)) {
        if (r1.instantiateCheck(r2, inst))
            return r2.getExtraSize() + r1.flags.num_arrays * sizeof(Expr*);
    }
    return r1.getExtraSize();
}

fn void TypeRef.instantiate(TypeRef* r, const TypeRef* r1, Instantiator* inst) {
    // TODO: instantiate template arguments and array dimension expressions
    if (const TypeRef* r2 = r1.matchesTemplate(inst)) {
        // Note: keep the srcloc intact
        // TODO enforce no prefix in template functions
        r.flagBits = r2.flagBits;
        r.flags.is_const |= r1.flags.is_const;
        r.flags.is_volatile |= r1.flags.is_volatile;
        r.flags.num_ptrs += r1.flags.num_ptrs;
        r.flags.num_arrays += r1.flags.num_arrays;
        r.dest = r2.dest; // ???
        u8* ptr = (u8*)&r.refs[0];
        // r1 is TypeRefKind.Builtin without prefix
        const u8* ptr1 = (const u8*)&r1.refs[0] + sizeof(Ref);
        const u8* ptr2 = (const u8*)&r2.refs[0];
        u32 ref_size = ((r2.flags.kind >= TypeRefKind.User) + r2.flags.has_prefix) * sizeof(Ref);
        if (ref_size) string.memcpy(ptr, ptr2, ref_size);
        ptr += ref_size;
        ptr2 += ref_size;
        if (r2.flags.kind == TypeRefKind.User) {
            r.refs[0].loc = r1.refs[0].loc;     // location from instance?
        }
        if (u32 array_size = r1.flags.num_arrays * sizeof(Expr*)) {
            string.memcpy(ptr, ptr1, array_size);
            ptr += array_size;
            ptr1 += array_size;
            // instantiate array expressions
            for (u32 i = 0; i < r1.flags.num_arrays; i++) {
                r.setArray(i, r.getArray(i).instantiate(inst));
            }
        }
        if (u32 array_size = r2.flags.num_arrays * sizeof(Expr*)) {
            string.memcpy(ptr, ptr2, array_size);
            ptr += array_size;
            ptr2 += array_size;
        }
        if (u32 array_size = r2.flags.num_args * sizeof(Expr*)) {
            string.memcpy(ptr, ptr2, array_size);
            ptr += array_size;
            ptr2 += array_size;
        }
        if (inst.used_opaque && r.flags.num_ptrs == 0) {
            inst.on_opaque(r.refs[0].loc, r.refs[0].decl);
        }
    } else {
        string.memcpy(r, r1, sizeof(TypeRef) + r1.getExtraSize());
        // instantiate template arguments
        for (u32 i = 0; i < r1.flags.num_args; i++) {
            r.setArg(i, r1.getArg(i).instantiate(inst));
        }
    }
}

public fn void TypeRef.setDest(TypeRef* r, u32 dest) {
    assert(r.isUser());
    r.dest = dest;
}

fn u32 TypeRef.getExtraSize(const TypeRef* r) {
    // User, StructMemberType use Ref
    u32 numrefs = (r.flags.kind >= TypeRefKind.User) + r.flags.has_prefix;
    u32 extra = numrefs * sizeof(Ref);
    extra += (r.flags.num_arrays + r.flags.num_args) * sizeof(Expr*);
    return extra;
}

/*
public fn u32 TypeRef.getMaxSizeNoArray() {
    return sizeof(TypeRef) + 2 * sizeof(Ref);
}
*/

fn void* TypeRef.getPointerAfter(const TypeRef* r) {
    return (u8*)r + sizeof(TypeRef) + r.getExtraSize();
}

public fn bool TypeRef.isConst(const TypeRef* r) {
    return r.flags.is_const;
}

public fn bool TypeRef.isVolatile(const TypeRef* r) {
    return r.flags.is_volatile;
}

public fn bool TypeRef.isUser(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.User;
}

fn bool TypeRef.isBuiltin(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.Builtin;
}

public fn bool TypeRef.isFunction(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.Function;
}

public fn bool TypeRef.isVoid(const TypeRef* r) {
    return r.flags.kind == TypeRefKind.Void;
}

public fn bool TypeRef.isConstCharPtr(const TypeRef* r) {
    return r.flags.is_const && r.isBuiltin() && r.flags.num_ptrs == 1 &&
           r.flags.num_arrays == 0 && r.getBuiltinKind() == Char;
}

public fn bool TypeRef.isU32(const TypeRef* r) {
    return r.isBuiltin() && r.flags.num_ptrs == 0 && r.flags.num_arrays == 0 && r.getBuiltinKind() == UInt32;
}

public fn bool TypeRef.hasPrefix(const TypeRef* r) @(unused) {
    return r.flags.has_prefix;
}

public fn bool TypeRef.isIncrArray(const TypeRef* r) {
    return r.flags.incr_array;
}

#if 0
public fn bool TypeRef.isPointerTo(const TypeRef* r, u32 ptr_idx) {
    if (r.dest != ptr_idx || ptr_idx == 0) return false;
    return (r.flags.num_ptrs == 1 && r.flags.num_arrays == 0 && r.isUser());
}
#endif

public fn BuiltinKind TypeRef.getBuiltinKind(const TypeRef* r) {
    return (BuiltinKind)r.flags.builtin_kind;
}

public fn TypeRefKind TypeRef.getKind(const TypeRef* r) {
    return (TypeRefKind)r.flags.kind;
}

public fn SrcLoc TypeRef.getLoc(const TypeRef* r) {
    switch (r.getKind()) {
    case Builtin:
    case Void:
        break;
    case User:
        if (r.hasPrefix()) return r.refs[1].loc;
        else return r.refs[0].loc;
    case Function:
        //TODO
        //return r.user.decl.getLoc();
        break;
    }
    return r.loc;
}

public fn bool TypeRef.isPointer(const TypeRef* r) {
    return r.flags.num_ptrs != 0;
}

public fn u32 TypeRef.getNumPointers(const TypeRef* r) {
    return r.flags.num_ptrs;
}

public fn const Ref* TypeRef.getUser(const TypeRef* r) {
    if (r.isUser()) return &r.refs[0];
    return nil;
}

public fn const Ref* TypeRef.getStructMemberType(const TypeRef* r) {
    // Note: user should test kind before
    return &r.refs[0];
}

public fn const Decl* TypeRef.getUserDecl(const TypeRef* r) {
    if (r.isUser()) return r.refs[0].decl;
    return nil;
}

public fn const Ref* TypeRef.getPrefix(const TypeRef* r) {
    if (r.flags.has_prefix) return &r.refs[1];
    return nil;
}

public fn void TypeRef.setPrefix(TypeRef* r, Decl* d) {
    r.refs[1].decl = d;
}

public fn void TypeRef.setUser(TypeRef* r, Decl* d) {
    r.refs[0].decl = d;
}

public fn bool TypeRef.isArray(const TypeRef* r) {
    return r.flags.num_arrays != 0;
}

public fn u32 TypeRef.getNumArrays(const TypeRef* r) {
    return r.flags.num_arrays;
}

public fn Expr* TypeRef.getArray(const TypeRef* r, u32 idx) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** arrays = (Expr**)ptr;
    return arrays[idx];
}

public fn Expr** TypeRef.getArray2(TypeRef* r, u32 idx) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** arrays = (Expr**)ptr;
    return &arrays[idx];
}

fn void TypeRef.setArray(TypeRef* r, u32 idx, Expr* d) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** arrays = (Expr**)ptr;
    arrays[idx] = d;
}

public fn bool TypeRef.isTemplate(const TypeRef* r) {
    return r.flags.num_args != 0;
}

public fn u32 TypeRef.getNumArgs(const TypeRef* r) {
    return r.flags.num_args;
}

public fn Expr** TypeRef.getArgs(TypeRef* r) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    return (Expr**)ptr + r.flags.num_arrays;
}

public fn Expr* TypeRef.getArg(const TypeRef* r, u32 idx) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** args = (Expr**)ptr + r.flags.num_arrays;
    return args[idx];
}

fn void TypeRef.setArg(TypeRef* r, u32 idx, Expr* d) {
    const u32 numrefs = r.isUser() + r.flags.has_prefix;
    const u8* ptr = (u8*)r.refs + numrefs * sizeof(Ref);
    Expr** args = (Expr**)ptr + r.flags.num_arrays;
    args[idx] = d;
}

public fn void TypeRef.printLiteral(const TypeRef* r, string_buffer.Buf* out, bool print_prefix) {
    if (r.isConst()) out.add("const ");
    if (r.isVolatile()) out.add("volatile ");

    switch ((TypeRefKind)r.flags.kind) {
    case Builtin:
        out.add(builtinType_names[r.getBuiltinKind()]);
        break;
    case Void:
        out.add("void");
        break;
    case User:
        Decl* d = r.refs[0].decl;
        assert(d);
        if (print_prefix) {
            out.add(d.getFullName());
        } else {
            out.add(d.getName());
        }
        if (u32 num_args = r.getNumArgs()) {
            out.add1('<');
            for (u32 i = 0; i < num_args; i++) {
                if (i) out.add(", ");
                r.getArg(i).printLiteral(out);
            }
            out.add1('>');
        }
        break;
    case Function:
        out.add("FN TODO");
        // TODO
        break;
    }

    for (u32 i=0; i<r.flags.num_ptrs; i++) out.add1('*');

    if (r.flags.incr_array) out.add("[+]");

    for (u32 i = 0; i < r.flags.num_arrays; i++) {
        out.add1('[');
        const Expr* a = r.getArray(i);
        // note: a can be nil, when[]
        if (a) a.printLiteral(out);
        out.add1(']');
    }
}

fn void TypeRef.print(const TypeRef* r, string_buffer.Buf* out, bool filled) {
    // eg. const test.Foo*[10]

    out.color(col_Error);
    if (r.isConst()) out.add("const ");
    if (r.isVolatile()) out.add("volatile ");

    switch ((TypeRefKind)r.flags.kind) {
    case Builtin:
        out.add(builtinType_names[r.getBuiltinKind()]);
        break;
    case Void:
        out.add("void");
        break;
    case User:
        if (r.flags.has_prefix) {
            out.add(idx2name(r.refs[1].name_idx));
            out.add1('.');
        }
        out.add(idx2name(r.refs[0].name_idx));
        if (u32 num_args = r.getNumArgs()) {
            out.add1('<');
            for (u32 i = 0; i < num_args; i++) {
                if (i) out.add(", ");
                r.getArg(i).printLiteral(out);
            }
            out.add1('>');
        }
        break;
    case Function:
        out.add("fn ");
        assert(r.refs[0].decl);
        const FunctionDecl* fd = (FunctionDecl*)r.refs[0].decl;
        fd.printType(out);
        break;
    }

    for (u32 i=0; i<r.flags.num_ptrs; i++) out.add1('*');

    if (r.flags.incr_array) {
        out.add("[+]");
    }

    if (filled) {
        // Note: we can iterate normal way here, since we just print
        for (u32 i=0; i<r.flags.num_arrays; i++) {
            out.add1('[');
            const Expr* a = r.getArray(i);
            // note: a can be nil, when[]
            if (a) a.printLiteral(out);
            out.add1(']');
        }
    }
}

// Note: only use on filled TypeRef
public fn void TypeRef.dump(const TypeRef* r) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    r.print(out, true);
    ast.flushDumpBuf(out);
}

// Note: only use on filled TypeRef
public fn void TypeRef.dump_full(const TypeRef* r) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    out.add("TypeRef:\n");
    out.indent(1);
    out.add("flags:");
    if (r.flags.is_const) out.add(" const");
    out.print(" args=%d", r.flags.num_args);
    out.print(" ptrs=%d", r.flags.num_ptrs);
    out.print(" kind=%s", TypeRefKind.str((TypeRefKind)r.flags.kind));
    out.print(" has_prefix=%d", r.flags.has_prefix);
    out.newline();
    out.indent(1);
    out.print("dest %d\n", r.dest);
    u32 num_refs = 0;
    if (r.isUser()) num_refs++;
    if (r.flags.has_prefix) num_refs++;
    for (u32 i=0; i<num_refs; i++) {
        out.indent(1);
        const Ref* ref = &r.refs[i];
        out.print("ref[%d] loc %d  name_idx %d  decl %p\n", i, ref.loc, ref.name_idx, ref.decl);
    }
    ast.flushDumpBuf(out);
}

public fn const char* TypeRef.diagName(const TypeRef* r) {
    local char[128] result;
    string_buffer.Buf buf.init(result, elemsof(result), false, false, 0);
    r.print(&buf, true);
    return buf.str();  // ensure null terminator
}

