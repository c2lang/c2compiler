/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import ast_context;
import string_buffer;
import src_loc local;

import string;

type StructTypeDeclBits struct {
    u32 : NumDeclBits;
    u32 is_struct : 1;
    u32 is_global : 1;
    u32 attr_packed : 1;
    u32 attr_opaque : 1;
    u32 attr_notypedef : 1;
    u32 size_analysed : 1;  // set when sizeof/offsetof is used (also set in (anonymous) substructs)
}

type StructLayout struct {
    u32 size;
    u32 alignment;
    u32 attr_alignment;
    u32[0] member_offsets;
}

public type StructTypeDecl struct @(opaque) {
    Decl parent;
    u32 num_members;
    u32 num_struct_functions;
    FunctionDecl** struct_functions;
    Decl*[0] members;   // tail-allocated
    //StructLayout layout[0]; // tail-allocated
}

public fn StructTypeDecl* StructTypeDecl.create(ast_context.Context* c,
                                                  u32 name,
                                                  SrcLoc loc,
                                                  bool is_public,
                                                  u32 ast_idx,
                                                  bool is_struct,
                                                  bool is_global,
                                                  Decl** members,
                                                  u32 num_members)
{
    u32 size = sizeof(StructTypeDecl) + num_members * sizeof(Decl*);
    size += sizeof(StructLayout);
    size += num_members * sizeof(u32); // to store offsets
    size = (size + 7) & ~0x7; // round to 8-byte (temp)
    StructTypeDecl* d = c.alloc(size);
    StructType* stype = StructType.create(c, d);
    QualType qt = QualType.init(stype.asType());
    stype.asType().setCanonicalType(qt);
    d.parent.init(DeclKind.StructType, name, loc, is_public, qt, ast_idx);
    d.parent.structTypeDeclBits.is_struct = is_struct;
    d.parent.structTypeDeclBits.is_global = is_global;

    if (!is_global) d.parent.setUsed(); // set sub-structs to used

    d.num_members = num_members;
    d.num_struct_functions = 0;
    d.struct_functions = nil;

    StructLayout* layout = d.getLayoutPtr();
    layout.size = 0;
    layout.alignment = 0;
    layout.attr_alignment = 1;

    u32* member_offsets = cast<u32*>(&d.members[d.num_members]);
    if (num_members) {
        string.memcpy(cast<void*>(d.members), cast<void*>(members), num_members * sizeof(Decl*));
        string.memset(layout.member_offsets, 0, num_members * sizeof(u32));
    }
#if AstStatistics
    Stats.addDecl(DeclKind.StructType, size);
#endif
    return d;
}

public fn Decl* StructTypeDecl.asDecl(StructTypeDecl* d) {
    return &d.parent;
}

public fn u32 StructTypeDecl.getNumMembers(const StructTypeDecl* d) {
    return d.num_members;
}

public fn Decl** StructTypeDecl.getMembers(StructTypeDecl* d) {
    // NOTE: doesn't check if present!
    return d.members;
}

public fn bool StructTypeDecl.isStruct(const StructTypeDecl* d) {
    return d.parent.structTypeDeclBits.is_struct;
}

public fn bool StructTypeDecl.isUnion(const StructTypeDecl* d) {
    return !d.parent.structTypeDeclBits.is_struct;
}

public fn const FunctionDecl** StructTypeDecl.getStructFunctions(const StructTypeDecl* d) {
    // TEMP const-cast until ptr-ptr -> const ptr-ptr is fixed in analyser
    return cast<const FunctionDecl**>(d.struct_functions);
}

public fn u32 StructTypeDecl.getNumStructFunctions(const StructTypeDecl* d) {
    return d.num_struct_functions;
}

fn StructLayout* StructTypeDecl.getLayoutPtr(const StructTypeDecl* d) {
    return cast<StructLayout*>(&d.members[d.num_members]);
}

public fn void StructTypeDecl.setMemberOffset(StructTypeDecl* d, u32 member_idx, u32 offset) {
    StructLayout* layout = d.getLayoutPtr();
    layout.member_offsets[member_idx] = offset;
}

public fn u32 StructTypeDecl.getMemberOffset(const StructTypeDecl* d, u32 member_idx) {
    StructLayout* layout = d.getLayoutPtr();
    return layout.member_offsets[member_idx];
}

public fn u32 StructTypeDecl.getSize(const StructTypeDecl* d) {
    StructLayout* layout = d.getLayoutPtr();
    return layout.size;
}

public fn void StructTypeDecl.setSizeAlignment(StructTypeDecl* d, u32 size, u32 alignment) {
    StructLayout* layout = d.getLayoutPtr();
    d.parent.structTypeDeclBits.size_analysed = true;
    layout.size = size;
    layout.alignment = alignment;
}

public fn u32 StructTypeDecl.getAlignment(const StructTypeDecl* d) {
    StructLayout* layout = d.getLayoutPtr();
    return layout.alignment;
}

public fn u32 StructTypeDecl.getAttrAlignment(const StructTypeDecl* d) {
    StructLayout* layout = d.getLayoutPtr();
    return layout.attr_alignment;
}

public fn void StructTypeDecl.setAttrAlignment(StructTypeDecl* d, u32 alignment) {
    StructLayout* layout = d.getLayoutPtr();
    layout.attr_alignment = alignment;
}

public fn void StructTypeDecl.setPacked(StructTypeDecl* d) {
    d.parent.structTypeDeclBits.attr_packed = 1;
}

public fn bool StructTypeDecl.isPacked(const StructTypeDecl* d) {
    return d.parent.structTypeDeclBits.attr_packed;
}

public fn void StructTypeDecl.setOpaque(StructTypeDecl* d) {
    d.parent.structTypeDeclBits.attr_opaque = 1;
}

public fn bool StructTypeDecl.isOpaque(const StructTypeDecl* d) {
    return d.parent.structTypeDeclBits.attr_opaque;
}

public fn bool StructTypeDecl.isGlobal(const StructTypeDecl* d) {
    return d.parent.structTypeDeclBits.is_global;
}

public fn void StructTypeDecl.setAttrNoTypeDef(StructTypeDecl* d) {
    d.parent.structTypeDeclBits.attr_notypedef = 1;
}

public fn bool StructTypeDecl.hasAttrNoTypeDef(const StructTypeDecl* d) {
    return d.parent.structTypeDeclBits.attr_notypedef;
}

public fn void StructTypeDecl.setStructFunctions(StructTypeDecl* d, ast_context.Context* c, FunctionDecl** funcs, u32 count) {
    const u32 size = count * sizeof(FunctionDecl*);
    void* dest = c.alloc(size);
    string.memcpy(dest, cast<void*>(funcs), size);
    d.struct_functions = dest;
    d.num_struct_functions = count;
}

public fn Decl* StructTypeDecl.findAny(const StructTypeDecl* s, u32 name_idx) {
    for (u32 i=0; i<s.getNumMembers(); i++) {
        Decl* d = s.members[i];
        u32 member_name = d.getNameIdx();

        if (member_name == name_idx) return d;

        if (member_name == 0  && d.isStructType()) {
            StructTypeDecl* sub = cast<StructTypeDecl*>(d);
            d = sub.findAny(name_idx);
            if (d) return d;
        }
    }

    if (s.parent.structTypeDeclBits.is_global) {
        for (u32 i=0; i<s.num_struct_functions; i++) {
            Decl* sf = cast<Decl*>(s.struct_functions[i]);
            if (sf.getNameIdx() == name_idx) return sf;
        }
    }
    return nil;
}

public fn Decl* StructTypeDecl.findMember(const StructTypeDecl* s, u32 name_idx, u32* offset) {
    for (u32 i=0; i<s.getNumMembers(); i++) {
        Decl* d = s.members[i];
        u32 member_name = d.getNameIdx();

        if (member_name == name_idx) {
            if (offset) *offset += s.getMemberOffset(i);
            return d;
        }

        // search unnamed sub-structs
        if (member_name == 0 && d.isStructType()) {
            StructTypeDecl* sub = cast<StructTypeDecl*>(d);
            d = sub.findMember(name_idx, offset);
            if (d) {
                if (offset) *offset += s.getMemberOffset(i);
                return d;
            }
        }
    }
    return nil;
}

fn void StructTypeDecl.print(const StructTypeDecl* d, string_buffer.Buf* out, u32 indent) {
    d.parent.printKind(out, indent, true);
    d.parent.printBits(out);
    bool is_global = d.parent.structTypeDeclBits.is_global;
    if (is_global) out.add(" global");
    if (d.parent.structTypeDeclBits.is_struct) out.add(" struct");
    else out.add(" union");

    if (d.isPacked()) out.add(" packed");
    if (d.isOpaque()) out.add(" opaque");
    if (d.hasAttrNoTypeDef()) out.add(" notypedef");

    if (is_global) d.parent.printAttrs(out);


    if (d.parent.structTypeDeclBits.size_analysed) {
        out.color(col_Calc);
        StructLayout* layout = d.getLayoutPtr();
        out.print(" size=%d align=%d", layout.size, layout.alignment);
    }

    out.space();
    out.color(col_Value);
    if (d.parent.getName()) out.add(d.parent.getName());
    else out.add("<anonymous>");
    out.newline();

    for (u32 i=0; i<d.num_members; i++) {
        out.indent(indent + 1);
        out.color(col_Calc);
        out.print("offset=%d\n", d.getMemberOffset(i));
        d.members[i].print(out, indent + 1);
    }
}

