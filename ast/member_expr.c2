/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import ast_context;
import src_loc local;
import string_buffer;

import string;

public type MemberConversion enum u8 {
    None,
    Addr,       // Foo -> Foo* (ie &f)
    Deref,      // Foo* -> Foo (ie *f)
}

type MemberExprBits struct {
    u32 : NumExprBits;
    u32 kind : 3;   // IdentifierKind
    u32 num_decls : 2;  // how many refs have a decl (from the bottom up), set during analysis
    u32 has_expr : 1;
    u32 is_struct_func : 1; // not only a function with prefix, but also used that way
    u32 is_static_sf : 1;
    u32 is_const_base : 1;
    u32 is_volatile_base : 1;
    u32 conversion : 2; // MemberConversion
    u32 is_bitfield : 1;
    u32 base_len : 5;
}

// 2 variants: pure: `a.b` and non pure: `<expr>.b`
type MemberRef union {
    u32 name_idx;
    Decl* decl;     // set during analysis
    Expr* expr;     // for first ref in non-pure mode
    usize bits;
}

static_assert(8, sizeof(MemberRef));

public type MemberExpr struct @(opaque) {
    // base.loc points to the beginning of the member name in refs[1]
    Expr base;
    MemberRef[2] refs;
}

// if base == nil, MemberExpr is pure, otherwise non-pure
public fn MemberExpr* MemberExpr.create(ast_context.Context* c, Expr* base, u32 base_name_idx, u32 base_len, SrcLoc loc, u32 member_name_idx) {
    u32 size = sizeof(MemberExpr);
    MemberExpr* e = c.alloc(size);
    e.base.init(Member, loc, 0, 0, 0, NValue);
    e.base.base.memberExprBits.base_len = base_len;
    e.refs[0].bits = 0;
    e.refs[0].name_idx = base_name_idx;
    if (base) {
        e.refs[0].expr = base;
        e.base.base.memberExprBits.has_expr = 1;
    }
    e.refs[1].bits = 0;
    e.refs[1].name_idx = member_name_idx;
#if AstStatistics
    Stats.addExpr(Member, size);
#endif
    return e;
}

fn Expr* MemberExpr.instantiate(MemberExpr* e, Instantiator* inst) {
    u32 size = sizeof(MemberExpr);
    MemberExpr* e2 = inst.c.alloc(size);

    string.memcpy(e2, e, size);
    if (e2.hasExpr()) e2.refs[0].expr = e2.refs[0].expr.instantiate(inst);

#if AstStatistics
    Stats.addExpr(Member, size);
#endif
    return (Expr*)e2;
}

public fn bool MemberExpr.hasExpr(const MemberExpr* e) {
    return e.base.base.memberExprBits.has_expr;
}

public fn Expr* MemberExpr.getBaseExpr(const MemberExpr* e) {
    if (e.hasExpr()) return e.refs[0].expr;
    return nil;
}

public fn void MemberExpr.setConversion(MemberExpr* e, MemberConversion c) {
    e.base.base.memberExprBits.conversion = c;
}

public fn MemberConversion MemberExpr.getConversion(const MemberExpr* e) {
    return (MemberConversion)e.base.base.memberExprBits.conversion;
}

public fn const char* MemberExpr.getName(const MemberExpr* e, u32 ref_idx) {
    if (u32 name_idx = e.getNameIdx(ref_idx)) return idx2name(name_idx);
    return nil;
}

public fn u32 MemberExpr.getNameIdx(const MemberExpr* e, u32 ref_idx) {
    if (ref_idx == 0 && e.hasExpr()) {
        Expr* base = e.getBaseExpr();
        if (base.isIdentifier()) return ((IdentifierExpr*)base).getNameIdx();
        return 0;
    }
    const MemberRef* ref = &e.refs[ref_idx];
    if (e.base.base.memberExprBits.num_decls > ref_idx) {
        Decl* d = ref.decl;
        if (d.isImport()) {
            const ImportDecl* id = (ImportDecl*)d;
            u32 alias_idx = id.getAliasNameIdx();
            if (alias_idx) return alias_idx;
        }
        return d.getNameIdx();
    }
    return ref.name_idx;
}

public fn SrcLoc MemberExpr.getLoc(const MemberExpr* e, u32 ref_idx = 1) {
    SrcLoc loc = e.base.getLoc();
    if (ref_idx) return loc;
    if (e.hasExpr()) return e.getBaseExpr().getLoc();
    return loc - 1 - e.base.base.memberExprBits.base_len;
}

public fn SrcLoc MemberExpr.getMemberLoc(const MemberExpr* e) {
    return e.base.getLoc();
}

fn SrcLoc MemberExpr.getStartLoc(const MemberExpr* e) {
    if (e.hasExpr()) return e.refs[0].expr.getStartLoc();
    return e.base.getLoc() - 1 - e.base.base.memberExprBits.base_len;
}

fn SrcLoc MemberExpr.getEndLoc(const MemberExpr* e) {
    return e.base.getLoc() + (u32)string.strlen(e.getName(1));
}

fn SrcLoc MemberExpr.getBaseEndLoc(const MemberExpr* e) {
    if (e.hasExpr()) return e.getBaseExpr().getEndLoc();
    return e.base.getLoc() - 1;
}

public fn SrcRange MemberExpr.getBaseRange(const MemberExpr* e) {
    return { e.getStartLoc(), e.getBaseEndLoc() }
}

public fn Ref MemberExpr.getBaseRef(const MemberExpr* e) {
    Ref ref;
    ref.loc = e.getStartLoc();
    ref.name_idx = e.getNameIdx(0);
    ref.decl = e.getDecl(0);
    return ref;
}

public fn Ref MemberExpr.getRef(const MemberExpr* e) {
    Ref ref;
    ref.loc = e.getLoc(1);
    ref.name_idx = e.getNameIdx(1);
    ref.decl = e.getDecl(1);
    return ref;
}

public fn IdentifierKind MemberExpr.getKind(const MemberExpr* e) {
    return (IdentifierKind)e.base.base.memberExprBits.kind;
}

public fn void MemberExpr.setKind(MemberExpr* e, IdentifierKind kind) {
    e.base.base.memberExprBits.kind = kind;
}

/*
public fn bool MemberExpr.isVarKind(const MemberExpr* e) {
    return e.getKind() == Var;
}
*/

public fn void MemberExpr.setIsTypeFunc(MemberExpr* e) {
    e.base.base.memberExprBits.is_struct_func = 1;
}

public fn bool MemberExpr.isTypeFunc(const MemberExpr* e) {
    return e.base.base.memberExprBits.is_struct_func;
}

public fn void MemberExpr.setBitfield(MemberExpr* e) {
    e.base.base.memberExprBits.is_bitfield = 1;
}

fn bool MemberExpr.isBitfield(const MemberExpr* e) {
    return e.base.base.memberExprBits.is_bitfield;
}

public fn void MemberExpr.setIsStaticTypeFunc(MemberExpr* e) {
    e.base.base.memberExprBits.is_static_sf = 1;
}

public fn bool MemberExpr.isStaticTypeFunc(const MemberExpr* e) {
    return e.base.base.memberExprBits.is_static_sf;
}

public fn void MemberExpr.setConstBase(MemberExpr* e, bool b) {
    e.base.base.memberExprBits.is_const_base = b;
}

fn bool MemberExpr.isConstBase(const MemberExpr* e) {
    return e.base.base.memberExprBits.is_const_base;
}

public fn void MemberExpr.setVolatileBase(MemberExpr* e, bool b) {
    e.base.base.memberExprBits.is_volatile_base = b;
}

fn bool MemberExpr.isVolatileBase(const MemberExpr* e) {
    return e.base.base.memberExprBits.is_volatile_base;
}

// returns the final base decl (eg: a.b.c.d <- returns c). Must be fully analysed
public fn Decl* MemberExpr.getBaseDecl(const MemberExpr* e) {
    if (e.hasExpr()) {
        Expr* base = e.getBaseExpr();
        if (base.isIdentifier()) return ((IdentifierExpr*)base).getDecl();
        if (base.isMember()) return ((MemberExpr*)base).getFullDecl();
        return nil;
    }
    if (e.base.base.memberExprBits.num_decls < 1) return nil;
    return e.refs[0].decl;
}

// returns the final decl after a.b.c.d <-, must be fully analysed
public fn Decl* MemberExpr.getFullDecl(const MemberExpr* e) {
    if (e.base.base.memberExprBits.num_decls < 2) return nil;
    return e.refs[1].decl;
}

public fn Decl* MemberExpr.getDecl(const MemberExpr* e, u32 ref_idx) {
    if (e.base.base.memberExprBits.num_decls <= ref_idx) return nil;
    return e.refs[ref_idx].decl;
}

public fn void MemberExpr.setDecl(MemberExpr* e, Decl* d, u32 ref_idx) {
    e.base.base.memberExprBits.num_decls = ref_idx + 1;
    e.refs[ref_idx].decl = d;
}

public fn QualType MemberExpr.getBaseType(const MemberExpr* m) {
    if (m.hasExpr()) return m.refs[0].expr.getType();
    // TODO: check num_decls?
    QualType qt = m.refs[0].decl.getType();
    if (m.isConstBase()) qt.setConst();
    if (m.isVolatileBase()) qt.setVolatile();
    return qt;
}

public fn const char* MemberExpr.getMemberName(const MemberExpr* e) {
    return e.getName(1);
}

fn void MemberExpr.print(const MemberExpr* e, string_buffer.Buf* out, u32 indent) {
    e.base.printKind(out, indent);
    e.base.printTypeBits(out);
    out.space();
    IdentifierKind kind = e.getKind();
    if (kind == Unresolved) out.color(col_Error);
    else out.color(col_Attr);
    out.add(kind.str());
    out.color(col_Attr);
    if (e.isBitfield()) out.add(" bitfield");
    if (e.isTypeFunc()) out.add(" TF");
    if (e.isStaticTypeFunc()) out.add(" STF");
    if (e.isConstBase()) out.add(" const-base");
    if (e.isVolatileBase()) out.add(" volatile-base");
    switch (e.getConversion()) {
    case None:
        break;
    case Addr:
        out.add(" Addr");
        break;
    case Deref:
        out.add(" Deref");
        break;
    }
    out.print(" refs=%d/2 ", e.base.base.memberExprBits.num_decls);
    out.color(col_Value);
    e.printLiteral(out);
    if (kind == Function || kind == Type || kind == Var) {
        if (Decl* d = e.getDecl(1)) {
            out.space();
            out.add(d.getFullName());
        }
    }
    out.newline();
    if (e.hasExpr()) e.refs[0].expr.print(out, indent + 1);
}

fn void MemberExpr.printLiteral(const MemberExpr* e, string_buffer.Buf* out) {
    if (e.hasExpr()) {
        e.refs[0].expr.printLiteral(out);
    } else {
        out.add(e.getName(0));
    }
    out.add1('.');
    out.add(e.getName(1));
}

public fn void MemberExpr.dump(const MemberExpr* m) @(unused) {
    string_buffer.Buf* out = ast.getDumpBuf();
    out.color(col_Expr);
    out.print("MemberExpr loc %d expr %d decl %d/2\n",
              m.base.getLoc(), m.hasExpr(), m.base.base.memberExprBits.num_decls);
    const MemberExprBits* bits = &m.base.base.memberExprBits;
    IdentifierKind k = (IdentifierKind)bits.kind;
    out.print("  bits: kind %s, sf %d, ssf %d, conv %d, bitf %d\n",
              k.str(), bits.is_struct_func, bits.is_static_sf,
              bits.conversion, bits.is_bitfield);
    u32 start = 0;
    if (m.hasExpr()) {
        out.indent(1);
        out.color(col_Value);
        out.add("<expr>\n");
        Expr* e = m.getBaseExpr();
        e.print(out, 1);
        start = 1;
    }
    for (u32 i = start; i < 2; i++) {
        const MemberRef* ref = &m.refs[i];
        out.indent(1);
        out.color(col_Expr);
        if (m.base.base.memberExprBits.num_decls > i) {
            out.print("[%d]\n", i);
            ref.decl.print(out, 1);
        } else {
            out.print("[%d] %s\n", i, idx2name(ref.name_idx));
        }
    }
    ast.flushDumpBuf(out);
}

