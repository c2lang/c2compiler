/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

import string_buffer;
import src_loc local;

import stdio;

public type StmtKind enum u8 {
    Return,
    Expr,
    If,
    While,
    For,
    Switch,
    Break,
    Continue,
    Fallthrough,
    Label,
    Goto,
    Compound,
    Decl,
    Asm,
    Assert,
}

const char*[] stmtKind_names = {
    "ReturnStmt",
    "ExprStmt",
    "IfStmt",
    "WhileStmt",
    "ForStmt",
    "SwitchStmt",
    "BreakStmt",
    "ContinueStmt",
    "FallthroughStmt",
    "LabelStmt",
    "GotoStmt",
    "CompoundStmt",
    "DeclStmt",
    "Asm",
    "AssertStmt",
}

static_assert(elemsof(StmtKind), elemsof(stmtKind_names));

type StmtBits struct {
    u32 kind : NumStmtBits;
}

const u32 NumStmtBits = 4;

public type Stmt struct @(opaque) {
    union {
        StmtBits stmtBits;
        AsmStmtBits asmStmtBits;
        LabelStmtBits labelStmtBits;
        ReturnStmtBits returnStmtBits;
        SwitchStmtBits switchStmtBits;
        CompoundStmtBits compoundStmtBits;

        ExprBits exprBits;
        IfStmtBits ifStmtBits;
        BuiltinExprBits builtinExprBits;
        BooleanLiteralBits booleanLiteralBits;
        CharLiteralBits charLiteralBits;
        IdentifierExprBits identifierExprBits;
        MemberExprBits memberExprBits;
        IntegerLiteralBits integerLiteralBits;
        UnaryOperatorBits unaryOperatorBits;
        BinaryOperatorBits binaryOperatorBits;
        BitOffsetExprBits bitOffsetBits;
        CallExprBits callExprBits;
        InitListExprBits initListExprBits;
        ImplicitCastBits implicitCastBits;
        u32 bits;
    }
}

fn void Stmt.init(Stmt* s, StmtKind k) {
    s.bits = 0;
    s.stmtBits.kind = k;
}

fn Stmt* Stmt.instantiate(Stmt* s, Instantiator* inst) {
    switch (s.getKind()) {
    case Return:
        return ReturnStmt.instantiate(cast<ReturnStmt*>(s), inst);
    case Expr:
        return cast<Stmt*>(Expr.instantiate(cast<Expr*>(s), inst));
    case If:
        return IfStmt.instantiate(cast<IfStmt*>(s), inst);
    case While:
        return WhileStmt.instantiate(cast<WhileStmt*>(s), inst);
    case For:
        return ForStmt.instantiate(cast<ForStmt*>(s), inst);
    case Switch:
        return SwitchStmt.instantiate(cast<SwitchStmt*>(s), inst);
    case Break:
        return s;
    case Continue:
        return s;
    case Fallthrough:
        return s;
    case Label:
        return LabelStmt.instantiate(cast<LabelStmt*>(s), inst);
    case Goto:
        return s;
    case Compound:
        return cast<Stmt*>(CompoundStmt.instantiate(cast<CompoundStmt*>(s), inst));
    case Decl:
        return DeclStmt.instantiate(cast<DeclStmt*>(s), inst);
    case Asm:
        break;
    case Assert:
        return AssertStmt.instantiate(cast<AssertStmt*>(s), inst);
    }
    s.dump();
    assert(0);
    return nil;
}

// TEMP cast needed until Analyser fixed
public fn StmtKind Stmt.getKind(const Stmt* s) { return cast<StmtKind>(s.stmtBits.kind); }

public fn bool Stmt.isReturn(const Stmt* s) {
    return s.getKind() == StmtKind.Return;
}

public fn bool Stmt.isExpr(const Stmt* s) {
    return s.getKind() == StmtKind.Expr;
}

public fn bool Stmt.isCompound(const Stmt* s) {
    return s.getKind() == StmtKind.Compound;
}

public fn bool Stmt.isFallthrough(const Stmt* s) {
    return s.getKind() == StmtKind.Fallthrough;
}

public fn bool Stmt.isDecl(const Stmt* s) {
    return s.getKind() == StmtKind.Decl;
}

public fn SrcLoc Stmt.getLoc(const Stmt* s) {
    switch (s.getKind()) {
    case Return:
        const ReturnStmt* r = cast<ReturnStmt*>(s);
        return r.getLoc();
    case Expr:
        const Expr* e = cast<Expr*>(s);
        return e.getLoc();
    case If:
        //const IfStmt* i = cast<IfStmt*>(s);
        //return i.getLoc();
        break;
    case While:
        //const WhileStmt* w = cast<WhileStmt*>(s);
        //return w.getLoc();
        break;
    case For:
        const ForStmt* f = cast<ForStmt*>(s);
        return f.getLoc();
    case Switch:
        const SwitchStmt* sw = cast<SwitchStmt*>(s);
        return sw.getLoc();
    case Break:
        const BreakStmt* b = cast<BreakStmt*>(s);
        return b.getLoc();
    case Continue:
        const ContinueStmt* c = cast<ContinueStmt*>(s);
        return c.getLoc();
    case Fallthrough:
        const FallthroughStmt* f = cast<FallthroughStmt*>(s);
        return f.getLoc();
    case Label:
        const LabelStmt* l = cast<LabelStmt*>(s);
        return l.getLoc();
    case Goto:
        const GotoStmt* g = cast<GotoStmt*>(s);
        return g.getLoc();
    case Compound:
        const CompoundStmt* c = cast<CompoundStmt*>(s);
        return c.getEndLoc();
    case Decl:
        const DeclStmt* d = cast<DeclStmt*>(s);
        Decl* vd = cast<Decl*>(d.getDecl());
        return vd.getLoc();
    case Asm:
        const AsmStmt* a = cast<AsmStmt*>(s);
        return a.getLoc();
    case Assert:
        const AssertStmt* a = cast<AssertStmt*>(s);
        return a.getLoc();
    }
    return 0;
}

public fn void Stmt.dump(const Stmt* s) {
    string_buffer.Buf* out = string_buffer.create(10*4096, useColor(), 2);
    s.print(out, 0);
    out.color(col_Normal);
    stdio.puts(out.data());
    out.free();
}

fn void Stmt.print(const Stmt* s, string_buffer.Buf* out, u32 indent) {
    switch (s.getKind()) {
    case Return:
        ReturnStmt.print(cast<ReturnStmt*>(s), out, indent);
        break;
    case Expr:
        Expr.print(cast<Expr*>(s), out, indent);
        break;
    case If:
        IfStmt.print(cast<IfStmt*>(s), out, indent);
        break;
    case While:
        WhileStmt.print(cast<WhileStmt*>(s), out, indent);
        break;
    case For:
        ForStmt.print(cast<ForStmt*>(s), out, indent);
        break;
    case Switch:
        SwitchStmt.print(cast<SwitchStmt*>(s), out, indent);
        break;
    case Break:
        BreakStmt.print(cast<BreakStmt*>(s), out, indent);
        break;
    case Continue:
        ContinueStmt.print(cast<ContinueStmt*>(s), out, indent);
        break;
    case Fallthrough:
        FallthroughStmt.print(cast<FallthroughStmt*>(s), out, indent);
        break;
    case Label:
        LabelStmt.print(cast<LabelStmt*>(s), out, indent);
        break;
    case Goto:
        GotoStmt.print(cast<GotoStmt*>(s), out, indent);
        break;
    case Compound:
        CompoundStmt.print(cast<CompoundStmt*>(s), out, indent);
        break;
    case Decl:
        DeclStmt.print(cast<DeclStmt*>(s), out, indent);
        break;
    case Asm:
        AsmStmt.print(cast<AsmStmt*>(s), out, indent);
        break;
    case Assert:
        AssertStmt.print(cast<AssertStmt*>(s), out, indent);
        break;
    }
}

fn void Stmt.printKind(const Stmt* s, string_buffer.Buf* out, u32 indent) {
    out.indent(indent);
    out.color(col_Stmt);
    out.add(stmtKind_names[s.getKind()]);
}

