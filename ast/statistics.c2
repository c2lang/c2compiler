/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ast;

#if AstStatistics
import string;
import stdio local;

const u32 NCat = 1;             // 32 for fine grained analysis
const u32 BucketWidth = 8;      // 4 or less for slack analysis

type Stat struct {
    u32[NCat] count;
    u32[NCat] size;
}

type Stats struct {
    Stat[elemsof(TypeKind)] types;
    Stat[elemsof(ExprKind)] exprs;
    Stat[elemsof(StmtKind)] stmts;
    Stat[elemsof(DeclKind)] decls;
    Stat[3] others; // 0=ArrayValue, 1=StaticAssert, 2=SwitchCase
}

fn void Stats.reset(Stats* s) {
    string.memset(s, 0, sizeof(Stats));
}

fn void Stat.add(Stat* ss, u32 size) {
    if (NCat > 1) {
        u32 cat = (size + BucketWidth - 1) / BucketWidth;
        if (cat >= NCat) cat = NCat - 1;
        ss.count[cat]++;
        ss.size[cat] += (size + 7) & ~0x7;
    } else {
        ss.count[0]++;
        ss.size[0] += (size + 7) & ~0x7;
    }
}

fn void Stats.addType(TypeKind kind, u32 size) {
    globals.stats.types[kind].add(size);
}

fn void Stats.addExpr(ExprKind kind, u32 size) {
    globals.stats.exprs[kind].add(size);
}

fn void Stats.addStmt(StmtKind kind, u32 size) {
    globals.stats.stmts[kind].add(size);
}

fn void Stats.addDecl(DeclKind kind, u32 size) {
    globals.stats.decls[kind].add(size);
}

const char*[] other_names = { "ArrayValue", "StaticAssert", "SwitchCase" }

fn void Stats.addArrayValue(u32 size) {
    globals.stats.others[0].add(size);
}

fn void Stats.addStaticAssert(u32 size) {
    globals.stats.others[1].add(size);
}

fn void Stats.addSwitchCase(u32 size) {
    globals.stats.others[2].add(size);
}

fn void Stat.slack(const Stat* ss, u32* countp, u32* totalp) {
    if (BucketWidth & 0x7) {
        for (u32 cat = 0; cat < NCat; cat++) {
            if (u32 frac = (cat * BucketWidth) & 0x7) {
                *countp += ss.count[cat];
                *totalp += ss.count[cat] * (8 - frac);
            }
        }
    }
}

fn void Stat.dump(const Stat* ss, const char* name, u32* countp, u32* totalp) {
    u32 count = 0;
    u32 size = 0;
    for (u32 cat = 0; cat < NCat; cat++) {
        count += ss.count[cat];
        size += ss.size[cat];
    }
    printf("  %20s  %6d  %7d", name, count, size);
    bool output = false;
    for (u32 cat = 0; cat < NCat; cat++) {
        if (!ss.count[cat]) continue;
        if (count == ss.count[cat]) {
            // no repeat if single category
            if (NCat > 1) printf("  %d", cat * BucketWidth);
            break;
        }
        printf("  %d:%d/%d", cat * BucketWidth, ss.count[cat], ss.size[cat]);
    }
    printf("\n");
    *countp += count;
    *totalp += size;
}

fn void Stats.dump(const Stats* s) {
    printf("---------------------------------------\n");

    printf("--- Types ---\n");
    u32 typesTotal = 0;
    u32 typesCount = 0;
    for (TypeKind kind = TypeKind.min; kind <= TypeKind.max; kind++) {
        s.types[kind].dump(typeKind_names[kind], &typesCount, &typesTotal);
    }
    printf("  %20s  %6d  %7d\n", "total", typesCount, typesTotal);

    printf("--- Expressions ---\n");
    u32 exprTotal = 0;
    u32 exprCount = 0;
    for (ExprKind i = ExprKind.min; i <= ExprKind.max; i++) {
        s.exprs[i].dump(exprKind_names[i], &exprCount, &exprTotal);
    }
    printf("  %20s  %6d  %7d\n", "total", exprCount, exprTotal);

    printf("--- Statements ---\n");
    u32 stmtTotal = 0;
    u32 stmtCount = 0;
    for (StmtKind i = StmtKind.min; i <= StmtKind.max; i++) {
        s.stmts[i].dump(stmtKind_names[i], &stmtCount, &stmtTotal);
    }
    printf("  %20s  %6d  %7d\n", "total", stmtCount, stmtTotal);

    printf("--- Decls ---\n");
    u32 declTotal = 0;
    u32 declCount = 0;
    for (DeclKind i = DeclKind.min; i <= DeclKind.max; i++) {
        s.decls[i].dump(declKind_names[i], &declCount, &declTotal);
    }
    printf("  %20s  %6d  %7d\n", "total", declCount, declTotal);

    printf("--- Other ---\n");
    u32 otherTotal = 0;
    u32 otherCount = 0;
    for (u32 i=0; i<3; i++) {
        s.others[i].dump(other_names[i], &otherCount, &otherTotal);
    }
    printf("  %20s  %6d  %7d\n", "total", otherCount, otherTotal);

    printf("--- Total ---\n");
    u32 totalCount = typesCount + exprCount + stmtCount + declCount + otherCount;
    u32 totalSize = typesTotal + exprTotal + stmtTotal + declTotal + otherTotal;
    printf("  %20s  %6d  %7d\n", "objects", totalCount, totalSize);
    if (NCat > 1 && BucketWidth < 8) {
        u32 slackCount = 0;
        u32 slackTotal = 0;
        u32 nStats = sizeof(Stats) / sizeof(Stat);
        Stat* sp = (Stat*)s;
        for (u32 i = 0; i < nStats; i++) {
            sp[i].slack(&slackCount, &slackTotal);
        }
        if (slackCount) {
            printf("  %20s  %6d  %7d\n", "slack", slackCount, slackTotal);
        }
    }
    printf("---------------------------------------\n");
}

#endif
