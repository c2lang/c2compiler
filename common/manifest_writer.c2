/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module manifest_writer;

import ast;
import component;
import console;
import constants;
import file_utils;
import string_buffer;
import string_list;

import stdio;
import stdlib local;

fn const char* getKindStr(const component.Component* c) {
    switch (c.getKind()) {
    case Internal:
    case Image:
        assert(0);
        break;
    case Executable:
        assert(0);
        break;
    case StaticLibrary:     return "static";
    case DynamicLibrary:    return "dynamic";
    case ExternalStatic:
    case ExternalDynamic:
        assert(0);
        break;
    }

    return "";
}

fn void on_module(void* arg, ast.Module* m) {
    if (!m.isExported()) return;
    string_buffer.Buf* out = arg;

    out.print("    - %s\n", m.getName());
}

public fn void write(const char* dir, component.Component* c, const char* filename) {
    string_buffer.Buf* out = string_buffer.create(4096, false, 2);

    out.print("# Generated by C2C\n"
              "\n"
              "info:\n"
              "    language: C2\n"
              "    type: library\n"
              "    linkname: %s\n"
              "    kinds:\n"
              "        - %s\n"
              "\n",
              c.getName(), getKindStr(c));

    const string_list.List* deps = c.getDeps();
    for (u32 i = 0; i < deps.length(); i++) {
        // TODO can only be dynamic (unless sourcelib?)
        out.print("dependencies:\n"
                  "    %s: dynamic\n",
                  deps.get(i));
    }
    out.newline();

    out.add("modules:\n");
    c.visitModules(on_module, out);

    char[constants.Max_path] fullname;
    stdio.snprintf(fullname, elemsof(fullname), "%s/%s", dir, filename);
    file_utils.Writer writer;
    if (!writer.write(fullname, out.data(), out.size())) {
        console.error("cannot write to %s: %s", fullname, writer.getError());
        exit(EXIT_FAILURE);
    }
    out.free();
}

