/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module manifest_writer;

import ast;
import component;
import console;
import file_utils;
import string_buffer;
import string_list;

import stdlib local;
import string local;

fn const char* getKindStr(const component.Component* c) {
    switch (c.getKind()) {
    case Internal:
    case Image:
        assert(0);
        break;
    case Executable:
        assert(0);
        break;
    case StaticLibrary:     return "static";
    case DynamicLibrary:    return "dynamic";
    case SourceLibrary:     return "source";
    case ExternalStaticLib:
    case ExternalDynamicLib:
    case ExternalSourceLib:
        assert(0);
        break;
    }

    return "";
}

fn void on_module(void* arg, ast.Module* m) {
    if (!m.isExported()) return;
    string_buffer.Buf* out = arg;

    out.print("    - %s\n", m.getName());
}

fn void on_file(void* arg, const char* filename, u32 src_loc) {
    string_buffer.Buf* out = arg;
    out.print("   - %s\n", filename);
}

public fn void write(const char* dir, component.Component* c, const char* filename) {
    string_buffer.Buf* out = string_buffer.create(4096, false, 2);

    out.print("# Generated by C2C\n"
              "\n"
              "info:\n"
              "    language: C2\n"
              "    type: library\n"
              "    linkname: %s\n"
              "    kinds:\n"
              "        - %s\n"
              "\n",
              c.getName(), getKindStr(c));

    const string_list.List* deps = c.getDeps();
    if (deps.length()) {
        out.print("dependencies:\n");
        for (u32 i = 0; i < deps.length(); i++) {
            const char* depname = deps.get(i);
            if (strcmp(depname, "c2") == 0) continue;   // dont emit dependency on c2
            out.print("    %s: dynamic\n", deps.get(i));
        }
        out.newline();
    }

    out.add("modules:\n");
    c.visitModules(on_module, out);
    out.newline();

    if (c.isSourceLib()) {
        out.add("files:\n");
        c.visitFiles(out, on_file);
        out.newline();
    }

    file_utils.File file.init(dir, filename);
    if (!file.write(out.data(), out.size())) {
        console.error("cannot write to %s: %s", file.path, file.getError());
        exit(EXIT_FAILURE);
    }
    out.free();
}

