/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module file_utils;

import libc_fcntl local;
import c_errno local;
import sys_stat local;
import unistd local;
import stdlib;

fn isize read2(i32 hd, void* data, usize len) {
    u8* p = data;
    isize total_read = 0;
    while (len > 0) {
        isize nread = read(hd, p, len);
        if (nread >= 0) {
            total_read += nread;
            p += nread;
            len -= nread;
        } else {
            if (errno != EINTR)
                return -1;
        }
    }
    return total_read;
}

public fn bool File.load(File* file) {
    if (file.error) return false;
    file.contents_size = 0;
    if (file.contents) {
        stdlib.free(file.contents);
        file.contents = nil;
    }
    i32 fd = open(file.path, O_RDONLY | O_BINARY);
    if (fd < 0) {
        file.error = errno;
        return false;
    }

    // TODO: handle files whose size cannot be determined
    Stat statbuf;
    if (fstat(fd, &statbuf)) {
        file.error = errno;
        close(fd);
        return false;
    }

    if ((statbuf.st_mode & S_IFMT) != S_IFREG) {
        file.error = Err_not_a_file;
        close(fd);
        return false;
    }

    u32 size = (u32)statbuf.st_size;
    if (size != statbuf.st_size) {
        file.error = Err_too_large;
        close(fd);
        return false;
    }

    u8* region = stdlib.malloc((usize)size + 1);
    if (!region) {
        file.error = ENOMEM;
        close(fd);
        return false;
    }
    isize numread = read2(fd, region, size);
    if (numread < 0) {
        file.error = errno;
        stdlib.free(region);
        close(fd);
        return false;
    }
    if ((usize)numread != size) {
        file.error = Err_read_error;
        stdlib.free(region);
        close(fd);
        return false;
    }
    region[size] = '\0';
    file.contents = region;
    file.contents_size = size;
    close(fd);
    return true;
}

public fn bool File.isOpen(const File* file) @(unused) {
    return file.contents != nil;
}

public fn const void* File.data(File* file) @(unused) {
    return file.contents;
}

public fn u32 File.data_size(File* file) @(unused) {
    return file.contents_size;
}

public fn bool File.isEmpty(const File* file) @(unused) {
    return file.contents_size == 0;
}

public fn void* File.detach(File* file, u32 *psize) @(unused) {
    void* data = file.contents;
    *psize = file.contents_size;
    file.contents = nil;
    file.contents_size = 0;
    return data;
}
