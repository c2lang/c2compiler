/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module attr;

import src_loc local;
import string_pool;

// note: keep Attr prefix because Kind already exists a lot
public type AttrKind enum u8 {
    Unknown,
    Export,         // Type | Func | Var
    Packed,         // Struct
    Unused,         // Type | Func | Var
    UnusedParams,   // Type | Func
    Section,        //        Func | Var, needs string arg
    NoReturn,       //        Func
    Inline,         //        Func
    PrintfFormat,   //             | Var, function param only
    ScanfFormat,    //             | Var, function param only
    Aligned,        // Type | Func | Var, needs number arg
    Weak,           //        Func | Var
    Opaque,         // Struct
    CName,          // Type | Func | Var, only in interface, needs string arg
    CDef,           // Type | Func | Var, only in interface, needs string arg
    NoTypeDef,      // Type, only interface files
    Constructor,    //        Func
    Destructor,     //        Func
    Pure,           //        Func
    AutoFile,       //               Var, function param only
    AutoLine,       //               Var, function param only
    AutoFunc,       //               Var, function param only
    Embed,          //               Var, globals only
    Deprecated,     //        Func
    NoInit,         //               Var
}

const char*[AttrKind] attrKind_names = {
    "?",
    "export",
    "packed",
    "unused",
    "unused_params",
    "section",
    "noreturn",
    "inline",
    "printf_format",
    "scanf_format",
    "aligned",
    "weak",
    "opaque",
    "cname",
    "cdef",
    "no_typedef",
    "constructor",
    "destructor",
    "pure",
    "auto_file",
    "auto_line",
    "auto_func",
    "embed",
    "deprecated",
    "noinit",
}

public type AttrValueKind enum u8 {
    None,
    Number,
    String,
}

// Note: Value itself does not need to know the kind
public type AttrValue struct {
    SrcLoc loc;
    union {
        u32 text;
        u32 number;
    }
}

public type Attr struct {
    void* decl;
    u32 name;  // needed for unknown attributes
    SrcLoc loc;
    AttrKind kind;
    AttrValueKind value_kind;
    AttrValue value;
}
static_assert(32, sizeof(Attr));

// Note: only meant for printing (since not allocated in StringPool)
public fn const char* Attr.kind2name(const Attr* a) {
    return attrKind_names[a.kind];
}

public type AttrRegistry struct {
    u32[elemsof(AttrKind)] name_indexes;
}

public fn void AttrRegistry.init(AttrRegistry* ar, string_pool.Pool* pool) {
    // skip unknown attribute
    ar.name_indexes[0] = 0;
    for (AttrKind kind = (AttrKind)1; kind <= AttrKind.max; kind++) {
        ar.name_indexes[kind] = pool.addStr(attrKind_names[kind], true);
    }
}

public fn AttrKind AttrRegistry.find(AttrRegistry* ar, u32 name_idx) {
    // skip unknown
    for (AttrKind kind = (AttrKind)1; kind <= AttrKind.max; kind++) {
        if (name_idx == ar.name_indexes[kind]) return kind;
    }
    return Unknown;
}

const AttrReq[AttrKind] Required_arg = {
    [Unknown]      = NoArg,
    [Export]       = NoArg,
    [Packed]       = NoArg,
    [Unused]       = NoArg,
    [UnusedParams] = NoArg,
    [Section]      = String,
    [NoReturn]     = NoArg,
    [Inline]       = NoArg,
    [PrintfFormat] = NoArg,
    [ScanfFormat]  = NoArg,
    [Aligned]      = Number,
    [Weak]         = NoArg,
    [Opaque]       = NoArg,
    [CName]        = String,
    [CDef]         = String,
    [NoTypeDef]    = NoArg,
    [Constructor]  = NoArg,
    [Destructor]   = NoArg,
    [Pure]         = NoArg,
    [AutoFile]     = NoArg,
    [AutoLine]     = NoArg,
    [AutoFunc]     = NoArg,
    [Embed]        = String,
    [Deprecated]   = String,
    [NoInit]       = NoArg,
}

public type AttrReq enum u8 {
    NoArg = 0,
    Arg,
    Number,
    String,
    Power2,
    Ok,
}

fn bool isPowerOf2(u32 val) {
    return val && !(val & (val - 1));
}

public fn AttrReq Attr.checkArgument(const Attr* a) {
    switch (Required_arg[a.kind]) {
    case NoArg:
        if (a.value_kind != None) return NoArg;
        break;
    case Number:
        switch (a.value_kind) {
        case None:
            return Arg;
        case Number:
            if (a.kind == Aligned) {
                if (!isPowerOf2(a.value.number)) return Power2;
            }
            break;
        case String:
            return Number;
        }
        break;
    case String:
        switch (a.value_kind) {
        case None:
            return Arg;
        case Number:
            return String;
        case String:
            break;
        }
        break;
    default:
        break;
    }
    return Ok;
}

