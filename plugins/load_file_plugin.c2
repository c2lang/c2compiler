/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module plugin_main;

import component;
import console;
import constants;
import file_utils;
import plugin_info;
import string_buffer;
import yaml;

import c_errno local;
import ctype;
import stdio;
import stdlib local;
import string local;

public plugin_info.Plugin handle @(export) = {
    .load = load,
    .unload = unload,
    .init = init,
    .post_parse = nil,
    .post_analysis = nil,
    .name = "Load-File Version 1.0",
}

type Plugin struct {
    plugin_info.Info* info;
    const char* config_file; // no ownership
}

fn void escape(string_buffer.Buf* out, file_utils.Reader* file, bool terminate) {
    const u8* data = file.data();
    out.add("  ");
    for (u32 i=0; i<file.size; i++) {
        out.print("0x%02X,", data[i]);
        if (i%20 == 19) {
            out.newline();
            out.add("  ");
        }
    }
    if (terminate) out.add("0x00");
    out.newline();
}

fn bool load_file(string_buffer.Buf* out, const char* filename, const char* variable, bool terminate) {
    console.debug("load_file: loading %s", filename);

    file_utils.Reader file;
    if (!file.open(filename)) {
        console.error("load_file: cannot open file %s: %s", filename, strerror(*errno2()));
        return false;
    }

    out.print("public const u8[] Data_%s = {\n", variable);
    escape(out, &file, terminate);
    out.add("}\n\n");

    u32 size = file.size;
    if (terminate) size++;

    out.print("public const File %s = {\n", variable);
    out.print("  .data = Data_%s,\n", variable);
    out.print("  .size = %d,\n", size);
    out.add("}\n\n");
    // TODO check for duplicates
    // TODO generate AST directly (faster + less memory)

    file.close();

    return true;
}

fn bool parse_config(yaml.Parser* parser, const char* config_file, string_buffer.Buf* out) {
    const char* module_name = "load_file";
    const char* mod_name = parser.getScalarValue("file.module");
    if (mod_name) module_name = mod_name;

    out.add("// NOTE: this file is generated by the load-file plugin\n");
    out.print("module %s;\n\n", module_name);
    out.add("public type File struct {\n");
    out.add("   const u8* data;\n");
    out.add("   u32 size;\n");
    out.add("}\n\n");

    const yaml.Node* f = parser.findNode("file.files");
    if (!f) {
        console.error("load_file: missing 'file.files'");
        return false;
    }
    yaml.Iter iter = parser.getNodeChildIter(f);
    while (!iter.done()) {
        const char* variable = iter.getChildScalarValue("variable");
        if (!variable) {
            console.error("load_file: missing 'variable' entry");
            return false;
        }
        if (!ctype.isupper(variable[0])) {
            console.error("load_file: %s: variable '%s' must start with an upper case", config_file, variable);
            return false;
        }

        const char* file = iter.getChildScalarValue("file");
        if (!file) {
            console.error("load_file: missing 'file' entry");
            return false;
        }

        const char* null_terminate = iter.getChildScalarValue("null_terminate"); // optional
        bool terminate = false;
        if (null_terminate && strcmp(null_terminate, "true") == 0) terminate = true;

        if (!load_file(out, file, variable, terminate)) return false;

        iter.next();
    }

    return true;
}

fn void* load(const char* options, bool show_timing, bool show_debug) {
    Plugin* p = calloc(1, sizeof(Plugin));
    console.init();
    console.setTiming(show_timing);
    console.setDebug(show_debug);

    assert(options);
    p.config_file = options; // options should point to a YAML file

    return p;
}

fn void unload(void* arg) {
    free(arg);
}

fn void init(void* arg, plugin_info.Info* info) {
    Plugin* p = arg;
    p.info = info;

    console.debug("load_file: opening %s", p.config_file);
    file_utils.Reader file;
    if (!file.open(p.config_file)) {
        console.error("load_file: cannot open file %s: %s", p.config_file, strerror(*errno2()));
        exit(EXIT_FAILURE);
    }

    yaml.Parser* parser = yaml.Parser.create();
    if (!parser.parse(file.char_data())) {
        console.error("load_file: %s", parser.getMessage());
        exit(EXIT_FAILURE);
    }

    string_buffer.Buf* out = string_buffer.create(1024, false, 2);

    if (!parse_config(parser, p.config_file, out)) {
        exit(EXIT_FAILURE);
    }

    file_utils.Writer outfile;
    char[constants.Max_path] fullname;
    stdio.sprintf(fullname, "%s/%s", info.output_dir, "loadfile.c2");
    console.debug("load_file: writing %s (%d bytes)", fullname, out.size());
    if (!outfile.write(fullname, out.udata(), out.size())) {
        console.error("load_file: %s", outfile.msg);
        exit(EXIT_FAILURE);
    }

    out.free();
    file.close();
    parser.destroy();

    // add generated file to Target
    u32 filename = info.auxPool.addStr(fullname, false);
    info.target.addFile(filename, 0);
}

