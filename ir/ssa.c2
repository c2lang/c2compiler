/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ir_context;

import ir local;
import ir_rev_list local;
import ir_slot_collector local;

import std local;

fn void Tools.createSSA(Tools* t) {
    FunctionInfo* fi = t.fi;
    const u32 num_blocks = fi.blocks.getCount();

    t.inserter.clear(num_blocks, fi.instructions.getCount());

    // do slot promotion, convert those load/stores to copy
    t.collector.fill(fi);

    t.revlist.build(fi);
    t.active_blocks.reset(num_blocks);

    //t.collector.dump();
    //t.revlist.dump();

    //t.print_func("after collector.fill");

    /*
        Algorithm for PHI insertion

        foreach block
          foreach read
            foreach predecessor
                checkPredBlock
            if num_results > 1 -> Phi, update read-ref
            mark read as done

        checkPredBlock
            checkPredessors
            if num_results > 1 -> Phi
            if (also have same read)
                mark as done
                update read_ref
            return ref
    */


    // Note: block 0 will usually never have reads, but can have after optimizations with loops
    Block* blocks = fi.blocks.get(0);

    for (u32 blk_id = 0; blk_id < num_blocks; blk_id++) {
        // Note: dont add start block as active, since it might provide write itself (in loops)

        // V2: dont store ReadSlotAccess, just go through all copies and get value.
        // If not there it is first read, otherwise fill with last write
        Block* b = &blocks[blk_id];

        t.slot_values.clear(fi.num_slots);
        u32 last = b.instr.start + b.instr.count;

        for (u32 j=b.instr.start; j<last; j++) {
            // TODO refactor inserter not to re-alloc current list
            Instr* ii = fi.instructions.get(j);
            if (!ii.isCopy()) continue;
            if (!ii.args[0].isSlot()) continue;

            u16 slot = (u16)ii.args[0].value;
            //printf("B%d  R S%d\n", blk_id, slot);
            // check if in write list already, take that value then, otherwise do code below
            Ref ref = t.slot_values.find(slot);
            if (ref.isNone()) {
                ref = t.checkBlockRead(blk_id, slot);
                if (ref.isNone()) {
                    printf("NONE for B%d  slot %d\n", blk_id, slot);
                }
                assert(!ref.isNone());  // read of undefined variable
                t.slot_values.set(slot, ref);
                //printf("  new write   S%d  %s %d\n", slot, ref.getKindName(), ref.value);
            } else {
                //printf("  used write  S%d  %s %d\n", slot, ref.getKindName(), ref.value);
            }
            ii.args[0] = ref;
        }

        t.active_blocks.clear(blk_id);
    }
    //t.inserter.dump();
}

fn Ref Tools.checkBlockRead(Tools* t, BlockId blk_id, u16 slot) {
    FunctionInfo* fi = t.fi;
    //printf(">> B%d S%d <<\n", blk_id, slot);

    PhiClauses clauses.init();
    RevIndex revs = t.revlist.getBlockIndex(blk_id);

    for (u32 r = revs.start; r < revs.start + revs.count; r++) {
        u32 rev_blk = t.revlist.getRev(r);
        if (!t.active_blocks.get(rev_blk)) {
            Ref ref = t.checkPredBlock(rev_blk, slot, fi);
            if (ref.isValid()) {
                //printf("  B%d S%d Pred %d match (%s %d)\n", blk_id, slot, rev_blk, ref.getKindName(), ref.value);
                clauses.add(rev_blk, ref);
            }
        }
    }

    // Note: clauses.getCount() can be 0 if only passing variable to calls
    Ref ref = {}
    if (clauses.getCount()) {
        if (clauses.getCount() > 1) {
            //printf("  B%d (a) NEED PHI for S%d\n", blk_id, slot);
            Block* b = fi.blocks.get(blk_id);
            u32 loc = b.instr.start;
            if (fi.instructions.get(loc).isComment()) loc++;
            ref = t.addPhiInstr(fi, &clauses, loc, slot);
        } else {
            ref = clauses.stash[0].ref;
        }
        t.collector.insertWriteIfNone(blk_id, slot, ref);
    }
    clauses.free();
    return ref;
}

fn Ref Tools.checkPredBlock(Tools* t, BlockId blk_id, u16 slot, FunctionInfo* fi) {
    Ref ref = { }

    t.active_blocks.set(blk_id);

    // check if this block writes slot, otherwise propagate up
    //printf("B%d check S%d\n", blk_id, slot);

    const Ref* wr = t.collector.findWrite(blk_id, slot);
    if (wr) {
        //printf("B%d S%d W %s %d\n", blk_id, slot, wr.ref.getKindName(), wr.ref.value);
        // Note: can stil have read before this write, that's ok
        t.active_blocks.clear(blk_id);
        return *wr;
    }

    // search all predecessors
    RevIndex revs = t.revlist.getBlockIndex(blk_id);
    u32 rev_end = revs.start + revs.count;
    PhiClauses clauses.init();
    for (u32 j = revs.start; j < rev_end; j++) {
        u32 rev_blk = t.revlist.getRev(j);
        // TODO do check block itself, but not more (for loops)
        if (!t.active_blocks.get(rev_blk)) {
            Ref ref2 = t.checkPredBlock(rev_blk, slot, fi);
            if (ref2.isValid()) {
                //printf("B%d S%d Pred %d match (%s %d)\n", blk_id, slot, rev_blk, ref2.getKindName(), ref2.value);
                clauses.add(rev_blk, ref2);
            }
        }
    }
    // if no matches, variable is undefined!
    if (clauses.getCount() != 0) {
        ReadSlotAccess* my_read = t.collector.findRead(blk_id, slot);
        if (my_read) {
            my_read.done = 1;
            //printf("B%d finished my S%d\n", blk_id, slot);
        }

        if (clauses.getCount() != 0) {
            if (clauses.getCount() > 1) {
                //printf("  B%d (b) NEED PHI for S%d\n", blk_id, slot);
                Block* b = fi.blocks.get(blk_id);
                u32 loc = b.instr.start;
                if (fi.instructions.get(loc).isComment()) loc++;
                ref = t.addPhiInstr(fi, &clauses, loc, slot);

                if (my_read) {
                    // TODO replace load with copy with phi_ref
                }
            } else {
                ref = clauses.stash[0].ref;
            }

            // add virtual write to prevent doing the same work again
            assert(ref.isValid());
            t.collector.insertWrite(blk_id, slot, ref);
            if (my_read) {
                // TODO replace load with copy with ref to result[0]
            }
        }
    }
    clauses.free();
    t.active_blocks.clear(blk_id);
    return ref;
}

fn Ref Tools.addPhiInstr(Tools* t, FunctionInfo* fi, const PhiClauses* cache, u32 loc, u16 slot) {
    //printf("==== ADD PHI  loc %d  slot %d ====\n", loc, slot);
    u32 instr_idx = t.inserter.addInstr(loc);
    Ref out.init(RefKind.Temp, instr_idx);

    Instr* ii = t.inserter.getLastInstr();
    u32 phi_start = fi.phis.addCache(instr_idx, cache);
    //printf("  CLAUSES %d %d\n", phi_start, cache.getCount());
    ii.initPhi(phi_start, cache.getCount());

    // mark all source blocks as phi_source
    const PhiClause* clauses = cache.getClauses();
    for (u32 i=0; i<cache.getCount(); i++) {
        BlockId blk_id = clauses[i].src;
        Block* b = fi.blocks.get(blk_id);
        b.phi_source = 1;
    }

    Ref comment_ref.init(RefKind.Text, getSlotName(slot));
    t.inserter.addInstr(loc);
    Instr* ii2 = t.inserter.getLastInstr();
    ii2.init1(InstrKind.Comment, comment_ref);

    //printf("  PHI REF %d\n", out.value);
    return out;
}

fn void Tools.eliminateCopies(Tools* t) {
    FunctionInfo* fi = t.fi;
    // do copy eliminination. Try 1 pass (if possible)
    // otherwise mark in prev run and apply here
    t.copies.clear();

    // Needs 2 loops, one to fill copylist, remove copies, 2nd to replace
    // Note: the filling could be done in previous loop already!

    Instr* all = fi.instructions.get(0);

    for (u32 i=0; i<fi.instructions.getCount(); i++) {
        Instr* instr = &all[i];
        if (instr.isCopy()) {
            t.copies.add(i, instr.args[0]);
            //printf("add %d   %s\n", i, instr.args[0].str());
            instr.clear();
        }
    }
    for (u32 i=0; i<fi.instructions.getCount(); i++) {
        Instr* instr = &all[i];
        if (instr.isPhi()) {
            PhiClause* clauses = fi.phis.get(instr.args[0].value);
            for (u32 j=0; j<instr.args[1].value; j++) {
                Ref* r = &clauses[j].ref;
                if (r.isTemp()) {
                    Ref* copy = t.copies.find(r.value);
                    if (copy) {
                        //printf("replace %s with %s\n", r.str(), copy.str());
                        *r = *copy;
                    }
                }
            }
        } else {
            Ref* r = &instr.args[0];
            if (r.isTemp()) {
                Ref* copy = t.copies.find(r.value);
                if (copy) {
                    //printf("replace %s with %s\n", r.str(), copy.str());
                    instr.args[0] = *copy;
                }
            }
            r = &instr.args[1];
            if (r.isTemp()) {
                Ref* copy = t.copies.find(r.value);
                if (copy) {
                    //printf("replace %s with %s\n", r.str(), copy.str());
                    instr.args[1] = *copy;
                }
            }
        }
    }
}


fn void Tools.checkRef(Tools* t, Ref r) {
    if (r.isTemp()) t.usage.incr(r.value);
}

fn void Tools.removeUnused(Tools* t) {
    FunctionInfo* fi = t.fi;
    t.usage.clear(fi.instructions.getCount());

    // Usage: counter both usage and if it has a result.
    // count 0 means: has no result, (of course) not used
    // count 1 means: has result, not used (could still have side effects)
    // count 2+ means: used

    Instr* all = fi.instructions.get(0);
    for (u32 i=0; i<fi.instructions.getCount(); i++) {
        Instr* is = &all[i];
        if (is.hasResult()) t.usage.incr(i);

        switch (is.getKind()) {
        case Call:
            // TODO check if call with side effects.
            // TEMP do extra incr then so it will not be pruned (could be void, so incr twice)
            t.usage.incr(i);
            t.usage.incr(i);
            t.checkRef(is.args[0]);
            t.checkRef(is.args[1]);
            break;
        case Switch:
            t.checkRef(is.args[0]);
            break;
        case Phi:
            PhiClause* clauses = fi.phis.get(is.args[0].value);
            for (u32 p=0; p<is.args[1].value; p++) {
                t.checkRef(clauses[p].ref);
            }
            break;
        default:
            t.checkRef(is.args[0]);
            t.checkRef(is.args[1]);
            break;
        }
    }

    //t.usage.dump();
    t.usage.fillQueue();

    while (t.usage.hasWork()) {
        u32 i = t.usage.popHead();
        Instr* is = &all[i];
        Ref* r = &is.args[0];
        if (r.isTemp()) t.usage.decr(r.value);
        r = &is.args[1];
        if (r.isTemp()) t.usage.decr(r.value);
        is.clear();
    }
}

#if 0
fn bool Tools.propagateConstants(Tools* t) {
    FunctionInfo* fi = t.fi;
// return true if changed
    // look for add x, y where x, y are both constants, replace with copy
    bool changed = false;
    u32 matches = 0;

    Instr* all = fi.instructions.get(0);
    for (u32 i=0; i<fi.instructions.getCount(); i++) {
        Instr* instr = &all[i];
        if (!instr.isArithmetic()) continue;

        if (!instr.args[0].isConstant()) continue;
        if (!instr.args[1].isConstant()) continue;

        matches++;
        printf("MATCH %d  %d\n", i, matches);
        // only 29 matches in c2c!
        changed = true;
    }

    return changed;
}
#endif

fn void Tools.removeNone(Tools* t) {
    FunctionInfo* fi = t.fi;
    t.inserter.clear(fi.blocks.getCount(), fi.instructions.getCount());
    t.fixup_function();
}

// merge new instructions into list, also remove empty instructions
fn void Tools.fixup_function(Tools* t) {
    FunctionInfo* fi = t.fi;
    // only change instructions!, not blocks (except to update instr start+count)
    u32 old_icount = fi.instructions.getCount();
    u32 total = old_icount + t.inserter.getInstrCount();

    InstrList new_instrs.init(total);
    t.conversion.clear(total);
    t.inserter.start();

    const Instr* old_instrs = fi.instructions.get(0);
    u32 num_blocks = fi.blocks.getCount();

    // 1st step: insert new instructions, remove None instructions
    u32 new_index = 0;
    for (u32 blk_id=0; blk_id<num_blocks; blk_id++) {
        Block* b = fi.blocks.get(blk_id);
        u32 i_start = b.instr.start;
        u32 i_count = b.instr.count;
        //printf("B%d  %d %d\n", blk_id, i_start, i_count);
        u32 new_start = new_index;

        // double check here for empty blocks
        while (t.inserter.hasInsert(i_start)) {
            Instr* is = new_instrs.add();
            //printf("  insert %d @ %d\n", t.inserter.getInstrIdx(), i_start);
            is.copy(t.inserter.getInstr());
            t.conversion.set(t.inserter.getInstrIdx(), new_index);
            t.inserter.next();
            new_index++;
        }

        for (u32 j=i_start; j<i_start+i_count; j++) {
            // check for insertion
            while (t.inserter.hasInsert(j)) {
                Instr* is = new_instrs.add();
                //printf("  insert %d @ %d\n", t.inserter.getInstrIdx(), j);
                is.copy(t.inserter.getInstr());
                t.conversion.set(t.inserter.getInstrIdx(), new_index);
                t.inserter.next();
                new_index++;
            }

            if (old_instrs[j].isNone()) continue;

            Instr* is = new_instrs.add();
            is.copy(&old_instrs[j]);
            t.conversion.set(j, new_index);

            new_index++;
        }
        b.instr.start = new_start;
        b.instr.count = new_index - new_start;
    }

    new_instrs.swap(&fi.instructions);
    new_instrs.free();
    t.inserter.clear(0, 0);

    // 2nd step: update all temps (needed after first loop for forwards refs)
    Instr* instrs = fi.instructions.get(0);
    Block* blocks = fi.blocks.get(0);
    for (u32 i=0; i<num_blocks; i++) {
        Block* b = &blocks[i];
        u32 i_start = b.instr.start;
        u32 i_count = b.instr.count;
        //stdio.printf("   B[%d] %d - %d\n", i, i_start, i_start+i_count-1);
        for (u32 j=i_start; j<i_start+i_count; j++) {
            Instr* is = &instrs[j];

            if (is.isPhi()) {
                PhiClause* clauses = fi.phis.get(is.args[0].value);
                for (u32 p=0; p<is.args[1].value; p++) {
                    PhiClause* pc = &clauses[p];
                    pc.dest_idx = t.conversion.get(pc.dest_idx);
                    Ref* r = &pc.ref;
                    if (r.isTemp()) r.value = t.conversion.get(r.value);
                }
            } else {
                Ref* r = &is.args[0];
                if (r.isTemp()) r.value = t.conversion.get(r.value);
                r = &is.args[1];
                if (r.isTemp()) r.value = t.conversion.get(r.value);
            }
        }
    }
}

