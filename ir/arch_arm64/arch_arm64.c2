/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module arch_arm64;

import ir_tools local;
import ir local;

import stdio local;
/*
type Regs enum u8 {
    R0, R1, R2, R3, R4, R5, R6, R7, // return + args
    R8, R9, R10, R11, R12, R13, R14, R15,   // temp
    R19, R20, R21, R22, R23, R24, R25, R26, R27, R28,   // callee saved
    R16, R17, R18, R29, R30, R31, // other
}
*/

type Regs struct {
    u32 ngrn;   // Next General-purpose Register Number
    u32 nsrn;   // Next SIMD and FP Register Nmuber
    u32 nprn;   // Next Scalable Predicate Register Number
    i32 nsaa;   // Next stacked argument address

    // TODO arg info [MaxArgs] // number, stack, pointer, etc
}

fn void instructionSelection(Tools* t, ir.FunctionInfo* f) {
}

fn void applyCallingConv(Tools* t, FunctionInfo* f) {

    //printf("ARM64 calling conv.\n");
    FunctionInfo* fi = t.fi;
    u32 num_blocks = fi.blocks.getCount();
    Block* blocks = fi.blocks.get(0);
    Instr* instrs = fi.instructions.get(0);

    // Stage A - initialization
    Regs regs = { }
    //regs.nsaa = stack;

    // Stage B - Pre-padding + extension of arguments
    // TODO for now only support integers
    for (u32 i = 0; i < f.num_args; i++) {
        Type tt = f.getArg(i);
        //printf("  [%d] %s\n", i, tt.str());
    }

    // Stage C - Assignment of arguments to registers and stack
    for (u32 i = 0; i < f.num_args; i++) {
        Type argtype = f.getArg(i);
        //printf("ARG[%d]: ", i);
        u8 size = 0;
        u8 align = 0;
        //printf("  [%d] %s\n", i, tt.str());
        switch (argtype) {
        case None:
        case I8:
        case I16:
        case I32:
        case I64:
        case U8:
        case U16:
        case U32:
        case U64:
            if (regs.ngrn < 8) {
                // C.9 - assign x[ngrn]
                //printf(" x%d\n", regs.ngrn);
                regs.ngrn++;
                continue;
            }
            break;
        case F32:
        case F64:
            if (regs.nsrn < 8) {
                // C.1 - assign v[nsrn]
                //printf(" v%d\n", regs.nsrn);
                regs.nsrn++;
                continue;
            }
            // TODO HFA/HVA C.1-C.5
            size = 8;   // C.5
            printf(" S-%d\n", regs.nsaa);
            regs.nsaa += size;
            continue;
        }

        // C.10
        if (align == 16) regs.ngrn = (regs.ngrn + 1) & ~0x1;
        // TODO more

    }



    // Params, replace %1 = param with  %1 = copy R0
    {
        Block* b0 = &blocks[0];
        u32 num_arg = 0;
        while (1) {
            Instr* ii = &instrs[b0.instr.start + num_arg];
            if (!ii.isParam()) break;
            // For now always put stack-based arguments in a register immediately
            ii.instrBits.kind = InstrKind.Copy;
            ii.args[0].setRegister(num_arg);    // start with R0
            num_arg++;
        }
    }

    // replace args with copy (if arg is Temp)
    // arg %1 =>  R0 = copy %1
    for (u32 blk_id = 0; blk_id < num_blocks; blk_id++) {
        Block* b = &blocks[blk_id];
        u32 last = b.instr.start + b.instr.count;
        u32 num_arg = 0;
        for (u32 j = b.instr.start; j < last; j++) {
            Instr* ii = &instrs[j];
            switch (ii.getKind()) {
            case Call:
                num_arg = 0;
                break;
            case Ret:
                // TODO is Ret, just add copy a0 = copy %1
                break;
            case Arg:
                ii.setReg((u8)num_arg);
                ii.instrBits.kind = InstrKind.Copy;
                num_arg++;
                break;
            default:
                break;
            }
        }
    }
}

const Target ArchInfo = {
    .applyCallingConv = applyCallingConv,
    .instructionSelection = instructionSelection,
    .num_args_in_regs = 8,
    .num_regs = 32,
    .num_temps = 8,
    .num_saved = 10,
    .arg0_reg = 0,
    .saved0_reg = 16,
    .regs = nil,    // num_regs_long, TODO how what to point to?
}

public fn const Target* getTarget() {
    return &ArchInfo;
}

