/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module ir;

import std local;

public type InstrBits struct {
    InstrKind kind : 8;
    u32 type_ : 4;  // resulting type if any
    u32 has_result : 1;
    u32 has_register : 1;
    u32 register_nr : 6;    // might need more for spilling
}

public type Instr struct {
    union {
        InstrBits instrBits;
        u32 bits;
    }
    Ref[2] args; // most instructions
}
static_assert(12, sizeof(Instr));

public fn void Instr.setReg(Instr* i, u8 reg) {
    i.instrBits.has_register = 1;
    i.instrBits.register_nr = reg;
}

// instructions with no result or args (eg. hlt, jmp)
public fn void Instr.init0(Instr* i, InstrKind k) {
    memset(i, 0, sizeof(Instr));
    i.instrBits.kind = k;
}

// instructions with result, no args (eg param)
public fn void Instr.init0b(Instr* i, InstrKind k) {
    memset(i, 0, sizeof(Instr));
    i.instrBits.kind = k;
    i.instrBits.has_result = true;
}

public fn void Instr.initPhi(Instr* i, u32 clause_start, u32 num_clauses) {
    i.bits = 0;
    i.instrBits.kind = InstrKind.Phi;
    i.instrBits.has_result = true;
    i.args[0].init(RefKind.PhiClause, clause_start);
    i.args[1].init(RefKind.PhiClause, num_clauses);
}

// instructions with no result, 1 arg (eg. jmp, ret)
public fn void Instr.init1(Instr* i, InstrKind k, Ref ref1) {
    memset(i, 0, sizeof(Instr));
    i.instrBits.kind = k;
    i.args[0] = ref1;
}

// instructions with 1 result and 1 arg (eg. neg, load, alloc)
public fn void Instr.init1b(Instr* i, InstrKind k, Ref ref1) {
    memset(i, 0, sizeof(Instr));
    i.instrBits.kind = k;
    i.instrBits.has_result = true;
    i.args[0] = ref1;
}

// instructions with no result, 2 args (eg store)
public fn void Instr.init2(Instr* i, InstrKind k, Ref ref1, Ref ref2) {
    memset(i, 0, sizeof(Instr));
    i.instrBits.kind = k;
    i.args[0] = ref1;
    i.args[1] = ref2;
}

// instructions with result + 2 args (eg add, call, jmp_if)
public fn void Instr.init2b(Instr* i, InstrKind k, Ref ref1, Ref ref2) {
    i.bits = 0;
    i.instrBits.kind = k;
    i.instrBits.has_result = true;
    i.args[0] = ref1;
    i.args[1] = ref2;
}

public fn void Instr.initRegCopy(Instr* i, u8 dst_reg, Ref ref) {
    i.instrBits.kind = InstrKind.Copy;
    i.instrBits.type_ = 0; // not used
    i.instrBits.has_result = 1;
    i.instrBits.has_register = 1;
    i.instrBits.register_nr = dst_reg;
    i.args[0] = ref;
    i.args[1].kind = RefKind.None;
    i.args[1].value = 0;
}

public fn void Instr.copy(Instr* i, const Instr* i2) {
    memcpy(i, i2, sizeof(Instr));
}

public fn InstrKind Instr.getKind(const Instr* i) {
    return i.instrBits.kind;
}

public fn bool Instr.hasResult(const Instr* i) {
    return i.instrBits.has_result;
}

public fn bool Instr.hasRegister(const Instr* i) {
    return i.instrBits.has_register;
}

public fn u32 Instr.getRegister(const Instr* i) {
    return i.instrBits.register_nr;
}

public fn void Instr.clear(Instr* i) {
    memset(i, 0, sizeof(Instr));
}

public fn const char* Instr.getKindName(const Instr* i) {
    InstrKind k = i.getKind();
    return k.str();
}

public fn bool Instr.isPseudo(const Instr* i) {
    return i.getKind() >= InstrKind.Switch;
}

public fn bool Instr.isNone(const Instr* i) {
    return i.getKind() == InstrKind.None;
}

public fn bool Instr.isCopy(const Instr* i) {
    return i.getKind() == InstrKind.Copy;
}

public fn bool Instr.isReturn(const Instr* i) {
    return i.getKind() == InstrKind.Ret;
}

/*
fn bool Instr.isArithmetic(const Instr* i) {
    InstrKind k = i.getKind();
    return k >= InstrKind.Add && k <= InstrKind.Shl;
}
*/

public fn bool Instr.isSwitch(const Instr* i) {
    return i.getKind() == InstrKind.Switch;
}

public fn bool Instr.isPhi(const Instr* i) {
    return i.getKind() == InstrKind.Phi;
}

public fn bool Instr.isComment(const Instr* i) {
    return i.getKind() == InstrKind.Comment;
}

