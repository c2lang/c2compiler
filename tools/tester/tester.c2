/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module tester_main;

import stdio local;
import stdlib local;
import string local;
import sys_stat local;
import sys_time;
import libc_dirent local;
import c_errno local;
import unistd;
import pthread;

import color;
import test_utils local;
import test_db local;
import string_buffer;
import file_utils;

/*
    Syntax:
    .c2:
        (optional) // @warnings{..}
        (optional) // @skip
        (optional) // @target{target-triplet}
    .c2t:  test generation of specified files
        (required) // @recipe bin/lib dynamic/static
        (optional) // @skip
        (required) // @file{filename}
        (optional) // @expect{atleast/complete, filename}
    .c2a: test AST of parsed file (no unused)
        (optional) // @skip
        (required) // @file{filename}   allowed ONCE
        (required) // @expect{atleast/complete}  allowed ONCE
*/

const u32 MAX_THREADS = 32;

const char* c2c_cmd = "output/c2c/c2c";
bool color_output = true;
bool runSkipped;
i32 verboseLevel = 1;

// TODO move test + queue to own file
type Test struct {
    char* filename;
    TestKind kind;
    bool failed;
    Test* next;
}

fn Test* Test.create(const char* filename, TestKind kind) {
    Test* t = calloc(1, sizeof(Test));
    t.filename = strdup(filename);
    t.kind = kind;
    return t;
}

fn void Test.destroy(Test* t) {
    free(t.filename);
    free(t);
}

type TestQueue struct {
    pthread.Mutex lock;
    Test* head;
    Test* tail;
    Test* cur;
    u32 count;
}

fn TestQueue* TestQueue.create() {
    TestQueue* q = calloc(1, sizeof(TestQueue));
    q.lock.init(nil);
    return q;
}

fn void TestQueue.destroy(TestQueue* q) {
    Test* cur = q.head;
    while (cur) {
        Test* next = cur.next;
        cur.destroy();
        cur = next;
    }
    free(q);
}

fn void TestQueue.add(TestQueue* q, const char* filename, TestKind kind) {
    Test* t = Test.create(filename, kind);
    q.lock.lock();
    if (q.tail) {
        q.tail.next = t;
    } else {
        q.head = t;
        q.cur = t;
    }
    q.tail = t;
    q.count++;
    q.lock.unlock();
}

fn Test* TestQueue.get(TestQueue* q) {
    Test* t = nil;
    q.lock.lock();
    if (q.cur) {
        t = q.cur;
        q.cur = q.cur.next;
    }
    q.lock.unlock();
    return t;
}

fn void TestQueue.summarizeFailed(const TestQueue* q) {
    printf("\nFailed test summary:\n");
    const Test* t = q.head;
    while (t) {
        if (t.failed) color_print(colError, "%s", t.filename);
        t = t.next;
    }
}

fn u32 online_cpus() {
    i64 ncpus = unistd.sysconf(unistd._SC_NPROCESSORS_ONLN);
    if (ncpus > 8) return 8;    // Hack around Ryzen virtual cores. Using only physical is faster
    if (ncpus > 0) return cast<u32>(ncpus);
    return 1;
}

fn void handle_file(TestQueue* queue, const char* filename) {
    TestKind kind;
    if (endsWith(filename, ".c2")) {
        kind = TestKind.C2;
    } else if (endsWith(filename, ".c2t")) {
        kind = TestKind.C2T;
    } else if (endsWith(filename, ".c2a")) {
        kind = TestKind.C2A;
    } else {
        return;
    }

    queue.add(filename, kind);
}

fn void handle_dir(TestQueue* queue, const char* path) {
    DIR* dir = opendir(path);
    if (dir == nil) {
        color_print(colError, "cannot open dir '%s': %s", path, strerror(*errno2()));
        return;
    }
    Dirent* dir2 = readdir(dir);
    char[test_db.MAX_LINE] temp;
    while (dir2 != nil) {
        // FIXME: need string.makepath
        snprintf(temp, sizeof(temp), "%s/%s", path, dir2.d_name);
        switch (dir2.d_type) {
        case DT_REG:
            handle_file(queue, temp);
            break;
        case DT_DIR:
            if (strcmp(dir2.d_name, ".") != 0 && strcmp(dir2.d_name, "..") != 0) {
                handle_dir(queue, temp);
            }
            break;
        default:
            break;
        }
        dir2 = readdir(dir);
    }
    closedir(dir);
}


type Tester struct {
    u32 numtests;
    u32 numerrors;
    u32 numskipped;

    u32 index;
    TestQueue* queue;
    pthread.Pthread thread;
    char[32] tmp_dir;
    const char* cwd;    // no ownership
}

fn void* tester_thread_main(void* arg) {
    Tester* t = arg;
    t.run();
    return nil;
}

fn Tester* Tester.create(u32 idx, TestQueue* q, const char* cwd) {
    Tester* t = calloc(1, sizeof(Tester));
    t.index = idx;
    t.queue = q;
    t.cwd = cwd;
    snprintf(t.tmp_dir, sizeof(t.tmp_dir), "/tmp/tester%d", idx);
    pthread.create(&t.thread, nil, tester_thread_main, t);
    return t;
}

fn void Tester.destroy(Tester* t) {
    free(t);
}

fn void Tester.join(Tester* t) {
    pthread.join(t.thread, nil);
}

fn void Tester.run(Tester* t) {
    while (1) {
        Test* test = t.queue.get();
        if (!test) break;
        t.run_test(test);
    }
}

fn void Tester.run_test(Tester* t, Test* test) {
    // setup dir
    // temp, just delete this way
    char[64] cmd;
    snprintf(cmd, sizeof(cmd), "rm -rf %s", t.tmp_dir);
    i32 err = system(cmd);
    if (err != 0 && *errno2() != 10) {
        i32 saved = *errno2();
        fprintf(stderr, "error running '%s': %s, %d\n", cmd, strerror(saved), saved);
        exit(EXIT_FAILURE);
    }
    // create test dir
    err = mkdir(t.tmp_dir, 0777);
    if (err) {
        fprintf(stderr, "error creating %s: %s\n", t.tmp_dir, strerror(*errno2()));
        exit(EXIT_FAILURE);
    }

    t.numtests++;

    string_buffer.Buf* buf = string_buffer.create(4096, true, 2);
    buf.print("%s ", test.filename);

    file_utils.Reader file;
    bool ok = file.open(test.filename);
    if (!ok) {
        fprintf(stderr, "error opening %s: %s\n", test.filename, strerror(*errno2()));
        exit(EXIT_FAILURE);
    }

    test_db.Db db;
    db.init(buf, &file, test.filename, test.kind, t.tmp_dir, c2c_cmd, t.cwd, runSkipped);
    bool print = verboseLevel > 1;
    bool skip = db.parse();
    if (skip) {
        t.numskipped++;
        buf.clear();
        color_print2(buf, colSkip, "%s SKIPPED", test.filename);
        if (verboseLevel >= 1) print = true;
    } else {
        buf.newline();

        if (!db.haveErrors()) {
            db.testFile();
            if (db.printIssues()) print = true;
        }
        if (db.haveErrors()) {
            print = true;
            test.failed = true;
            t.numerrors++;
        }
    }
    if (print) printf("%s", buf.data());

    db.destroy();
    file.close();
    buf.free();
}

fn void usage(const char* name) {
    printf("Usage: %s [file/dir] <options>\n", name);
    printf("    -j    use multi-threading\n");
    printf("    -n    no multi-threading\n");
    printf("    -s    only run skipped tests\n");
    printf("    -t    terse output, only errors shown\n");
    printf("    -v    verbose output\n");
    exit(EXIT_FAILURE);
}

fn u64 now() {
    sys_time.Timeval tv;
    sys_time.gettimeofday(&tv, nil);
    u64 now64 = cast<u64>(tv.tv_sec);
    now64 *= 1000000;
    now64 += tv.tv_usec;
    return now64;
}

public fn i32 main(i32 argc, char** argv) {
    set_color_output(unistd.isatty(1));

    u32 num_threads = 0;
    char* target = nil;

    for (i32 i = 1; i < argc; i++) {
        char *arg = argv[i];
        if (arg[0] == '-') {
            if (strcmp(arg, "-s") == 0) {
                runSkipped = true;
            } else if (strcmp(arg, "-t") == 0) {
                verboseLevel -= 1;
            } else if (strcmp(arg, "-v") == 0) {
                verboseLevel += 1;
            } else if (strcmp(arg, "-n") == 0) {
                num_threads = 1;
            } else if (strncmp(arg, "-j", 2) == 0) {
                num_threads = cast<u32>(atoi(arg + 2));
            } else {
                usage(argv[0]);
            }
        } else {
            if (target != nil) usage(argv[0]);
            target = arg;
        }
    }
    if (target == nil) usage(argv[0]);

    if (num_threads == 0) num_threads = online_cpus();
    if (num_threads > MAX_THREADS) num_threads = MAX_THREADS;

    color_output = unistd.isatty(1);

    Stat statbuf;
    if (stat(target, &statbuf)) {
        fprintf(stderr, "error stat-ing %s: %s\n", target, strerror(*errno2()));
        return -1;
    }

    // strip off trailing '/'
    usize len = strlen(target);
    if (len > 1 && target[len - 1] == '/') target[--len] = '\0';

    char* cwd = unistd.getcwd(nil, 0);
    if (cwd == nil) {
        perror("getcwd");
        exit(EXIT_FAILURE);
    }

    TestQueue* queue = TestQueue.create();

    u64 t1 = now();

    if (statbuf.st_mode & S_IFMT == S_IFREG) {
        num_threads = 1;
        handle_file(queue, target);
    } else if (statbuf.st_mode & S_IFMT == S_IFDIR) {
        handle_dir(queue, target);
    } else {
        usage(argv[0]);
    }

    Tester*[MAX_THREADS] testers = { nil }
    for (u32 i=0; i<num_threads; i++) {
        testers[i] = Tester.create(i, queue, cwd);
    }

    // TODO handle Ctrl-C

    u32 numtests = 0;
    u32 numerrors = 0;
    u32 numskipped = 0;

    for (u32 i=0; i<num_threads; i++) {
        Tester* t = testers[i];
        t.join();
        numtests += t.numtests;
        numerrors += t.numerrors;
        numskipped += t.numskipped;
        t.destroy();
    }

    u64 t2 = now();

    const char* col = (numerrors ? colError : colOk);
    color_print(col, "RESULTS: %d test%s, %d threads (%d ok, %d failed, %d skipped) ran in %d ms",
        numtests, numtests == 1 ? "" : "s", num_threads, numtests - (numerrors+numskipped), numerrors, numskipped, (t2-t1)/1000);
    if (numerrors) queue.summarizeFailed();

    queue.destroy();
    free(cwd);

	return 0;
}

