/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import scope;
import src_loc;

fn bool hasReturn(const Stmt* s) {

    switch (s.getKind()) {
        case Return:
            return true;
        case If:
            const IfStmt* i = cast<IfStmt*>(s);
            if (!hasReturn(i.getThen())) return false;
            const Stmt* e = i.getElse();
            if (e && hasReturn(e)) return true;
            break;
        case While:
            // TODO only allow while(true/1), no breaks and only return
            break;
        case Do:
            // TODO
            break;
        case For:
            // TODO
            break;
        case Switch:
            // TODO
            break;
        case Label:
            // TODO
            break;
        case Compound:
            const CompoundStmt* cs = cast<CompoundStmt*>(s);
            const Stmt* last = cs.getLastStmt();
            if (!last) return false;
            return hasReturn(last);
        default:
            break;
    }

    return false;
}

fn void Analyser.analyseStmt(Analyser* ma, Stmt* s, bool checkEffect) {
    if (ma.scope.isUnreachable() && s.getKind() != StmtKind.Label) {
        ma.warn(s.getLoc(), "unreachable code");
        // TODO dont warn anymore
    }
    switch (s.getKind()) {
        case Return:
            ma.analyseReturnStmt(s);
            ma.scope.setUnreachable();
            break;
        case Expr:
            // TODO need a different set, since this one uses the Stack of Globals
            ma.analyseExpr(cast<Expr**>(&s), false, 0);
            Expr* e = cast<Expr*>(s);
            if (checkEffect && !e.hasEffect()) ma.errorRange(e.getLoc(), e.getRange(), "expression without effect");
            break;
        case If:
            ma.analyseIfStmt(s);
            break;
        case While:
            ma.analyseWhileStmt(s);
            break;
        case Do:
            ma.analyseDoStmt(s);
            break;
        case For:
            ma.analyseForStmt(s);
            break;
        case Switch:
            ma.analyseSwitchStmt(s);
            break;
        case Break:
            ma.analyseBreakStmt(s);
            ma.scope.setUnreachable();
            break;
        case Continue:
            ma.analyseContinueStmt(s);
            ma.scope.setUnreachable();
            break;
        case Fallthrough:
            ma.analyseFallthroughStmt(s);
            break;
        case Label:
            ma.analyseLabelStmt(s);
            ma.scope.setReachable();
            break;
        case Goto:
            ma.analyseGotoStmt(s);
            ma.scope.setUnreachable();
            break;
        case Compound:
            ma.scope.enter(scope.Decl);
        ma.analyseCompoundStmt(cast<CompoundStmt*>(s));
        ma.scope.exit(ma.has_error);
        break;
    case Decl:
        ma.analyseDeclStmt(s);
        break;
    case Asm:
        ma.analyseAsmStmt(s);
        break;
    case Assert:
        ma.analyseAssertStmt(s);
        break;
    }
}

fn void Analyser.analyseBreakStmt(Analyser* ma, Stmt* s) {
    if (!ma.scope.allowBreak()) {
        BreakStmt* b = cast<BreakStmt*>(s);
        ma.error(b.getLoc(), "'break' statement not in loop or switch statement");
    }
}

fn void Analyser.analyseContinueStmt(Analyser* ma, Stmt* s) {
    if (!ma.scope.allowContinue()) {
        ContinueStmt* c = cast<ContinueStmt*>(s);
        ma.error(c.getLoc(), "'continue' statement not in loop statement");
    }
}

fn void Analyser.analyseFallthroughStmt(Analyser* ma, Stmt* s) {
    if (!ma.scope.allowFallthrough()) {
        FallthroughStmt* f = cast<FallthroughStmt*>(s);
        ma.error(f.getLoc(), "'fallthrough' statement cannot be used here");
    }
}

fn void Analyser.analyseLabelStmt(Analyser* ma, Stmt* s) {
    LabelStmt* ls = cast<LabelStmt*>(s);
    u32 name = ls.getNameIdx();

    Label* label = ma.labels.find(name);
    if (label) {
        if (label.is_label) {
            ma.error(ls.getLoc(), "redefinition of label '%s'", ls.getName());
            ma.note(label.loc, "previous definition is here");
        } else {
            label.is_label = true;
        }
    } else {
        ma.labels.add(name, ls.getLoc(), true);
    }
}

fn void Analyser.analyseGotoStmt(Analyser* ma, Stmt* s) {
    GotoStmt* gs = cast<GotoStmt*>(s);
    u32 name = gs.getNameIdx();
    src_loc.SrcLoc loc = gs.getLoc();

    Label* label = ma.labels.find(name);
    if (label) {
        label.used = true;
    } else {
        ma.labels.add(name, gs.getLoc(), false);
    }
}

fn void Analyser.analyseCompoundStmt(Analyser* ma, CompoundStmt* c) {
    u32 count = c.getCount();
    Stmt** stmts = c.getStmts();
    for (u32 i=0; i<count; i++) {
        Stmt* s = stmts[i];
        ma.analyseStmt(s, true);
        if (ma.has_error) break;
    }
}

fn QualType Analyser.analyseCondition(Analyser* ma, Stmt** s_ptr, bool check_assign) {
    Stmt* s = *s_ptr;
    if (s.isDecl()) {
        QualType qt = ma.analyseDeclStmt(s);
        if (qt.isValid()) {
            DeclStmt* ds = cast<DeclStmt*>(s);
            VarDecl* vd = ds.getDecl();
            if (!vd.getInit()) {
                ma.error(vd.asDecl().getLoc(), "variable declaration in condition must have an initializer");
                return QualType_Invalid;
            }
        }
        return qt;
    }

    assert(s.isExpr());
    Expr* e = cast<Expr*>(s);
    // Note: cannot insert ImplicitCastExpr here!
    QualType qt = ma.analyseExpr(&e, true, RHS);
    if (qt.isValid()) ma.checker.check(builtins[BuiltinKind.Bool], qt, cast<Expr**>(s_ptr), e.getLoc());

    if (check_assign && e.isBinaryOperator()) {
        const BinaryOperator* b = cast<BinaryOperator*>(e);
        if (b.getOpcode() == BinaryOpcode.Assign) {
            ma.warn(e.getLoc(), "using the result of an assignment as a condition without parentheses");
        }
    }

    return qt;
}

fn void Analyser.analyseIfStmt(Analyser* ma, Stmt* s) {
    IfStmt* i = cast<IfStmt*>(s);
    ma.scope.enter(scope.Decl);
    ma.analyseCondition(i.getCond2(), true);
    if (ma.has_error) return;

    ma.scope.enter(scope.Decl);
    ma.analyseStmt(i.getThen(), false);
    ma.scope.exit(ma.has_error);

    Stmt* else_ = i.getElse();
    if (else_) {
        ma.scope.enter(scope.Decl);
        ma.analyseStmt(else_, false);
        ma.scope.exit(ma.has_error);
    }

    ma.scope.exit(ma.has_error);
}

fn void Analyser.analyseForStmt(Analyser* ma, Stmt* s) {
    ForStmt* f = cast<ForStmt*>(s);

    ma.scope.enter(scope.Break | scope.Continue | scope.Decl | scope.Control);
    Stmt** init_ = f.getInit2();
    if (init_) {
        QualType ct = ma.analyseCondition(init_, false);
        if (ct.isInvalid()) return;
    }

    Expr** cond = f.getCond2();
    if (cond) {
        QualType qt = ma.analyseExpr(cond, true, RHS);
        if (qt.isInvalid()) return;
        ma.checker.check(builtins[BuiltinKind.Bool], qt, cond, (*cond).getLoc());
    }

    Expr** incr = f.getIncr2();
    if (incr) {
        QualType qt = ma.analyseExpr(incr, true, RHS);
        if (qt.isInvalid()) return;
    }

    ma.analyseStmt(f.getBody(), true);
    ma.scope.exit(ma.has_error);
}

fn void Analyser.analyseWhileStmt(Analyser* ma, Stmt* s) {
    WhileStmt* w = cast<WhileStmt*>(s);
    ma.scope.enter(scope.Decl);
    ma.analyseCondition(w.getCond2(), true);
    if (ma.has_error) return;

    ma.scope.enter(scope.Break | scope.Continue | scope.Decl | scope.Control);
    ma.analyseStmt(w.getBody(), true);
    ma.scope.exit(ma.has_error);
    ma.scope.exit(ma.has_error);
}

fn void Analyser.analyseDoStmt(Analyser* ma, Stmt* s) {
    DoStmt* d = cast<DoStmt*>(s);
    ma.scope.enter(scope.Break | scope.Continue | scope.Decl);
    ma.analyseStmt(d.getBody(), true);
    ma.scope.exit(ma.has_error);
    ma.analyseStmt(d.getCond(), false);
}

fn QualType Analyser.analyseDeclStmt(Analyser* ma, Stmt* s) {
    DeclStmt* ds = cast<DeclStmt*>(s);
    VarDecl* vd = ds.getDecl();
    Decl* d = cast<Decl*>(vd);

    // Note: d.getType() is 0 here! (use refType)
    TypeRef* ref = vd.getTypeRef();

    if (ref.isIncrArray()) {
        ma.error(ref.getLoc(), "incremental arrays not allowed in function scope");
        return QualType_Invalid;
    }

    QualType res = ma.analyseTypeRef(ref);
    if (res.isInvalid()) return QualType_Invalid;
    d.setType(res);

    if (res.isVoid()) {
        ma.error(ref.getLoc(), "variable has invalid type 'void'");
        return QualType_Invalid;
    }

    ma.checkName(d, false);

    Expr** initExpr = vd.getInit2();
    if (initExpr) {
        ma.analyseInitExpr(initExpr, res, vd.getAssignLoc());
    } else {
        if (res.isConstant()) {
            ma.error(d.getLoc(), "constant variable '%s' must be initialized", d.getName());
            return QualType_Invalid;
        }
        const ArrayType* at = res.getArrayTypeOrNil();
        if (at) {
            if (at.hasSize()) {
                if (at.getSize() == 0) {
                    ma.error(ref.getLoc(), "only struct members may have array size zero");
                    return QualType_Invalid;
                }
            } else {
                ma.error(d.getLoc(), "array-type variable '%s' needs an explicit size or an initializer", d.getName());
                return QualType_Invalid;
            }
        }
    }

    d.setChecked();
    ma.has_error = ma.scope.add(d);
    return res;
}

fn void Analyser.analyseAsmStmt(Analyser* ma, Stmt* s) {
    AsmStmt* a = cast<AsmStmt*>(s);

    u32 num_exprs = a.getNumExprs();
    Expr** exprs = a.getExprs();
    u32 num_outputs = a.getNumOutputs();

    for (u32 i=0; i<num_exprs; i++) {
        bool need_rvalue;
        u32 side;
        if (i<num_outputs) { // expr is output
            need_rvalue = false;
            side = LHS;
        } else {
            need_rvalue = true;
            side = RHS;
        }
        QualType qt = ma.analyseExpr(&exprs[i], need_rvalue, side);
        if (qt.isInvalid()) return;
    }
}

fn void Analyser.analyseAssertStmt(Analyser* ma, Stmt* s) {
    AssertStmt* a = cast<AssertStmt*>(s);
    QualType qt = ma.analyseExpr(a.getInner2(), true, RHS);
    if (qt.isInvalid()) return;
    Expr* inner = a.getInner();
    ma.checker.check(builtins[BuiltinKind.Bool], qt, a.getInner2(), inner.getLoc());
}

fn void Analyser.analyseReturnStmt(Analyser* ma, Stmt* s) {
    ReturnStmt* r = cast<ReturnStmt*>(s);

    Expr** arg = r.getValue2();

    if (ma.curFunction.hasReturn()) {
        if (!arg) {
            //Expr* e = r.getValue();
            // +6 is skip 'return', to end up at ;
            ma.error(r.getLoc()+6, "non-void function %s should return a value", ma.curFunction.asDecl().getName());
            return;
        }
    } else {
        if (arg) {
            Expr* e = r.getValue();
            ma.error(e.getLoc(), "void function %s should not return a value", ma.curFunction.asDecl().getName());
            return;
        }
    }
    if (arg) {
        QualType qt = ma.analyseExpr(arg, true, RHS);
        if (qt.isInvalid()) return;

        ma.checker.check(ma.curFunction.getRType(), qt, arg, (*arg).getLoc());
    }
}

