/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module unused_checker;

import ast local;
import diagnostics;
import warning_flags local;

public fn void check(diagnostics.Diags* diags,
                       const WarningFlags* warnings,
                       Module* mod)
{
    Checker c = {
        .diags = diags,
        .warnings = warnings,
    }

    if (mod.isUsed()) {
        mod.visitDecls(Checker.check, &c);
    } else {
        mod.visitASTs(Checker.unused_module, &c);
    }
}

type Checker struct {
    diagnostics.Diags* diags;
    const WarningFlags* warnings;
}

fn void Checker.unused_module(void* arg, AST* a) {
    Checker* c = arg;
    c.diags.warn(W_unused_module, a.getLoc(), "unused module '%s'", a.getName());
}

fn void Checker.check(void* arg, Decl* d) {
    Checker* c = arg;
    bool used = d.isUsed();
    if (used && d.isPublic() && !d.isUsedPublic() && !d.hasAttrUnused()) {
        c.diags.warn(W_unused_public, d.getLoc(), "%s '%s' is not used public", d.getKindName(), d.getFullName());
    }

    WarningKind wk = W_unknown;
    switch (d.getKind()) {
    case Function:
        if (d.hasAttrUnused()) return;
        wk = W_unused_function;
        break;
    case Import:
        wk = W_unused_import;
        break;
    case StructType:
        if (used) {
            c.checkStructMembers(d);
        }
        wk = W_unused_type;
        break;
    case EnumType:
        if (used && c.warnings.test(W_unused_enum_constant)) {
            c.checkEnum((EnumTypeDecl*)(d));
        }
        wk = W_unused_enum_constant;
        break;
    case EnumConstant:
        wk = W_unused_enum_constant;
        break;
    case FunctionType:
        wk = W_unused_type;
        break;
    case AliasType:
        wk = W_unused_type;
        break;
    case Variable:
        wk = W_unused_variable;
        break;
    }
    if (!used && !d.hasAttrUnused() && !d.isExported()) {
        c.diags.warn(wk, d.getLoc(), "unused %s '%s'", d.getKindName(), d.getFullName());
        return;
    }
}

fn void Checker.checkEnum(Checker* c, EnumTypeDecl* d) {
    u32 num_consts = d.getNumConstants();
    EnumConstantDecl** constants = d.getConstants();
    for (u32 i=0; i<num_consts; i++) {
        EnumConstantDecl* ecd = constants[i];
        Decl* dd = (Decl*)ecd;
        if (!dd.isUsed()) {
            c.diags.warn(W_unused_enum_constant, dd.getLoc(), "unused %s '%s'", dd.getKindName(), dd.getName());
        }
    }
}

fn void Checker.checkStructMembers(Checker* c, Decl* d) {
    StructTypeDecl* std = (StructTypeDecl*)d;
    u32 num_members = std.getNumMembers();
    Decl** members = std.getMembers();
    for (u32 i=0; i<num_members; i++) {
        Decl* member = members[i];
        if (member.isStructType()) {
            c.checkStructMembers(member);
        } else {
            if (!member.isUsed()) {
                c.diags.warn(W_unused_variable, member.getLoc(), "unused %s member '%s'", std.isStruct() ? "struct" : "union", member.getName());
            }
        }
    }
}

