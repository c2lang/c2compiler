/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import c_prec local;
import c2_prec local;
import conversion_checker;
import src_loc local;

fn bool validArithType(QualType t) {
    t = t.getCanonicalType();
    switch (t.getKind()) {
    case Builtin:
    case Enum:
        return true;
    default:
        return false;
    }
}

fn bool validIntegerType(QualType t) {
    t = t.getCanonicalType();
    switch (t.getKind()) {
    case Builtin:
        return !t.isFloat();
    case Enum:
        return true;
    default:
        return false;
    }
}

fn bool validTestType(QualType t) {
    t = t.getCanonicalType();
    if (!t.isValid()) return false;
    switch (t.getKind()) {
    case Builtin:
    case Pointer:
    case Enum:
    case Function:
        return true;
    default:
        return false;
    }
}

fn QualType Analyser.invalidBinOp1(Analyser* ma, BinaryOperator* b, Expr* sub, QualType qt) {
    ma.error(sub.getLoc(), "invalid operand type '%s' for binary expression '%s'",
             qt.diagName(), b.getOpcode().str());
    return QualType_Invalid;
}

fn QualType Analyser.invalidBinOp2(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    ma.error(((Expr*)b).getLoc(), "invalid operands to binary expression ('%s' and '%s')", lhs.diagName(), rhs.diagName());
    return QualType_Invalid;
}

fn QualType Analyser.invalidFuncCompare(Analyser* ma, BinaryOperator* b) {
    ma.error(((Expr*)b).getLoc(), "comparing functions may only be done with '!=' or '=='");
    return QualType_Invalid;
}

const u32[] Binop_lhs = {
    RHS,        // Multiply
    RHS,        // Divide
    RHS,        // Remainder
    RHS,        // Add
    RHS,        // Subtract
    RHS,        // ShiftLeft
    RHS,        // ShiftRight
    RHS,        // LessThan
    RHS,        // GreaterThan
    RHS,        // LessEqual
    RHS,        // GreaterEqual
    RHS,        // Equal
    RHS,        // NotEqual
    RHS,        // And
    RHS,        // Xor
    RHS,        // Or
    RHS,        // LAnd
    RHS,        // LOr
    LHS,        // Assign
    LHS|RHS,    // MulAssign
    LHS|RHS,    // DivAssign
    LHS|RHS,    // RemAssign
    LHS|RHS,    // AddAssign
    LHS|RHS,    // SubAssign
    LHS|RHS,    // ShlAssign
    LHS|RHS,    // ShrASsign
    LHS|RHS,    // AndAssign
    LHS|RHS,    // XorAssign
    LHS|RHS,    // OrAssign
}

static_assert(elemsof(BinaryOpcode), elemsof(Binop_lhs));

/*
    // convert aliasType + enum to impl for check
    // ignoring Floats for now
    Multiply,       int
    Divide          int
    Remainder,      int
    Add,            ptr(l/r), int
    Subtract,       ptr(l/both), int
    ShiftLeft,      int
    ShiftRight,     int
    LessThan,       ptr(both), int (both)
    GreaterThan,    ptr(both), int (both)
    LessEqual,      ptr(both), int (both)
    GreaterEqual,   ptr(both), int (hoth)
    Equal,          ptr(both), int (both)
    NotEqual,       ptr(both), int (both)
    And,            int
    Xor,            int
    Or,             int
    LAnd,           ptr, int
    LOr,            ptr, int
    Assign,         struct(both), ptr, int
    MulAssign,      int
    DivAssign,      int
    RemAssign,      int
    AddAssign,      ptr(l), int
    SubAssign,      ptr(l), int
    ShlAssign,      int
    ShrASsign,      int
    AndAssign,      int
    XorAssign,      int
    OrAssign,       int
*/

    /*
        int + int -> integer promotions
        const int + int -> int
        const int + const int -> int
        int + enum -> int
        enumA + enumA -> enumA

        Not Allowed
        enumA + enumB
    */
fn QualType Analyser.checkBinopArithArgs(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs, bool assign) {
    // Note: enums are their own canonical type, so use implType here
    QualType lcanon = lhs.getImplType();
    QualType rcanon = rhs.getImplType();
    if (!validArithType(lcanon)) {
        if (!validArithType(rcanon)) return ma.invalidBinOp2(b, lhs, rhs);
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    }
    if (!validArithType(rcanon)) return ma.invalidBinOp1(b, b.getRHS(), rhs);

    BuiltinType* bl = lcanon.getBuiltinTypeOrNil();
    BuiltinType* br = rcanon.getBuiltinTypeOrNil();
    QualType optype = conversion_checker.usual_arithmetic_conversion(bl, br);
    BuiltinType* bi = optype.getBuiltin();
    if (br != bi) {
        ma.builder.insertImplicitCast(IntegralCast, b.getRHS2(), optype);
    }
    if (assign) {
        if (rcanon.isFloat() && !lcanon.isFloat()) {
            //return ma.invalidBinOp2(b, lhs, rhs);
            ma.error(((Expr*)b).getLoc(), "implicit conversion turns floating-point number into integer:");
            return QualType_Invalid;
        }
        return lhs;
    }
    if (bl != bi) {
        ma.builder.insertImplicitCast(IntegralCast, b.getLHS2(), optype);
    }
    return optype;
}

// Both sides must be integers (Enum is allowed)
fn QualType Analyser.checkBinopIntArgs(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs, bool assign) {
    // Note: enums are their own canonical type, so use implType here
    QualType lcanon = lhs.getImplType();
    QualType rcanon = rhs.getImplType();
    if (!validIntegerType(lcanon)) {
        if (!validIntegerType(rcanon)) return ma.invalidBinOp2(b, lhs, rhs);
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    }
    if (!validIntegerType(rcanon)) return ma.invalidBinOp1(b, b.getRHS(), rhs);

    BuiltinType* bl = lcanon.getBuiltinTypeOrNil();
    BuiltinType* br = rcanon.getBuiltinTypeOrNil();
    QualType optype = conversion_checker.usual_arithmetic_conversion(bl, br);
    BuiltinType* bi = optype.getBuiltin();
    if (br != bi) {
        ma.builder.insertImplicitCast(IntegralCast, b.getRHS2(), optype);
    }
    if (assign) return lhs;
    if (bl != bi) {
        ma.builder.insertImplicitCast(IntegralCast, b.getLHS2(), optype);
    }
    return optype;
}

// Both sides must be integers (Enum is allowed)
fn QualType Analyser.checkBinopShiftArgs(Analyser* ma, BinaryOperator* b, QualType ltype, QualType rtype, bool assign) {
    // Note: enums are their own canonical type, so use implType here
    QualType lcanon = ltype.getImplType();
    QualType rcanon = rtype.getImplType();
    if (!validIntegerType(lcanon)) {
        if (!validIntegerType(rcanon)) return ma.invalidBinOp2(b, ltype, rtype);
        return ma.invalidBinOp1(b, b.getLHS(), ltype);
    }
    if (!validIntegerType(rcanon)) return ma.invalidBinOp1(b, b.getRHS(), rtype);

    BuiltinType* bl = lcanon.getBuiltinTypeOrNil();
    BuiltinType* br = rcanon.getBuiltinTypeOrNil();
    u32 width = bl.getWidth();

    // perform integer promotion on both arguments
    if (bl.isPromotableIntegerType()) {
        lcanon = getBuiltinQT(Int32);
        width = 32;
        if (!assign) ma.builder.insertImplicitCast(IntegralCast, b.getLHS2(), lcanon);
    }
    if (br.isPromotableIntegerType()) {
        rcanon = getBuiltinQT(Int32);
        ma.builder.insertImplicitCast(IntegralCast, b.getRHS2(), rcanon);
    }
    Expr* lhs = b.getLHS();
    if (lhs.isCtv()) {
        Value val = ast.evalExpr(lhs);
        if (val.isNegative()) {
            ma.error(lhs.getLoc(), "shifting a negative signed value is undefined");
            return QualType_Invalid;
        }
    }
    Expr* rhs = b.getRHS();
    if (rhs.isCtv()) {
        Value val = ast.evalExpr(rhs);
        if (val.isNegative()) {
            ma.error(rhs.getLoc(), "shift count is negative");
            return QualType_Invalid;
        }

        // check if shifting more than width
        // (do not reduce width of signed types to allow `i32 a = 1 << 31;`)
        if (val.as_u64() >= width) {
            ma.error(rhs.getLoc(), "shift count >= width of type");
            return QualType_Invalid;
        }
    }
    if (assign) return ltype;
    return lcanon;
}

fn QualType Analyser.checkBinopLogical(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    if (!validTestType(lhs)) {
        if (!validTestType(rhs)) return ma.invalidBinOp2(b, lhs, rhs);
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    }
    if (!validTestType(rhs)) return ma.invalidBinOp1(b, b.getRHS(), rhs);

    return getBuiltinQT(Bool);
}

// 0  cannot happen
// 1  invalid lhs
// 2  invalid rhs
// 3  invalid operands
// 4  builtin -= builtin
// 5  builtin -= enum -> int
// 6  pointer -= builtin/enum
// 7  enum -= builtin
// 8  enum -= enum -> int (CTV)
const u8[elemsof(TypeKind)][elemsof(TypeKind)] BinOpConvAddSubAss = {
    //  Builtin Pointer Array   Struct  Enum    Func   Void   Alias  Module
    //  Builtin += / -=
    {   4,      2,      0,      2,      5,      2,     2,     0,     0  },
    //  Pointer += / -=
    {   6,      3,      0,      2,      6,      2,     2,     0,     0  },
    //  Array += / -=
    {   0,      0,      0,      0,      0,      0,     0,     0,     0  },
    //  Struct += / -=
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    //  Enum += / -=
    {   7,      1,      0,      2,      8,      2,     2,     0,     0  },
    //  Function += / -=
    {   1,      3,      0,      3,      1,      3,     3,     0,     0  },
    //  Void += / -=
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    // Alias + Module are zero
}
fn QualType Analyser.checkBinopAddSubAssign(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    QualType lcanon = lhs.getCanonicalType();
    QualType rcanon = rhs.getCanonicalType();
    assert(lcanon.isValid());
    assert(rcanon.isValid());

    u8 res = BinOpConvAddSubAss[lcanon.getKind()][rcanon.getKind()];
    switch (res) {
    case 0: // cannot happen
        break;
    case 1: // invalid lhs
    invalid_lhs:
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    case 2: // invalid rhs
    invalid_rhs:
        return ma.invalidBinOp1(b, b.getRHS(), rhs);
    case 3: // invalid operands
        return ma.invalidBinOp2(b, lhs, rhs);
    case 4: // builtin - builtin
    case 5: // builtin - enum -> int
        return ma.checkBinopArithArgs(b, lhs, rhs, true);
    case 6: // pointer - builtin/enum
        if (lcanon.isVoidPtr())  goto invalid_lhs;
        if (!validIntegerType(rcanon)) goto invalid_rhs;
        return lhs;
    case 7: // enum - builtin
        return ma.checkBinopIntArgs(b, lhs, rhs, true);
    case 8: // enum - enum -> int (CTV)
        // TODO check same enum type?
        return ma.checkBinopIntArgs(b, lhs, rhs, true);
    }
    assert(0);
    return QualType_Invalid;
}

// 0  cannot happen
// 1  invalid op1
// 2  invalid op2
// 3  invalid operands
// 4  builtin + builtin
// 5  builtin + enum -> int
// 6  enum + builtin -> int
// 7  builtin/enum + ptr
// 8  ptr + builtin/enum
// TODO remove Alias/Module (+Array, need to move) since already checked
// TODO need to fix C2C.c++ (asserts of elemsof(..) -2), then table can be 5x5
const u8[elemsof(TypeKind)][elemsof(TypeKind)] BinOpConvAdd = {
    //  Builtin Pointer Array   Struct  Enum    Func   Void   Alias  Module
    //  Builtin +
    {   4,      7,      0,      2,      5,      2,     2,     0,     0  },
    //  Pointer +
    {   8,      3,      0,      2,      8,      3,     2,     0,     0  },
    //  Array +
    {   0,      0,      0,      0,      0,      0,     0,     0,     0  },
    //  Struct +
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    //  Enum +
    {   6,      7,      0,      2,      3,      2,     2,     0,     0  },
    //  Function +
    {   1,      3,      0,      3,      1,      3,     3,     0,     0  },
    //  Void +
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    // Alias + Module are zero
}
fn QualType Analyser.checkBinopAddArgs(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    QualType lcanon = lhs.getCanonicalType();
    QualType rcanon = rhs.getCanonicalType();
    assert(lcanon.isValid());
    assert(rcanon.isValid());

    u8 res = BinOpConvAdd[lcanon.getKind()][rcanon.getKind()];
    switch (res) {
    case 0: // cannot happen
        break;
    case 1: // invalid lhs
    invalid_lhs:
        if (rcanon.isVoidPtr())  goto invalid;
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    case 2: // invalid rhs
    invalid_rhs:
        if (lcanon.isVoidPtr())  goto invalid;
        return ma.invalidBinOp1(b, b.getRHS(), rhs);
    case 3: // invalid operands
    invalid:
        return ma.invalidBinOp2(b, lhs, rhs);
    case 4: // builtin + builtin
    builtin:
        BuiltinType* bl = lcanon.getBuiltin();
        BuiltinType* br = rcanon.getBuiltin();
        // TODO move somewhere else (used at many places)
        QualType optype = conversion_checker.usual_arithmetic_conversion(bl, br);
        if (!optype.isValid()) goto invalid;
        BuiltinType* bi = optype.getBuiltin();
        if (bl != bi) {
            ma.builder.insertImplicitCast(IntegralCast, b.getLHS2(), optype);
        }
        if (br != bi) {
            ma.builder.insertImplicitCast(IntegralCast, b.getRHS2(), optype);
        }
        return optype;
    case 5: // builtin + enum -> int
        rcanon = rcanon.getImplType();
        goto builtin;
    case 6: // enum + builtin -> int
        lcanon = lcanon.getImplType();
        goto builtin;
    case 7: // builtin/enum + ptr
        if (!validIntegerType(lcanon)) goto invalid_lhs;
        if (rcanon.isVoidPtr()) goto invalid_rhs;
        return rhs;
    case 8: // ptr + builtin/enum
        if (lcanon.isVoidPtr())  goto invalid_lhs;
        if (!validIntegerType(rcanon))  goto invalid_rhs;
        return lhs;
    }
    assert(0);
    return QualType_Invalid;
}

// 0  cannot happen
// 1  invalid op1
// 2  invalid op2
// 3  invalid operands
// 4  builtin - builtin
// 5  builtin - enum -> int
// 6  enum - builtin -> lhs
// 7  enum - enum -> int if same enum
// 8  pointer - builtin/enum
// 9  pointer - pointer -> isize
const u8[elemsof(TypeKind)][elemsof(TypeKind)] BinOpConvSub = {
    //  Builtin Pointer Array   Struct  Enum    Func   Void   Alias  Module
    //  Builtin -
    {   4,      3,      0,      2,      5,      2,     2,     0,     0  },
    //  Pointer -
    {   8,      9,      0,      1,      8,      2,     2,     0,     0  },
    //  Array -
    {   0,      0,      0,      0,      0,      0,     0,     0,     0  },
    //  Struct -
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    //  Enum -
    {   6,      3,      0,      2,      7,      2,     2,     0,     0  },
    //  Function -
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    //  Void += / -=
    {   1,      1,      0,      3,      1,      3,     3,     0,     0  },
    // Alias + Module are zero
}
fn QualType Analyser.checkBinopSubArgs(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs) {
    QualType lcanon = lhs.getCanonicalType();
    QualType rcanon = rhs.getCanonicalType();
    assert(lcanon.isValid());
    assert(rcanon.isValid());

    u8 res = BinOpConvSub[lcanon.getKind()][rcanon.getKind()];
    switch (res) {
    case 0: // cannot happen
        break;
    case 1: // invalid lhs
    invalid_lhs:
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    case 2: // invalid rhs
    invalid_rhs:
        return ma.invalidBinOp1(b, b.getRHS(), rhs);
    case 3: // invalid operands
    invalid:
        return ma.invalidBinOp2(b, lhs, rhs);
    case 4: // builtin - builtin
    builtin:
        BuiltinType* bl = lcanon.getBuiltin();
        BuiltinType* br = rcanon.getBuiltin();
        // TODO move somewhere else (used at many places)
        QualType optype = conversion_checker.usual_arithmetic_conversion(bl, br);
        if (!optype.isValid()) goto invalid;
        BuiltinType* bi = optype.getBuiltin();
        if (bl != bi) {
            ma.builder.insertImplicitCast(IntegralCast, b.getLHS2(), optype);
        }
        if (br != bi) {
            ma.builder.insertImplicitCast(IntegralCast, b.getRHS2(), optype);
        }
        return optype;
    case 5: // builtin - enum -> int
        rcanon = rcanon.getImplType();
        goto builtin;
    case 6: // enum - builtin -> int
        lcanon = lcanon.getImplType();
        goto builtin;
    case 7: // enum - enum -> check same enum
        EnumType* et1 = (EnumType*)lcanon.getTypeOrNil();
        EnumType* et2 = (EnumType*)rcanon.getTypeOrNil();
        //if (et1 != et2) goto invalid;
        lcanon = et1.getImplType();
        rcanon = et2.getImplType();
        // TODO: if u32 - u32 -> i32?
        goto builtin;
    case 8: // pointer - builtin/enum
        if (lcanon.isVoidPtr()) goto invalid_lhs;
        if (!validIntegerType(rcanon)) goto invalid_rhs;
        return lhs;
    case 9: // pointer - pointer
        // TODO extract to function? (same_pointer)
        PointerType* pt1 = lcanon.getPointerType();
        PointerType* pt2 = rcanon.getPointerType();
        QualType t1 = pt1.getInner();
        QualType t2 = pt2.getInner();
        if (t1.getTypeOrNil() != t2.getTypeOrNil() || t1.isVoid() || t2.isVoid()) goto invalid;
        return getBuiltinQT(ISize);
    }
    return ma.invalidBinOp2(b, lhs, rhs);
}

// 0  cannot happen
// 1  invalid operands
// 2  builtin : builtin
// 3  builtin : enum
// 4  pointer : pointer - check same type
// 5  enum : builtin
// 6  enum : enum -> same type
// 7  pointer : function
// 8  function : pointer
// 9  function : function
// 10  invalid lhs
// 11  invalid rhs
// TODO: accept pointer/function : 0 and 0 : pointer/function
const u8[elemsof(TypeKind)][elemsof(TypeKind)] BinOpConvComparison = {
    //  Builtin Pointer Array   Struct  Enum    Func   Void   Alias  Module
    //  Builtin :
    {   2,      1,      0,     11,      3,      0,    11,     0,     0  },
    //  Pointer :
    {   1,      4,      0,     11,      1,      7,    11,     0,     0  },
    //  Array :
    {   0,      0,      0,      0,      0,      0,     0,     0,     0  },
    //  Struct :
    {  10,     10,      0,      1,     10,     10,     1,     0,     0  },
    //  Enum :
    {   5,      1,      0,     11,      6,      1,    11,     0,     0  },
    //  Function :
    {   1,      8,      0,     11,      1,      9,     1,     0,     0  },
    //  Void += / -=
    {  10,     10,      0,      1,     10,      1,     1,     0,     0  },
    // Alias + Module are zero
}
fn QualType Analyser.checkBinopComparison(Analyser* ma, BinaryOperator* b, QualType lhs, QualType rhs, bool is_relative) {
    QualType lcanon = lhs.getCanonicalType();
    QualType rcanon = rhs.getCanonicalType();
    Expr* e = (Expr*)b;
    assert(lcanon.isValid());
    assert(rcanon.isValid());

    u8 res = BinOpConvComparison[lcanon.getKind()][rcanon.getKind()];
    switch (res) {
    case 0: // cannot happen
    case 1: // invalid operands
    invalid:
        return ma.invalidBinOp2(b, lhs, rhs);
    case 2: // builtin : builtin
    builtin:
        BuiltinType* bl = lcanon.getBuiltin();
        BuiltinType* br = rcanon.getBuiltin();
        // TODO move somewhere else (used at many places)
        QualType optype = conversion_checker.usual_arithmetic_conversion(bl, br);
        if (!optype.isValid()) goto invalid;
        BuiltinType* bi = optype.getBuiltin();
        if (bl != bi) {
            ma.builder.insertImplicitCast(IntegralCast, b.getLHS2(), optype);
        }
        if (br != bi) {
            ma.builder.insertImplicitCast(IntegralCast, b.getRHS2(), optype);
        }
        // TODO should detect comparison between i32/u32 and i32/u32
        // TODO i32 < u32 is not the same as i32 = u32! dont use checker
        //if (ma.checker.check(lhs, rhs, &e, e.getLoc())) return QualType_Invalid;
        return getBuiltinQT(Bool);
    case 3: // builtin : enum
        rcanon = rcanon.getImplType();
        goto builtin;
    case 4: // pointer : pointer - check same type
        PointerType* pt1 = lcanon.getPointerType();
        PointerType* pt2 = rcanon.getPointerType();
        QualType t1 = pt1.getInner();
        QualType t2 = pt2.getInner();
        if (t1.isVoid() || t2.isVoid()) {
            if (is_relative) goto invalid;
        } else
        if (t1.getTypeOrNil() != t2.getTypeOrNil()) {
            ma.error(e.getLoc(), "comparing pointers to different types ('%s' and '%s')", lhs.diagName(), rhs.diagName());
            return QualType_Invalid;
        }
        return getBuiltinQT(Bool);
    case 5: // enum : builtin
        lcanon = lcanon.getImplType();
        goto builtin;
    case 6: // enum : enum -> same type
        if (lcanon.getTypeOrNil() != rcanon.getTypeOrNil()) {
            ma.error(e.getLoc(), "comparing enums of different types ('%s' and '%s')", lhs.diagName(), rhs.diagName());
            return QualType_Invalid;
        }
        return getBuiltinQT(Bool);
    case 7: // pointer : function
        if (is_relative) return ma.invalidFuncCompare(b);
        // TODO accept 0 == f, (void*)0 == f and (void*)nil == f
        if (b.getLHS().getKind() != Nil) goto invalid;
        return ma.checkFuncTest(rcanon.getFunctionType(), e.getLoc());
    case 8: // function : pointer
        if (is_relative) return ma.invalidFuncCompare(b);
        // TODO accept f == 0, f == (void*)0 and f == (void*)nil
        if (b.getRHS().getKind() != Nil) goto invalid;
        return ma.checkFuncTest(lcanon.getFunctionType(), e.getLoc());
    case 9: // function : function
        if (is_relative) return ma.invalidFuncCompare(b);
        return getBuiltinQT(Bool);
    case 10: // invalid lhs
        return ma.invalidBinOp1(b, b.getLHS(), lhs);
    case 11: // invalid rhs
        return ma.invalidBinOp1(b, b.getRHS(), rhs);
    }
    ma.error(e.getLoc(), "TODO BINOP %d", res);
    assert(0);
    return QualType_Invalid;
}

fn QualType Analyser.checkFuncTest(Analyser* ma, FunctionType* ft, SrcLoc loc) {
    // only allow nil vs weak-function or function pointer
    FunctionDecl* fd = ft.getDecl();
    if (fd.isType() || fd.hasAttrWeak()) return getBuiltinQT(Bool); // Variable with Function type (eg callback)
    ma.error(loc, "comparison of function '%s' will always be true", fd.asDecl().getFullName());
    return QualType_Invalid;
}

fn bool incompatible_opcodes(BinaryOpcode op1, BinaryOpcode op2) {
    C_Prec c_p1 = C_Prec_table[op1];
    C_Prec c_p2 = C_Prec_table[op2];
    Prec c2_p1 = Prec_table[op1];
    Prec c2_p2 = Prec_table[op2];
    if (c2_p1 == c2_p2) return c2_p1 == Relational || c_p1 != c_p2;
    if (c2_p1 < c2_p2) return c_p1 >= c_p2;
    return c_p1 <= c_p2;
}

fn bool Analyser.checkAmbiguousOperators(Analyser* ma, BinaryOpcode opcode, Expr* sub) {
    if (sub.isBinaryOperator()) {
        BinaryOperator* b = (BinaryOperator*)sub;
        BinaryOpcode op1 = b.getOpcode();
        if (incompatible_opcodes(opcode, op1)) {
            ma.error(sub.getLoc(), "operators '%s' and '%s' do not combine without parentheses",
                     opcode.str(), op1.str());
            return false;
        }
    }
    return true;
}

fn QualType Analyser.analyseBinaryOperator(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BinaryOperator* b = (BinaryOperator*)e;
    BinaryOpcode opcode = b.getOpcode();

    bool need_lhs_rvalue = true;
    if (opcode >= BinaryOpcode.Assign) need_lhs_rvalue = false;

    QualType ltype = ma.analyseExpr(b.getLHS2(), need_lhs_rvalue, Binop_lhs[opcode]);
    if (ltype.isInvalid()) return QualType_Invalid;

    if (!need_lhs_rvalue) { // so we need an lvalue
        if (!ma.checkAssignment(b.getLHS(), ltype, "left operand of assignment", e.getLoc())) {
            return QualType_Invalid;
        }
    }

    if (opcode.isComparison()) {
        // special case for enum comparison without prefix (eg kind >= KW_void)
        if (ma.checkEnumArg(b.getRHS2(), ltype))
            return getBuiltinQT(Bool);
    }
    QualType rtype;
    if (opcode == BinaryOpcode.Assign) {
        if (!ma.analyseInitExpr(b.getRHS2(), ltype, e.getLoc(), false, false))
            return QualType_Invalid;
        //rtype = b.getRHS().getType();
        return ltype;
    } else {
        rtype = ma.analyseExpr(b.getRHS2(), true, RHS);
    }
    if (rtype.isInvalid()) return QualType_Invalid;

    Expr* lhs = b.getLHS();
    Expr* rhs = b.getRHS();

    // enforce parentheses on ambiguous operator combinations
    if (!ma.checkAmbiguousOperators(opcode, lhs) || !ma.checkAmbiguousOperators(opcode, rhs)) {
        return QualType_Invalid;
    }

    // TODO pass a struct with the types and canonical Types along, so we dont have to do this in every function

    QualType result = QualType_Invalid;
    switch (opcode) {
    case Multiply:
        result = ma.checkBinopArithArgs(b, ltype, rtype, false);
        break;
    case Divide:
        result = ma.checkBinopArithArgs(b, ltype, rtype, false);
        if (!ma.checkZero(b.getRHS(), "division")) return QualType_Invalid;
        break;
    case Remainder:
        result = ma.checkBinopIntArgs(b, ltype, rtype, false);
        if (!ma.checkZero(b.getRHS(), "remainder")) return QualType_Invalid;
        break;
    case Add:
        result = ma.checkBinopAddArgs(b, ltype, rtype);
        break;
    case Subtract:
        result = ma.checkBinopSubArgs(b, ltype, rtype);
        break;
    case ShiftLeft:
    case ShiftRight:
        result = ma.checkBinopShiftArgs(b, ltype, rtype, false);
        break;
    case LessThan:
    case GreaterThan:
    case LessEqual:
    case GreaterEqual:
        result = ma.checkBinopComparison(b, ltype, rtype, true);
        break;
    case Equal:
    case NotEqual:
        result = ma.checkBinopComparison(b, ltype, rtype, false);
        break;
    case And:
    case Xor:
    case Or:
        result = ma.checkBinopIntArgs(b, ltype, rtype, false);
        break;
    case LAnd:
    case LOr:
        result = ma.checkBinopLogical(b, ltype, rtype);
        break;
    case Assign:
        result = ltype;
        break;
    case MulAssign:
        result = ma.checkBinopArithArgs(b, ltype, rtype, true);
        break;
    case DivAssign:
        result = ma.checkBinopArithArgs(b, ltype, rtype, true);
        if (!ma.checkZero(b.getRHS(), "division")) return QualType_Invalid;
        break;
    case RemAssign:
        result = ma.checkBinopIntArgs(b, ltype, rtype, true);
        if (!ma.checkZero(b.getRHS(), "remainder")) return QualType_Invalid;
        break;
    case AddAssign:
    case SubAssign:
        result = ma.checkBinopAddSubAssign(b, ltype, rtype);
        break;
    case ShlAssign:
    case ShrAssign:
        result = ma.checkBinopShiftArgs(b, ltype, rtype, true);
        break;
    case AndAssign:
    case XorAssign:
    case OrAssign:
        result = ma.checkBinopIntArgs(b, ltype, rtype, true);
        break;
    }

    e.combineConstantFlags(lhs, rhs);
    return result;
}

fn bool Analyser.checkZero(Analyser* ma, Expr* e, const char* operation) {
    if (!e.isCtv()) return true;

    Value val = ast.evalExpr(e);
    if (val.isDecimal() && val.isZero()) {
        ma.error(e.getLoc(), "%s by zero is undefined", operation);
        return false;
    }
    // TODO check for division overflow: max_i64 / -1
    return true;
}

