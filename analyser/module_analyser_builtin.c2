/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module module_analyser;

import ast local;
import size_analyser;
import src_loc local;

fn QualType Analyser.analyseBuiltin(Analyser* ma, Expr** e_ptr) {
    Expr* e = *e_ptr;
    BuiltinExpr* b = (BuiltinExpr*)e;

    switch (b.getKind()) {
    case Sizeof:
        return ma.analyseSizeof(b);
    case Elemsof:
        return ma.analyseElemsof(b);
    case EnumMin:
    case EnumMax:
        return ma.analyseEnumMinMax(b);
    case OffsetOf:
        return ma.analyseOffsetOf(b);
    case ToContainer:
        return ma.analyseToContainer(b);
    }

    return QualType_Invalid;
}

fn QualType Analyser.analyseSizeof(Analyser* ma, BuiltinExpr* e) {
    Expr* inner = e.getInner();
    assert(inner);

    bool savedPublic = ma.usedPublic;
    ma.usedPublic = false;
    QualType qt;
    if (inner.isType()) {
        TypeExpr* te = (TypeExpr*)inner;
        TypeRef* ref = te.getTypeRef();
        qt = ma.analyseTypeRef(ref);
        inner.setType(qt);
    } else {
        // is Identifier/memberExpr, could still be Type!

        qt = ma.analyseExpr(&inner, false, 0); // dont set side
        if (qt.isInvalid()) return QualType_Invalid;

        // TODO extract to function
        if (qt.isArray()) {
            const ArrayType* at = qt.getArrayTypeOrNil();
            if (at && !at.hasSize()) {
                ma.error(inner.getLoc(), "sizeof cannot be used on arrays of unknown length");
                return QualType_Invalid;
            }
        }
        if (qt.isStruct()) {
            StructType* st = qt.getStructType();
            const StructTypeDecl* std = st.getDecl();
            if (std.isOpaque()) {
                const Decl* d = (Decl*)std;
                bool is_external = ma.mod != d.getModule();
                if (ma.curFunction && ma.curFunction.getInstanceModule() == d.getModule()) {
                    // type is local in instantiation module
                    is_external = false;
                }
                if (is_external) {
                    ma.error(inner.getLoc(), "opaque type '%s' used by value", qt.diagName());
                }
            }
        }
    }
    ma.usedPublic = savedPublic;
    if (qt.isInvalid()) return QualType_Invalid;

    size_analyser.TypeSize info = size_analyser.sizeOfType(qt);
    e.setUValue(info.size);
    return getBuiltinQT(UInt32);
}

fn QualType Analyser.analyseElemsof(Analyser* ma, BuiltinExpr* b) {
    // could be EnumType or array VarDecl

    Expr* inner = b.getInner();
    bool savedPublic = ma.usedPublic;
    ma.usedPublic = false;
    QualType qt = ma.analyseExpr(&inner, false, RHS);
    ma.usedPublic = savedPublic;
    if (qt.isInvalid()) return qt;

    const ArrayType* at = qt.getArrayTypeOrNil();
    if (at) {
        if (!at.hasSize()) {
            ma.error(inner.getLoc(), "elemsof cannot be used on arrays of unknown length");
            return QualType_Invalid;
        }
        b.setUValue(at.getSize());
        return getBuiltinQT(UInt32);
    }
    const EnumType* et = qt.getEnumTypeOrNil();
    if (et) {
        const EnumTypeDecl* etd = et.getDecl();
        b.setUValue(etd.getNumConstants());
        return getBuiltinQT(UInt32);
    }
    ma.error(inner.getLoc(), "elemsof can only be used on arrays/enums");
    return QualType_Invalid;
}

fn QualType Analyser.analyseEnumMinMax(Analyser* ma, BuiltinExpr* b) {
    Expr* inner = b.getInner();
    QualType qt = ma.analyseExpr(&inner, false, RHS);
    if (qt.isInvalid()) return QualType_Invalid;

    EnumType* et = qt.getEnumTypeOrNil();
    if (!et) {
        const char* kind = (b.getKind() == EnumMin) ? "enum_min" : "enum_max";
        ma.error(inner.getLoc(), "%s can only be used on enum types", kind);
        return QualType_Invalid;
    }

    EnumTypeDecl* etd = et.getDecl();
    u32 num = etd.getNumConstants();
    EnumConstantDecl** constants = etd.getConstants();

    u32 index = 0;
    if (b.getKind() == EnumMax) index = num-1;
    // Since enum constants must be in-order return value of first/last
    b.setValue(constants[index].getValue());

    return etd.getImplType();
}

fn QualType Analyser.analyseOffsetOf(Analyser* ma, BuiltinExpr* b) {
    Expr* e = (Expr*)b;
    Expr* inner = b.getInner();
    QualType qt = ma.analyseExpr(&inner, false, RHS);
    if (qt.isInvalid()) return QualType_Invalid;

    e.setType(getBuiltinQT(UInt32));

    StructType* st = qt.getStructTypeOrNil();
    if (!st) {
        ma.error(inner.getLoc(), "offsetof can only be used on struct types");
        return QualType_Invalid;
    }

    StructTypeDecl* std = st.getDecl();
    if (!ma.checkOpaque(std, inner.getLoc())) return QualType_Invalid;

    Expr* member = b.getOffsetOfMember();
    Decl* d = ma.findMemberOffset(b, std, member);
    if (!d) return QualType_Invalid;
    return e.getType();
}

fn QualType Analyser.analyseToContainer(Analyser* ma, BuiltinExpr* b) {
    // syntax: const? volatile? Type* to_container(Type, member, const? volatile? member*)
    Expr* inner = b.getInner(); // Type
    QualType qt = ma.analyseExpr(&inner, false, RHS);
    if (qt.isInvalid()) return QualType_Invalid;

    StructType* st = qt.getStructTypeOrNil();
    if (!st) {
        ma.error(inner.getLoc(), "to_container can only be used on struct types");
        return QualType_Invalid;
    }

    StructTypeDecl* std = st.getDecl();
    if (!ma.checkOpaque(std, inner.getLoc())) return QualType_Invalid;

    // check member
    Expr* member = b.getToContainerMember();
    Decl* d = ma.findMemberOffset(b, std, member);
    if (!d) return QualType_Invalid;

    // check ptr
    Expr** pptr = b.getToContainerPointer2();
    QualType qptr = ma.analyseExpr(pptr, false, RHS);
    if (qptr.isInvalid()) return QualType_Invalid;

    // Note: 3rd argument may be const/volatile ptr: copy qualifiers to result type
    PointerType* pt = qptr.getPointerType();
    qt.copyQuals(pt.getInner());

    // Construct expected pointer type with proper qualifiers
    QualType qmem = d.getType();
    qmem.copyQuals(pt.getInner());
    QualType expectedType = ma.builder.actOnPointerType(qmem);

    if (!ma.checker.check(expectedType, qptr, pptr, (*pptr).getLoc())) {
        return QualType_Invalid;
    }

    return ma.builder.actOnPointerType(qt);
}

type FindMemberOffsetContext struct {
    StructTypeDecl* std;
    u32 base_offset;
}

fn Decl* Analyser.findMemberOffsetAux(Analyser* ma, FindMemberOffsetContext* ctx, Expr* member) {
    Decl* d = nil;
    if (member.isIdentifier()) {
        IdentifierExpr* i = (IdentifierExpr*)member;
        u32 name_idx = i.getNameIdx();

        d = ma.findStructMemberOffset(ctx.std, name_idx, member.getLoc(), &ctx.base_offset);
        if (!d) return nil;

        i.setDecl(d);
        d.setUsed();
        member.setLValue();
        i.setKind(StructMember);
    } else {
        assert(member.isMember());
        MemberExpr* m = (MemberExpr*)member;
        u32 start = 0;
        if (m.hasExpr()) {
            d = ma.findMemberOffsetAux(ctx, m.getBaseExpr());
            if (!d) return nil;
            if (d.isStructType()) ctx.std = (StructTypeDecl*)d;
            start = 1;
        }
        for (u32 i = start; i < 2; i++) {
            u32 name_idx = m.getNameIdx(i);
            SrcLoc loc = m.getLoc(i);
            d = ma.findStructMemberOffset(ctx.std, name_idx, loc, &ctx.base_offset);
            if (!d) return nil;

            if (d.isStructType()) ctx.std = (StructTypeDecl*)d;
            d.setUsed();
            m.setDecl(d, i);
        }
        m.setKind(StructMember);
    }
    member.setType(d.getType());
    return d;
}

fn Decl* Analyser.findMemberOffset(Analyser* ma, BuiltinExpr* b, StructTypeDecl* std, Expr* member) {
    FindMemberOffsetContext ctx = { std, 0 }
    Decl* d = ma.findMemberOffsetAux(&ctx, member);
    if (d) b.setUValue(ctx.base_offset);
    return d;
}

fn Decl* Analyser.findStructMemberOffset(Analyser* ma, StructTypeDecl* s, u32 name_idx, SrcLoc loc, u32* base) {
    Decl* d = s.findMember(name_idx, base);
    if (!d) ma.memberError(name_idx, loc, s);
    return d;
}

