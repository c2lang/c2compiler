/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module token;

import number_radix local;
import src_loc local;

import string;

public type Kind enum u8 {
    None,
    Identifier,         // abc
    IntegerLiteral,     // 123
    FloatLiteral,       // 3.1415
    CharLiteral,        // 'c'
    StringLiteral,      // "abc"
    LParen,             // (
    RParen,             // )
    LSquare,            // [
    RSquare,            // ]
    LBrace,             // {
    RBrace,             // }
    Exclaim,            // !
    ExclaimEqual,       // !=
    Star,               // *
    StarEqual,          // *=
    Amp,                // &
    AmpAmp,             // &&
    AmpEqual,           // &=
    Pipe,               // |
    PipePipe,           // ||
    PipeEqual,          // |=
    Equal,              // =
    EqualEqual,         // ==
    Semicolon,          // ;
    Colon,              // :
    At,                 // @
    Caret,              // ^
    CaretEqual,         // ^=
    Question,           // ?
    Dot,                // .
    Ellipsis,           // ...
    Comma,              // ,
    Plus,               // +
    PlusPlus,           // ++
    PlusEqual,          // +=
    Minus,              // -
    MinusMinus,         // --
    MinusEqual,         // -=
    Tilde,              // ~
    Slash,              // /
    SlashEqual,         // /=
    Percent,            // %
    PercentEqual,       // %=
    Less,               // <
    LessLess,           // <<
    LessEqual,          // <=
    LessLessEqual,      // <<=
    Greater,            // >
    GreaterGreater,     // >>
    GreaterEqual,       // >=
    GreaterGreaterEqual, // >>=
    // builtin-types
    KW_bool,    // keep as first BuiltinType, since we check range
    KW_char,
    KW_i8,
    KW_i16,
    KW_i32,
    KW_i64,
    KW_u8,
    KW_u16,
    KW_u32,
    KW_u64,
    KW_reg8,
    KW_reg16,
    KW_reg32,
    KW_reg64,
    KW_isize,
    KW_usize,
    KW_f32,
    KW_f64,
    KW_void,        // keep as last BuiltinType, since we check range
    // C types
    KW_int,
    KW_ssize_t,
    KW_size_t,
    KW_float,
    KW_double,
    KW_short,
    KW_long,
    KW_signed,
    KW_unsigned,
    // C keywords
    KW_typedef,
    // other keywords
    KW_as,
    KW_asm,
    KW_assert,
    KW_break,
    KW_case,
    KW_cast,
    KW_const,
    KW_continue,
    KW_default,
    KW_elemsof,
    KW_else,
    KW_enum_max,
    KW_enum_min,
    KW_enum,
    KW_extern,
    KW_fallthrough,
    KW_false,
    KW_fn,
    KW_for,
    KW_goto,
    KW_if,
    KW_import,
    KW_local,
    KW_module,
    KW_nil,
    KW_offsetof,
    KW_public,
    KW_return,
    KW_sizeof,
    KW_static_assert,
    KW_struct,
    KW_switch,
    KW_template,
    KW_to_container,
    KW_true,
    KW_type,
    KW_union,
    KW_volatile,
    KW_while,
    // only in raw mode
    Feat_if,
    Feat_ifdef,
    Feat_ifndef,
    Feat_elif,
    Feat_else,
    Feat_endif,
    Feat_error,
    Feat_warning,
    Invalid,
    LineComment,
    BlockComment,
    // Special Tokens
    Eof,
    Error,
}

public fn bool Kind.isKeyword(Kind kind) {
    return kind >= KW_bool && kind <= KW_while;
}

public fn bool Kind.isQualifier(Kind kind) {
    return kind == KW_const || kind == KW_volatile;
}

public fn bool Kind.isBuiltinType(Kind kind) {
    return kind >= KW_bool && kind < KW_void;
}

public fn bool Kind.isTypeKeyword(Kind kind) {
    return kind >= KW_bool && kind <= KW_unsigned;
}

public fn bool Kind.isCType(Kind kind) {
    return kind >= KW_int && kind <= KW_unsigned;
}

// NOTE: keep in sync with TokenKind
const char*[Kind] token_names = {
    [None]             = "none",
    [Identifier]       = "identifier",
    [IntegerLiteral]   = "integer",
    [FloatLiteral]     = "float",
    [CharLiteral]      = "character",
    [StringLiteral]    = "string",
    [LParen]           = "(",
    [RParen]           = ")",
    [LSquare]          = "[",
    [RSquare]          = "]",
    [LBrace]           = "{",
    [RBrace]           = "}",
    [Exclaim]          = "!",
    [ExclaimEqual]     = "!=",
    [Star]             = "*",
    [StarEqual]        = "*=",
    [Amp]              = "&",
    [AmpAmp]           = "&&",
    [AmpEqual]         = "&=",
    [Pipe]             = "|",
    [PipePipe]         = "||",
    [PipeEqual]        = "|=",
    [Equal]            = "=",
    [EqualEqual]       = "==",
    [Semicolon]        = ";",
    [Colon]            = ":",
    [At]               = "@",
    [Caret]            = "^",
    [CaretEqual]       = "^=",
    [Question]         = "?",
    [Dot]              = ".",
    [Ellipsis]         = "...",
    [Comma]            = ",",
    [Plus]             = "+",
    [PlusPlus]         = "++",
    [PlusEqual]        = "+=",
    [Minus]            = "-",
    [MinusMinus]       = "--",
    [MinusEqual]       = "-=",
    [Tilde]            = "~",
    [Slash]            = "/",
    [SlashEqual]       = "/=",
    [Percent]          = "%",
    [PercentEqual]     = "%=",
    [Less]             = "<",
    [LessLess]         = "<<",
    [LessEqual]        = "<=",
    [LessLessEqual]    = "<<=",
    [Greater]          = ">",
    [GreaterGreater]   = ">>",
    [GreaterEqual]     = ">=",
    [GreaterGreaterEqual] = ">>=",
    [KW_bool]          = "bool",
    [KW_char]          = "char",
    [KW_i8]            = "i8",
    [KW_i16]           = "i16",
    [KW_i32]           = "i32",
    [KW_i64]           = "i64",
    [KW_u8]            = "u8",
    [KW_u16]           = "u16",
    [KW_u32]           = "u32",
    [KW_u64]           = "u64",
    [KW_reg8]          = "reg8",
    [KW_reg16]         = "reg16",
    [KW_reg32]         = "reg32",
    [KW_reg64]         = "reg64",
    [KW_isize]         = "isize",
    [KW_usize]         = "usize",
    [KW_f32]           = "f32",
    [KW_f64]           = "f64",
    [KW_void]          = "void",
    [KW_int]           = "int",
    [KW_ssize_t]       = "ssize_t",
    [KW_size_t]        = "size_t",
    [KW_float]         = "float",
    [KW_double]        = "double",
    [KW_short]         = "short",
    [KW_long]          = "long",
    [KW_signed]        = "signed",
    [KW_unsigned]      = "unsigned",
    [KW_typedef]       = "typedef",
    [KW_as]            = "as",
    [KW_asm]           = "asm",
    [KW_assert]        = "assert",
    [KW_break]         = "break",
    [KW_case]          = "case",
    [KW_cast]          = "cast",
    [KW_const]         = "const",
    [KW_continue]      = "continue",
    [KW_default]       = "default",
    [KW_elemsof]       = "elemsof",
    [KW_else]          = "else",
    [KW_enum_max]      = "enum_max",
    [KW_enum_min]      = "enum_min",
    [KW_enum]          = "enum",
    [KW_extern]        = "extern",
    [KW_fallthrough]   = "fallthrough",
    [KW_false]         = "false",
    [KW_fn]            = "fn",
    [KW_for]           = "for",
    [KW_goto]          = "goto",
    [KW_if]            = "if",
    [KW_import]        = "import",
    [KW_local]         = "local",
    [KW_module]        = "module",
    [KW_nil]           = "nil",
    [KW_offsetof]      = "offsetof",
    [KW_public]        = "public",
    [KW_return]        = "return",
    [KW_sizeof]        = "sizeof",
    [KW_static_assert] = "static_assert",
    [KW_struct]        = "struct",
    [KW_switch]        = "switch",
    [KW_template]      = "template",
    [KW_to_container]  = "to_container",
    [KW_true]          = "true",
    [KW_type]          = "type",
    [KW_union]         = "union",
    [KW_volatile]      = "volatile",
    [KW_while]         = "while",
    [Feat_if]          = "#if",
    [Feat_ifdef]       = "#ifdef",
    [Feat_ifndef]      = "#ifndef",
    [Feat_elif]        = "#elif",
    [Feat_else]        = "#else",
    [Feat_endif]       = "#endif",
    [Feat_error]       = "#error",
    [Feat_warning]     = "#warning",
    [Invalid]          = "invalid",
    [LineComment]      = "l-comment",
    [BlockComment]     = "b-comment",
    [Eof]              = "eof",
    [Error]            = "error",
}

public fn const char* Kind.str(Kind k) {
    return token_names[k];
}

public type Token struct {
    SrcLoc loc;
    u16 len : 16;
    Kind kind : 8;
    bool done : 1;
    // TODO: fix QualType.getBitFieldWidth() to return actual number of bits instead of implementation type
    u8 radix : 2;   // number_radix.Radix: for IntegerLiteral (2,8,10,16), FloatLiteral(10,16) and CharLiteral (8,16)
    u8 raw : 1;     // for StringLiteral
    bool reserved : 1;
    bool suffix_F : 1;
    union {
        const char* error_msg;  // ERROR
        struct {           // StringLiteral, LineComment, BlockComment
            u32 text_idx;  // pool index of encoded string or comment
            u32 text_len;  // length of converted string (without null terminator)
        }
        u32 name_idx;      // Identifier and all keywords
        u64 int_value;     // IntegerLiteral
        f64 float_value;   // FloatLiteral
        u8 char_value;     // CharLiteral
        char[8] invalid;   // Invalid
    }
}
static_assert(16, sizeof(Token));

public fn void Token.init(Token* tok) {
    string.memset(tok, 0, sizeof(Token));
}

public fn Radix Token.getRadix(const Token* tok) {
    return (Radix)tok.radix;
}
