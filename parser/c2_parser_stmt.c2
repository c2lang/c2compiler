/* Copyright 2022-2024 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c2_parser;

import stmt_list;
import ast local;
import token local;
import src_loc local;
import string_list;

fn Stmt* Parser.parseStmt(Parser* p) {
    // TODO use Jump Table (combined one for multiple purposes?)
    // TODO also jump to Expr part, since most entries use parseExprStmt (dont lookup again in Expr)
    switch (p.tok.kind) {
    case Identifier:
        return p.parseDeclOrStmt();
    case LBrace:
        return cast<Stmt*>(p.parseCompoundStmt());
    case RBrace:
        p.error("expected stmt");
        break;
    case KW_asm:
        return p.parseAsmStmt();
    case KW_assert:
        return p.parseAssertStmt();
    case KW_break:
        return p.parseBreakStmt();
    case KW_continue:
        return p.parseContinueStmt();
    case KW_do:
        return p.parseDoStmt();
    case KW_fallthrough:
        return p.parseFallthroughStmt();
    case KW_for:
        return p.parseForStmt();
    case KW_goto:
        return p.parseGotoStmt();
    case KW_if:
        return p.parseIfStmt();
    case KW_return:
        return p.parseReturnStmt();
    case KW_switch:
        return p.parseSwitchStmt(false);
    case KW_sswitch:
        return p.parseSwitchStmt(true);
    case KW_bool:   fallthrough;
    case KW_char:   fallthrough;
    case KW_const:   fallthrough;
    case KW_i8:    fallthrough;
    case KW_i16:   fallthrough;
    case KW_i32:   fallthrough;
    case KW_i64:   fallthrough;
    case KW_isize:   fallthrough;
    case KW_f32:   fallthrough;
    case KW_f64:   fallthrough;
    case KW_local:   fallthrough;
    case KW_reg8:    fallthrough;
    case KW_reg16:   fallthrough;
    case KW_reg32:   fallthrough;
    case KW_reg64:   fallthrough;
    case KW_u8:    fallthrough;
    case KW_u16:   fallthrough;
    case KW_u32:   fallthrough;
    case KW_u64:   fallthrough;
    case KW_usize:   fallthrough;
    case KW_volatile:   fallthrough;
    case KW_void:
        return p.parseDeclStmt(true, true);
    case KW_while:
        return p.parseWhileStmt();
    default:
        return p.parseExprStmt();
    }
    return nil;
}

/*
    Declarations (type + name)
        a* b <init> -> yes
        a[] b <init> -> yes
        a[10] b -> yes
        a*[] b <init> -> yes
        a b <init> -> yes
        a.b c -> yes
    Assignments/Function calls
        a = ..     -> no
        a *= .. etc -> no
        a() -> no
        a[10] = .. -> no
        a.b.c .. -> no
        a.b->.. -> no
*/
fn bool Parser.isTypeSpec(Parser* p) {
    assert(p.tok.kind == Kind.Identifier);
    Token t;

    // State: 0 = ID1, 1 = ID2, 2 = pointers, 3 = arrays
    u32 state = 0;
    u32 lookahead = 1;
    while (1) {
        Token t2 = p.tokenizer.lookahead(lookahead);
        switch (t2.kind) {
        case Identifier:
            goto type_done;
        case LSquare:
            lookahead = p.skipArray(lookahead);
            state = 3;
            break;
        case Star:
            if (state == 3) return false; // a[1] * ..
            state = 2;
            lookahead++;
            break;
        case Dot:
            if (state == 0) {
                Token t3 = p.tokenizer.lookahead(lookahead+1);
                if (t3.kind != Kind.Identifier) {
                    // syntax error
                    return false;
                }
                state = 2;
                lookahead += 2;
            } else {
                return false; // a.b.c
            }
            break;
        default:
            goto type_done;
        }
    }
type_done:
    // if token after type is identifier, it's a decl, otherwise it's not
    t = p.tokenizer.lookahead(lookahead);
    return t.kind == Kind.Identifier;
}

fn u32 Parser.skipArray(Parser* p, u32 lookahead) {
    lookahead++;

    u32 depth =1;
    while (depth) {
        Token next = p.tokenizer.lookahead(lookahead);
        switch (next.kind) {
        case LSquare:
            depth++;
            break;
        case RSquare:
            depth--;
            break;
        case Eof:
            p.error("unexpected end-of-file");
            break;
        default:
            break;
        }
        lookahead++;
    }

    return lookahead;
}

/*
  Syntax:
    Number num = .     // id = type
    Utils.Type t = .  // id = module.type
    myfunc()        // id = func
    Mod.func()     // id = module.func
    count =         // id = var
    Mod.var =      // id = module.var
    id:             // id = label
*/
fn Stmt* Parser.parseDeclOrStmt(Parser* p) {
    assert(p.tok.kind == Kind.Identifier);
    bool isDecl = p.isTypeSpec();

    if (isDecl) return p.parseDeclStmt(true, true);

    Token next = p.tokenizer.lookahead(1);
    if (next.kind == Kind.Colon) return p.parseLabelStmt();

    return p.parseExprStmt();
}

fn CompoundStmt* Parser.parseCompoundStmt(Parser* p) {
    p.expectAndConsume(Kind.LBrace);

    stmt_list.List stmts;
    stmts.init();   // TODO register somewhere to free memory on error (register handler?)

    while (p.tok.kind != Kind.RBrace) {
        stmts.add(p.parseStmt());
    }

    SrcLoc endLoc = p.tok.loc;
    p.expectAndConsume(Kind.RBrace);

    CompoundStmt* s = p.builder.actOnCompoundStmt(endLoc, stmts.getData(), stmts.size());
    stmts.free();

    return s;
}

// Syntax (GNU extended asm statement)
// asm-statement:
//      'asm' type-qualifier[opt] '(' asm-argument ')' ';'
//
// asm-argument:
//      asm-string-literal
//      asm-string-literal ':' asm-operands[opt]
//      asm-string-literal ':' asm-operands[opt] ':' asm-operands[opt]
//      asm-string-literal ':' asm-operands[opt] ':' asm-operands[opt]
//              ':' asm-clobbers
//
// asm-clobbers:
//      asm-string-literal
//      asm-clobbers ',' asm-string-literal
//
fn Stmt* Parser.parseAsmStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();
    u32 quals = p.parseOptionalTypeQualifier();
    bool is_volatile = (quals == QualType_Volatile);
    //TODO check allowed qualifiers

    p.expectAndConsume(Kind.LParen);

    p.expect(Kind.StringLiteral);
    // TODO concatenate multiple strings
    Expr* str = p.parseStringLiteral();

    ExprList constraints;
    constraints.init(2);
    ExprList exprs;
    exprs.init(2);
    ExprList clobbers;
    clobbers.init(2);

    // Basic Asm stmt
    if (p.tok.kind == Kind.RParen) {
        p.consumeToken();
        p.expectAndConsume(Kind.Semicolon);
        Stmt* s = p.builder.actOnAsmStmt(loc, true, is_volatile, 0, 0, nil, &constraints, &exprs, &clobbers, str);
        constraints.free();
        exprs.free();
        clobbers.free();
        return s;
    }

    string_list.List names;
    names.init(p.pool);

    // Extended Asm stmt

    // parse Outputs, if present
    if (p.tok.kind == Kind.Colon) {
        p.consumeToken();
        p.parseAsmOperandsOpt(&names, &constraints, &exprs);
    }

    u32 num_outputs = names.length();

    // parse Inputs, if present
    if (p.tok.kind == Kind.Colon) {
        p.consumeToken();
        p.parseAsmOperandsOpt(&names, &constraints, &exprs);
    }

    u32 num_inputs = names.length() - num_outputs;

    // parse Clobbers, if present
    if (p.tok.kind == Kind.Colon) {
        p.consumeToken();

        // Parse the asm-string list for clobbers if present
        if (p.tok.kind != Kind.RParen) {
            while (1) {
                // TODO concatenate multiple strings
                p.expect(Kind.StringLiteral);
                Expr* e = p.parseStringLiteral();
                clobbers.add(e);
                if (p.tok.kind != Kind.Comma) break;
                p.consumeToken();
            }
        }
    }

    p.expectAndConsume(Kind.RParen);
    p.expectAndConsume(Kind.Semicolon);

    Stmt* s = p.builder.actOnAsmStmt(loc, false, is_volatile, num_outputs, num_inputs, names.getData(), &constraints, &exprs, &clobbers, str);
    names.free();
    constraints.free();
    exprs.free();
    clobbers.free();
    return s;
}

// Syntax:
// asm-operands:
//      asm-operand
//      asm-operands ',' asm-operand
//
// asm-operand:
//      asm-string_literal '(' expression ')'
//      '[' identifier ']' asm-string_literal '(' expression ')'
//
fn void Parser.parseAsmOperandsOpt(Parser* p, string_list.List* names, ExprList* constraints, ExprList* exprs) {
    // 'asm-operands' isn't present
    if (p.tok.kind != Kind.StringLiteral && p.tok.kind != Kind.LSquare) return;

    while (1) {
        // read the [id] if present
        if (p.tok.kind == Kind.LSquare) {
            p.consumeToken();

            p.expectIdentifier();
            u32 name = p.tok.text_idx;
            //SrcLoc loc = p.tok.loc;
            p.consumeToken();
            names.add(name);
            p.expectAndConsume(Kind.RSquare);
        } else {
            names.add(0);
        }

        p.expect(Kind.StringLiteral);
        Expr* e = p.parseStringLiteral();
        constraints.add(e);

        // read the parenthesized expression
        p.expectAndConsume(Kind.LParen);
        e = p.parseExpr();
        p.expectAndConsume(Kind.RParen);
        exprs.add(e);

        if (p.tok.kind != Kind.Comma) return;
        p.consumeToken();
    }
}

fn Stmt* Parser.parseAssertStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();
    p.expectAndConsume(Kind.LParen);
    Expr* inner = p.parseExpr();
    p.expectAndConsume(Kind.RParen);
    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnAssertStmt(loc, inner);
}

fn Stmt* Parser.parseBreakStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnBreakStmt(loc);
}

fn Stmt* Parser.parseContinueStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnContinueStmt(loc);
}

fn Stmt* Parser.parseFallthroughStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnFallthroughStmt(loc);
}

fn Stmt* Parser.parseCondition(Parser* p) {
    p.expectAndConsume(Kind.LParen);

    Stmt* s;
    if (p.isDeclaration()) {
        s = p.parseDeclStmt(false, false);
    } else {
        Expr* cond = p.parseExpr();
        s = cond.asStmt();
    }
    p.expectAndConsume(Kind.RParen);
    return s;
}

fn Stmt* Parser.parseIfStmt(Parser* p) {
    p.consumeToken();

    Stmt* cond = p.parseCondition();
    Stmt* then = p.parseStmt();

    Stmt* else_stmt = nil;
    if (p.tok.kind == Kind.KW_else) {
        p.consumeToken();
        else_stmt = p.parseStmt();
    }

    return p.builder.actOnIfStmt(cond, then, else_stmt);
}

fn Stmt* Parser.parseReturnStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    Expr* ret = nil;
    if (p.tok.kind != Kind.Semicolon) {
        ret = p.parseExpr();
    }

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnReturnStmt(loc, ret);
}

fn Stmt* Parser.parseDoStmt(Parser* p) {
    p.consumeToken();

    Stmt* then = p.parseStmt();
    p.expectAndConsume(Kind.KW_while);
    Stmt* cond = p.parseCondition();

    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnDoStmt(cond, then);
}

fn Stmt* Parser.parseForStmt(Parser* p) {
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    p.expectAndConsume(Kind.LParen);

    // init
    Stmt* init_ = nil;
    if (p.tok.kind != Kind.Semicolon) {
        // parseCondition
        if (p.isDeclaration()) {
            init_ = p.parseDeclStmt(false, false);
        } else {
            init_ = p.parseExpr().asStmt();
        }
    }
    p.expectAndConsume(Kind.Semicolon);

    // cond
    Expr* cond = nil;
    if (p.tok.kind != Kind.Semicolon) {
        cond = p.parseExpr();
    }
    p.expectAndConsume(Kind.Semicolon);

    // incr
    Expr* incr = nil;
    if (p.tok.kind != Kind.RParen) {
        incr = p.parseExpr();
    }
    p.expectAndConsume(Kind.RParen);

    Stmt* body = p.parseStmt();

    return p.builder.actOnForStmt(loc, init_, cond, incr, body);
}

fn Stmt* Parser.parseWhileStmt(Parser* p) {
    p.consumeToken();

    Stmt* cond = p.parseCondition();
    Stmt* then = p.parseStmt();

    return p.builder.actOnWhileStmt(cond, then);
}

fn Stmt* Parser.parseDeclStmt(Parser* p, bool checkSemi, bool allowLocal) {
    bool has_local = false;
    if (p.tok.kind == Kind.KW_local) {
        has_local = true;
        if (!allowLocal) p.error("keyword 'local' is not allowed here");
        p.consumeToken();
    }

    TypeRefHolder ref;
    ref.init();
    p.parseTypeSpecifier(&ref, true, true);

    p.expectIdentifier();

    u32 name = p.tok.text_idx;
    SrcLoc loc = p.tok.loc;
    p.consumeToken();

    // TODO same as parseVarDecl()
    bool need_semi = true;
    Expr* initValue = nil;
    SrcLoc assignLoc = 0;

    if (p.tok.kind == Kind.Equal) {
        assignLoc = p.tok.loc;
        p.consumeToken();
        initValue = p.parseInitValue(&need_semi, false);
    }

    Stmt* s = p.builder.actOnVarDeclStmt(name, loc, &ref, assignLoc, initValue, has_local);
    if (checkSemi && need_semi) {
        p.expectAndConsume(Kind.Semicolon);
    }

    return s;
}

fn Stmt* Parser.parseExprStmt(Parser* p) {
    Expr* e = p.parseExpr();
    p.expectAndConsume(Kind.Semicolon);
    return e.asStmt();
}

fn Stmt* Parser.parseLabelStmt(Parser* p) {
    u32 name =  p.tok.text_idx;
    SrcLoc loc = p.tok.loc;
    p.consumeToken(); // identifier
    p.expectAndConsume(Kind.Colon);
    return p.builder.actOnLabelStmt(name, loc);
}

fn Stmt* Parser.parseGotoStmt(Parser* p) {
    p.consumeToken();
    p.expectIdentifier();
    u32 name =  p.tok.text_idx;
    SrcLoc loc = p.tok.loc;
    p.consumeToken();
    p.expectAndConsume(Kind.Semicolon);
    return p.builder.actOnGotoStmt(name, loc);
}

// TODO rename: detect whether we have a Type
fn bool Parser.isDeclaration(Parser* p) {
    const Kind kind = p.tok.kind;
    if (kind == Kind.Identifier) return p.isTypeSpec();
    if (kind >= Kind.KW_bool && kind <= Kind.KW_void) return true;
    if (kind == Kind.KW_local) return true;
    return false;
}

