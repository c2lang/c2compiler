/* Copyright 2022-2023 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c2c_main;

import build_file;
import build_target;
import color;
import console;
import c2recipe;
import compiler;
import constants;
import file_utils;
#if C2_PLUGINS
import git_version; // from plugin
#endif
import diagnostics;
import parser_utils;
import plugin_info;
import plugin_mgr;
import source_mgr;
import string_list;
import string_buffer;
import string_pool;
import utils;

import stdlib local;
import unistd;
import string local;
import c_errno local;

type Options struct {
    bool log_verbose;
    bool print_timing;
    bool show_targets;
    bool show_plugins;
    bool no_plugins;
    const char* target;
    const char* single_file;
    const char* build_file;
    const char* other_dir;
}

fn void create_project(const char* name) {

    if (file_utils.exists("main.c2") || file_utils.exists("recipe.txt")) {
        console.error("main.c2 and/or recipe.txt already exist");
        exit(EXIT_FAILURE);
    }

    string_buffer.Buf* buf = string_buffer.create(4096, false, 2);
    file_utils.Writer writer;

    buf.print("module %s_main;\n\n", name);
    buf.add("public fn i32 main(i32 argc, char** argv) {\n");
    buf.add("\n");
    buf.add("\treturn 0;\n");
    buf.add("}\n");
    bool ok = writer.write("main.c2", buf.udata(), buf.size());
    if (!ok) {
        console.error("%s", writer.getError());
        exit(EXIT_FAILURE);
    }

    buf.clear();
    buf.print("\nexecutable %s\n", name);
    buf.add("\t$warnings no-unused\n");
    buf.add("\t$backend c\n");
    buf.newline();
    buf.add("\tmain.c2\n");
    buf.add("end\n");
    ok = writer.write("recipe.txt", buf.udata(), buf.size());
    if (!ok) {
        console.error("%s", writer.getError());
        exit(EXIT_FAILURE);
    }

    buf.free();
    console.log("created new project files");
    exit(EXIT_SUCCESS);
}

fn void print_recipe_help() {
    console.log("---- recipe.txt ----");
    console.log("");
    console.log("plugin <name> [<plugin-options]");
    console.log("");
    console.log("config <options>");
    console.log("");
    console.log("executable <name>");
    console.log("   $warnings <no-unused>");
    console.log("             <no-unused-variable>");
    console.log("             <no-unused-function>");
    console.log("             <no-unused-parameter>");
    console.log("             <no-unused-type>");
    console.log("             <no-unused-module>");
    console.log("             <no-unused-import> ");
    console.log("             <no-unused-public>");
    console.log("             <no-unused-label> ");
    console.log("             <no-unused-enum-constant>");
    console.log("             <promote-to-error> ");
    console.log("   $backend c <fast>");
    console.log("              <no-build>");
    console.log("              <check>");
    console.log("              <fast>");
    console.log("              <no-build>");
    console.log("              <skip>");
    console.log("   $backend llvm <options>");
    console.log("   $backend qbe <options>");
    console.log("   $nolibc");
    console.log("   $disable-asserts");
    console.log("   $config <options>");
    console.log("   $plugin <name> [<plugin-options>]");
    console.log("   $use <library-name> dynamic/static");
    console.log("   file1.c2");
    console.log("   file2.c2");
    console.log("end");
    console.log("");
    console.log("lib <name> shared/static");
    console.log("   $export <module-names>");
    console.log("   (other options same as executable");
    console.log("end");
    console.log("");
    console.log("--------------------");
}

fn void print_version() {
#if C2_PLUGINS
    console.log("version: %s", git_version.Describe);
#else
    console.log("version: unknown");
#endif
}

fn void usage(const char* me) {
    console.log("Usage: %s <options>", me);
    console.log("Options:");
    console.log("\t-a                print ASTs");
    console.log("\t-A                print Library ASTs");
    console.log("\t-b [file]         use specified build file");
    console.log("\t-c                generate C-code");
    console.log("\t-C                generate + print C-code");
    console.log("\t-d [dir]          change to [dir] first");
    console.log("\t-f [file]         only parse single file");
    console.log("\t-h                print this help");
    console.log("\t-m                print modules");
    console.log("\t-q                generate QBE");
    console.log("\t-Q                generate + print QBE");
    console.log("\t-r                print reports");
    console.log("\t-s                print symbols");
    console.log("\t-S                print library symbols");
    console.log("\t-t                print timing");
    console.log("\t-T                print AST statistics");
    console.log("\t-v                verbose logging");
    console.log("\t--check           only parse and check");
    console.log("\t--create [name]   test mode (dont check for main() function)");
    console.log("\t--fast            do fast, un-optimized build");
    console.log("\t--help            print this help");
    console.log("\t--help-recipe     print the recipe syntax");
    console.log("\t--noplugins       dont use plugins");
    console.log("\t--showlibs        print available libraries");
    console.log("\t--showplugins     print available plugins");
    console.log("\t--targets         show available targets in recipe");
    console.log("\t--test            test mode (dont check for main() function)");
    console.log("\t--version         print version");
    exit(EXIT_FAILURE);
}

fn i32 parse_long_opt(i32 i, i32 argc, char** argv, compiler.Options* opts, Options* other) {
    const char* arg = argv[i];
    sswitch (arg+2) {
    case "check":
        opts.check_only = true;
    case "create":
        if (i==argc-1) usage(argv[0]);
        i++;
        create_project(argv[i]);
        return 0;
    case "fast":
        opts.fast_build = true;
    case "help":
        usage(argv[0]);
    case "help-recipe":
        print_recipe_help();
        exit(EXIT_SUCCESS);
    case "noplugins":
        other.no_plugins = true;
    case "showlibs":
        opts.show_libs = true;
    case "showplugins":
        other.show_plugins = true;
    case "targets":
        other.show_targets = true;
    case "test":
        opts.test_mode = true;
    case "version":
        print_version();
        exit(EXIT_SUCCESS);
    default:
        usage(argv[0]);
    }
    return i;
}

fn void parse_opts(i32 argc, char** argv, compiler.Options* opts, Options* other) {
    for (i32 i=1; i<argc; i++) {
        const char* arg = argv[i];
        if (arg[0] == '-') {
            if (arg[1] == '-') {
                i = parse_long_opt(i, argc, argv, opts, other);
            } else {
                if (strlen(arg) != 2) usage(argv[0]);

                switch (arg[1]) {
                case '0':    // 'hidden' feature, print AST early after parsing, then quit
                    opts.print_ast_early = true;
                    break;
                case 'A':
                    opts.print_lib_ast = true;
                    break;
                case 'C':
                    opts.generate_c = true;
                    opts.print_c = true;
                    break;
                case 'S':
                    opts.print_external_symbols = true;
                    break;
                case 'T':
                    opts. print_ast_stats = true;
                    break;
                case 'Q':
                    opts.generate_qbe = true;
                    opts.print_qbe = true;
                    break;
                case 'a':
                    opts.print_ast = true;
                    break;
                case 'b':
                    if (i==argc-1) usage(argv[0]);
                    i++;
                    other.build_file = argv[i];
                    break;
                case 'c':
                    opts.generate_c = true;
                    break;
                case 'd':
                    if (i==argc-1) usage(argv[0]);
                    i++;
                    other.other_dir = argv[i];
                    break;
                case 'f':
                    if (i==argc-1) usage(argv[0]);
                    i++;
                    other.single_file = argv[i];
                    break;
                case 'h':
                    usage(argv[0]);
                    break;
                case 'm':
                    opts.print_modules = true;
                    break;
                case 'q':
                    opts.generate_qbe = true;
                    break;
                case 'r':
                    opts.print_reports = true;
                    break;
                case 's':
                    opts.print_symbols = true;
                    break;
                case 't':
                    other.print_timing = true;
                    break;
                case 'v':
                    other.log_verbose = true;
                    break;
                default:
                    console.error("unknown option '-%c'", arg[1]);
                    usage(argv[0]);
                    break;
                }
            }
        } else {
            if (other.target) usage(argv[0]);
            other.target = arg;
        }
    }
    if (other.target && other.single_file) usage(argv[0]);
}

fn void plugins_start_target(void* arg, plugin_info.Info* info) {
    plugin_mgr.Mgr* plugins = arg;
    plugins.beginTarget(info);
}

fn void plugins_after_parsing(void* arg) {
    plugin_mgr.Mgr* plugins = arg;
    plugins.postParse();
}

fn void plugins_after_analysis(void* arg) {
    plugin_mgr.Mgr* plugins = arg;
    plugins.postAnalysis();
}

fn void plugins_end_target(void* arg) {
    plugin_mgr.Mgr* plugins = arg;
    plugins.endTarget();
}

public fn i32 main(i32 argc, char** argv) {
    console.init();

    Options opts = { }
    compiler.Options comp_opts = { }

    parse_opts(argc, argv, &comp_opts, &opts);

    console.setTiming(opts.print_timing);
    console.setDebug(opts.log_verbose);

    if (opts.other_dir) {
        if (unistd.chdir(opts.other_dir)) {
            console.error("cannot chdir to %s: %s", opts.other_dir, strerror(*errno2()));
            exit(EXIT_FAILURE);
        }
    }

    // note: auxPool is used by recipe, build-file and manifests
    string_pool.Pool* auxPool = string_pool.create(32*1024, 64);

    source_mgr.SourceMgr* sm = source_mgr.create(auxPool, constants.Max_open_files);
    diagnostics.Diags* diags = diagnostics.create(sm, color.useColor(), parser_utils.getTokenEnd);

    c2recipe.Recipe* recipe = c2recipe.create(sm, auxPool);

    i32 recipe_id = -1;

    bool hasError = false;

    if (opts.single_file) {
        recipe.addDummyTarget(opts.single_file);
    } else {
        if (!utils.findProjectDir(nil)) {
            console.error("c2c: error: cannot find C2 root dir");
            console.error("c2c requires a %s file in the project root", constants.recipe_name);
            console.error("Use argument -h for a list of available opts and usage of c2c");
            return -1;
        }
        u32 recipe_idx = auxPool.addStr(constants.recipe_name, false);

        i32 yaml_id = sm.open(recipe_idx, 0, false);
        if (yaml_id == -1) return -1;
        if (!recipe.parse(yaml_id)) return -1;

        // TEMP also parse yaml version
        recipe_id = yaml_id;
        //u32 recipe2_idx = auxPool.addStr("c2recipe.yaml", false);
        //recipe_id = sm.open(recipe2_idx, 0, false);
        //if (recipe_id == -1) return -1;
        //if (!recipe.parseYaml(recipe_id)) return -1;
    }

    // look for build file (or use specified one)
    if (!opts.build_file) {
        opts.build_file = utils.findBuildFile();
    }

    plugin_mgr.Mgr* plugins = plugin_mgr.create(auxPool, opts.print_timing, opts.log_verbose, opts.no_plugins);

    build_file.Info* build_info = nil;
    if (opts.build_file) {
        console.log("using build-file %s", opts.build_file);
        build_info = build_file.parse(sm, auxPool, opts.build_file);
        if (!build_info) return -1;

        const string_list.List* plugin_dirs = build_info.getPluginDirs();
        for (u32 i=0; i<plugin_dirs.length(); i++) {
            plugins.addPath(plugin_dirs.get_idx(i));
        }

        if (!opts.show_plugins) {
            // load global plugins from build-file
            for (u32 i=0; i<build_info.getNumPlugins(); i++) {
                const build_file.Plugin* p = build_info.getPlugin(i);
                if (!plugins.loadGlobal(p.name, p.options)) {
                    // return -1;
                }
            }
        }
    } else {
        const char* plugin_dir = getenv("C2_PLUGINDIR");
        if (plugin_dir) {
            u32 path_name = auxPool.addStr(plugin_dir, true);
            plugins.addPath(path_name);
        }
    }

    if (opts.show_plugins) {
        plugins.show();
        return 0;
    }

    // load global plugins from recipe
    const build_target.PluginList* pl = recipe.getPlugins();
    for (u32 i=0; i<pl.size(); i++) {
        const build_target.Plugin* p = pl.get(i);
        // TODO pass p.loc? (need src-mgr then)
        if (!plugins.loadGlobal(p.name, p.options)) {
            // return -1;
        }
    }

    const char* libdir = getenv("C2_LIBDIR");
    if (libdir) comp_opts.libdir = auxPool.addStr(libdir, true);
    if (!libdir && !opts.build_file) {
        console.warn("environment variable C2_LIBDIR not set!");
    }

    u32 plugins_feature = auxPool.addStr("C2_PLUGINS", false);

    compiler.PluginHandler pluginHandler = {
        .start_target = plugins_start_target,
        .after_parsing = plugins_after_parsing,
        .after_analysis = plugins_after_analysis,
        .end_target = plugins_end_target,
        .arg = plugins,
    }
    u32 num_build = 0;
    for (u32 i=0; i<recipe.numTargets(); i++) {
        build_target.Target* target = recipe.getTarget(i);
        const char* target_name = auxPool.idx2str(target.getNameIdx());
        if (opts.target && strcmp(opts.target, target_name) != 0) continue;
        if (opts.show_targets) {
            console.log("%s", target_name);
            continue;
        }
        console.log("building %s", target_name);
        num_build++;

        // load target-specific plugins from recipe
        pl = target.getPlugins();
        for (u32 j=0; j<pl.size(); j++) {
            const build_target.Plugin* p = pl.get(j);
            // TODO pass p.loc? (need src-mgr then)
            if (!plugins.loadLocal(p.name, p.options)) {
                // return -1
            }
        }

        if (!opts.no_plugins) target.addFeature(plugins_feature);

        if (!target.hasBackend()) {
            if (!comp_opts.test_mode && !comp_opts.check_only && !comp_opts.generate_c && !comp_opts.generate_qbe) {
                console.error("no backend for target %s defined in %s", target_name, constants.recipe_name);
                if (recipe_id != -1) sm.clear(recipe_id);
                continue;
            }
        }

        compiler.build(auxPool, sm, diags, build_info, target, &comp_opts, &pluginHandler);
        hasError |= (diags.getNumErrors() != 0);

        // TODO fix build_file
        if (recipe_id != -1) sm.clear(recipe_id);
    }

    if (opts.target && num_build == 0)  {
        console.warn("no such target in %s", constants.recipe_name);
    }

    plugins.free();
    if (build_info) build_info.free();
    recipe.free();
    auxPool.free();
    diags.free();
    sm.free();

	return hasError ? -1 : 0;
}

