/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module compiler;

import ast;
import component;
import console;
import module_list;
import module_sorter;
import string_list;
import unused_checker;
import utils;
import warning_flags;

fn bool Compiler.analyse(Compiler* c) {
    u64 analysis_start = utils.now();

    // check for duplicate modules
    if (!c.checkDuplicateModules()) return false;

    // resolve imports in .c2 files (not in .c2i files yet)
    if (!c.analyseSourceImports()) return false;

    // mark exported modules (cannot be external/C2-module)
    if (!c.check_exports()) return false;

    // parse external components top-down (to also mark used modules in lower libs)
    // libraries can only be parsed since, since we know which modules are needed
    for (u32 i=c.components.size(); i!=0; i--) {
        component.Component* comp = c.components.get(i-1);
        if (!comp.isExternal()) continue;

        c.parse_lib(comp);
    }

    // analyse components bottom up
    for (u32 i=0; i<c.components.size(); i++) {
        component.Component* comp = c.components.get(i);
        console.debug("analysing component %s", comp.getName());

        c.analyse_component(comp);
        if (c.diags.hasErrors()) break;
    }

    if (c.diags.hasErrors()) {
        if (c.opts.print_ast) c.mainComp.print(true);
        return false;
    }

    // mark main module as used (for libs top level module (at least) should be exported)
    c.checkMain();

    // check unused
    const warning_flags.Flags* warnings = c.target.getWarnings();
    if (!warnings.no_unused) {
        c.mainComp.visitModules(Compiler.checkUnused, c);
    }

    u64 analysis_end = utils.now();
    console.log_time("analysis", analysis_end - analysis_start);

    if (!c.diags.isOk()) return false;

    c.builder.setComponent(c.mainComp);
    c.pluginHandler.after_analysis(c.pluginHandler.arg);

    // check that a library has exported symbols (otherwise error in c-build due to export script)
    if (c.mainComp.isLibrary() || c.mainComp.isExternalSourceLib()) {
        //console.error("library has no exported symbols");
    }
    return true;
}

fn bool Compiler.checkDuplicateModules(Compiler* c) {
    // check for modules defined within different components
    c.allmodules.clear();
    for (u32 i=0; i<c.components.size(); i++) {
        component.Component* comp = c.components.get(i);
        module_list.List* mod_list = comp.getModules();
        ast.Module** mods = mod_list.get();
        for (u32 j = 0; j < mod_list.length(); j++) {
            ast.Module* m = mods[j];
            if (c.allmodules.containsName(m.getNameIdx())) {
                component.Component* other = c.findModuleComponent(m.getNameIdx());
                assert(other);
                console.error("module '%s' is defined in component %s and %s", m.getName(), comp.getName(), other.getName());
                return false;
            }
            c.allmodules.add(m);
        }
    }
    c.allmodules.clear();
    return true;
}

fn bool Compiler.analyseSourceImports(Compiler* c) {
    // check source-libs + main component, mark imported modules as used
    // create allmodules per component, bottom up and check its imports
    console.debug("analysing imports");
    for (u32 i=0; i<c.components.size(); i++) {
        // create list of allmodules for each component with all direct dependencies
        component.Component* comp = c.components.get(i);
        if (!comp.hasSources()) continue;

        c.allmodules.clear();
        c.allmodules.addList(comp.getModules(), false);

        string_list.List* deps = comp.getDeps();
        u32 num_deps = deps.length();
        const u32* dep_names = deps.getData();
        for (u32 j = 0; j < num_deps; j++) {
            component.Component* sub = c.components.find(dep_names[j]);
            // TODO should handle non-public modules from source libs (dont add)
            // if comp is source-lib, add flag false, else true below as extra arg
            c.allmodules.addList(sub.getModules(), sub.isExternalSourceLib());
        }

        c.current = comp;
        comp.visitModules(Compiler.handleModuleImports, c);
        if (!c.diags.isOk()) return false;
    }

    return true;
}

// used for main component and source libs (all .c2 files)
fn void Compiler.handleModuleImports(void* arg, ast.Module* m) {
    Compiler* c = arg;
    m.visitImports(Compiler.handleImport, c);
}

fn void Compiler.handleImport(void* arg, ast.ImportDecl* id) {
    Compiler* c = arg;

    if (id.getDest()) return;

    ast.Decl* d = (ast.Decl*)id;
    u32 name_idx = d.getNameIdx();
    ast.Module* m = c.allmodules.find(name_idx);
    if (!m) {
        component.Component* comp = c.findModuleComponent(name_idx);
        if (comp) {
            // check if comp is a direct dependency, otherwise module is a private module
            if (c.current.hasDep(comp.getNameIdx())) {
                c.diags.error(d.getLoc(), "module '%s' is private to component %s", ast.idx2name(name_idx), comp.getName());
            } else {
                c.diags.error(d.getLoc(), "module '%s' is defined in component %s that is not a dependency of component %s", ast.idx2name(name_idx), comp.getName(), c.current.getName());
            }
        } else {
            c.diags.error(d.getLoc(), "unknown module: '%s'", ast.idx2name(name_idx));
        }
        return;
    }

    if (c.current.isExternal() && !m.isLoaded()) {
        //component.Component* co = c.find_component(m);
        if (c.current.hasModule(m)) {
            if (!m.isUsed()) c.parse_queue.add(m);
        } else {
            // otherwise just set used below
        }
    }

    id.setDest(m);
    m.setUsed();
    d.setChecked();
    d.setType(ast.QualType.create((ast.Type*)m.getType()));
}

fn bool Compiler.check_exports(Compiler* c) {
    const string_list.List* exports = c.target.getExports();

    // library targets must have exported symbols, not perse whole modules (plugins only export single symbol)
    if (c.is_image && exports.length()) {
        console.error("images cannot export modules");
        return false;
    }

    for (u32 i = 0; i< exports.length(); i++) {
        const char* name = exports.get(i);  // NOTE: from auxPool!
        u32 name_idx = c.astPool.addStr(name, true);  // put in astPool so we can compare indexes
        ast.Module* m = c.allmodules.find(name_idx);
        if (m) {
            if (m.isExternal()) {
                console.error("cannot export external module %s", name);
                return false;
            }
            m.setExported();
        } else {
            console.error("cannot export %s, no such module", name);
            return false;
        }
    }
    return true;
}

fn void Compiler.analyse_component(Compiler* c, component.Component* comp) {
    // sort modules
    module_sorter.sort(comp, c.diags);

    if (comp.isExternal()) {
        comp.visitModules(Compiler.analyseUsedModule, c);

        if (c.opts.print_lib_ast) comp.print(true);
    } else {
        comp.visitModules(Compiler.analyseModule, c);
    }
}

fn void Compiler.checkMain(Compiler* c) {
    c.mainComp.visitModules(Compiler.findTopModule, c);
    if (c.target.needsMain()) {
        if (!c.mainFunc) {
            if (!c.opts.test_mode) c.diags.error(0, "no 'main' function found");

            return;
        }

        if (!c.mainFunc.isPublic()) {
            c.diags.error(c.mainFunc.getLoc(), "function 'main' should be declared public");
            return;
        }

        ast.FunctionDecl* main = (ast.FunctionDecl*)c.mainFunc;

        if (!main.hasReturn()) {
            c.diags.error(c.mainFunc.getLoc(), "function 'main' should return 'i32'");
            return;
        }

        ast.QualType rtype = main.getRType();
        ast.BuiltinType* bi = rtype.getBuiltin();
        if (!rtype.isBuiltin() || !bi.isInt32()) {
            c.diags.error(c.mainFunc.getLoc(), "function 'main' should return 'i32'");
            return;
        }

    } else {
        if (c.mainFunc) {
            c.diags.error(c.mainFunc.getLoc(), "libraries cannot have a 'main' function");
        }
    }
}

fn void Compiler.checkUnused(void* arg, ast.Module* m) {
    Compiler* c = arg;
    unused_checker.check(c.diags, c.target.getWarnings(), m);
}

