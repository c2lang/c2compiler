// WARNING: this file is auto-generated by the C2 compiler.
// Any changes you make might be lost!

#ifndef EXTERNAL_H
#define EXTERNAL_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wincompatible-library-redeclaration"
#  pragma clang diagnostic ignored "-Wunknown-warning-option"
#  pragma clang diagnostic ignored "-Wparentheses-equality"
#  pragma clang diagnostic ignored "-Wsometimes-uninitialized"
#  pragma clang diagnostic ignored "-Wtypedef-redefinition"
#  pragma clang diagnostic ignored "-Wstring-plus-int"
#  if (__clang_major__ >= 10)
#    define fallthrough  __attribute__((fallthrough))
#  endif
#elif defined(__GNUC__)
#  if (__GNUC__ >= 11)
#    define fallthrough  [[fallthrough]]
#  elif (__GNUC__ >= 7)
#    define fallthrough  __attribute__((fallthrough))
#  endif
#  pragma GCC diagnostic ignored "-Wmain"
#  if (__GNUC__ >= 10)
#    pragma GCC diagnostic ignored "-Wzero-length-bounds"
#  endif
#  if (__GNUC__ >= 7)
#    pragma GCC diagnostic ignored "-Wformat-overflow"
#    pragma GCC diagnostic ignored "-Wstringop-overflow"
#  endif
#endif

#ifndef fallthrough
#  define fallthrough
#endif

// --- internally added ---
typedef unsigned char bool;
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef signed short int16_t;
typedef unsigned short uint16_t;
typedef signed int int32_t;
typedef unsigned int uint32_t;
// FIXME: these should be target dependent
typedef signed long int64_t;
typedef unsigned long uint64_t;
typedef long ssize_t;
typedef unsigned long size_t;
#define true 1
#define false 0

#define NULL ((void*)0)
#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
#define offsetof(type, member) __builtin_offsetof(type, member)
#define to_container(type, member, ptr) ((type*)((char*)(ptr) - offsetof(type, member)))

int dprintf(int fd, const char *format, ...);
void abort(void);
static int c2_assert(const char* filename, int line, const char* funcname, const char* condstr) {
    dprintf(2, "%s:%d: function %s: Assertion failed: %s\n", filename, line, funcname, condstr);
    abort();
    return 0;
}
static int c2_strswitch(const char* s1, const char* s2) {
    if (!s1) return 0;  // nil
    if (!*s1) return 1; // ""
    int idx = 2;
    while (*s2) {
        unsigned len = *s2++ & 0xFF;
        for (unsigned i = 0;; i++) {
            if (i == len) {
                if (s1[i] == '\0')
                    goto done;
                break;
            }
            if (s1[i] != s2[i])
                break;
        }
        s2 += len;
        idx++;
    }
done:
    return idx;
}
#endif

// --- module c2 ---

typedef char c2_c_char;

typedef uint16_t c2_c_ushort;

typedef int32_t c2_c_int;

typedef uint32_t c2_c_uint;

typedef int64_t c2_c_longlong;

typedef uint64_t c2_c_ulonglong;

typedef float c2_c_float;

typedef double c2_c_double;

typedef int64_t c2_c_long;

typedef uint64_t c2_c_ulong;

typedef uint64_t c2_c_size;

typedef int64_t c2_c_ssize;

#define c2_max_i32 2147483647
#define c2_min_i64 (-9223372036854775807l-1)
#define c2_max_u64 18446744073709551615lu


// --- module c_errno ---

extern int* __errno_location(void);

#define ENOENT 2
#define EINTR 4
#define EEXIST 17


// --- module csetjmp ---
typedef struct __jmp_buf_tag_ __jmp_buf_tag;

struct __jmp_buf_tag_ {
   char data[200];
};

typedef __jmp_buf_tag* jmp_buf;

int32_t setjmp(jmp_buf __env);
void longjmp(jmp_buf __env, int32_t __val);


// --- module ctype ---

int32_t isalnum(int32_t c);
int32_t isalpha(int32_t c);
int32_t isdigit(int32_t c);
int32_t islower(int32_t c);
int32_t isprint(int32_t c);
int32_t isspace(int32_t c);
int32_t isupper(int32_t c);
int32_t isxdigit(int32_t c);
int32_t toupper(int32_t c);
int32_t isblank(int32_t c);


// --- module libc_dirent ---
typedef struct DIR_ DIR;
typedef struct dirent_ dirent;

struct DIR_ {
};

typedef int32_t (*FilterFn)(const dirent* _arg0);

typedef int32_t (*DirentCompareFn)(const dirent** _arg0, const dirent** _arg1);

struct dirent_ {
   uint64_t d_ino;
   int64_t d_off;
   uint16_t d_reclen;
   uint8_t d_type;
   char d_name[256];
};

#define DT_DIR 4
#define DT_REG 8
DIR* opendir(const char* name);
int32_t closedir(DIR* dirp);
dirent* readdir(DIR* dirp);


// --- module libc_fcntl ---

#define O_BINARY 0
#define O_RDONLY 0
#define O_WRONLY 01
#define O_CREAT 0100
#define O_TRUNC 01000
#define AT_FDCWD -100
#define F_SETFD 2
#define FD_CLOEXEC 1
int32_t open(const char* __file, int32_t __oflag, ...);
int32_t openat(int32_t dirfd, const char* pathname, int32_t flags, ...);
int32_t fcntl(int32_t __fd, int32_t __cmd, ...);


// --- module stdarg ---
// Note: this module is a special case and is custom generated
#define va_list __builtin_va_list
#define va_start __builtin_va_start
#define va_end __builtin_va_end


// --- module stdio ---
typedef struct _IO_marker_ _IO_marker;
typedef struct FILE_ FILE;

struct _IO_marker_ {
   _IO_marker* next;
   FILE* sbuf;
   int32_t _pos;
};

typedef uint64_t off_t;

struct FILE_ {
};

extern FILE* stdout;

extern FILE* stderr;

int32_t fflush(FILE* __stream);
__attribute__((__format__(printf, 2, 3))) 
int32_t fprintf(FILE* __stream, const char* __format, ...);
__attribute__((__format__(printf, 1, 2))) 
int32_t printf(const char* __format, ...);
__attribute__((__format__(printf, 2, 3))) 
int32_t sprintf(char* __s, const char* __format, ...);
__attribute__((__format__(printf, 3, 4))) 
int32_t snprintf(char* __s, uint64_t size, const char* __format, ...);
int32_t fputs(const char* __s, FILE* __stream);
int32_t puts(const char* __s);
void perror(const char* __s);
int32_t vsprintf(char* str, const char* format, va_list ap);
int32_t vsnprintf(char* str, uint64_t size, const char* format, va_list ap);


// --- module stdlib ---
typedef struct div_t_ div_t;
typedef struct Ldiv_t_ Ldiv_t;
typedef struct random_data_ random_data;
typedef struct drand48_data_ drand48_data;

struct div_t_ {
   int32_t quot;
   int32_t rem;
};

struct Ldiv_t_ {
   int64_t quot;
   int64_t rem;
};

struct random_data_ {
};

struct drand48_data_ {
};

typedef void (*AtExitFn)(void);

typedef void (*OnExitFn)(int32_t _arg0, void* _arg1);

typedef int32_t (*__compar_fn_t)(const void* _arg0, const void* _arg1);

#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0
void* calloc(uint64_t count, uint64_t size);
void* malloc(uint64_t size);
void free(void* ptr);
double atof(const char* nptr);
double strtod(const char* nptr, char** endptr);
void exit(int32_t __status);
void _exit(int32_t __status);
char* getenv(const char* __name);


// --- module string ---

void* memcpy(void* dest, const void* src, uint64_t n);
void* memmove(void* dest, const void* src, uint64_t n);
char* strcpy(char* dest, const char* src);
char* strncpy(char* dest, const char* src, uint64_t n);
char* strdup(const char* s);
char* strcat(char* dest, const char* src);
int32_t memcmp(const void* s1, const void* s2, uint64_t n);
int32_t strcmp(const char* s1, const char* s2);
int32_t strncmp(const char* s1, const char* s2, uint64_t n);
void* memchr(const void* s, int32_t c, uint64_t n);
char* strchr(const char* s, int32_t c);
char* strtok(char* s1, const char* s2);
void* memset(void* s, int32_t c, uint64_t n);
char* strerror(int32_t errnum);
uint64_t strlen(const char* s);
int32_t strcasecmp(const char* s1, const char* s2);


// --- module sys_stat ---

struct stat {
   uint64_t st_dev;
   uint64_t st_ino;
   uint64_t st_nlink;
   uint32_t st_mode;
   uint32_t st_uid;
   uint32_t st_gid;
   uint64_t st_rdev;
   int64_t st_size;
   int64_t st_blksize;
   int64_t st_blocks;
   int64_t st_atime;
   int64_t st_atime_nsec;
   int64_t st_mtime;
   int64_t st_mtime_nsec;
   int64_t st_ctime;
   int64_t st_ctime_nsec;
   int64_t reserved[3];
};

typedef uint32_t Mode;

#define S_IFMT 0170000
#define S_IFREG 0100000
int32_t fstat(int32_t fd, struct stat* buf);
int32_t stat(const char* pathname, struct stat* buf);
int32_t mkdir(const char* __file, uint32_t mode);


// --- module sys_time ---
typedef struct timeval_ timeval;
typedef struct timezone_ timezone;

typedef int64_t time_t;

typedef int64_t suseconds_t;

struct timeval_ {
   time_t tv_sec;
   suseconds_t tv_usec;
};

struct timezone_ {
   int32_t tz_minuteswest;
   int32_t tz_dsttime;
};

int32_t gettimeofday(timeval* tv, timezone* tz);


// --- module sys_utsname ---
typedef struct utsname_ utsname;

#define NAME_LEN 65
struct utsname_ {
   char sysname[65];
   char nodename[65];
   char release[65];
   char version[65];
   char machine[65];
   char domainname[65];
};

int32_t uname(utsname* buf);


// --- module unistd ---

typedef int32_t pid_t;

#define STDOUT_FILENO 1
#define STDERR_FILENO 2
char* getcwd(char* buf, uint64_t size);
int32_t chdir(const char* path);
int32_t fchdir(int32_t fd);
int32_t close(int32_t fd);
int64_t read(int32_t fd, void* buf, uint64_t count);
int32_t isatty(int32_t fd);
int64_t write(int32_t fd, const void* buf, uint64_t count);
int32_t pipe(int32_t* pipefd);
int32_t fsync(int32_t fd);
pid_t fork(void);
pid_t waitpid(pid_t pid, int32_t* wstatus, int32_t options);
int32_t dup2(int32_t oldfd, int32_t newfd);
int32_t execv(const char* pathname, char** argv);


// --- module dlfcn ---

#define RTLD_NOW 0x2
#define RTLD_LOCAL 0
void* dlopen(const char* file, int32_t mode);
int32_t dlclose(void* handle);
void* dlsym(void* handle, const char* name);
char* dlerror(void);


// --- module color ---

static const char color_Black[8] = "\033[0;30m";

static const char color_Red[8] = "\033[0;31m";

static const char color_Green[8] = "\033[0;32m";

static const char color_Yellow[8] = "\033[0;33m";

static const char color_Blue[8] = "\033[0;34m";

static const char color_Magenta[8] = "\033[0;35m";

static const char color_Cyan[8] = "\033[0;36m";

static const char color_Grey[8] = "\033[0;37m";

static const char color_Darkgrey[9] = "\033[01;30m";

static const char color_Bred[9] = "\033[01;31m";

static const char color_Bgreen[9] = "\033[01;32m";

static const char color_Byellow[9] = "\033[01;33m";

static const char color_Bblue[9] = "\033[01;34m";

static const char color_Bmagenta[9] = "\033[01;35m";

static const char color_Bcyan[9] = "\033[01;36m";

static const char color_White[9] = "\033[01;37m";

static const char color_Normal[5] = "\033[0m";

static _Bool color_useColor(void);

static _Bool color_useColor(void)
{
   return isatty(1);
}


// --- module ast_context ---
typedef struct ast_context_Block_ ast_context_Block;
typedef struct ast_context_Context_ ast_context_Context;

struct ast_context_Block_ {
   ast_context_Block* next;
   uint32_t size;
   uint32_t allocated;
   uint8_t data[0];
};

struct ast_context_Context_ {
   ast_context_Block* blk_head;
   ast_context_Block* blk_tail;
   uint32_t blk_size;
   uint32_t num_allocs;
   uint8_t* cur_data;
   uint32_t cur_size;
   uint32_t cur_allocated;
};

static ast_context_Block* ast_context_Block_create(uint32_t blk_size);
static ast_context_Block* ast_context_Block_free(ast_context_Block* b);
static void ast_context_Context_init(ast_context_Context* c, uint32_t blk_size);
static ast_context_Context* ast_context_create(uint32_t blk_size);
static void ast_context_Context_freeBlocks(ast_context_Context* c);
static void ast_context_Context_free(ast_context_Context* c);
static void* ast_context_Context_alloc(ast_context_Context* c, uint32_t len);
static void ast_context_Context_report(const ast_context_Context* c);

static ast_context_Block* ast_context_Block_create(uint32_t blk_size)
{
   ast_context_Block* b = malloc((16 + blk_size));
   b->next = NULL;
   b->size = 0;
   b->allocated = blk_size;
   return b;
}

static ast_context_Block* ast_context_Block_free(ast_context_Block* b)
{
   ast_context_Block* next = b->next;
   free(b);
   return next;
}

static void ast_context_Context_init(ast_context_Context* c, uint32_t blk_size)
{
   c->blk_head = NULL;
   c->blk_tail = NULL;
   c->blk_size = (blk_size >= 1024) ? (blk_size - 16) : blk_size;
   c->num_allocs = 0;
   c->cur_data = NULL;
   c->cur_size = 0;
   c->cur_allocated = 0;
}

static ast_context_Context* ast_context_create(uint32_t blk_size)
{
   ast_context_Context* c = malloc(40);
   ast_context_Context_init(c, blk_size);
   return c;
}

static void ast_context_Context_freeBlocks(ast_context_Context* c)
{
   ast_context_Block* blk = c->blk_head;
   while (blk) blk = ast_context_Block_free(blk);
   c->blk_head = c->blk_tail = NULL;
}

static void ast_context_Context_free(ast_context_Context* c)
{
   ast_context_Context_freeBlocks(c);
   free(c);
}

static void* ast_context_Context_alloc(ast_context_Context* c, uint32_t len)
{
   len = (((len + 7)) & ~0x7);
   c->num_allocs++;
   if (((c->cur_size + len) > c->cur_allocated)) {
      if (!c->blk_size) c->blk_size = (16384 - 16);
      ast_context_Block* newb = ast_context_Block_create((len > c->blk_size) ? len : c->blk_size);
      ast_context_Block* last = c->blk_tail;
      if (last) {
         last->size = c->cur_size;
         last->next = newb;
      } else {
         c->blk_head = newb;
      }
      c->blk_tail = newb;
      c->cur_size = 0;
      c->cur_allocated = newb->allocated;
      c->cur_data = newb->data;
   }
   void* cur = (c->cur_data + c->cur_size);
   c->cur_size += len;
   return cur;
}

static void ast_context_Context_report(const ast_context_Context* c)
{
   uint32_t blocks = 0;
   uint32_t total = 0;
   uint32_t slack = 0;
   uint32_t avail = 0;
   if (c->blk_tail) c->blk_tail->size = c->cur_size;
   for (const ast_context_Block* blk = c->blk_head; blk; blk = blk->next) {
      blocks++;
      total += blk->size;
      slack += avail;
      avail = (blk->allocated - blk->size);
   }
   uint32_t avg = 0;
   if (c->num_allocs) avg = (total / c->num_allocs);
   printf("context: %u allocs, total %u (%u KB), avg %u bytes, %u blocks (%u), slack %u, avail %u\n", c->num_allocs, total, (((total + 1023)) / 1024), avg, blocks, c->blk_size, slack, avail);
}


// --- module number_radix ---

typedef enum {
   number_radix_Radix_Default,
   number_radix_Radix_Hex,
   number_radix_Radix_Octal,
   number_radix_Radix_Binary,
   _number_radix_Radix_max = 255
} __attribute__((packed)) number_radix_Radix;



// --- module src_loc ---
typedef struct src_loc_SrcRange_ src_loc_SrcRange;

typedef uint32_t src_loc_SrcLoc;

struct src_loc_SrcRange_ {
   src_loc_SrcLoc start;
   src_loc_SrcLoc end;
};



// --- module string_buffer ---
typedef struct string_buffer_Buf_ string_buffer_Buf;

struct string_buffer_Buf_ {
   uint32_t capacity;
   uint32_t size_;
   char* data_;
   uint32_t indent_step;
   _Bool colors;
   _Bool own;
};

static const uint8_t string_buffer_ToHex[16] = {
   '0',
   '1',
   '2',
   '3',
   '4',
   '5',
   '6',
   '7',
   '8',
   '9',
   'A',
   'B',
   'C',
   'D',
   'E',
   'F'
};

static string_buffer_Buf* string_buffer_create(uint32_t capacity, _Bool colors, uint32_t indent_step);
static string_buffer_Buf* string_buffer_create_static(uint32_t capacity, _Bool colors, char* data);
static void string_buffer_Buf_free(string_buffer_Buf* buf);
static uint32_t string_buffer_Buf_size(const string_buffer_Buf* buf);
static const char* string_buffer_Buf_data(const string_buffer_Buf* buf);
static const uint8_t* string_buffer_Buf_udata(const string_buffer_Buf* buf);
static void string_buffer_Buf_clear(string_buffer_Buf* buf);
static void string_buffer_Buf_color(string_buffer_Buf* buf, const char* color);
static void string_buffer_Buf_add1(string_buffer_Buf* buf, char c);
static void string_buffer_Buf_add(string_buffer_Buf* buf, const char* text);
static void string_buffer_Buf_add2(string_buffer_Buf* buf, const char* text, uint32_t len);
static void string_buffer_Buf_newline(string_buffer_Buf* buf);
static void string_buffer_Buf_space(string_buffer_Buf* buf);
static void string_buffer_Buf_lparen(string_buffer_Buf* buf);
static void string_buffer_Buf_rparen(string_buffer_Buf* buf);
__attribute__((__format__(printf, 2, 3))) 
static void string_buffer_Buf_print(string_buffer_Buf* buf, const char* format, ...);
static void string_buffer_Buf_vprintf(string_buffer_Buf* buf, const char* format, va_list args);
static void string_buffer_Buf_indent(string_buffer_Buf* buf, uint32_t indent);
static _Bool string_buffer_Buf_endsWith(const string_buffer_Buf* buf, char c);
static void string_buffer_Buf_resize(string_buffer_Buf* buf, uint32_t capacity);
static uint32_t string_buffer_Buf_encodeBytes(string_buffer_Buf* buf, const char* p, uint32_t len, char sep);
static void string_buffer_Buf_encodeHex(string_buffer_Buf* buf, const uint8_t* data, uint32_t len);
static void string_buffer_Buf_resetToLastNewline(string_buffer_Buf* buf);

static string_buffer_Buf* string_buffer_create(uint32_t capacity, _Bool colors, uint32_t indent_step)
{
   string_buffer_Buf* buf = malloc(24);
   buf->capacity = capacity;
   buf->size_ = 0;
   buf->data_ = malloc(capacity);
   buf->indent_step = indent_step;
   buf->colors = colors;
   buf->own = true;
   buf->data_[0] = 0;
   return buf;
}

static string_buffer_Buf* string_buffer_create_static(uint32_t capacity, _Bool colors, char* data)
{
   string_buffer_Buf* buf = malloc(24);
   buf->capacity = capacity;
   buf->size_ = 0;
   buf->data_ = data;
   buf->indent_step = 0;
   buf->colors = colors;
   buf->own = false;
   buf->data_[0] = 0;
   return buf;
}

static void string_buffer_Buf_free(string_buffer_Buf* buf)
{
   if (buf->own) free(buf->data_);
   free(buf);
}

static uint32_t string_buffer_Buf_size(const string_buffer_Buf* buf)
{
   return buf->size_;
}

static const char* string_buffer_Buf_data(const string_buffer_Buf* buf)
{
   return buf->data_;
}

static const uint8_t* string_buffer_Buf_udata(const string_buffer_Buf* buf)
{
   return ((uint8_t*)(buf->data_));
}

static void string_buffer_Buf_clear(string_buffer_Buf* buf)
{
   buf->size_ = 0;
}

static void string_buffer_Buf_color(string_buffer_Buf* buf, const char* color)
{
   if (buf->colors) string_buffer_Buf_add(buf, color);
}

static void string_buffer_Buf_add1(string_buffer_Buf* buf, char c)
{
   if (((buf->size_ + 2) > buf->capacity)) {
      uint32_t new_cap = (buf->capacity * 2);
      while (((buf->size_ + 2) > new_cap)) new_cap *= 2;
      string_buffer_Buf_resize(buf, new_cap);
   }
   buf->data_[buf->size_] = c;
   buf->size_ += 1;
   buf->data_[buf->size_] = '\0';
}

static void string_buffer_Buf_add(string_buffer_Buf* buf, const char* text)
{
   uint32_t len = ((uint32_t)(strlen(text)));
   string_buffer_Buf_add2(buf, text, len);
}

static void string_buffer_Buf_add2(string_buffer_Buf* buf, const char* text, uint32_t len)
{
   if ((((buf->size_ + len) + 1) > buf->capacity)) {
      uint32_t new_cap = (buf->capacity * 2);
      while ((((buf->size_ + len) + 1) > new_cap)) new_cap *= 2;
      string_buffer_Buf_resize(buf, new_cap);
   }
   memcpy(&buf->data_[buf->size_], text, len);
   buf->size_ += len;
   buf->data_[buf->size_] = '\0';
}

static void string_buffer_Buf_newline(string_buffer_Buf* buf)
{
   if (((buf->size_ + 2) > buf->capacity)) {
      uint32_t new_cap = (buf->capacity * 2);
      while (((buf->size_ + 2) > new_cap)) new_cap *= 2;
      string_buffer_Buf_resize(buf, new_cap);
   }
   buf->data_[buf->size_] = '\n';
   buf->size_ += 1;
   buf->data_[buf->size_] = 0;
}

static void string_buffer_Buf_space(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, ' ');
}

static void string_buffer_Buf_lparen(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, '(');
}

static void string_buffer_Buf_rparen(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, ')');
}

__attribute__((__format__(printf, 2, 3))) 
static void string_buffer_Buf_print(string_buffer_Buf* buf, const char* format, ...)
{
   char tmp[4096];
   va_list args;
   va_start(args, format);
   int32_t len = vsnprintf(tmp, 4096, format, args);
   ((len < 4096)) || c2_assert("ast_utils/string_buffer.c2", 135, "string_buffer.Buf.print", "len < sizeof(tmp)");
   string_buffer_Buf_add2(buf, tmp, ((uint32_t)(len)));
   va_end(args);
}

static void string_buffer_Buf_vprintf(string_buffer_Buf* buf, const char* format, va_list args)
{
   char tmp[4096];
   int32_t len = vsnprintf(tmp, 4096, format, args);
   ((len < 4096)) || c2_assert("ast_utils/string_buffer.c2", 144, "string_buffer.Buf.vprintf", "len < sizeof(tmp)");
   string_buffer_Buf_add2(buf, tmp, ((uint32_t)(len)));
}

static void string_buffer_Buf_indent(string_buffer_Buf* buf, uint32_t indent)
{
   if ((indent == 0)) return;

   indent *= buf->indent_step;
   if ((((buf->size_ + indent) + 1) > buf->capacity)) {
      string_buffer_Buf_resize(buf, (buf->capacity * 2));
   }
   char* cur = (buf->data_ + buf->size_);
   for (uint32_t i = 0; (i < indent); i++) cur[i] = ' ';
   cur[indent] = 0;
   buf->size_ += indent;
}

static _Bool string_buffer_Buf_endsWith(const string_buffer_Buf* buf, char c)
{
   if ((buf->size_ && (buf->data_[(buf->size_ - 1)] == c))) return true;

   return false;
}

static void string_buffer_Buf_resize(string_buffer_Buf* buf, uint32_t capacity)
{
   (buf->own) || c2_assert("ast_utils/string_buffer.c2", 168, "string_buffer.Buf.resize", "buf.own");
   buf->capacity = capacity;
   char* data2 = malloc(buf->capacity);
   memcpy(data2, buf->data_, buf->size_);
   free(buf->data_);
   buf->data_ = data2;
}

static uint32_t string_buffer_Buf_encodeBytes(string_buffer_Buf* buf, const char* p, uint32_t len, char sep)
{
   uint32_t size = buf->size_;
   uint32_t copy = 0;
   const char* end = (p + len);
   while ((p < end)) {
      uint8_t c = *p++;
      switch (c) {
      case '\a':
         c = 'a';
         goto add_char;
      case '\b':
         c = 'b';
         goto add_char;
      case '\f':
         c = 'f';
         goto add_char;
      case '\n':
         c = 'n';
         goto add_char;
      case '\r':
         c = 'r';
         goto add_char;
      case '\t':
         c = 't';
         goto add_char;
      case '\v':
         c = 'v';
         goto add_char;
      case '"':
         fallthrough;
      case '\'':
         if ((sep && (sep != c))) goto normal;

         fallthrough;
      case '\\':
         add_char:
         if (copy) string_buffer_Buf_add2(buf, ((p - copy) - 1), copy);
         string_buffer_Buf_add1(buf, '\\');
         string_buffer_Buf_add1(buf, c);
         copy = 0;
         break;
      default:
         if (((c < ' ') || (c >= 0x7f))) {
            char arr[4];
            if (copy) string_buffer_Buf_add2(buf, ((p - copy) - 1), copy);
            arr[0] = '\\';
            arr[1] = ('0' + ((((c >> 6)) & 7)));
            arr[2] = ('0' + ((((c >> 3)) & 7)));
            arr[3] = ('0' + ((c & 7)));
            uint32_t esc_len = 4;
            if (((c == 0) && (((p == end) || !(((*p >= '0') && (*p <= '9'))))))) esc_len = 2;
            string_buffer_Buf_add2(buf, arr, esc_len);
            copy = 0;
            break;
         }
         normal:
         copy++;
         break;
      }
   }
   if (copy) string_buffer_Buf_add2(buf, (p - copy), copy);
   return (buf->size_ - size);
}

static void string_buffer_Buf_encodeHex(string_buffer_Buf* buf, const uint8_t* data, uint32_t len)
{
   if ((len == 0)) return;

   if (((buf->size_ + (len * 3)) >= buf->capacity)) {
      uint32_t new_cap = (buf->capacity * 2);
      while (((buf->size_ + (len * 3)) >= new_cap)) new_cap *= 2;
      string_buffer_Buf_resize(buf, new_cap);
   }
   char* cp = &buf->data_[buf->size_];
   for (uint32_t i = 0; (i < len); i++) {
      if ((i != 0)) *cp++ = ' ';
      uint8_t v = data[i];
      *cp++ = string_buffer_ToHex[(v >> 4)];
      *cp++ = string_buffer_ToHex[(v & 0xf)];
   }
   *cp = 0;
   buf->size_ += ((len * 3) - 1);
}

static void string_buffer_Buf_resetToLastNewline(string_buffer_Buf* buf)
{
   while (buf->size_) {
      buf->size_--;
      if ((buf->data_[buf->size_] == '\n')) {
         buf->data_[buf->size_] = 0;
         return;
      }
   }
}


// --- module string_pool ---
typedef struct string_pool_Pool_ string_pool_Pool;

typedef uint32_t string_pool_HashEntry;

struct string_pool_Pool_ {
   uint32_t data_size;
   uint32_t data_capacity;
   char* data;
   uint32_t num_adds;
   uint32_t total_size;
   uint32_t hash_count;
   uint32_t hash_mask;
   uint32_t entry_size;
   uint32_t entry_capacity;
   string_pool_HashEntry* entries;
};

#define string_pool_NEXT_SHIFT 17
#define string_pool_INDEX_BITS (((1 << string_pool_NEXT_SHIFT)) - 1)
#define string_pool_INDEX_SHIFT 2
#define string_pool_DATA_ALIGN (1 << string_pool_INDEX_SHIFT)
#define string_pool_HASH_INITIAL 13
#define string_pool_HASH_PRIME 17
static string_pool_Pool* string_pool_create(uint32_t data_capacity, uint32_t hash_size);
static void string_pool_Pool_free(string_pool_Pool* p);
static uint32_t string_pool_hash(const char* text, size_t len);
static const char* string_pool_Pool_idx2str(const string_pool_Pool* p, uint32_t idx);
static _Bool string_pool_same_string(const char* left, const char* right, size_t rlen);
static uint32_t string_pool_Pool_add(string_pool_Pool* p, const char* text, size_t len, _Bool filter);
static uint32_t string_pool_Pool_addStr(string_pool_Pool* p, const char* text, _Bool filter);
static void string_pool_Pool_resize_data(string_pool_Pool* p, uint32_t capacity);
static void string_pool_Pool_resize_entries(string_pool_Pool* p, uint32_t capacity);
static void string_pool_Pool_report(const string_pool_Pool* p);

static string_pool_Pool* string_pool_create(uint32_t data_capacity, uint32_t hash_size)
{
   string_pool_Pool* p = calloc(1, 48);
   string_pool_Pool_resize_data(p, data_capacity);
   p->data[0] = 0;
   p->data_size = string_pool_DATA_ALIGN;
   if ((hash_size & ((hash_size - 1)))) {
      hash_size |= (hash_size >> 16);
      hash_size |= (hash_size >> 8);
      hash_size |= (hash_size >> 4);
      hash_size |= (hash_size >> 2);
      hash_size |= (hash_size >> 1);
      hash_size += 1;
   }
   if ((hash_size < 256)) hash_size = 256;
   p->hash_mask = (hash_size - 1);
   p->entry_size = hash_size;
   p->entry_capacity = (hash_size * 2);
   p->entries = calloc(p->entry_capacity, 4);
   return p;
}

static void string_pool_Pool_free(string_pool_Pool* p)
{
   free(p->entries);
   free(p->data);
   free(p);
}

static uint32_t string_pool_hash(const char* text, size_t len)
{
   uint32_t result = string_pool_HASH_INITIAL;
   for (uint32_t i = 0; (i < len); i++) {
      result = (result ^ text[i]);
      result *= string_pool_HASH_PRIME;
   }
   return result;
}

static const char* string_pool_Pool_idx2str(const string_pool_Pool* p, uint32_t idx)
{
   return (p->data + idx);
}

static _Bool string_pool_same_string(const char* left, const char* right, size_t rlen)
{
   for (uint32_t i = 0; (i < rlen); i++) {
      if ((left[i] != right[i])) return false;

   }
   return ((left[rlen] == '\0'));
}

static uint32_t string_pool_Pool_add(string_pool_Pool* p, const char* text, size_t len, _Bool filter)
{
   p->num_adds++;
   p->total_size += (len + 1);
   if (filter) {
      size_t i = (string_pool_hash(text, len) & p->hash_mask);
      string_pool_HashEntry v = p->entries[i];
      if ((v != 0)) {
         string_pool_HashEntry next;
         for (;;) {
            uint32_t index = (((v & string_pool_INDEX_BITS)) << string_pool_INDEX_SHIFT);
            const char* word = (p->data + index);
            if (string_pool_same_string(word, text, len)) return index;

            next = (v >> string_pool_NEXT_SHIFT);
            if ((next == 0)) break;

            i = next;
            v = p->entries[i];
         }
         next = p->entry_size;
         if ((next == p->entry_capacity)) {
            string_pool_Pool_resize_entries(p, (p->entry_capacity * 2));
         }
         p->entries[i] = (v | ((next << string_pool_NEXT_SHIFT)));
         p->entry_size++;
         i = next;
      }
      p->entries[i] = ((p->data_size >> string_pool_INDEX_SHIFT));
      p->hash_count++;
   }
   while ((((p->data_size + len) + 1) > p->data_capacity)) {
      if (((text >= p->data) && (text < (p->data + p->data_size)))) {
         ssize_t offset = (text - p->data);
         string_pool_Pool_resize_data(p, (p->data_capacity * 2));
         text = (p->data + offset);
      } else {
         string_pool_Pool_resize_data(p, (p->data_capacity * 2));
      }
   }
   uint32_t idx = p->data_size;
   char* dest = (p->data + idx);
   memcpy(dest, text, len);
   dest[len] = 0;
   p->data_size += (((len / string_pool_DATA_ALIGN) * string_pool_DATA_ALIGN) + string_pool_DATA_ALIGN);
   return idx;
}

static uint32_t string_pool_Pool_addStr(string_pool_Pool* p, const char* text, _Bool filter)
{
   return string_pool_Pool_add(p, text, strlen(text), filter);
}

static void string_pool_Pool_resize_data(string_pool_Pool* p, uint32_t capacity)
{
   p->data_capacity = capacity;
   char* data2 = malloc(capacity);
   if (p->data_size) {
      memcpy(data2, p->data, p->data_size);
      free(p->data);
   }
   p->data = data2;
}

static void string_pool_Pool_resize_entries(string_pool_Pool* p, uint32_t capacity)
{
   string_pool_HashEntry* entries = malloc((capacity * 4));
   if (p->entries) {
      memcpy(entries, p->entries, (p->entry_size * 4));
      free(p->entries);
   }
   p->entry_capacity = capacity;
   p->entries = entries;
}

static void string_pool_Pool_report(const string_pool_Pool* p)
{
   uint32_t max = 0;
   uint32_t min = 999;
   uint32_t hash_size = (p->hash_mask + 1);
   uint32_t count = 0;
   uint32_t cc[256] = { };
   for (uint32_t i = 0; (i < hash_size); i++) {
      string_pool_HashEntry v = p->entries[i];
      if ((v != 0)) {
         uint32_t num = 1;
         while ((v >> string_pool_NEXT_SHIFT)) {
            num++;
            v = p->entries[(v >> string_pool_NEXT_SHIFT)];
         }
         count += num;
         if ((num < 256)) cc[num]++;
         if (num) {
            if ((num > max)) max = num;
            if ((num < min)) min = num;
         }
      }
   }
   printf("pool: count %u, adds %u, data %u/%u\n", p->hash_count, p->num_adds, p->data_size, p->data_capacity);
   printf("  hash: entries: %u/%u/%u/%u, min %u, max %u, avg %.2f, memory %u\n", hash_size, count, p->entry_size, p->entry_capacity, min, max, count ? (((count + 0.0)) / ((hash_size - cc[0]))) : 0.0, (p->entry_capacity * 4));
   printf("  buckets: %u", cc[0]);
   for (uint32_t i = 1; (i <= max); i++) printf(", %u", cc[i]);
   printf("\n");
}


// --- module yaml ---
typedef struct yaml_Node_ yaml_Node;
typedef struct yaml_StackLevel_ yaml_StackLevel;
typedef struct yaml_Data_ yaml_Data;
typedef struct yaml_Iter_ yaml_Iter;
typedef struct yaml_Location_ yaml_Location;
typedef struct yaml_Token_ yaml_Token;
typedef struct yaml_Tokenizer_ yaml_Tokenizer;
typedef struct yaml_Parser_ yaml_Parser;

typedef enum {
   yaml_NodeKind_Unknown,
   yaml_NodeKind_Scalar,
   yaml_NodeKind_Map,
   yaml_NodeKind_Sequence,
   _yaml_NodeKind_max = 255
} __attribute__((packed)) yaml_NodeKind;

struct yaml_Node_ {
   yaml_NodeKind kind;
   uint32_t next_idx;
   uint32_t name_idx;
   union {
      uint32_t text_idx;
      uint32_t child_idx;
   };
};

struct yaml_StackLevel_ {
   int32_t indent;
   yaml_Node* node;
   yaml_Node* last_child;
};

struct yaml_Data_ {
   char* text;
   uint32_t text_size;
   char* text_cur;
   yaml_Node* nodes;
   uint32_t nodes_count;
   yaml_Node* nodes_cur;
   yaml_StackLevel* stack;
};

#define yaml_MaxDepth 8
static const char* yaml_node_names[4] = { "UNK", "SCA", "MAP", "SEQ" };

static void yaml_Data_init(yaml_Data* d, uint32_t text_size, uint32_t nodes_count, yaml_StackLevel* stack);
static void yaml_Data_destroy(yaml_Data* d);
static void yaml_Data_resize_nodes(yaml_Data* d);
static void yaml_Data_resize_text(yaml_Data* d);
static yaml_Node* yaml_Data_add_node(yaml_Data* d, yaml_NodeKind kind, uint32_t name_idx);
static inline 
uint32_t yaml_Data_node2idx(const yaml_Data* d, const yaml_Node* n);
static uint32_t yaml_Data_add_text(yaml_Data* d, const char* text, uint32_t len);
static yaml_Node* yaml_Data_idx2node(const yaml_Data* d, uint32_t idx);
static void yaml_Parser_dump(const yaml_Parser* p, _Bool verbose);
static void yaml_Data_dump(const yaml_Data* d, _Bool verbose);
static void yaml_Data_dump_node(const yaml_Data* d, const yaml_Node* n, int32_t indent);
struct yaml_Iter_ {
   const void* data;
   const yaml_Node* node;
};

static _Bool yaml_Node_isMap(const yaml_Node* n);
static _Bool yaml_Node_isSequence(const yaml_Node* n);
static _Bool yaml_Node_isScalar(const yaml_Node* n);
static const yaml_Node* yaml_Parser_getRoot(const yaml_Parser* p);
static const char* yaml_Parser_getScalarValue(const yaml_Parser* p, const char* path);
static const yaml_Node* yaml_Parser_findNode(const yaml_Parser* p, const char* path);
static const yaml_Node* yaml_Data_findNode(const yaml_Data* d, const char* path);
static const yaml_Node* yaml_Data_findChildNode(const yaml_Data* d, const char* path, uint32_t next);
static yaml_Iter yaml_Parser_getNodeChildIter(const yaml_Parser* p, const yaml_Node* n);
static void yaml_Iter_next(yaml_Iter* iter);
static _Bool yaml_Iter_done(const yaml_Iter* iter);
static const char* yaml_Iter_getName(const yaml_Iter* iter);
static const char* yaml_Iter_getValue(const yaml_Iter* iter);
static yaml_Iter yaml_Iter_getChildIter(yaml_Iter* parent);
static const char* yaml_Iter_getChildScalarValue(yaml_Iter* iter, const char* path);
static const char* yaml_starts_with(const char* full, const char* start);
struct yaml_Location_ {
   uint32_t line;
   uint32_t column;
};

typedef enum {
   yaml_TokenKind_None,
   yaml_TokenKind_Plain_Scalar,
   yaml_TokenKind_Single_Quoted_Scalar,
   yaml_TokenKind_Double_Quoted_Scalar,
   yaml_TokenKind_Colon,
   yaml_TokenKind_Dash,
   yaml_TokenKind_Indent,
   yaml_TokenKind_Dedent,
   yaml_TokenKind_Doc_Start,
   yaml_TokenKind_Doc_End,
   yaml_TokenKind_Directive,
   yaml_TokenKind_Eof,
   yaml_TokenKind_Error,
   _yaml_TokenKind_max = 255
} __attribute__((packed)) yaml_TokenKind;

struct yaml_Token_ {
   yaml_Location loc;
   yaml_TokenKind kind;
   _Bool same_line;
   union {
      const char* error_msg;
      uint32_t text_idx;
      int32_t indent;
   };
};

struct yaml_Tokenizer_ {
   const char* cur;
   yaml_Location loc;
   const char* input_start;
   char* error_msg;
   int32_t cur_indent;
   _Bool same_line;
   yaml_Data* data;
   yaml_Token next;
};

static const char* yaml_token_names[13] = {
   "none",
   "scalar",
   "'scalar'",
   "\"scalar\"",
   ":",
   "-",
   "indent",
   "dedent",
   "---",
   "...",
   "%",
   "eof",
   "error"
};

static const char* yaml_Location_str(const yaml_Location* loc);
static const char* yaml_Token_str(const yaml_Token* tok);
static void yaml_Tokenizer_init(yaml_Tokenizer* t, const char* input, yaml_Data* d, char* error_msg);
static void yaml_Tokenizer_lex(yaml_Tokenizer* t, yaml_Token* result);
static yaml_Token* yaml_Tokenizer_lex_next(yaml_Tokenizer* t);
static _Bool yaml_Tokenizer_lex_indent(yaml_Tokenizer* t, yaml_Token* result);
static void yaml_Tokenizer_lex_comment(yaml_Tokenizer* t);
static void yaml_Tokenizer_lex_directive(yaml_Tokenizer* t, yaml_Token* result);
static void yaml_Tokenizer_lex_quoted_string(yaml_Tokenizer* t, yaml_Token* result, char delim);
static _Bool yaml_is_string(char c);
static void yaml_Tokenizer_lex_string(yaml_Tokenizer* t, yaml_Token* result);
static void yaml_Tokenizer_error(yaml_Tokenizer* t, yaml_Token* result);
#define yaml_MaxDiag 256
struct yaml_Parser_ {
   yaml_Token token;
   yaml_Tokenizer tokenizer;
   int32_t cur_indent;
   _Bool doc_started;
   _Bool in_document;
   yaml_StackLevel stack[8];
   uint32_t stack_size;
   yaml_Data data;
   __jmp_buf_tag jmp_err;
   char message[256];
};

static yaml_Parser* yaml_Parser_create(void);
static void yaml_Parser_destroy(yaml_Parser* p);
static _Bool yaml_Parser_parse(yaml_Parser* p, const char* input);
static const char* yaml_Parser_getMessage(const yaml_Parser* p);
__attribute__((__format__(printf, 2, 3))) 
static void yaml_Parser_error(yaml_Parser* p, const char* format, ...);
static void yaml_Parser_consumeToken(yaml_Parser* p);
static void yaml_Parser_expectAndConsume(yaml_Parser* p, yaml_TokenKind kind);
static void yaml_Parser_parse_doc(yaml_Parser* p);
static void yaml_Parser_parse_node(yaml_Parser* p);
static void yaml_Parser_parse_value(yaml_Parser* p);
static void yaml_Parser_parse_node_or_value(yaml_Parser* p);
static void yaml_Parser_doc_start(yaml_Parser* p);
static void yaml_Parser_doc_end(yaml_Parser* p);
static void yaml_Parser_add_scalar_value(yaml_Parser* p, uint32_t value_idx);
static void yaml_Parser_pop(yaml_Parser* p);
static void yaml_Parser_push_root(yaml_Parser* p);
static void yaml_Parser_push_node(yaml_Parser* p, yaml_Node* n, yaml_NodeKind parent_kind, int32_t indent);

static void yaml_Data_init(yaml_Data* d, uint32_t text_size, uint32_t nodes_count, yaml_StackLevel* stack)
{
   d->text = malloc(text_size);
   d->text_size = text_size;
   d->text_cur = (d->text + 1);
   d->text[0] = 0;
   d->nodes = malloc((nodes_count * 16));
   d->nodes_count = nodes_count;
   d->nodes_cur = &d->nodes[1];
   memset(&d->nodes[0], 0, 16);
   d->stack = stack;
}

static void yaml_Data_destroy(yaml_Data* d)
{
   free(d->text);
   free(d->nodes);
}

static void yaml_Data_resize_nodes(yaml_Data* d)
{
   uint32_t idx = ((uint32_t)((d->nodes_cur - d->nodes)));
   d->nodes_count *= 2;
   yaml_Node* nodes2 = malloc((d->nodes_count * 16));
   memcpy(nodes2, d->nodes, (idx * 16));
   for (uint32_t i = 0; (i < yaml_MaxDepth); i++) {
      yaml_StackLevel* sl = &d->stack[i];
      if (sl->node) {
         uint32_t node_idx = ((uint32_t)((sl->node - d->nodes)));
         sl->node = &nodes2[node_idx];
      }
      if (sl->last_child) {
         uint32_t last_child_idx = ((uint32_t)((sl->last_child - d->nodes)));
         sl->last_child = &nodes2[last_child_idx];
      }
   }
   free(d->nodes);
   d->nodes = nodes2;
   d->nodes_cur = &d->nodes[idx];
}

static void yaml_Data_resize_text(yaml_Data* d)
{
   uint32_t idx = ((uint32_t)((d->text_cur - d->text)));
   d->text_size *= 2;
   char* text2 = malloc(d->text_size);
   memcpy(text2, d->text, (idx + 1));
   free(d->text);
   d->text = text2;
   d->text_cur = &d->text[idx];
}

static yaml_Node* yaml_Data_add_node(yaml_Data* d, yaml_NodeKind kind, uint32_t name_idx)
{
   uint32_t idx = ((uint32_t)((d->nodes_cur - d->nodes)));
   if ((idx >= (d->nodes_count - 1))) yaml_Data_resize_nodes(d);
   yaml_Node* result = d->nodes_cur;
   d->nodes_cur++;
   result->kind = kind;
   result->next_idx = 0;
   result->name_idx = name_idx;
   result->child_idx = 0;
   return result;
}

static inline 
uint32_t yaml_Data_node2idx(const yaml_Data* d, const yaml_Node* n)
{
   return ((uint32_t)((n - d->nodes)));
}

static uint32_t yaml_Data_add_text(yaml_Data* d, const char* text, uint32_t len)
{
   uint32_t idx = ((uint32_t)((d->text_cur - d->text)));
   while ((((idx + len) + 1) >= d->text_size)) yaml_Data_resize_text(d);
   memcpy(d->text_cur, text, len);
   d->text_cur[len] = 0;
   d->text_cur += (len + 1);
   return idx;
}

static yaml_Node* yaml_Data_idx2node(const yaml_Data* d, uint32_t idx)
{
   return &d->nodes[idx];
}

static void yaml_Parser_dump(const yaml_Parser* p, _Bool verbose)
{
   yaml_Data_dump(&p->data, verbose);
}

static void yaml_Data_dump(const yaml_Data* d, _Bool verbose)
{
   uint32_t node_count = ((uint32_t)((d->nodes_cur - d->nodes)));
   if (verbose) {
      printf("Text %u/%u\n", ((uint32_t)((d->text_cur - d->text))), d->text_size);
      const char* cp = (d->text + 1);
      while ((cp < d->text_cur)) {
         uint32_t len = ((uint32_t)(strlen(cp)));
         uint32_t offset = ((uint32_t)((cp - d->text)));
         printf("  [%3u] %s\n", offset, cp);
         cp += (len + 1);
      }
      printf("Nodes %u/%u\n", node_count, d->nodes_count);
      for (uint32_t i = 1; (i < node_count); i++) {
         const yaml_Node* n = &d->nodes[i];
         printf("  [%2u] %s  next %3u  name %3u  value/child %3u\n", i, yaml_node_names[n->kind], n->next_idx, n->name_idx, n->text_idx);
      }
   }
   if ((node_count > 1)) yaml_Data_dump_node(d, &d->nodes[1], 0);
}

static void yaml_Data_dump_node(const yaml_Data* d, const yaml_Node* n, int32_t indent)
{
   for (int32_t i = 0; (i < indent); i++) printf("   ");
   printf("[%2u] %s", yaml_Data_node2idx(d, n), yaml_node_names[n->kind]);
   printf("  name: ");
   if (n->name_idx) printf("%s", &d->text[n->name_idx]);
   else printf("-");
   printf("  value: ");
   switch (n->kind) {
   case yaml_NodeKind_Unknown:
      printf("-\n");
      break;
   case yaml_NodeKind_Scalar:
      if (n->text_idx) printf("%s", &d->text[n->text_idx]);
      printf("\n");
      break;
   case yaml_NodeKind_Map:
      fallthrough;
   case yaml_NodeKind_Sequence:
      printf("-\n");
      if (n->child_idx) yaml_Data_dump_node(d, yaml_Data_idx2node(d, n->child_idx), (indent + 1));
      break;
   }
   if (n->next_idx) {
      yaml_Data_dump_node(d, yaml_Data_idx2node(d, n->next_idx), indent);
   }
}

static _Bool yaml_Node_isMap(const yaml_Node* n)
{
   return (n->kind == yaml_NodeKind_Map);
}

static _Bool yaml_Node_isSequence(const yaml_Node* n)
{
   return (n->kind == yaml_NodeKind_Sequence);
}

static _Bool yaml_Node_isScalar(const yaml_Node* n)
{
   return (n->kind == yaml_NodeKind_Scalar);
}

static const yaml_Node* yaml_Parser_getRoot(const yaml_Parser* p)
{
   uint32_t node_count = (((uint32_t)((p->data.nodes_cur - p->data.nodes))) - 1);
   if ((node_count == 0)) return NULL;

   return &p->data.nodes[1];
}

static const char* yaml_Parser_getScalarValue(const yaml_Parser* p, const char* path)
{
   const yaml_Node* n = yaml_Parser_findNode(p, path);
   if ((n && yaml_Node_isScalar(n))) return &p->data.text[n->text_idx];

   return NULL;
}

static const yaml_Node* yaml_Parser_findNode(const yaml_Parser* p, const char* path)
{
   return yaml_Data_findNode(&p->data, path);
}

static const yaml_Node* yaml_Data_findNode(const yaml_Data* d, const char* path)
{
   uint32_t node_count = (((uint32_t)((d->nodes_cur - d->nodes))) - 1);
   if ((node_count == 0)) return NULL;

   const yaml_Node* root = &d->nodes[1];
   if ((root->kind == yaml_NodeKind_Sequence)) return NULL;

   return yaml_Data_findChildNode(d, path, root->child_idx);
}

static const yaml_Node* yaml_Data_findChildNode(const yaml_Data* d, const char* path, uint32_t next)
{
   while (next) {
      const yaml_Node* node = yaml_Data_idx2node(d, next);
      if (node->name_idx) {
         const char* name = &d->text[node->name_idx];
         const char* rest = yaml_starts_with(path, name);
         if (rest) {
            path = rest;
            if ((path[0] == 0)) return node;

            if ((node->kind == yaml_NodeKind_Sequence)) return NULL;

            next = node->child_idx;
            continue;
         }
      }
      next = node->next_idx;
   }
   return NULL;
}

static yaml_Iter yaml_Parser_getNodeChildIter(const yaml_Parser* p, const yaml_Node* n)
{
   yaml_Iter iter = { .data = &p->data, .node = NULL };
   if (((n && (n->kind != yaml_NodeKind_Scalar)) && n->child_idx)) {
      iter.node = yaml_Data_idx2node(&p->data, n->child_idx);
   }
   return iter;
}

static void yaml_Iter_next(yaml_Iter* iter)
{
   const yaml_Data* d = ((yaml_Data*)(iter->data));
   if (iter->node) {
      if (iter->node->next_idx) iter->node = yaml_Data_idx2node(d, iter->node->next_idx);
      else iter->node = NULL;
   }
}

static _Bool yaml_Iter_done(const yaml_Iter* iter)
{
   return (iter->node == NULL);
}

static const char* yaml_Iter_getName(const yaml_Iter* iter)
{
   const yaml_Data* d = ((yaml_Data*)(iter->data));
   if (iter->node) return &d->text[iter->node->name_idx];

   return NULL;
}

static const char* yaml_Iter_getValue(const yaml_Iter* iter)
{
   const yaml_Data* d = ((yaml_Data*)(iter->data));
   if ((iter->node && (iter->node->kind == yaml_NodeKind_Scalar))) return &d->text[iter->node->text_idx];

   return NULL;
}

static yaml_Iter yaml_Iter_getChildIter(yaml_Iter* parent)
{
   yaml_Iter iter = { .data = parent->data, .node = NULL };
   if ((parent->node == NULL)) return iter;

   const yaml_Node* n = parent->node;
   if (((n->kind != yaml_NodeKind_Scalar) && n->child_idx)) {
      const yaml_Data* d = ((yaml_Data*)(iter.data));
      iter.node = yaml_Data_idx2node(d, n->child_idx);
   }
   return iter;
}

static const char* yaml_Iter_getChildScalarValue(yaml_Iter* iter, const char* path)
{
   if (!iter->node) return NULL;

   if ((iter->node->kind == yaml_NodeKind_Sequence)) return NULL;

   const yaml_Data* d = ((yaml_Data*)(iter->data));
   const yaml_Node* n = yaml_Data_findChildNode(d, path, iter->node->child_idx);
   if ((n && yaml_Node_isScalar(n))) return &d->text[n->text_idx];

   return NULL;
}

static const char* yaml_starts_with(const char* full, const char* start)
{
   uint32_t len = ((uint32_t)(strlen(start)));
   if ((strncmp(full, start, len) == 0)) {
      full += len;
      if ((full[0] == '.')) return (full + 1);

      if ((full[0] == 0)) return full;

   }
   return NULL;
}

static const char* yaml_Location_str(const yaml_Location* loc)
{
   static char msg[32];
   sprintf(msg, "at line %u:%u", loc->line, loc->column);
   return msg;
}

static const char* yaml_Token_str(const yaml_Token* tok)
{
   return yaml_token_names[tok->kind];
}

static void yaml_Tokenizer_init(yaml_Tokenizer* t, const char* input, yaml_Data* d, char* error_msg)
{
   memset(t, 0, 72);
   t->cur = input;
   t->input_start = input;
   t->loc.line = 1;
   t->loc.column = 1;
   t->error_msg = error_msg;
   t->data = d;
   t->next.kind = yaml_TokenKind_None;
}

static void yaml_Tokenizer_lex(yaml_Tokenizer* t, yaml_Token* result)
{
   if ((t->next.kind != yaml_TokenKind_None)) {
      memcpy(result, &t->next, 24);
      t->next.kind = yaml_TokenKind_None;
      return;
   }
   result->same_line = t->same_line;
   t->same_line = true;
   result->text_idx = 0;
   while (1) {
      if ((((((t->loc.column == 1) && t->cur_indent) && (*t->cur != ' ')) && (*t->cur != '\r')) && (*t->cur != '\n'))) {
         result->loc = t->loc;
         result->kind = yaml_TokenKind_Dedent;
         result->indent = 0;
         t->cur_indent = 0;
         t->same_line = false;
         return;
      }
      switch (*t->cur) {
      case 0:
         result->loc = t->loc;
         result->kind = yaml_TokenKind_Eof;
         return;
      case '\t':
         sprintf(t->error_msg, "file contains TAB characters %s", yaml_Location_str(&t->loc));
         yaml_Tokenizer_error(t, result);
         return;
      case '\r':
         t->cur++;
         if ((*t->cur != '\n')) {
            sprintf(t->error_msg, "unexpected char 0x%02X %s", *t->cur, yaml_Location_str(&t->loc));
            yaml_Tokenizer_error(t, result);
            return;
         }
         fallthrough;
      case '\n':
         t->cur++;
         t->loc.line++;
         t->loc.column = 1;
         t->same_line = true;
         result->same_line = false;
         break;
      case ' ':
         if ((t->loc.column == 1)) {
            if (yaml_Tokenizer_lex_indent(t, result)) return;

            break;
         }
         t->cur++;
         t->loc.column++;
         break;
      case '"':
         yaml_Tokenizer_lex_quoted_string(t, result, '"');
         return;
      case '#':
         yaml_Tokenizer_lex_comment(t);
         break;
      case '%':
         yaml_Tokenizer_lex_directive(t, result);
         return;
      case '\'':
         yaml_Tokenizer_lex_quoted_string(t, result, '\'');
         return;
      case '-':
         if ((((t->cur[1] == ' ') || (t->cur[1] == '\r')) || (t->cur[1] == '\n'))) {
            t->cur++;
            result->loc = t->loc;
            result->kind = yaml_TokenKind_Dash;
            t->loc.column++;
            return;
         }
         if ((((t->loc.column == 1) && (t->cur[1] == '-')) && (t->cur[2] == '-'))) {
            t->cur += 3;
            result->loc = t->loc;
            result->kind = yaml_TokenKind_Doc_Start;
            t->loc.column += 3;
            return;
         }
         yaml_Tokenizer_lex_string(t, result);
         return;
      case '.':
         if ((((t->loc.column == 1) && (t->cur[1] == '.')) && (t->cur[2] == '.'))) {
            result->loc = t->loc;
            result->kind = yaml_TokenKind_Doc_End;
            t->cur += 3;
            t->loc.column += 3;
            return;
         }
         yaml_Tokenizer_lex_string(t, result);
         return;
      case ':':
         t->cur++;
         result->loc = t->loc;
         result->kind = yaml_TokenKind_Colon;
         t->loc.column++;
         return;
      default:
         if (yaml_is_string(*t->cur)) {
            yaml_Tokenizer_lex_string(t, result);
            return;
         }
         sprintf(t->error_msg, "unhandled char 0x%02x (%c) %s", *t->cur, isprint(*t->cur) ? *t->cur : ' ', yaml_Location_str(&t->loc));
         yaml_Tokenizer_error(t, result);
         return;
      }
   }
}

static yaml_Token* yaml_Tokenizer_lex_next(yaml_Tokenizer* t)
{
   if ((t->next.kind == yaml_TokenKind_None)) yaml_Tokenizer_lex(t, &t->next);
   return &t->next;
}

static _Bool yaml_Tokenizer_lex_indent(yaml_Tokenizer* t, yaml_Token* result)
{
   const char* start = t->cur;
   while ((*t->cur == ' ')) t->cur++;
   int32_t indent = ((int32_t)((t->cur - start)));
   result->loc = t->loc;
   t->loc.column += indent;
   if ((t->cur_indent == indent)) return false;

   if ((t->cur_indent > indent)) result->kind = yaml_TokenKind_Dedent;
   else result->kind = yaml_TokenKind_Indent;
   result->indent = indent;
   t->cur_indent = indent;
   return true;
}

static void yaml_Tokenizer_lex_comment(yaml_Tokenizer* t)
{
   const char* start = t->cur;
   t->cur++;
   while (1) {
      switch (*t->cur) {
      case 0:
         fallthrough;
      case '\r':
         fallthrough;
      case '\n':
         t->loc.column += ((t->cur - start));
         return;
      default:
         t->cur++;
         break;
      }
   }
}

static void yaml_Tokenizer_lex_directive(yaml_Tokenizer* t, yaml_Token* result)
{
   t->cur++;
   const char* start = t->cur;
   uint32_t count;
   while (1) {
      switch (*t->cur) {
      case 0:
         fallthrough;
      case '\r':
         fallthrough;
      case '\n':
         goto out;
      default:
         t->cur++;
         break;
      }
   }
   out:
   count = ((uint32_t)((t->cur - start)));
   t->error_msg[count] = 0;
   result->loc = t->loc;
   result->kind = yaml_TokenKind_Directive;
   result->text_idx = yaml_Data_add_text(t->data, start, count);
   t->loc.column += (count + 1);
}

static void yaml_Tokenizer_lex_quoted_string(yaml_Tokenizer* t, yaml_Token* result, char delim)
{
   t->cur++;
   const char* start = t->cur;
   uint32_t count;
   while (1) {
      switch (*t->cur) {
      case 0:
         fallthrough;
      case '\r':
         fallthrough;
      case '\n':
         t->loc.column += ((t->cur - start));
         sprintf(t->error_msg, "unterminated string %s", yaml_Location_str(&t->loc));
         yaml_Tokenizer_error(t, result);
         return;
      default:
         if ((*t->cur == delim)) goto out;

         t->cur++;
         break;
      }
   }
   out:
   count = ((uint32_t)((t->cur - start)));
   t->cur++;
   result->loc = t->loc;
   result->kind = ((delim == '"')) ? yaml_TokenKind_Double_Quoted_Scalar : yaml_TokenKind_Single_Quoted_Scalar;
   result->text_idx = yaml_Data_add_text(t->data, start, count);
   t->loc.column += (count + 2);
}

static _Bool yaml_is_string(char c)
{
   if (((((((isalpha(c) || isdigit(c)) || (c == '_')) || (c == '-')) || (c == '.')) || (c == '/')) || (c == '~'))) {
      return true;
   }
   return false;
}

static void yaml_Tokenizer_lex_string(yaml_Tokenizer* t, yaml_Token* result)
{
   const char* start = t->cur;
   t->cur++;
   while (1) {
      char c = *t->cur;
      if (yaml_is_string(c)) {
         t->cur++;
         continue;
      }
      if (((c == ' ') && yaml_is_string(t->cur[1]))) {
         t->cur += 2;
         continue;
      }
      break;
   }
   uint32_t count = ((uint32_t)((t->cur - start)));
   result->loc = t->loc;
   result->kind = yaml_TokenKind_Plain_Scalar;
   result->text_idx = yaml_Data_add_text(t->data, start, count);
   t->loc.column += count;
}

static void yaml_Tokenizer_error(yaml_Tokenizer* t, yaml_Token* result)
{
   result->loc = t->loc;
   result->kind = yaml_TokenKind_Error;
   result->error_msg = t->error_msg;
}

static yaml_Parser* yaml_Parser_create(void)
{
   yaml_Parser* p = calloc(1, 816);
   yaml_Data_init(&p->data, 1024, 32, p->stack);
   return p;
}

static void yaml_Parser_destroy(yaml_Parser* p)
{
   yaml_Data_destroy(&p->data);
   free(p);
}

static _Bool yaml_Parser_parse(yaml_Parser* p, const char* input)
{
   yaml_Tokenizer_init(&p->tokenizer, input, &p->data, p->message);
   p->token.kind = yaml_TokenKind_None;
   int32_t res = setjmp(&p->jmp_err);
   if ((res == 0)) {
      yaml_Parser_consumeToken(p);
      while ((p->token.kind != yaml_TokenKind_Eof)) yaml_Parser_parse_doc(p);
   } else {
      return false;
   }
   return true;
}

static const char* yaml_Parser_getMessage(const yaml_Parser* p)
{
   return p->message;
}

__attribute__((__format__(printf, 2, 3))) 
static void yaml_Parser_error(yaml_Parser* p, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   char* cp = p->message;
   cp += vsnprintf(cp, (yaml_MaxDiag - 1), format, args);
   va_end(args);
   sprintf(cp, " %s", yaml_Location_str(&p->token.loc));
   longjmp(&p->jmp_err, 1);
}

static void yaml_Parser_consumeToken(yaml_Parser* p)
{
   yaml_Tokenizer_lex(&p->tokenizer, &p->token);
   if ((p->token.kind == yaml_TokenKind_Error)) longjmp(&p->jmp_err, 1);
}

static void yaml_Parser_expectAndConsume(yaml_Parser* p, yaml_TokenKind kind)
{
   if ((p->token.kind != kind)) {
      yaml_Parser_error(p, "expected '%s', got '%s'", yaml_token_names[kind], yaml_Token_str(&p->token));
   }
   yaml_Parser_consumeToken(p);
}

static void yaml_Parser_parse_doc(yaml_Parser* p)
{
   while (1) {
      switch (p->token.kind) {
      case yaml_TokenKind_Doc_Start:
         yaml_Parser_consumeToken(p);
         if (p->doc_started) yaml_Parser_doc_end(p);
         yaml_Parser_doc_start(p);
         break;
      case yaml_TokenKind_Doc_End:
         if ((!p->doc_started || !p->in_document)) {
            yaml_Parser_error(p, "END document without start");
         }
         yaml_Parser_consumeToken(p);
         yaml_Parser_doc_end(p);
         return;
      case yaml_TokenKind_Directive:
         yaml_Parser_consumeToken(p);
         break;
      case yaml_TokenKind_Eof:
         return;
      default:
         if (!p->doc_started) yaml_Parser_doc_start(p);
         yaml_Parser_parse_node(p);
         break;
      }
   }
}

static void yaml_Parser_parse_node(yaml_Parser* p)
{
   switch (p->token.kind) {
   case yaml_TokenKind_Plain_Scalar:
      fallthrough;
   case yaml_TokenKind_Single_Quoted_Scalar:
      fallthrough;
   case yaml_TokenKind_Double_Quoted_Scalar: {
      yaml_Node* n = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, p->token.text_idx);
      yaml_Parser_push_node(p, n, yaml_NodeKind_Unknown, p->cur_indent);
      yaml_Parser_consumeToken(p);
      yaml_Parser_expectAndConsume(p, yaml_TokenKind_Colon);
      yaml_Parser_parse_value(p);
      break;
   }
   case yaml_TokenKind_Dash: {
      yaml_Parser_consumeToken(p);
      yaml_Node* n = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, 0);
      yaml_Parser_push_node(p, n, yaml_NodeKind_Sequence, (p->cur_indent + 1));
      yaml_Parser_parse_node_or_value(p);
      break;
   }
   case yaml_TokenKind_Indent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      break;
   case yaml_TokenKind_Dedent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      yaml_Parser_pop(p);
      break;
   case yaml_TokenKind_Doc_Start:
      fallthrough;
   case yaml_TokenKind_Doc_End:
      break;
   default:
      yaml_Parser_error(p, "%s() unhandled token '%s'", "parse_node", yaml_Token_str(&p->token));
      break;
   }
}

static void yaml_Parser_parse_value(yaml_Parser* p)
{
   switch (p->token.kind) {
   case yaml_TokenKind_Plain_Scalar:
      fallthrough;
   case yaml_TokenKind_Single_Quoted_Scalar:
      fallthrough;
   case yaml_TokenKind_Double_Quoted_Scalar:
      if (p->token.same_line) {
         yaml_Parser_add_scalar_value(p, p->token.text_idx);
         yaml_Parser_consumeToken(p);
      } else {
         (0) || c2_assert("common/yaml/yaml_parser.c2", 173, "yaml.Parser.parse_value", "0");
      }
      return;
   case yaml_TokenKind_Dash: {
      yaml_Parser_consumeToken(p);
      yaml_Node* n = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, 0);
      yaml_Parser_push_node(p, n, yaml_NodeKind_Sequence, (p->cur_indent + 1));
      yaml_Parser_parse_node_or_value(p);
      return;
   }
   case yaml_TokenKind_Indent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      yaml_Parser_parse_node(p);
      return;
   case yaml_TokenKind_Dedent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      yaml_Parser_pop(p);
      return;
   case yaml_TokenKind_Doc_Start:
      fallthrough;
   case yaml_TokenKind_Doc_End:
      return;
   case yaml_TokenKind_Eof:
      yaml_Parser_add_scalar_value(p, 0);
      return;
   default:
      yaml_Parser_error(p, "%s() unhandled token '%s'", "parse_value", yaml_Token_str(&p->token));
      break;
   }
}

static void yaml_Parser_parse_node_or_value(yaml_Parser* p)
{
   switch (p->token.kind) {
   case yaml_TokenKind_Plain_Scalar:
      fallthrough;
   case yaml_TokenKind_Single_Quoted_Scalar:
      fallthrough;
   case yaml_TokenKind_Double_Quoted_Scalar: {
      yaml_Token* next = yaml_Tokenizer_lex_next(&p->tokenizer);
      if ((next->kind == yaml_TokenKind_Colon)) {
         p->cur_indent += 2;
         p->tokenizer.cur_indent += 2;
         yaml_Parser_parse_node(p);
         return;
      }
      break;
   }
   default:
      break;
   }
   yaml_Parser_parse_value(p);
}

static void yaml_Parser_doc_start(yaml_Parser* p)
{
   yaml_Parser_push_root(p);
   p->doc_started = true;
   p->in_document = true;
}

static void yaml_Parser_doc_end(yaml_Parser* p)
{
   p->cur_indent = -1;
   if (((p->stack_size == 1) && (p->stack[0].node->kind == yaml_NodeKind_Unknown))) {
      p->stack[0].node->kind = yaml_NodeKind_Map;
   }
   yaml_Parser_pop(p);
   p->cur_indent = 0;
   p->in_document = false;
}

static void yaml_Parser_add_scalar_value(yaml_Parser* p, uint32_t value_idx)
{
   yaml_StackLevel* top = &p->stack[(p->stack_size - 1)];
   yaml_Node* n = top->node;
   if ((n->kind != yaml_NodeKind_Unknown)) {
      yaml_Parser_error(p, "%s() cannot add scalar to node", "add_scalar_value");
   }
   n->kind = yaml_NodeKind_Scalar;
   n->text_idx = value_idx;
}

static void yaml_Parser_pop(yaml_Parser* p)
{
   int32_t indent = p->cur_indent;
   while (1) {
      yaml_StackLevel* top = &p->stack[(p->stack_size - 1)];
      if ((top->indent <= indent)) break;

      if ((p->stack_size >= 1)) {
         yaml_StackLevel* prev = &p->stack[(p->stack_size - 2)];
         prev->last_child = top->node;
      }
      if ((top->node->kind == yaml_NodeKind_Unknown)) top->node->kind = yaml_NodeKind_Scalar;
      top->indent = 0;
      top->node = NULL;
      top->last_child = NULL;
      p->stack_size--;
   }
}

static void yaml_Parser_push_root(yaml_Parser* p)
{
   yaml_Node* root = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, 0);
   yaml_StackLevel* top = &p->stack[0];
   if (p->stack_size) {
      top->node->next_idx = yaml_Data_node2idx(&p->data, root);
   }
   top->node = root;
   top->indent = -1;
   top->last_child = NULL;
   p->stack_size = 1;
}

static void yaml_Parser_push_node(yaml_Parser* p, yaml_Node* n, yaml_NodeKind parent_kind, int32_t indent)
{
   (p->stack_size) || c2_assert("common/yaml/yaml_parser.c2", 285, "yaml.Parser.push_node", "p.stack_size");
   uint32_t n_idx = yaml_Data_node2idx(&p->data, n);
   yaml_StackLevel* top = &p->stack[(p->stack_size - 1)];
   if ((indent < top->indent)) {
      (((indent + 1) == top->indent)) || c2_assert("common/yaml/yaml_parser.c2", 290, "yaml.Parser.push_node", "indent + 1 == top.indent");
      yaml_Parser_pop(p);
      top = &p->stack[(p->stack_size - 1)];
   }
   if ((top->indent == indent)) {
      if (top->node) {
         if ((top->node->kind == yaml_NodeKind_Unknown)) top->node->kind = yaml_NodeKind_Scalar;
         top->node->next_idx = n_idx;
      }
      top->last_child = NULL;
   } else {
      (((p->stack_size + 1) < yaml_MaxDepth)) || c2_assert("common/yaml/yaml_parser.c2", 303, "yaml.Parser.push_node", "p.stack_size + 1 < MaxDepth");
      ((indent > top->indent)) || c2_assert("common/yaml/yaml_parser.c2", 304, "yaml.Parser.push_node", "indent > top.indent");
      yaml_Node* parent = top->node;
      if ((parent->kind == yaml_NodeKind_Unknown)) {
         if ((parent_kind == yaml_NodeKind_Unknown)) parent_kind = yaml_NodeKind_Map;
         parent->kind = parent_kind;
      }
      if (top->last_child) {
         top->last_child->next_idx = n_idx;
      } else {
         ((parent->child_idx == 0)) || c2_assert("common/yaml/yaml_parser.c2", 315, "yaml.Parser.push_node", "parent.child_idx == 0");
         parent->child_idx = n_idx;
      }
      top->last_child = n;
      p->stack_size++;
      top = &p->stack[(p->stack_size - 1)];
   }
   top->indent = indent;
   top->node = n;
   yaml_StackLevel* prev = &p->stack[(p->stack_size - 2)];
   yaml_Node* parent = prev->node;
   if (((parent->kind != parent_kind) && !(((parent->kind == yaml_NodeKind_Map) && (parent_kind == yaml_NodeKind_Unknown))))) {
      if ((parent->kind == yaml_NodeKind_Sequence)) {
         yaml_Parser_error(p, "invalid scalar after sequence");
      } else {
         yaml_Parser_error(p, "invalid scalar after %s", yaml_node_names[parent->kind]);
      }
   }
}


// --- module console ---

static _Bool console_use_color = false;

static _Bool console_show_debug = false;

static _Bool console_show_timing = false;

#define console_BUF_SIZE 4096
static void console_init(void);
static void console_setDebug(_Bool enable);
static void console_setTiming(_Bool enable);
__attribute__((__format__(printf, 1, 2))) 
static void console_debug(const char* format, ...);
__attribute__((__format__(printf, 1, 2))) 
static void console_log(const char* format, ...);
__attribute__((__format__(printf, 1, 2))) 
static void console_warn(const char* format, ...);
__attribute__((__format__(printf, 1, 2))) 
static void console_error(const char* format, ...);
__attribute__((__format__(printf, 2, 3))) 
static void console_error_diag(const char* loc, const char* format, ...);
static void console_log_time(const char* item, uint64_t duration);

static void console_init(void)
{
   console_use_color = color_useColor();
}

static void console_setDebug(_Bool enable)
{
   console_show_debug = enable;
}

static void console_setTiming(_Bool enable)
{
   console_show_timing = enable;
}

__attribute__((__format__(printf, 1, 2))) 
static void console_debug(const char* format, ...)
{
   if (!console_show_debug) return;

   char buf[4096];
   va_list args;
   va_start(args, format);
   vsnprintf(buf, 4096, format, args);
   va_end(args);
   if (console_use_color) {
      printf("%s%s%s\n", color_Blue, buf, color_Normal);
   } else {
      printf("%s\n", buf);
   }
}

__attribute__((__format__(printf, 1, 2))) 
static void console_log(const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsnprintf(buf, 4096, format, args);
   va_end(args);
   printf("%s\n", buf);
}

__attribute__((__format__(printf, 1, 2))) 
static void console_warn(const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsnprintf(buf, 4096, format, args);
   va_end(args);
   if (console_use_color) {
      fprintf(stderr, "%swarning: %s%s\n", color_Yellow, buf, color_Normal);
   } else {
      fprintf(stderr, "warning: %s\n", buf);
   }
}

__attribute__((__format__(printf, 1, 2))) 
static void console_error(const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsprintf(buf, format, args);
   va_end(args);
   if (console_use_color) {
      fprintf(stderr, "%serror: %s%s\n", color_Red, buf, color_Normal);
   } else {
      fprintf(stderr, "error: %s\n", buf);
   }
}

__attribute__((__format__(printf, 2, 3))) 
static void console_error_diag(const char* loc, const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsprintf(buf, format, args);
   va_end(args);
   if (console_use_color) {
      fprintf(stderr, "%s%s: error: %s%s\n", color_Red, loc, buf, color_Normal);
   } else {
      fprintf(stderr, "%s: error: %s\n", loc, buf);
   }
}

static void console_log_time(const char* item, uint64_t duration)
{
   if (!console_show_timing) return;

   if (console_use_color) {
      printf("%s%s took %lu usec%s\n", color_Blue, item, duration, color_Normal);
   } else {
      printf("%s took %lu usec\n", item, duration);
   }
}


// --- module constants ---

#define constants_MaxCallArgs 24
#define constants_MaxScopes 32
#define constants_MaxIdentifierLen 31
#define constants_MaxFeatureDepth 6
#define constants_MaxErrorMsgLen 31
#define constants_MaxMultiString (64 * 1024)
#define constants_Max_path 512
#define constants_Max_open_files 200
static const char* constants_output_dir = "output";

static const char* constants_recipe_name = "recipe.txt";

static const char* constants_buildfile_name = "build.yaml";

static const char* constants_manifest_name = "manifest.yaml";

static const char* constants_refs_filename = "refs";



// --- module file_utils ---
typedef struct file_utils_Reader_ file_utils_Reader;
typedef struct file_utils_Writer_ file_utils_Writer;

struct file_utils_Reader_ {
   uint8_t* region;
   uint32_t size;
   int32_t error;
};

static uint8_t file_utils_empty = 0;

#define file_utils_Err_not_a_file 2001
#define file_utils_Err_read_error 2002
static _Bool file_utils_Reader_open(file_utils_Reader* file, const char* filename);
static void file_utils_Reader_close(file_utils_Reader* file);
static _Bool file_utils_Reader_isOpen(const file_utils_Reader* file);
static const uint8_t* file_utils_Reader_udata(file_utils_Reader* file);
static const char* file_utils_Reader_data(file_utils_Reader* file);
static _Bool file_utils_Reader_isEmpty(const file_utils_Reader* file);
static const char* file_utils_Reader_getError(const file_utils_Reader* file);
struct file_utils_Writer_ {
   int32_t error;
};

#define file_utils_Err_write_error 2003
static _Bool file_utils_Writer_write(file_utils_Writer* writer, const char* filename, const void* data, uint32_t len);
static const char* file_utils_Writer_getError(const file_utils_Writer* file);
static int32_t file_utils_create_directory(const char* path);
static _Bool file_utils_exists(const char* filename);

static _Bool file_utils_Reader_open(file_utils_Reader* file, const char* filename)
{
   file->region = NULL;
   file->size = 0;
   file->error = 0;
   int32_t fd = open(filename, (O_RDONLY | O_BINARY));
   if ((fd == -1)) {
      file->error = (*__errno_location());
      return false;
   }
   struct stat statbuf;
   if (fstat(fd, &statbuf)) {
      file->error = (*__errno_location());
      close(fd);
      return false;
   }
   if (((statbuf.st_mode & S_IFMT) != S_IFREG)) {
      file->error = file_utils_Err_not_a_file;
      close(fd);
      return false;
   }
   uint32_t size = ((uint32_t)(statbuf.st_size));
   uint8_t* region;
   if ((size == 0)) {
      region = &file_utils_empty;
   } else {
      region = malloc((size + 1));
      int64_t numread = read(fd, region, size);
      if ((numread < 0)) {
         file->error = (*__errno_location());
         free(region);
         close(fd);
         return false;
      }
      if ((numread != size)) {
         file->error = file_utils_Err_read_error;
         free(region);
         close(fd);
         return false;
      }
      region[size] = '\0';
   }
   file->region = region;
   file->size = size;
   close(fd);
   return true;
}

static void file_utils_Reader_close(file_utils_Reader* file)
{
   if (file->size) {
      free(file->region);
      file->region = NULL;
      file->size = 0;
   }
}

static _Bool file_utils_Reader_isOpen(const file_utils_Reader* file)
{
   return (file->region != NULL);
}

static const uint8_t* file_utils_Reader_udata(file_utils_Reader* file)
{
   return file->region;
}

static const char* file_utils_Reader_data(file_utils_Reader* file)
{
   return ((const char*)(file->region));
}

static _Bool file_utils_Reader_isEmpty(const file_utils_Reader* file)
{
   return (file->size == 0);
}

static const char* file_utils_Reader_getError(const file_utils_Reader* file)
{
   const char* msg;
   switch (file->error) {
   case file_utils_Err_not_a_file:
      msg = "not a regular file";
      break;
   case file_utils_Err_read_error:
      msg = "read error";
      break;
   default:
      msg = strerror(file->error);
      break;
   }
   return msg;
}

static _Bool file_utils_Writer_write(file_utils_Writer* writer, const char* filename, const void* data, uint32_t len)
{
   writer->error = 0;
   int32_t fd = open(filename, (((O_CREAT | O_WRONLY) | O_TRUNC) | O_BINARY), 0660);
   if ((fd == -1)) {
      writer->error = (*__errno_location());
      return false;
   }
   int64_t written = write(fd, data, len);
   if ((written < 0)) {
      writer->error = (*__errno_location());
      close(fd);
      return false;
   }
   if ((written != len)) {
      writer->error = file_utils_Err_write_error;
      close(fd);
      return false;
   }
   close(fd);
   return true;
}

static const char* file_utils_Writer_getError(const file_utils_Writer* file)
{
   const char* msg;
   switch (file->error) {
   case file_utils_Err_write_error:
      msg = "write error";
      break;
   default:
      msg = strerror(file->error);
      break;
   }
   return msg;
}

static int32_t file_utils_create_directory(const char* path)
{
   int32_t fd = openat(AT_FDCWD, ".", O_RDONLY);
   if ((fd == -1)) return (*__errno_location());

   char tmp[256];
   const char* cp = path;
   int32_t errno_ = 0;
   if ((*cp == '/')) {
      cp++;
      if (chdir("/")) errno_ = (*__errno_location());
   }
   while ((!errno_ && *cp)) {
      const char* slash = strchr(cp, '/');
      if (slash) {
         size_t len = ((size_t)((slash - cp)));
         ((len < 256)) || c2_assert("common/file/file_utils.c2", 40, "file_utils.create_directory", "len < elemsof(tmp)");
         memcpy(tmp, cp, len);
         tmp[len] = '\0';
         cp = (slash + 1);
         if (!len) continue;

         if ((((mkdir(tmp, 0777) && ((*__errno_location()) != EEXIST))) || chdir(tmp))) {
            errno_ = (*__errno_location());
            break;
         }
      } else {
         if ((mkdir(cp, 0777) && ((*__errno_location()) != EEXIST))) errno_ = (*__errno_location());
         break;
      }
   }
   fchdir(fd);
   close(fd);
   return errno_;
}

static _Bool file_utils_exists(const char* filename)
{
   struct stat statbuf;
   return ((stat(filename, &statbuf) == 0));
}


// --- module library_list ---
typedef struct library_list_Lib_ library_list_Lib;
typedef struct library_list_List_ library_list_List;

struct library_list_Lib_ {
   uint32_t name;
   _Bool is_static;
};

struct library_list_List_ {
   library_list_Lib* libs;
   uint32_t count;
   uint32_t capacity;
};

typedef void (*library_list_Visitor)(void* arg, uint32_t name, _Bool is_static);

static void library_list_List_init(library_list_List* l);
static void library_list_List_free(library_list_List* l);
static void library_list_List_visit(const library_list_List* l, library_list_Visitor visitor, void* arg);
static void library_list_List_add(library_list_List* l, uint32_t name, _Bool is_static);
static _Bool library_list_List_contains(const library_list_List* l, uint32_t name);
static void library_list_List_resize(library_list_List* l, uint32_t cap);

static void library_list_List_init(library_list_List* l)
{
   memset(l, 0, 16);
   library_list_List_resize(l, 2);
}

static void library_list_List_free(library_list_List* l)
{
   free(l->libs);
}

static void library_list_List_visit(const library_list_List* l, library_list_Visitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      const library_list_Lib* lib = &l->libs[i];
      visitor(arg, lib->name, lib->is_static);
   }
}

static void library_list_List_add(library_list_List* l, uint32_t name, _Bool is_static)
{
   if ((l->count == l->capacity)) library_list_List_resize(l, (l->capacity * 2));
   l->libs[l->count].name = name;
   l->libs[l->count].is_static = is_static;
   l->count++;
}

static _Bool library_list_List_contains(const library_list_List* l, uint32_t name)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      if ((l->libs[i].name == name)) return true;

   }
   return false;
}

static void library_list_List_resize(library_list_List* l, uint32_t cap)
{
   l->capacity = cap;
   library_list_Lib* libs2 = malloc((l->capacity * 8));
   if (l->libs) {
      memcpy(libs2, l->libs, (l->count * 8));
      free(l->libs);
   }
   l->libs = libs2;
}


// --- module linked_list ---
typedef struct linked_list_Element_ linked_list_Element;

struct linked_list_Element_ {
   linked_list_Element* prev;
   linked_list_Element* next;
};

static void linked_list_Element_init(linked_list_Element* src);
static void linked_list_Element_addTail(linked_list_Element* src, linked_list_Element* item);
static void linked_list_Element_addFront(linked_list_Element* src, linked_list_Element* item);
static linked_list_Element* linked_list_Element_popFront(linked_list_Element* item);
static void linked_list_Element_remove(linked_list_Element* item);
static uint64_t linked_list_Element_size(const linked_list_Element* src);
static _Bool linked_list_Element_isEmpty(const linked_list_Element* src);
static void linked_list_Element_move(linked_list_Element* src, linked_list_Element* dest);

static void linked_list_Element_init(linked_list_Element* src)
{
   src->prev = src;
   src->next = src;
}

static void linked_list_Element_addTail(linked_list_Element* src, linked_list_Element* item)
{
   linked_list_Element* old_tail = src->prev;
   src->prev = item;
   item->next = src;
   item->prev = old_tail;
   old_tail->next = item;
}

static void linked_list_Element_addFront(linked_list_Element* src, linked_list_Element* item)
{
   linked_list_Element* old_head = src->next;
   old_head->prev = item;
   item->next = old_head;
   item->prev = src;
   src->next = item;
}

static linked_list_Element* linked_list_Element_popFront(linked_list_Element* item)
{
   linked_list_Element* node = item->next;
   linked_list_Element_remove(node);
   return node;
}

static void linked_list_Element_remove(linked_list_Element* item)
{
   linked_list_Element* prev = item->prev;
   linked_list_Element* next = item->next;
   prev->next = next;
   next->prev = prev;
}

static uint64_t linked_list_Element_size(const linked_list_Element* src)
{
   uint64_t count = 0;
   linked_list_Element* node = src->next;
   while ((node != src)) {
      count++;
      node = node->next;
   }
   return count;
}

static _Bool linked_list_Element_isEmpty(const linked_list_Element* src)
{
   return (src->next == src);
}

static void linked_list_Element_move(linked_list_Element* src, linked_list_Element* dest)
{
   linked_list_Element* node = src->next;
   while ((node != src)) {
      linked_list_Element* tmp = node;
      node = node->next;
      linked_list_Element_remove(tmp);
      linked_list_Element_addTail(dest, tmp);
   }
}


// --- module process_utils ---

#define process_utils_MAX_ARG_LEN 512
#define process_utils_MAX_ARGS 16
static _Bool process_utils_doWIFSIGNALED(int32_t state);
static _Bool process_utils_doWIFEXITED(int32_t state);
static char process_utils_getWEXITSTATUS(int32_t state);
__attribute__((__format__(printf, 2, 3))) 
static void process_utils_child_error(int32_t fd, const char* format, ...);
static int32_t process_utils_run_args(const char* path, const char* cmd, const char* args, const char* logfile);
static uint32_t process_utils_parseArgs(const char* args, char** argv, uint32_t maxargs, char* tmp, size_t tmp_size);
static const char* process_utils_find_bin(char* dest, size_t size, const char* name);
static int32_t process_utils_run2(const char* path, const char* cmd, const char* args, char* output, size_t output_size);

static _Bool process_utils_doWIFSIGNALED(int32_t state)
{
   return (((((state & 0x7f)) > 0) && (((state & 0x7f)) < 0x7f)));
}

static _Bool process_utils_doWIFEXITED(int32_t state)
{
   return ((((state & 0xff)) == 0));
}

static char process_utils_getWEXITSTATUS(int32_t state)
{
   return ((char)((((state >> 8)) & 0xff)));
}

__attribute__((__format__(printf, 2, 3))) 
static void process_utils_child_error(int32_t fd, const char* format, ...)
{
   char msg[256];
   va_list args;
   va_start(args, format);
   int32_t res = vsnprintf(msg, 256, format, args);
   va_end(args);
   if ((res >= 0)) {
      size_t len = ((size_t)(res));
      msg[len++] = '\n';
      msg[len] = '\0';
      write(fd, msg, len);
      fsync(fd);
      fprintf(stderr, "[exec] %s\n", msg);
      fflush(stderr);
   }
   _exit(EXIT_FAILURE);
}

static int32_t process_utils_run_args(const char* path, const char* cmd, const char* args, const char* logfile)
{
   fflush(NULL);
   int32_t error_pipe[2];
   if (pipe(error_pipe)) {
      fprintf(stderr, "pipe() failed: %s\n", strerror((*__errno_location())));
      return -1;
   }
   if (fcntl(error_pipe[1], F_SETFD, FD_CLOEXEC)) {
      fprintf(stderr, "fcncl(FD_CLOEXEC) failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   pid_t child_pid = fork();
   if ((child_pid == -1)) {
      fprintf(stderr, "fork() failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   if ((child_pid == 0)) {
      close(error_pipe[0]);
      char filename[512];
      snprintf(filename, 512, "%s%s", path, logfile);
      close(STDOUT_FILENO);
      int32_t fdout = open(filename, ((O_TRUNC | O_CREAT) | O_WRONLY), 0644);
      if ((fdout == -1)) {
         process_utils_child_error(error_pipe[1], "cannot open output '%s': %s", filename, strerror((*__errno_location())));
      }
      while ((dup2(STDOUT_FILENO, STDERR_FILENO) == -1)) {
         if (((*__errno_location()) != EINTR)) process_utils_child_error(error_pipe[1], "dup2(): %s", strerror((*__errno_location())));
      }
      if ((path && *path)) {
         char* cwd = getcwd(NULL, 0);
         printf("current dir: %s\n", cwd);
         free(cwd);
         if ((chdir(path) != 0)) {
            process_utils_child_error(error_pipe[1], "cannot change to dir '%s': %s", path, strerror((*__errno_location())));
         }
         printf("changing to dir: %s\n", path);
      }
      char self[512];
      if (!process_utils_find_bin(self, 512, cmd)) {
         process_utils_child_error(error_pipe[1], "command not found: %s", cmd);
      }
      char* argv[18];
      char argbuf[512];
      uint32_t argc = 0;
      argv[argc++] = self;
      if ((args && *args)) {
         argc += process_utils_parseArgs(args, &argv[1], process_utils_MAX_ARGS, argbuf, 512);
      }
      argv[argc] = NULL;
      printf("running command: %s %s\n", cmd, args ? args : "");
      fflush(stdout);
      execv(self, argv);
      int32_t lasterr = (*__errno_location());
      fprintf(stderr, "failed to start %s: %s\n", cmd, strerror(lasterr));
      process_utils_child_error(error_pipe[1], "error starting %s: %s", cmd, strerror(lasterr));
      _exit(-1);
   } else {
      close(error_pipe[1]);
      char error[256];
      memset(error, 0, 256);
      ssize_t numread = read(error_pipe[0], error, (256 - 1));
      if ((numread < 0)) {
         fprintf(stderr, "Error reading pipe\n");
         close(error_pipe[0]);
         return -1;
      }
      error[numread] = 0;
      close(error_pipe[0]);
      if ((numread != 0)) {
         return -1;
      }
      int32_t state = 0;
      pid_t pid = waitpid(child_pid, &state, 0);
      if ((pid == -1)) {
         fprintf(stderr, "Error waiting for pid: %s\n", strerror((*__errno_location())));
         return -1;
      }
      if (process_utils_doWIFSIGNALED(state)) {
         return -1;
      }
      if (process_utils_doWIFEXITED(state)) {
         char exitcode = process_utils_getWEXITSTATUS(state);
         if ((exitcode != 0)) return -1;

      } else {
         return -1;
      }
   }
   return 0;
}

static uint32_t process_utils_parseArgs(const char* args, char** argv, uint32_t maxargs, char* tmp, size_t tmp_size)
{
   uint32_t argc = 0;
   size_t len = strlen(args);
   if ((len >= tmp_size)) len = (tmp_size - 1);
   memcpy(tmp, args, len);
   tmp[len] = '\0';
   char* token = strtok(tmp, " ");
   while ((((argc + 1) < maxargs) && token)) {
      argv[argc++] = token;
      token = strtok(NULL, " ");
   }
   argv[argc] = NULL;
   return argc;
}

static const char* process_utils_find_bin(char* dest, size_t size, const char* name)
{
   struct stat statbuf;
   const char* s = getenv("PATH");
   if (!s) s = "";
   for (;;) {
      int32_t len = 0;
      while ((s[len] && (s[len] != ':'))) len++;
      int32_t len2 = (((len > 0) && (s[(len - 1)] != '/')));
      int32_t len3 = snprintf(dest, size, "%.*s%.*s%s", len, s, len2, "/", name);
      if (((((size_t)(len3)) < size) && (stat(dest, &statbuf) == 0))) return dest;

      s += len;
      if (!*s++) break;

   }
   return NULL;
}

static int32_t process_utils_run2(const char* path, const char* cmd, const char* args, char* output, size_t output_size)
{
   fflush(NULL);
   int32_t error_pipe[2];
   if (pipe(error_pipe)) {
      fprintf(stderr, "pipe() failed: %s\n", strerror((*__errno_location())));
      return -1;
   }
   if (fcntl(error_pipe[1], F_SETFD, FD_CLOEXEC)) {
      fprintf(stderr, "fcncl(FD_CLOEXEC) failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   int32_t output_pipe[2];
   if (pipe(output_pipe)) {
      fprintf(stderr, "pipe() failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   pid_t child_pid = fork();
   if ((child_pid == -1)) {
      fprintf(stderr, "fork() failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      close(output_pipe[0]);
      close(output_pipe[1]);
      return -1;
   }
   if ((child_pid == 0)) {
      close(output_pipe[0]);
      close(error_pipe[0]);
      while ((dup2(output_pipe[1], STDOUT_FILENO) == -1)) {
         if (((*__errno_location()) != EINTR)) process_utils_child_error(error_pipe[1], "dup(): %s", strerror((*__errno_location())));
      }
      close(output_pipe[1]);
      while ((dup2(STDOUT_FILENO, STDERR_FILENO) == -1)) {
         if (((*__errno_location()) != EINTR)) process_utils_child_error(error_pipe[1], "dup2(): %s", strerror((*__errno_location())));
      }
      if ((path && *path)) {
         if ((chdir(path) != 0)) {
            process_utils_child_error(error_pipe[1], "cannot change to dir '%s': %s", path, strerror((*__errno_location())));
         }
      }
      char self[512];
      if (!process_utils_find_bin(self, 512, cmd)) {
         process_utils_child_error(error_pipe[1], "command not found: %s", cmd);
      }
      char* argv[18];
      char argbuf[512];
      uint32_t argc = 0;
      argv[argc++] = self;
      if ((args && *args)) {
         argc += process_utils_parseArgs(args, &argv[1], process_utils_MAX_ARGS, argbuf, 512);
      }
      argv[argc] = NULL;
      execv(self, argv);
      int32_t lasterr = (*__errno_location());
      fprintf(stderr, "failed to start %s: %s\n", cmd, strerror(lasterr));
      process_utils_child_error(error_pipe[1], "error starting %s: %s", cmd, strerror(lasterr));
      _exit(-1);
   } else {
      close(error_pipe[1]);
      close(output_pipe[1]);
      char error[256];
      memset(error, 0, 256);
      ssize_t numread = read(error_pipe[0], error, (256 - 1));
      if ((numread < 0)) {
         fprintf(stderr, "Error reading pipe\n");
         close(error_pipe[0]);
         close(output_pipe[0]);
         return -1;
      }
      error[numread] = 0;
      close(error_pipe[0]);
      if ((numread != 0)) {
         printf("ERROR %s\n", error);
         close(output_pipe[0]);
         return -1;
      }
      int32_t state = 0;
      pid_t pid = waitpid(child_pid, &state, 0);
      if ((pid == -1)) {
         fprintf(stderr, "Error waiting for pid: %s\n", strerror((*__errno_location())));
         close(output_pipe[0]);
         return -1;
      }
      if (process_utils_doWIFSIGNALED(state)) {
         close(output_pipe[0]);
         return -1;
      }
      if (process_utils_doWIFEXITED(state)) {
         char exitcode = process_utils_getWEXITSTATUS(state);
         if ((exitcode != 0)) return -1;

         numread = read(output_pipe[0], output, (output_size - 1));
         if ((numread < 0)) {
            fprintf(stderr, "error reading process output\n");
            close(output_pipe[0]);
            return -1;
         }
         output[numread] = '\0';
         while (((numread > 0) && isspace(output[(numread - 1)]))) output[--numread] = '\0';
         size_t skip = 0;
         while (isspace(output[skip])) skip++;
         if (skip) {
            numread -= skip;
            memmove(output, (output + skip), (((uint32_t)(numread)) + 1));
         }
      } else {
         fprintf(stderr, "child exited ABNORMALLY\n");
         close(output_pipe[0]);
         return -1;
      }
      close(output_pipe[0]);
   }
   return 0;
}


// --- module source_mgr ---
typedef struct source_mgr_CheckPoint_ source_mgr_CheckPoint;
typedef struct source_mgr_Location_ source_mgr_Location;
typedef struct source_mgr_File_ source_mgr_File;
typedef struct source_mgr_SourceMgr_ source_mgr_SourceMgr;

struct source_mgr_CheckPoint_ {
   uint32_t offset;
   uint32_t line;
};

struct source_mgr_Location_ {
   uint32_t line;
   uint32_t column;
   const char* filename;
   const char* line_start;
};

struct source_mgr_File_ {
   uint32_t filename;
   uint32_t offset;
   uint32_t data_size;
   _Bool needed;
   _Bool is_generated;
   _Bool is_source;
   union {
      file_utils_Reader file;
      string_buffer_Buf* contents;
   };
   uint32_t last_offset;
   source_mgr_Location last_loc;
   uint32_t checkpoint_count;
   uint32_t checkpoint_capacity;
   uint32_t next_checkpoint;
   source_mgr_CheckPoint* checkpoints;
};

struct source_mgr_SourceMgr_ {
   const string_pool_Pool* pool;
   source_mgr_File* files;
   uint32_t num_files;
   uint32_t max_files;
   uint32_t num_open;
   uint32_t max_open;
   uint32_t last_file;
   uint32_t last_file_offset;
   uint32_t other_count;
   uint32_t other_size;
   uint32_t sources_count;
   uint32_t sources_size;
};

#define source_mgr_InitialMaxFiles 32
#define source_mgr_CheckPointSize 128
static void source_mgr_File_close(source_mgr_File* f);
static _Bool source_mgr_File_isOpen(const source_mgr_File* f);
static void source_mgr_File_clear(source_mgr_File* f);
static uint32_t source_mgr_File_size(const source_mgr_File* f);
static const char* source_mgr_File_data(source_mgr_File* f);
static void source_mgr_File_addCheckPoint(source_mgr_File* f, uint32_t offset, uint32_t line);
static const source_mgr_CheckPoint* source_mgr_File_findCheckPoint(source_mgr_File* f, uint32_t offset);
static source_mgr_SourceMgr* source_mgr_create(const string_pool_Pool* pool, uint32_t max_open);
static void source_mgr_SourceMgr_free(source_mgr_SourceMgr* sm);
static void source_mgr_SourceMgr_clear(source_mgr_SourceMgr* sm, int32_t handle);
static file_utils_Reader source_mgr_SourceMgr_openInternal(source_mgr_SourceMgr* sm, const char* filename, src_loc_SrcLoc loc);
static _Bool source_mgr_SourceMgr_close_oldest(source_mgr_SourceMgr* sm);
static void source_mgr_SourceMgr_resize(source_mgr_SourceMgr* sm);
static int32_t source_mgr_SourceMgr_addGenerated(source_mgr_SourceMgr* sm, string_buffer_Buf* contents, uint32_t name);
static int32_t source_mgr_SourceMgr_open(source_mgr_SourceMgr* sm, uint32_t filename, src_loc_SrcLoc loc, _Bool is_source);
static void source_mgr_SourceMgr_close(source_mgr_SourceMgr* sm, int32_t file_id);
static void source_mgr_SourceMgr_checkOpen(source_mgr_SourceMgr* sm, int32_t handle);
static const char* source_mgr_SourceMgr_get_content(source_mgr_SourceMgr* sm, int32_t handle);
static uint32_t source_mgr_SourceMgr_get_offset(source_mgr_SourceMgr* sm, int32_t handle);
static uint32_t source_mgr_SourceMgr_getFileNameIdx(source_mgr_SourceMgr* sm, int32_t handle);
static const char* source_mgr_SourceMgr_getFileName(source_mgr_SourceMgr* sm, int32_t handle);
static void source_mgr_SourceMgr_dump(const source_mgr_SourceMgr* sm);
static source_mgr_File* source_mgr_SourceMgr_find_file(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc);
static source_mgr_Location source_mgr_SourceMgr_locate(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc);
static const char* source_mgr_SourceMgr_loc2str(source_mgr_SourceMgr* sm, src_loc_SrcLoc sloc);
static void source_mgr_SourceMgr_report(const source_mgr_SourceMgr* sm);

static void source_mgr_File_close(source_mgr_File* f)
{
   if (!f->is_generated) file_utils_Reader_close(&f->file);
}

static _Bool source_mgr_File_isOpen(const source_mgr_File* f)
{
   if (f->is_generated) return true;

   return file_utils_Reader_isOpen(&f->file);
}

static void source_mgr_File_clear(source_mgr_File* f)
{
   if (f->is_generated) {
      if (f->contents) string_buffer_Buf_free(f->contents);
      f->contents = NULL;
   } else {
      file_utils_Reader_close(&f->file);
   }
   free(f->checkpoints);
   f->checkpoints = NULL;
   f->checkpoint_count = f->checkpoint_capacity = 0;
}

static uint32_t source_mgr_File_size(const source_mgr_File* f)
{
   return f->data_size;
}

static const char* source_mgr_File_data(source_mgr_File* f)
{
   if (f->is_generated) return string_buffer_Buf_data(f->contents);

   return file_utils_Reader_data(&f->file);
}

static void source_mgr_File_addCheckPoint(source_mgr_File* f, uint32_t offset, uint32_t line)
{
   if ((f->checkpoint_count == f->checkpoint_capacity)) {
      if (f->checkpoint_capacity) f->checkpoint_capacity *= 2;
      else f->checkpoint_capacity = 16;
      source_mgr_CheckPoint* checkpoints = malloc((f->checkpoint_capacity * 8));
      if (f->checkpoints) {
         memcpy(checkpoints, f->checkpoints, (f->checkpoint_count * 8));
         free(f->checkpoints);
      }
      f->checkpoints = checkpoints;
   }
   source_mgr_CheckPoint* c = &f->checkpoints[f->checkpoint_count];
   f->checkpoint_count++;
   c->offset = offset;
   c->line = line;
   f->next_checkpoint = (offset + source_mgr_CheckPointSize);
}

static const source_mgr_CheckPoint* source_mgr_File_findCheckPoint(source_mgr_File* f, uint32_t offset)
{
   if ((f->checkpoint_count && (offset >= f->checkpoints[(f->checkpoint_count - 1)].offset))) {
      return &f->checkpoints[(f->checkpoint_count - 1)];
   }
   uint32_t left = 0;
   uint32_t right = f->checkpoint_count;
   while ((left < right)) {
      uint32_t middle = (((left + right)) / 2);
      const source_mgr_CheckPoint* cur = &f->checkpoints[middle];
      if ((offset < cur->offset)) {
         right = middle;
         continue;
      }
      if ((offset > cur->offset)) {
         if ((left == middle)) return cur;

         left = middle;
         continue;
      }
      return cur;
   }
   return NULL;
}

static source_mgr_SourceMgr* source_mgr_create(const string_pool_Pool* pool, uint32_t max_open)
{
   source_mgr_SourceMgr* sm = calloc(1, 56);
   sm->pool = pool;
   sm->max_files = source_mgr_InitialMaxFiles;
   sm->files = malloc((88 * sm->max_files));
   sm->max_open = max_open;
   return sm;
}

static void source_mgr_SourceMgr_free(source_mgr_SourceMgr* sm)
{
   for (uint32_t i = 0; (i < sm->num_files); i++) {
      source_mgr_File_clear(&sm->files[i]);
   }
   free(sm->files);
   free(sm);
}

static void source_mgr_SourceMgr_clear(source_mgr_SourceMgr* sm, int32_t handle)
{
   uint32_t start_handle = 0;
   if ((handle >= 0)) start_handle = ((uint32_t)((handle + 1)));
   for (uint32_t i = start_handle; (i < sm->num_files); i++) {
      source_mgr_File* f = &sm->files[i];
      if ((f->needed && !f->is_generated)) {
         printf("WARN %s still not closed\n", string_pool_Pool_idx2str(sm->pool, f->filename));
      }
      source_mgr_File_clear(f);
   }
   sm->num_files = start_handle;
   sm->num_open = 0;
   sm->other_count = 0;
   sm->other_size = 0;
   sm->sources_count = 0;
   sm->sources_size = 0;
   for (uint32_t i = 0; (i < sm->num_files); i++) {
      const source_mgr_File* f = &sm->files[i];
      if ((!f->is_generated && source_mgr_File_isOpen(f))) sm->num_open++;
      if (f->is_source) {
         sm->sources_count++;
         sm->sources_size += source_mgr_File_size(f);
      } else {
         sm->other_count++;
         sm->other_size += source_mgr_File_size(f);
      }
   }
   sm->last_file = 0;
   sm->last_file_offset = 0;
}

static file_utils_Reader source_mgr_SourceMgr_openInternal(source_mgr_SourceMgr* sm, const char* filename, src_loc_SrcLoc loc)
{
   file_utils_Reader file;
   if (file_utils_Reader_open(&file, filename)) {
      sm->num_open++;
   } else {
      if (loc) {
         fprintf(stderr, "%s: %serror:%s cannot open %s: %s\n", source_mgr_SourceMgr_loc2str(sm, loc), color_Red, color_Normal, filename, file_utils_Reader_getError(&file));
      } else {
         fprintf(stderr, "%serror%s: cannot open %s: %s\n", color_Red, color_Normal, filename, file_utils_Reader_getError(&file));
      }
   }
   return file;
}

static _Bool source_mgr_SourceMgr_close_oldest(source_mgr_SourceMgr* sm)
{
   for (uint32_t i = 0; (i < sm->num_files); i++) {
      source_mgr_File* f = &sm->files[i];
      if ((source_mgr_File_isOpen(f) && !f->needed)) {
         source_mgr_File_close(f);
         sm->num_open--;
         return true;
      }
   }
   return false;
}

static void source_mgr_SourceMgr_resize(source_mgr_SourceMgr* sm)
{
   sm->max_files *= 2;
   source_mgr_File* files2 = malloc((88 * sm->max_files));
   memcpy(files2, sm->files, (sm->num_files * 88));
   free(sm->files);
   sm->files = files2;
}

static int32_t source_mgr_SourceMgr_addGenerated(source_mgr_SourceMgr* sm, string_buffer_Buf* contents, uint32_t name)
{
   if ((sm->num_files == sm->max_files)) source_mgr_SourceMgr_resize(sm);
   source_mgr_File* f = &sm->files[sm->num_files];
   memset(f, 0, 88);
   uint32_t offset = 1;
   if (sm->num_files) {
      source_mgr_File* last = &sm->files[(sm->num_files - 1)];
      offset = ((last->offset + source_mgr_File_size(last)) + 1);
   }
   f->filename = name;
   f->offset = offset;
   f->data_size = string_buffer_Buf_size(contents);
   f->contents = contents;
   f->next_checkpoint = source_mgr_CheckPointSize;
   f->needed = true;
   f->is_generated = true;
   int32_t file_id = ((int32_t)(sm->num_files));
   sm->num_files++;
   return file_id;
}

static int32_t source_mgr_SourceMgr_open(source_mgr_SourceMgr* sm, uint32_t filename, src_loc_SrcLoc loc, _Bool is_source)
{
   if ((sm->num_open == sm->max_open)) {
      if (!source_mgr_SourceMgr_close_oldest(sm)) {
         fprintf(stderr, "%serror%s: too many files open\n", color_Red, color_Normal);
         return -1;
      }
   }
   file_utils_Reader file = source_mgr_SourceMgr_openInternal(sm, string_pool_Pool_idx2str(sm->pool, filename), loc);
   if (!file_utils_Reader_isOpen(&file)) return -1;

   if ((sm->num_files == sm->max_files)) source_mgr_SourceMgr_resize(sm);
   int32_t file_id = ((int32_t)(sm->num_files));
   source_mgr_File* f = &sm->files[sm->num_files];
   memset(f, 0, 88);
   uint32_t offset = 1;
   if (sm->num_files) {
      source_mgr_File* last = &sm->files[(sm->num_files - 1)];
      offset = ((last->offset + source_mgr_File_size(last)) + 1);
   }
   f->filename = filename;
   f->offset = offset;
   f->data_size = file.size;
   f->file = file;
   f->next_checkpoint = source_mgr_CheckPointSize;
   f->needed = true;
   f->is_source = is_source;
   if (is_source) {
      sm->sources_count++;
      sm->sources_size += f->data_size;
   } else {
      sm->other_count++;
      sm->other_size += f->data_size;
   }
   sm->num_files++;
   return file_id;
}

static void source_mgr_SourceMgr_close(source_mgr_SourceMgr* sm, int32_t file_id)
{
   sm->files[file_id].needed = false;
}

static void source_mgr_SourceMgr_checkOpen(source_mgr_SourceMgr* sm, int32_t handle)
{
   source_mgr_File* f = &sm->files[handle];
   if (source_mgr_File_isOpen(f)) return;

   if ((sm->num_open == sm->max_open)) {
      if (!source_mgr_SourceMgr_close_oldest(sm)) {
         fprintf(stderr, "%serror%s: too many files open\n", color_Red, color_Normal);
         exit(-1);
      }
   }
   (!f->is_generated) || c2_assert("common/source_mgr.c2", 349, "source_mgr.SourceMgr.checkOpen", "!f.is_generated");
   f->file = source_mgr_SourceMgr_openInternal(sm, string_pool_Pool_idx2str(sm->pool, f->filename), 0);
   if (!source_mgr_File_isOpen(f)) exit(-1);
}

static const char* source_mgr_SourceMgr_get_content(source_mgr_SourceMgr* sm, int32_t handle)
{
   source_mgr_SourceMgr_checkOpen(sm, handle);
   return source_mgr_File_data(&sm->files[handle]);
}

static uint32_t source_mgr_SourceMgr_get_offset(source_mgr_SourceMgr* sm, int32_t handle)
{
   return sm->files[handle].offset;
}

static uint32_t source_mgr_SourceMgr_getFileNameIdx(source_mgr_SourceMgr* sm, int32_t handle)
{
   return sm->files[handle].filename;
}

static const char* source_mgr_SourceMgr_getFileName(source_mgr_SourceMgr* sm, int32_t handle)
{
   uint32_t idx = sm->files[handle].filename;
   return string_pool_Pool_idx2str(sm->pool, idx);
}

static void source_mgr_SourceMgr_dump(const source_mgr_SourceMgr* sm)
{
   printf("SourceMgr  files %u  (open %u/%u)\n", sm->num_files, sm->num_open, sm->max_open);
   uint32_t total_size = 0;
   for (uint32_t i = 0; (i < sm->num_files); i++) {
      source_mgr_File* f = &sm->files[i];
      total_size += f->data_size;
      printf("  [%2u]  %7u  %7u %u %s\n", i, f->offset, f->data_size, f->is_generated, string_pool_Pool_idx2str(sm->pool, f->filename));
   }
   printf("Total size %u\n", total_size);
}

static source_mgr_File* source_mgr_SourceMgr_find_file(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc)
{
   uint32_t left = 0;
   if ((loc >= sm->last_file_offset)) {
      left = sm->last_file;
      if ((loc <= (sm->last_file_offset + source_mgr_File_size(&sm->files[sm->last_file])))) {
         return &sm->files[sm->last_file];
      }
   }
   uint32_t right = sm->num_files;
   while ((left < right)) {
      uint32_t middle = (((left + right)) / 2);
      source_mgr_File* f = &sm->files[middle];
      if ((loc < f->offset)) {
         right = middle;
         continue;
      }
      if ((loc > (f->offset + source_mgr_File_size(f)))) {
         left = (middle + 1);
         continue;
      }
      source_mgr_SourceMgr_checkOpen(sm, ((int32_t)(middle)));
      sm->last_file = middle;
      sm->last_file_offset = f->offset;
      return f;
   }
   return NULL;
}

static source_mgr_Location source_mgr_SourceMgr_locate(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc)
{
   source_mgr_Location l = { 1, 1, "-", NULL };
   if ((loc == 0)) return l;

   source_mgr_File* f = source_mgr_SourceMgr_find_file(sm, loc);
   if (f) {
      l.filename = string_pool_Pool_idx2str(sm->pool, f->filename);
      ((loc >= f->offset)) || c2_assert("common/source_mgr.c2", 434, "source_mgr.SourceMgr.locate", "loc >= f.offset");
      uint32_t offset = (loc - f->offset);
      uint32_t last_offset = 0;
      const char* data = source_mgr_File_data(f);
      const char* line = data;
      uint32_t line_nr = l.line;
      const source_mgr_CheckPoint* cp = source_mgr_File_findCheckPoint(f, offset);
      if (cp) {
         line_nr = cp->line;
         last_offset = cp->offset;
         line = (data + cp->offset);
      } else {
      }
      for (uint32_t i = last_offset; (i < offset); i++) {
         if ((data[i] == '\n')) {
            line_nr++;
            line = ((data + i) + 1);
            if ((i >= f->next_checkpoint)) {
               source_mgr_File_addCheckPoint(f, (i + 1), line_nr);
            }
         }
      }
      l.line = line_nr;
      l.column = (((uint32_t)((&data[offset] - line))) + 1);
      l.line_start = line;
      f->last_offset = offset;
      f->last_loc = l;
   }
   return l;
}

static const char* source_mgr_SourceMgr_loc2str(source_mgr_SourceMgr* sm, src_loc_SrcLoc sloc)
{
   static char tmp[256];
   if ((sloc == 0)) {
      strcpy(tmp, "-");
   } else {
      source_mgr_Location loc = source_mgr_SourceMgr_locate(sm, sloc);
      snprintf(tmp, 256, "%s:%u:%u", loc.filename, loc.line, loc.column);
   }
   return tmp;
}

static void source_mgr_SourceMgr_report(const source_mgr_SourceMgr* sm)
{
   printf("source-mgr: %u files, %u sources (%u bytes), %u other (%u bytes)\n", sm->num_files, sm->sources_count, sm->sources_size, sm->other_count, sm->other_size);
}


// --- module string_list ---
typedef struct string_list_List_ string_list_List;

struct string_list_List_ {
   string_pool_Pool* pool;
   uint32_t* indexes;
   uint32_t count;
   uint32_t capacity;
};

static void string_list_List_init(string_list_List* l, string_pool_Pool* pool);
static void string_list_List_free(string_list_List* l);
static void string_list_List_clear(string_list_List* l);
static void string_list_List_resize(string_list_List* l, uint32_t capacity);
static void string_list_List_add(string_list_List* l, uint32_t name_idx);
static uint32_t string_list_List_del(string_list_List* l, uint32_t idx);
static void string_list_List_addStr(string_list_List* l, const char* str);
static _Bool string_list_List_contains(const string_list_List* l, const char* name);
static _Bool string_list_List_contains_idx(const string_list_List* l, uint32_t idx);
static uint32_t string_list_List_length(const string_list_List* l);
static const char* string_list_List_get(const string_list_List* l, uint32_t idx);
static uint32_t string_list_List_get_idx(const string_list_List* l, uint32_t idx);
static uint32_t* string_list_List_getData(string_list_List* l);

static void string_list_List_init(string_list_List* l, string_pool_Pool* pool)
{
   memset(l, 0, 24);
   l->pool = pool;
   string_list_List_resize(l, 16);
}

static void string_list_List_free(string_list_List* l)
{
   free(l->indexes);
}

static void string_list_List_clear(string_list_List* l)
{
   l->count = 0;
}

static void string_list_List_resize(string_list_List* l, uint32_t capacity)
{
   l->capacity = capacity;
   uint32_t* indexes2 = malloc((capacity * 4));
   if (l->count) {
      memcpy(indexes2, l->indexes, (l->count * 4));
      free(l->indexes);
   }
   l->indexes = indexes2;
}

static void string_list_List_add(string_list_List* l, uint32_t name_idx)
{
   if ((l->count == l->capacity)) string_list_List_resize(l, (l->capacity * 2));
   l->indexes[l->count] = name_idx;
   l->count++;
}

static uint32_t string_list_List_del(string_list_List* l, uint32_t idx)
{
   uint32_t j = 0;
   uint32_t count = l->count;
   for (uint32_t i = 0; (i < count); i++) {
      if ((l->indexes[i] != idx)) l->indexes[j++] = l->indexes[i];
   }
   l->count = j;
   return (count - j);
}

static void string_list_List_addStr(string_list_List* l, const char* str)
{
   string_list_List_add(l, string_pool_Pool_addStr(l->pool, str, true));
}

static _Bool string_list_List_contains(const string_list_List* l, const char* name)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      if ((strcmp(string_pool_Pool_idx2str(l->pool, l->indexes[i]), name) == 0)) return true;

   }
   return false;
}

static _Bool string_list_List_contains_idx(const string_list_List* l, uint32_t idx)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      if ((l->indexes[i] == idx)) return true;

   }
   return false;
}

static uint32_t string_list_List_length(const string_list_List* l)
{
   return l->count;
}

static const char* string_list_List_get(const string_list_List* l, uint32_t idx)
{
   return string_pool_Pool_idx2str(l->pool, l->indexes[idx]);
}

static uint32_t string_list_List_get_idx(const string_list_List* l, uint32_t idx)
{
   return l->indexes[idx];
}

static uint32_t* string_list_List_getData(string_list_List* l)
{
   return l->indexes;
}


// --- module string_utils ---

static char* string_utils_toLower(const char* input, char* output);
static char* string_utils_toUpper(const char* input, char* output);
static char* string_utils_stripNewLine(char* buf);
static _Bool string_utils_endsWith(const char* text, const char* tail);
static const char* string_utils_getBasename(const char* s);
static const char* string_utils_getExtension(const char* s);

static char* string_utils_toLower(const char* input, char* output)
{
   size_t i;
   for (i = 0; input[i]; i++) {
      output[i] = ((char)(toupper(input[i])));
   }
   output[i] = '\0';
   return output;
}

static char* string_utils_toUpper(const char* input, char* output)
{
   size_t i;
   for (i = 0; input[i]; i++) {
      output[i] = ((char)(toupper(input[i])));
   }
   output[i] = '\0';
   return output;
}

static char* string_utils_stripNewLine(char* buf)
{
   size_t len = strlen(buf);
   if (((len > 0) && (buf[(len - 1)] == '\n'))) {
      buf[--len] = '\0';
      if (((len > 0) && (buf[(len - 1)] == '\r'))) buf[--len] = '\0';
   }
   return buf;
}

static _Bool string_utils_endsWith(const char* text, const char* tail)
{
   size_t len = strlen(text);
   size_t tlen = strlen(tail);
   return (((tlen <= len) && !memcmp(((text + len) - tlen), tail, tlen)));
}

static const char* string_utils_getBasename(const char* s)
{
   const char* base = s;
   while (*s) {
      if ((*s++ == '/')) base = s;
   }
   return base;
}

static const char* string_utils_getExtension(const char* s)
{
   const char* ext = NULL;
   for (; *s; s++) {
      if ((*s == '/')) ext = NULL;
      if ((*s == '.')) ext = s;
   }
   return ext ? ext : s;
}


// --- module utf8 ---

static uint32_t utf8_encode(char* dest, uint32_t max_len, uint32_t cc);
static uint32_t utf8_decode(const char* p, uint32_t max_len, uint32_t* pc);
static uint32_t utf8_sync(const char* p);

static uint32_t utf8_encode(char* dest, uint32_t max_len, uint32_t cc)
{
   if ((cc < 0x80)) {
      if ((max_len >= 1)) {
         dest[0] = ((char)(cc));
         return 1;
      }
   } else if ((cc < 0x800)) {
      if ((max_len >= 2)) {
         dest[0] = ((char)((0xc0 + ((cc >> 6)))));
         dest[1] = ((char)((0x80 + ((cc & 0x3f)))));
         return 2;
      }
   } else if ((cc < 0x10000)) {
      if ((max_len >= 3)) {
         dest[0] = ((char)((0xe0 + ((cc >> 12)))));
         dest[1] = ((char)((0x80 + ((((cc >> 6)) & 0x3f)))));
         dest[2] = ((char)((0x80 + ((cc & 0x3f)))));
         return 3;
      }
   } else if ((cc < 0x110000)) {
      if ((max_len >= 4)) {
         dest[0] = ((char)((0xf0 + ((cc >> 18)))));
         dest[1] = ((char)((0x80 + ((((cc >> 12)) & 0x3f)))));
         dest[2] = ((char)((0x80 + ((((cc >> 6)) & 0x3f)))));
         dest[3] = ((char)((0x80 + ((cc & 0x3f)))));
         return 4;
      }
   }



   return 0;
}

static uint32_t utf8_decode(const char* p, uint32_t max_len, uint32_t* pc)
{
   if (!max_len) return 0;

   uint32_t c = ((uint8_t)(*p++));
   if ((c < 0x80)) {
      *pc = c;
      return 1;
   } else if ((c < 0xc2)) {
   } else if ((c < 0xe0)) {
      if ((((max_len >= 2) && (p[0] >= 0x80)) && (p[0] <= 0xbf))) {
         *pc = (((((c - 0xc0)) << 6)) + ((p[0] - 0x80)));
         return 2;
      }
   } else if ((c < 0xf0)) {
      if ((((((max_len >= 3) && (p[0] >= 0x80)) && (p[0] <= 0xbf)) && (p[1] >= 0x80)) && (p[1] <= 0xbf))) {
         c = ((((((c - 0xe0)) << 12)) + ((((p[0] - 0x80)) << 6))) + ((p[1] - 0x80)));
         if ((c >= 0x800)) {
            *pc = c;
            return 3;
         }
      }
   } else if ((c <= 0xf4)) {
      if ((((((((max_len >= 4) && (p[0] >= 0x80)) && (p[0] <= 0xbf)) && (p[1] >= 0x80)) && (p[1] <= 0xbf)) && (p[2] >= 0x80)) && (p[2] <= 0xbf))) {
         c = (((((((c - 0xf0)) << 18)) + ((((p[0] - 0x80)) << 12))) + ((((p[1] - 0x80)) << 6))) + ((p[2] - 0x80)));
         if (((c >= 0x10000) && (c < 0x110000))) {
            *pc = c;
            return 4;
         }
      }
   }




   return 0;
}

static uint32_t utf8_sync(const char* p)
{
   uint32_t i = 0;
   while (((i < 3) && (((p[i] & 0xc0)) == 0x80))) i++;
   return i;
}


// --- module utils ---
typedef struct utils_PathInfo_ utils_PathInfo;

struct utils_PathInfo_ {
   char orig2root[512];
   char root2orig[512];
};

static uint64_t utils_now(void);
static _Bool utils_PathInfo_hasSubdir(const utils_PathInfo* pi);
static _Bool utils_findProjectDir(utils_PathInfo* info);
static const char* utils_findBuildFile(void);

static uint64_t utils_now(void)
{
   timeval tv;
   gettimeofday(&tv, NULL);
   uint64_t now64 = ((uint64_t)(tv.tv_sec));
   now64 *= 1000000;
   now64 += tv.tv_usec;
   return now64;
}

static _Bool utils_PathInfo_hasSubdir(const utils_PathInfo* pi)
{
   return (pi->orig2root[0] != 0);
}

static _Bool utils_findProjectDir(utils_PathInfo* info)
{
   if (info) {
      info->root2orig[0] = 0;
      info->orig2root[0] = 0;
   }
   char base_path[512];
   char rel_path[512];
   base_path[0] = 0;
   rel_path[0] = 0;
   char buffer[512];
   while (1) {
      char* path = getcwd(buffer, constants_Max_path);
      if ((path == NULL)) {
         perror("getcwd");
         return false;
      }
      if ((base_path[0] == 0)) strcpy(base_path, path);
      struct stat buf;
      int32_t error = stat(constants_recipe_name, &buf);
      if (error) {
         if (((path[0] == '/') && (path[1] == '\0'))) return false;

         if (((*__errno_location()) != ENOENT)) {
            perror("stat");
            return false;
         }
      } else {
         if (((buf.st_mode & S_IFMT) == S_IFREG)) {
            char* path_prefix = (base_path + strlen(path));
            if ((*path_prefix == '/')) path_prefix++;
            if (info) {
               strcpy(info->orig2root, path_prefix);
               strcpy(info->root2orig, rel_path);
            }
            return true;
         }
      }
      error = chdir("..");
      if (error) {
         perror("chdir");
         return false;
      }
      strcat(rel_path, "../");
   }
   return false;
}

static const char* utils_findBuildFile(void)
{
   struct stat buf;
   int32_t error = stat(constants_buildfile_name, &buf);
   if (error) return NULL;

   return constants_buildfile_name;
}


// --- module warning_flags ---
typedef struct warning_flags_Flags_ warning_flags_Flags;

struct warning_flags_Flags_ {
   _Bool no_unused;
   _Bool no_unused_variable;
   _Bool no_unused_function;
   _Bool no_unused_parameter;
   _Bool no_unused_type;
   _Bool no_unused_module;
   _Bool no_unused_import;
   _Bool no_unused_public;
   _Bool no_unused_label;
   _Bool no_unused_enum_constant;
   _Bool are_errors;
};



// --- module build_file ---
typedef struct build_file_Plugin_ build_file_Plugin;
typedef struct build_file_Info_ build_file_Info;

struct build_file_Plugin_ {
   uint32_t name;
   uint32_t options;
   src_loc_SrcLoc loc;
};

struct build_file_Info_ {
   string_pool_Pool* pool;
   const char* filename;
   uint32_t target;
   uint32_t output_dir;
   uint32_t cc;
   uint32_t cflags;
   uint32_t ldflags;
   uint32_t ldflags2;
   uint32_t asmflags;
   uint32_t linkerscript;
   string_list_List lib_dirs;
   string_list_List plugin_dirs;
   build_file_Plugin* plugins;
   uint32_t plugin_count;
   uint32_t plugin_max;
};

static void build_file_Info_addPlugin(build_file_Info* info, const char* name, const char* options, src_loc_SrcLoc loc);
static const char* build_file_Info_getTarget(const build_file_Info* info);
static const char* build_file_Info_getOutputDir(const build_file_Info* info);
static const char* build_file_Info_getCC(const build_file_Info* info);
static const char* build_file_Info_getCFlags(const build_file_Info* info);
static const char* build_file_Info_getLdFlags(const build_file_Info* info);
static const char* build_file_Info_getLdFlags2(const build_file_Info* info);
static const char* build_file_Info_getAsmFlags(const build_file_Info* info);
static const string_list_List* build_file_Info_getLibDirs(const build_file_Info* info);
static const string_list_List* build_file_Info_getPluginDirs(const build_file_Info* info);
static const build_file_Plugin* build_file_Info_getPlugin(const build_file_Info* info, uint32_t idx);
static uint32_t build_file_Info_getNumPlugins(const build_file_Info* info);
static uint32_t build_file_Info_expand(build_file_Info* info, const char* raw);
static _Bool build_file_getYamlInfo(yaml_Parser* parser, build_file_Info* info);
static _Bool build_file_Info_parse(build_file_Info* info, const char* data);
static build_file_Info* build_file_parse(source_mgr_SourceMgr* sm, string_pool_Pool* pool, const char* filename);
static void build_file_Info_free(build_file_Info* info);

static void build_file_Info_addPlugin(build_file_Info* info, const char* name, const char* options, src_loc_SrcLoc loc)
{
   if ((info->plugin_count == info->plugin_max)) {
      info->plugin_max += 2;
      build_file_Plugin* plugins2 = malloc((info->plugin_max * 12));
      if (info->plugins) {
         memcpy(plugins2, info->plugins, (info->plugin_count * 12));
         free(info->plugins);
      }
      info->plugins = plugins2;
   }
   build_file_Plugin* p = &info->plugins[info->plugin_count];
   info->plugin_count++;
   p->name = string_pool_Pool_addStr(info->pool, name, false);
   p->options = string_pool_Pool_addStr(info->pool, options, false);
   p->loc = loc;
}

static const char* build_file_Info_getTarget(const build_file_Info* info)
{
   if (info->target) return string_pool_Pool_idx2str(info->pool, info->target);

   return NULL;
}

static const char* build_file_Info_getOutputDir(const build_file_Info* info)
{
   if (info->output_dir) return string_pool_Pool_idx2str(info->pool, info->output_dir);

   return NULL;
}

static const char* build_file_Info_getCC(const build_file_Info* info)
{
   if (info->cc) return string_pool_Pool_idx2str(info->pool, info->cc);

   return NULL;
}

static const char* build_file_Info_getCFlags(const build_file_Info* info)
{
   if (info->cflags) return string_pool_Pool_idx2str(info->pool, info->cflags);

   return NULL;
}

static const char* build_file_Info_getLdFlags(const build_file_Info* info)
{
   if (info->ldflags) return string_pool_Pool_idx2str(info->pool, info->ldflags);

   return NULL;
}

static const char* build_file_Info_getLdFlags2(const build_file_Info* info)
{
   if (info->ldflags2) return string_pool_Pool_idx2str(info->pool, info->ldflags2);

   return NULL;
}

static const char* build_file_Info_getAsmFlags(const build_file_Info* info)
{
   if (info->asmflags) return string_pool_Pool_idx2str(info->pool, info->asmflags);

   return NULL;
}

static const string_list_List* build_file_Info_getLibDirs(const build_file_Info* info)
{
   return &info->lib_dirs;
}

static const string_list_List* build_file_Info_getPluginDirs(const build_file_Info* info)
{
   return &info->plugin_dirs;
}

static const build_file_Plugin* build_file_Info_getPlugin(const build_file_Info* info, uint32_t idx)
{
   return &info->plugins[idx];
}

static uint32_t build_file_Info_getNumPlugins(const build_file_Info* info)
{
   return info->plugin_count;
}

static uint32_t build_file_Info_expand(build_file_Info* info, const char* raw)
{
   if (!raw) return 0;

   if ((raw[0] == '$')) {
      const char* expand = getenv((raw + 1));
      if (!expand) {
         fprintf(stderr, "[build-file] warning: environment variable '%s' not set!\n", (raw + 1));
         return 0;
      }
      raw = expand;
   }
   return string_pool_Pool_addStr(info->pool, raw, false);
}

static _Bool build_file_getYamlInfo(yaml_Parser* parser, build_file_Info* info)
{
   const char* target = yaml_Parser_getScalarValue(parser, "target");
   info->target = build_file_Info_expand(info, target);
   const char* outputDir = yaml_Parser_getScalarValue(parser, "output_dir");
   info->output_dir = build_file_Info_expand(info, outputDir);
   const char* cc = yaml_Parser_getScalarValue(parser, "toolchain.cc");
   info->cc = build_file_Info_expand(info, cc);
   const char* cflags = yaml_Parser_getScalarValue(parser, "toolchain.cflags");
   info->cflags = build_file_Info_expand(info, cflags);
   const char* ldflags = yaml_Parser_getScalarValue(parser, "toolchain.ldflags");
   info->ldflags = build_file_Info_expand(info, ldflags);
   const char* ldflags2 = yaml_Parser_getScalarValue(parser, "toolchain.ldflags2");
   info->ldflags2 = build_file_Info_expand(info, ldflags2);
   const char* asmflags = yaml_Parser_getScalarValue(parser, "toolchain.asmflags");
   info->asmflags = build_file_Info_expand(info, asmflags);
   const char* linkerscript = yaml_Parser_getScalarValue(parser, "toolchain.linkerscript");
   info->linkerscript = build_file_Info_expand(info, linkerscript);
   const yaml_Node* dirs = yaml_Parser_findNode(parser, "libdir");
   yaml_Iter iter = yaml_Parser_getNodeChildIter(parser, dirs);
   while (!yaml_Iter_done(&iter)) {
      const char* dir = yaml_Iter_getValue(&iter);
      string_list_List_add(&info->lib_dirs, build_file_Info_expand(info, dir));
      yaml_Iter_next(&iter);
   }
   dirs = yaml_Parser_findNode(parser, "plugindir");
   iter = yaml_Parser_getNodeChildIter(parser, dirs);
   while (!yaml_Iter_done(&iter)) {
      const char* dir = yaml_Iter_getValue(&iter);
      string_list_List_add(&info->plugin_dirs, build_file_Info_expand(info, dir));
      yaml_Iter_next(&iter);
   }
   const yaml_Node* root = yaml_Parser_getRoot(parser);
   iter = yaml_Parser_getNodeChildIter(parser, root);
   while (!yaml_Iter_done(&iter)) {
      const char* name = yaml_Iter_getName(&iter);
      if ((strncmp(name, "plugin.,", 7) == 0)) {
         const char* options = yaml_Iter_getChildScalarValue(&iter, "options");
         if (!options) {
            fprintf(stderr, "[build-file] missing options for %s\n", name);
            exit(-1);
         }
         src_loc_SrcLoc loc = 0;
         build_file_Info_addPlugin(info, (name + 7), options, loc);
      }
      yaml_Iter_next(&iter);
   }
   return true;
}

static _Bool build_file_Info_parse(build_file_Info* info, const char* data)
{
   yaml_Parser* parser = yaml_Parser_create();
   _Bool ok = yaml_Parser_parse(parser, data);
   if (ok) {
      ok = build_file_getYamlInfo(parser, info);
   } else {
      fprintf(stderr, "Error: %s\n", yaml_Parser_getMessage(parser));
   }
   yaml_Parser_destroy(parser);
   return ok;
}

static build_file_Info* build_file_parse(source_mgr_SourceMgr* sm, string_pool_Pool* pool, const char* filename)
{
   build_file_Info info = { };
   info.pool = pool;
   info.filename = filename;
   string_list_List_init(&info.lib_dirs, pool);
   string_list_List_init(&info.plugin_dirs, pool);
   uint32_t filename_idx = string_pool_Pool_addStr(pool, filename, false);
   int32_t file_id = source_mgr_SourceMgr_open(sm, filename_idx, 0, false);
   if ((file_id == -1)) return NULL;

   _Bool ok = build_file_Info_parse(&info, source_mgr_SourceMgr_get_content(sm, file_id));
   source_mgr_SourceMgr_close(sm, file_id);
   if (!ok) return NULL;

   build_file_Info* result = malloc(112);
   memcpy(result, &info, 112);
   return result;
}

static void build_file_Info_free(build_file_Info* info)
{
   string_list_List_free(&info->lib_dirs);
   string_list_List_free(&info->plugin_dirs);
   free(info);
}


// --- module bit_array ---
typedef struct bit_array_BitArray_ bit_array_BitArray;

#define bit_array_MaxBits 256
struct bit_array_BitArray_ {
   uint64_t data[4];
};

static void bit_array_BitArray_reset(bit_array_BitArray* a, uint32_t cap);
static void bit_array_BitArray_set(bit_array_BitArray* a, uint32_t idx);
static void bit_array_BitArray_clear(bit_array_BitArray* a, uint32_t idx);
static _Bool bit_array_BitArray_get(const bit_array_BitArray* a, uint32_t idx);

static void bit_array_BitArray_reset(bit_array_BitArray* a, uint32_t cap)
{
   ((cap <= bit_array_MaxBits)) || c2_assert("common/bit_array.c2", 27, "bit_array.BitArray.reset", "cap <= MaxBits");
   uint32_t num_words = (((cap + 63)) / 64);
   memset(a->data, 0, (num_words * 8));
}

static void bit_array_BitArray_set(bit_array_BitArray* a, uint32_t idx)
{
   uint32_t word = (idx / 64);
   idx -= (word * 64);
   a->data[word] |= ((((uint64_t)(1)) << idx));
}

static void bit_array_BitArray_clear(bit_array_BitArray* a, uint32_t idx)
{
   uint32_t word = (idx / 64);
   idx -= (word * 64);
   a->data[word] &= ~((((uint64_t)(1)) << idx));
}

static _Bool bit_array_BitArray_get(const bit_array_BitArray* a, uint32_t idx)
{
   uint32_t word = (idx / 64);
   idx -= (word * 64);
   return (((a->data[word] >> idx)) & 0x1);
}


// --- module index_list ---
typedef struct index_list_List_ index_list_List;

struct index_list_List_ {
   uint32_t count;
   uint32_t capacity;
   uint32_t* data;
};

static void index_list_List_init(index_list_List* l, uint32_t initial);
static void index_list_List_free(index_list_List* l);
static void index_list_List_clear(index_list_List* l);
static void index_list_List_add(index_list_List* l, uint32_t item);
static uint32_t* index_list_List_getFrom(const index_list_List* l, uint32_t idx);
static uint32_t index_list_List_getCount(const index_list_List* l);
static void index_list_List_resize(index_list_List* l, uint32_t cap);

static void index_list_List_init(index_list_List* l, uint32_t initial)
{
   l->count = 0;
   index_list_List_resize(l, initial);
}

static void index_list_List_free(index_list_List* l)
{
   free(l->data);
}

static void index_list_List_clear(index_list_List* l)
{
   l->count = 0;
}

static void index_list_List_add(index_list_List* l, uint32_t item)
{
   if ((l->count == l->capacity)) index_list_List_resize(l, (l->capacity * 2));
   l->data[l->count] = item;
   l->count++;
}

static uint32_t* index_list_List_getFrom(const index_list_List* l, uint32_t idx)
{
   return &l->data[idx];
}

static uint32_t index_list_List_getCount(const index_list_List* l)
{
   return l->count;
}

static void index_list_List_resize(index_list_List* l, uint32_t cap)
{
   l->capacity = cap;
   uint32_t* data2 = malloc((l->capacity * 4));
   if (l->data) {
      memcpy(data2, l->data, (l->count * 4));
      free(l->data);
   }
   l->data = data2;
}


// --- module dsm_sorter ---
typedef struct dsm_sorter_Sorter_ dsm_sorter_Sorter;

struct dsm_sorter_Sorter_ {
   uint8_t* array;
   uint32_t count;
};

static void dsm_sorter_Sorter_init(dsm_sorter_Sorter* s, uint32_t count);
static void dsm_sorter_Sorter_free(dsm_sorter_Sorter* s);
static void dsm_sorter_Sorter_add_dep(dsm_sorter_Sorter* s, uint32_t src, uint32_t dst);
static const uint8_t* dsm_sorter_Sorter_get_array(dsm_sorter_Sorter* s);
static const uint8_t* dsm_sorter_Sorter_sort(dsm_sorter_Sorter* s);

static void dsm_sorter_Sorter_init(dsm_sorter_Sorter* s, uint32_t count)
{
   s->array = calloc(1, (count * ((count + 2))));
   s->count = count;
   ((count <= 256)) || c2_assert("common/dsm_sorter.c2", 28, "dsm_sorter.Sorter.init", "count <= 256");
}

static void dsm_sorter_Sorter_free(dsm_sorter_Sorter* s)
{
   free(s->array);
}

static void dsm_sorter_Sorter_add_dep(dsm_sorter_Sorter* s, uint32_t src, uint32_t dst)
{
   uint32_t offset = ((src * s->count) + dst);
   s->array[offset] = 1;
}

static const uint8_t* dsm_sorter_Sorter_get_array(dsm_sorter_Sorter* s)
{
   return s->array;
}

static const uint8_t* dsm_sorter_Sorter_sort(dsm_sorter_Sorter* s)
{
   const uint32_t count = s->count;
   uint8_t* sorted = &s->array[(count * ((count + 1)))];
   uint8_t* ringbuf = &s->array[(count * count)];
   uint32_t head = 0;
   uint32_t size = count;
   for (uint8_t i = 0; (i < count); i++) ringbuf[i] = i;
   uint32_t iterations = 0;
   while (size) {
      if ((iterations > size)) {
         return NULL;
      }
      uint8_t idx = ringbuf[head];
      head = (((head + 1)) % count);
      uint32_t offset = (idx * count);
      _Bool has_deps = false;
      for (uint32_t j = 0; (j < count); j++) {
         if ((s->array[(offset + j)] != 0)) {
            has_deps = true;
            break;
         }
      }
      if (has_deps) {
         ringbuf[((((head + size) - 1)) % count)] = idx;
         iterations++;
      } else {
         sorted[(count - size)] = ((uint8_t)(idx));
         iterations = 0;
         size--;
         for (uint32_t x = 0; (x < count); x++) s->array[((x * count) + idx)] = 0;
      }
   }
   return sorted;
}


// --- module target_info ---
typedef struct target_info_Info_ target_info_Info;

typedef enum {
   target_info_Arch_Unknown,
   target_info_Arch_I686,
   target_info_Arch_Arm,
   target_info_Arch_X86_64,
   target_info_Arch_Amd64,
   target_info_Arch_Arm64,
   target_info_Arch_Riscv_32,
   _target_info_Arch_max = 255
} __attribute__((packed)) target_info_Arch;

typedef enum {
   target_info_System_Unknown,
   target_info_System_Linux,
   target_info_System_Darwin,
   target_info_System_Cygwin,
   target_info_System_FreeBSD,
   target_info_System_OpenBSD,
   _target_info_System_max = 255
} __attribute__((packed)) target_info_System;

typedef enum {
   target_info_Vendor_Unknown,
   target_info_Vendor_Apple,
   _target_info_Vendor_max = 255
} __attribute__((packed)) target_info_Vendor;

typedef enum {
   target_info_Abi_Unknown,
   target_info_Abi_GNU,
   target_info_Abi_GNU_EABI,
   target_info_Abi_MACHO,
   target_info_Abi_WIN32,
   target_info_Abi_Rv32G,
   target_info_Abi_BSD,
   _target_info_Abi_max = 255
} __attribute__((packed)) target_info_Abi;

struct target_info_Info_ {
   target_info_Arch arch;
   target_info_System sys;
   target_info_Vendor vendor;
   target_info_Abi abi;
   uint32_t intWidth;
   char triple[80];
};

static const char* target_info_system_names[6] = { "unknown", "linux", "darwin", "cygwin", "freebsd", "openbsd" };

static const char* target_info_arch_names[7] = {
   "unknown",
   "i686",
   "arm",
   "x86_64",
   "amd64",
   "arm64",
   "riscv32"
};

static const char* target_info_vendor_names[2] = { "unknown", "apple" };

static const char* target_info_abi_names[7] = {
   "unknown",
   "gnu",
   "gnueabi",
   "macho",
   "win32",
   "rv32",
   "bsd"
};

static target_info_System target_info_str2sys(const char* name);
static target_info_Arch target_info_str2arch(const char* name);
static target_info_Vendor target_info_str2vendor(const char* name);
static target_info_Abi target_info_str2abi(const char* name);
static void target_info_Info_getNative(target_info_Info* info);
static void target_info_Info_init(target_info_Info* info);
static _Bool target_info_Info_fromString(target_info_Info* info, const char* triple);
static const char* target_info_Info_str(const target_info_Info* info);
static const char* target_info_Info_getSystemName(const target_info_Info* info);
static const char* target_info_Info_getArchName(const target_info_Info* info);

static target_info_System target_info_str2sys(const char* name)
{
   for (uint32_t i = 0; (i < 6); i++) {
      if ((strcasecmp(target_info_system_names[i], name) == 0)) return ((target_info_System)(i));

   }
   return target_info_System_Unknown;
}

static target_info_Arch target_info_str2arch(const char* name)
{
   for (uint32_t i = 0; (i < 7); i++) {
      if ((strcasecmp(target_info_arch_names[i], name) == 0)) return ((target_info_Arch)(i));

   }
   return target_info_Arch_Unknown;
}

static target_info_Vendor target_info_str2vendor(const char* name)
{
   for (uint32_t i = 0; (i < 2); i++) {
      if ((strcasecmp(target_info_vendor_names[i], name) == 0)) return ((target_info_Vendor)(i));

   }
   return target_info_Vendor_Unknown;
}

static target_info_Abi target_info_str2abi(const char* name)
{
   for (uint32_t i = 0; (i < 7); i++) {
      if ((strcasecmp(target_info_abi_names[i], name) == 0)) return ((target_info_Abi)(i));

   }
   return target_info_Abi_Unknown;
}

static void target_info_Info_getNative(target_info_Info* info)
{
   utsname un;
   if ((uname(&un) != 0)) {
      console_error("error getting system info: %s", strerror((*__errno_location())));
      exit(EXIT_FAILURE);
   }
   info->sys = target_info_str2sys(un.sysname);
   switch (info->sys) {
   case target_info_System_Unknown:
      console_error("unsupported system: '%s'", un.sysname);
      exit(EXIT_FAILURE);
      break;
   case target_info_System_Linux:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_GNU;
      break;
   case target_info_System_Darwin:
      info->vendor = target_info_Vendor_Apple;
      info->abi = target_info_Abi_MACHO;
      break;
   case target_info_System_Cygwin:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_WIN32;
      break;
   case target_info_System_FreeBSD:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_BSD;
      break;
   case target_info_System_OpenBSD:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_BSD;
      break;
   }
   info->arch = target_info_str2arch(un.machine);
   if ((info->arch == target_info_Arch_Unknown)) {
      console_error("unsupported arch: '%s'", un.machine);
      exit(EXIT_FAILURE);
   }
   target_info_Info_init(info);
}

static void target_info_Info_init(target_info_Info* info)
{
   switch (info->arch) {
   case target_info_Arch_Unknown:
      info->intWidth = 64;
      break;
   case target_info_Arch_I686:
      fallthrough;
   case target_info_Arch_Arm:
      info->intWidth = 32;
      break;
   case target_info_Arch_X86_64:
      fallthrough;
   case target_info_Arch_Arm64:
      fallthrough;
   case target_info_Arch_Amd64:
      info->intWidth = 64;
      break;
   case target_info_Arch_Riscv_32:
      info->intWidth = 32;
      break;
   }
   sprintf(info->triple, "%s-%s-%s-%s", target_info_arch_names[info->arch], target_info_vendor_names[info->vendor], target_info_system_names[info->sys], target_info_abi_names[info->abi]);
}

static _Bool target_info_Info_fromString(target_info_Info* info, const char* triple)
{
   char arch_str[32];
   char vendor_str[32];
   char sys_str[32];
   char abi_str[32];
   char* matches[4] = { arch_str, vendor_str, sys_str, abi_str };
   int32_t match = 0;
   const char* start = triple;
   const char* cp = start;
   while (*cp) {
      if ((*cp == '-')) {
         uint32_t len = ((uint32_t)((cp - start)));
         strncpy(matches[match], start, len);
         matches[match][len] = 0;
         start = (cp + 1);
         match++;
         if ((match == 5)) return false;

      }
      cp++;
   }
   if ((cp != start)) {
      uint32_t len = ((uint32_t)((cp - start)));
      strncpy(matches[match], start, len);
      matches[match][len] = 0;
      match++;
   }
   if ((match != 4)) return false;

   info->arch = target_info_str2arch(arch_str);
   if ((info->arch == target_info_Arch_Unknown)) {
      console_error("unsupported arch: %s", arch_str);
      return false;
   }
   info->vendor = target_info_str2vendor(vendor_str);
   info->sys = target_info_str2sys(sys_str);
   if ((info->sys == target_info_System_Unknown)) {
   }
   info->abi = target_info_str2abi(abi_str);
   if ((info->abi == target_info_Abi_Unknown)) {
      console_error("unsupported ABI: %s", abi_str);
      return false;
   }
   target_info_Info_init(info);
   return true;
}

static const char* target_info_Info_str(const target_info_Info* info)
{
   return info->triple;
}

static const char* target_info_Info_getSystemName(const target_info_Info* info)
{
   return target_info_system_names[info->sys];
}

static const char* target_info_Info_getArchName(const target_info_Info* info)
{
   return target_info_arch_names[info->arch];
}


// --- module value_maplist ---
typedef struct value_maplist_Value_ value_maplist_Value;
typedef struct value_maplist_List_ value_maplist_List;

struct value_maplist_Value_ {
   uint32_t key;
   uint32_t value;
};

struct value_maplist_List_ {
   value_maplist_Value* values;
   uint32_t count;
   uint32_t capacity;
};

static void value_maplist_List_init(value_maplist_List* l);
static void value_maplist_List_free(value_maplist_List* l);
static void value_maplist_List_clear(value_maplist_List* l);
static void value_maplist_List_add(value_maplist_List* l, uint32_t key, uint32_t value);
static uint32_t value_maplist_List_get(const value_maplist_List* l, uint32_t key);
static void value_maplist_List_resize(value_maplist_List* l, uint32_t cap);

static void value_maplist_List_init(value_maplist_List* l)
{
   memset(l, 0, 16);
   value_maplist_List_resize(l, 8);
}

static void value_maplist_List_free(value_maplist_List* l)
{
   free(l->values);
}

static void value_maplist_List_clear(value_maplist_List* l)
{
   l->count = 0;
}

static void value_maplist_List_add(value_maplist_List* l, uint32_t key, uint32_t value)
{
   if ((l->count == l->capacity)) value_maplist_List_resize(l, (l->capacity * 2));
   value_maplist_Value* v = &l->values[l->count];
   v->key = key;
   v->value = value;
   l->count++;
}

static uint32_t value_maplist_List_get(const value_maplist_List* l, uint32_t key)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      if ((l->values[i].key == key)) return l->values[i].value;

   }
   return 0;
}

static void value_maplist_List_resize(value_maplist_List* l, uint32_t cap)
{
   l->capacity = cap;
   value_maplist_Value* values2 = malloc((l->capacity * 8));
   if (l->count) memcpy(values2, l->values, (l->count * 8));
   if (l->values) free(l->values);
   l->values = values2;
}


// --- module token ---
typedef struct token_Token_ token_Token;

typedef enum {
   token_Kind_None,
   token_Kind_Identifier,
   token_Kind_IntegerLiteral,
   token_Kind_FloatLiteral,
   token_Kind_CharLiteral,
   token_Kind_StringLiteral,
   token_Kind_LParen,
   token_Kind_RParen,
   token_Kind_LSquare,
   token_Kind_RSquare,
   token_Kind_LBrace,
   token_Kind_RBrace,
   token_Kind_Exclaim,
   token_Kind_ExclaimEqual,
   token_Kind_Star,
   token_Kind_StarEqual,
   token_Kind_Amp,
   token_Kind_AmpAmp,
   token_Kind_AmpEqual,
   token_Kind_Pipe,
   token_Kind_PipePipe,
   token_Kind_PipeEqual,
   token_Kind_Equal,
   token_Kind_EqualEqual,
   token_Kind_Semicolon,
   token_Kind_Colon,
   token_Kind_At,
   token_Kind_Caret,
   token_Kind_CaretEqual,
   token_Kind_Question,
   token_Kind_Dot,
   token_Kind_Ellipsis,
   token_Kind_Comma,
   token_Kind_Plus,
   token_Kind_PlusPlus,
   token_Kind_PlusEqual,
   token_Kind_Minus,
   token_Kind_MinusMinus,
   token_Kind_MinusEqual,
   token_Kind_Tilde,
   token_Kind_Slash,
   token_Kind_SlashEqual,
   token_Kind_Percent,
   token_Kind_PercentEqual,
   token_Kind_Less,
   token_Kind_LessLess,
   token_Kind_LessEqual,
   token_Kind_LessLessEqual,
   token_Kind_Greater,
   token_Kind_GreaterGreater,
   token_Kind_GreaterEqual,
   token_Kind_GreaterGreaterEqual,
   token_Kind_KW_bool,
   token_Kind_KW_char,
   token_Kind_KW_i8,
   token_Kind_KW_i16,
   token_Kind_KW_i32,
   token_Kind_KW_i64,
   token_Kind_KW_u8,
   token_Kind_KW_u16,
   token_Kind_KW_u32,
   token_Kind_KW_u64,
   token_Kind_KW_reg8,
   token_Kind_KW_reg16,
   token_Kind_KW_reg32,
   token_Kind_KW_reg64,
   token_Kind_KW_isize,
   token_Kind_KW_usize,
   token_Kind_KW_f32,
   token_Kind_KW_f64,
   token_Kind_KW_void,
   token_Kind_KW_as,
   token_Kind_KW_asm,
   token_Kind_KW_assert,
   token_Kind_KW_break,
   token_Kind_KW_case,
   token_Kind_KW_cast,
   token_Kind_KW_const,
   token_Kind_KW_continue,
   token_Kind_KW_default,
   token_Kind_KW_elemsof,
   token_Kind_KW_else,
   token_Kind_KW_enum_max,
   token_Kind_KW_enum_min,
   token_Kind_KW_enum,
   token_Kind_KW_fallthrough,
   token_Kind_KW_false,
   token_Kind_KW_fn,
   token_Kind_KW_for,
   token_Kind_KW_goto,
   token_Kind_KW_if,
   token_Kind_KW_import,
   token_Kind_KW_local,
   token_Kind_KW_module,
   token_Kind_KW_nil,
   token_Kind_KW_offsetof,
   token_Kind_KW_public,
   token_Kind_KW_return,
   token_Kind_KW_sizeof,
   token_Kind_KW_static_assert,
   token_Kind_KW_struct,
   token_Kind_KW_switch,
   token_Kind_KW_template,
   token_Kind_KW_to_container,
   token_Kind_KW_true,
   token_Kind_KW_type,
   token_Kind_KW_union,
   token_Kind_KW_volatile,
   token_Kind_KW_while,
   token_Kind_Feat_if,
   token_Kind_Feat_ifdef,
   token_Kind_Feat_ifndef,
   token_Kind_Feat_elif,
   token_Kind_Feat_else,
   token_Kind_Feat_endif,
   token_Kind_Feat_error,
   token_Kind_Feat_warning,
   token_Kind_Invalid,
   token_Kind_LineComment,
   token_Kind_BlockComment,
   token_Kind_Eof,
   token_Kind_Warning,
   token_Kind_Error,
   _token_Kind_max = 255
} __attribute__((packed)) token_Kind;

struct token_Token_ {
   src_loc_SrcLoc loc;
   uint16_t len : 16;
   token_Kind kind : 8;
   _Bool done : 1;
   uint8_t radix : 2;
   uint8_t raw : 1;
   union {
      const char* error_msg;
      struct {
         uint32_t text_idx;
         uint32_t text_len;
      };
      uint32_t name_idx;
      uint64_t int_value;
      double float_value;
      uint8_t char_value;
      char invalid[8];
   };
};

static const char* token_token_names[123] = {
   [token_Kind_None] = "none",
   [token_Kind_Identifier] = "identifier",
   [token_Kind_IntegerLiteral] = "integer",
   [token_Kind_FloatLiteral] = "float",
   [token_Kind_CharLiteral] = "character",
   [token_Kind_StringLiteral] = "string",
   [token_Kind_LParen] = "(",
   [token_Kind_RParen] = ")",
   [token_Kind_LSquare] = "[",
   [token_Kind_RSquare] = "]",
   [token_Kind_LBrace] = "{",
   [token_Kind_RBrace] = "}",
   [token_Kind_Exclaim] = "!",
   [token_Kind_ExclaimEqual] = "!=",
   [token_Kind_Star] = "*",
   [token_Kind_StarEqual] = "*=",
   [token_Kind_Amp] = "&",
   [token_Kind_AmpAmp] = "&&",
   [token_Kind_AmpEqual] = "&=",
   [token_Kind_Pipe] = "|",
   [token_Kind_PipePipe] = "||",
   [token_Kind_PipeEqual] = "|=",
   [token_Kind_Equal] = "=",
   [token_Kind_EqualEqual] = "==",
   [token_Kind_Semicolon] = ";",
   [token_Kind_Colon] = ":",
   [token_Kind_At] = "@",
   [token_Kind_Caret] = "^",
   [token_Kind_CaretEqual] = "^=",
   [token_Kind_Question] = "?",
   [token_Kind_Dot] = ".",
   [token_Kind_Ellipsis] = "...",
   [token_Kind_Comma] = ",",
   [token_Kind_Plus] = "+",
   [token_Kind_PlusPlus] = "++",
   [token_Kind_PlusEqual] = "+=",
   [token_Kind_Minus] = "-",
   [token_Kind_MinusMinus] = "--",
   [token_Kind_MinusEqual] = "-=",
   [token_Kind_Tilde] = "~",
   [token_Kind_Slash] = "/",
   [token_Kind_SlashEqual] = "/=",
   [token_Kind_Percent] = "%",
   [token_Kind_PercentEqual] = "%=",
   [token_Kind_Less] = "<",
   [token_Kind_LessLess] = "<<",
   [token_Kind_LessEqual] = "<=",
   [token_Kind_LessLessEqual] = "<<=",
   [token_Kind_Greater] = ">",
   [token_Kind_GreaterGreater] = ">>",
   [token_Kind_GreaterEqual] = ">=",
   [token_Kind_GreaterGreaterEqual] = ">>=",
   [token_Kind_KW_bool] = "bool",
   [token_Kind_KW_char] = "char",
   [token_Kind_KW_i8] = "i8",
   [token_Kind_KW_i16] = "i16",
   [token_Kind_KW_i32] = "i32",
   [token_Kind_KW_i64] = "i64",
   [token_Kind_KW_u8] = "u8",
   [token_Kind_KW_u16] = "u16",
   [token_Kind_KW_u32] = "u32",
   [token_Kind_KW_u64] = "u64",
   [token_Kind_KW_reg8] = "reg8",
   [token_Kind_KW_reg16] = "reg16",
   [token_Kind_KW_reg32] = "reg32",
   [token_Kind_KW_reg64] = "reg64",
   [token_Kind_KW_isize] = "isize",
   [token_Kind_KW_usize] = "usize",
   [token_Kind_KW_f32] = "f32",
   [token_Kind_KW_f64] = "f64",
   [token_Kind_KW_void] = "void",
   [token_Kind_KW_as] = "as",
   [token_Kind_KW_asm] = "asm",
   [token_Kind_KW_assert] = "assert",
   [token_Kind_KW_break] = "break",
   [token_Kind_KW_case] = "case",
   [token_Kind_KW_cast] = "cast",
   [token_Kind_KW_const] = "const",
   [token_Kind_KW_continue] = "continue",
   [token_Kind_KW_default] = "default",
   [token_Kind_KW_elemsof] = "elemsof",
   [token_Kind_KW_else] = "else",
   [token_Kind_KW_enum_max] = "enum_max",
   [token_Kind_KW_enum_min] = "enum_min",
   [token_Kind_KW_enum] = "enum",
   [token_Kind_KW_fallthrough] = "fallthrough",
   [token_Kind_KW_false] = "false",
   [token_Kind_KW_fn] = "fn",
   [token_Kind_KW_for] = "for",
   [token_Kind_KW_goto] = "goto",
   [token_Kind_KW_if] = "if",
   [token_Kind_KW_import] = "import",
   [token_Kind_KW_local] = "local",
   [token_Kind_KW_module] = "module",
   [token_Kind_KW_nil] = "nil",
   [token_Kind_KW_offsetof] = "offsetof",
   [token_Kind_KW_public] = "public",
   [token_Kind_KW_return] = "return",
   [token_Kind_KW_sizeof] = "sizeof",
   [token_Kind_KW_static_assert] = "static_assert",
   [token_Kind_KW_struct] = "struct",
   [token_Kind_KW_switch] = "switch",
   [token_Kind_KW_template] = "template",
   [token_Kind_KW_to_container] = "to_container",
   [token_Kind_KW_true] = "true",
   [token_Kind_KW_type] = "type",
   [token_Kind_KW_union] = "union",
   [token_Kind_KW_volatile] = "volatile",
   [token_Kind_KW_while] = "while",
   [token_Kind_Feat_if] = "#if",
   [token_Kind_Feat_ifdef] = "#ifdef",
   [token_Kind_Feat_ifndef] = "#ifndef",
   [token_Kind_Feat_elif] = "#elif",
   [token_Kind_Feat_else] = "#else",
   [token_Kind_Feat_endif] = "#endif",
   [token_Kind_Feat_error] = "#error",
   [token_Kind_Feat_warning] = "#warning",
   [token_Kind_Invalid] = "invalid",
   [token_Kind_LineComment] = "l-comment",
   [token_Kind_BlockComment] = "b-comment",
   [token_Kind_Eof] = "eof",
   [token_Kind_Warning] = "warning",
   [token_Kind_Error] = "error"
};

static _Bool token_is_keyword(token_Kind k);
static const char* token_Kind_str(token_Kind k);
static void token_Token_init(token_Token* tok);
static number_radix_Radix token_Token_getRadix(const token_Token* tok);

static _Bool token_is_keyword(token_Kind k)
{
   return ((k >= token_Kind_KW_bool) && (k <= token_Kind_KW_while));
}

static const char* token_Kind_str(token_Kind k)
{
   return token_token_names[k];
}

static void token_Token_init(token_Token* tok)
{
   memset(tok, 0, 16);
}

static number_radix_Radix token_Token_getRadix(const token_Token* tok)
{
   return ((number_radix_Radix)(tok->radix));
}


// --- module init_checker ---
typedef struct init_checker_InitEntry_ init_checker_InitEntry;
typedef struct init_checker_Checker_ init_checker_Checker;

struct init_checker_InitEntry_ {
   uint32_t index;
   src_loc_SrcLoc loc;
};

struct init_checker_Checker_ {
   init_checker_InitEntry* entries;
   uint32_t count;
   uint32_t capacity;
   uint32_t max;
};

static void init_checker_Checker_free(init_checker_Checker* c);
static void init_checker_Checker_clear(init_checker_Checker* c);
static uint32_t init_checker_Checker_getCount(const init_checker_Checker* c);
static void init_checker_Checker_add(init_checker_Checker* c, uint32_t index, src_loc_SrcLoc loc);
static void init_checker_Checker_add2(init_checker_Checker* c, uint32_t index1, uint32_t index2, src_loc_SrcLoc loc);
static src_loc_SrcLoc init_checker_Checker_find(init_checker_Checker* c, uint32_t index);
static src_loc_SrcLoc init_checker_Checker_find2(init_checker_Checker* c, uint32_t index1, uint32_t index2);

static void init_checker_Checker_free(init_checker_Checker* c)
{
   free(c->entries);
   c->entries = NULL;
   c->count = 0;
   c->capacity = 0;
   c->max = 0;
}

static void init_checker_Checker_clear(init_checker_Checker* c)
{
   c->count = 0;
   c->max = 0;
}

static uint32_t init_checker_Checker_getCount(const init_checker_Checker* c)
{
   return c->count;
}

static void init_checker_Checker_add(init_checker_Checker* c, uint32_t index, src_loc_SrcLoc loc)
{
   if ((c->count >= c->capacity)) {
      c->capacity = c->capacity ? (c->capacity * 2) : 8;
      init_checker_InitEntry* entries = malloc((c->capacity * 8));
      if (c->entries) {
         memcpy(entries, c->entries, (c->count * 8));
         free(c->entries);
      }
      c->entries = entries;
   }
   init_checker_InitEntry* entry = &c->entries[c->count];
   entry->index = index;
   entry->loc = loc;
   if ((index > c->max)) c->max = index;
   c->count++;
}

static void init_checker_Checker_add2(init_checker_Checker* c, uint32_t index1, uint32_t index2, src_loc_SrcLoc loc)
{
   init_checker_Checker_add(c, index1, loc);
   if ((index1 != index2)) init_checker_Checker_add(c, index2, 0);
}

static src_loc_SrcLoc init_checker_Checker_find(init_checker_Checker* c, uint32_t index)
{
   if ((index > c->max)) return 0;

   for (uint32_t i = 0; (i < c->count); i++) {
      if ((c->entries[i].loc == 0)) {
         if (((c->entries[(i - 1)].index <= index) && (c->entries[i].index >= index))) return c->entries[(i - 1)].loc;

      } else {
         if ((c->entries[i].index == index)) return c->entries[i].loc;

      }
   }
   return 0;
}

static src_loc_SrcLoc init_checker_Checker_find2(init_checker_Checker* c, uint32_t index1, uint32_t index2)
{
   if ((index1 > c->max)) return 0;

   for (uint32_t i = 0; (i < c->count); i++) {
      if ((c->entries[i].loc == 0)) {
         if (((c->entries[(i - 1)].index <= index2) && (c->entries[i].index >= index1))) return c->entries[(i - 1)].loc;

      } else {
         if (((c->entries[i].index >= index1) && (c->entries[i].index <= index2))) return c->entries[i].loc;

      }
   }
   return 0;
}


// --- module name_vector ---
typedef struct name_vector_NameVector_ name_vector_NameVector;

struct name_vector_NameVector_ {
   uint32_t* data;
   uint32_t count;
   uint32_t capacity;
};

static void name_vector_NameVector_init(name_vector_NameVector* v, uint32_t capacity);
static void name_vector_NameVector_free(name_vector_NameVector* v);
static void name_vector_NameVector_clear(name_vector_NameVector* v);
static void name_vector_NameVector_resize(name_vector_NameVector* v);
static uint32_t name_vector_NameVector_add(name_vector_NameVector* v, uint32_t name_idx);
static uint32_t name_vector_NameVector_get(const name_vector_NameVector* v, uint32_t idx);
static _Bool name_vector_NameVector_find(name_vector_NameVector* v, uint32_t name_idx, uint32_t* index);

static void name_vector_NameVector_init(name_vector_NameVector* v, uint32_t capacity)
{
   v->data = NULL;
   v->count = 0;
   v->capacity = capacity;
   if (capacity) v->data = malloc((capacity * 4));
}

static void name_vector_NameVector_free(name_vector_NameVector* v)
{
   if (v->data) free(v->data);
   v->count = 0;
   v->capacity = 0;
   v->data = NULL;
}

static void name_vector_NameVector_clear(name_vector_NameVector* v)
{
   v->count = 0;
}

static void name_vector_NameVector_resize(name_vector_NameVector* v)
{
   v->capacity = (v->capacity == 0) ? 4 : (v->capacity * 2);
   void* data2 = malloc((v->capacity * 4));
   if (v->data) {
      memcpy(data2, v->data, (v->count * 4));
      free(v->data);
   }
   v->data = data2;
}

static uint32_t name_vector_NameVector_add(name_vector_NameVector* v, uint32_t name_idx)
{
   if ((v->count == v->capacity)) name_vector_NameVector_resize(v);
   uint32_t index = v->count;
   v->data[index] = name_idx;
   v->count++;
   return index;
}

static uint32_t name_vector_NameVector_get(const name_vector_NameVector* v, uint32_t idx)
{
   return v->data[idx];
}

static _Bool name_vector_NameVector_find(name_vector_NameVector* v, uint32_t name_idx, uint32_t* index)
{
   for (uint32_t i = 0; (i < v->count); i++) {
      if ((v->data[i] == name_idx)) {
         *index = i;
         return true;
      }
   }
   return false;
}


// --- module instr_inserter ---
typedef struct instr_inserter_InstrInsertion_ instr_inserter_InstrInsertion;
typedef struct instr_inserter_InstrInserter_ instr_inserter_InstrInserter;

struct instr_inserter_InstrInsertion_ {
   uint32_t location;
   uint32_t instr_idx;
};

struct instr_inserter_InstrInserter_ {
   uint32_t next_loc;
   uint32_t cur;
   uint32_t count;
   uint32_t capacity;
   instr_inserter_InstrInsertion* ins;
};

static void instr_inserter_InstrInserter_create(instr_inserter_InstrInserter* ii);
static void instr_inserter_InstrInserter_resize(instr_inserter_InstrInserter* ii, uint32_t capacity);
static void instr_inserter_InstrInserter_clear(instr_inserter_InstrInserter* ii);
static void instr_inserter_InstrInserter_free(instr_inserter_InstrInserter* ii);
static void instr_inserter_InstrInserter_add(instr_inserter_InstrInserter* ii, uint32_t location, uint32_t instr_idx);
static void instr_inserter_InstrInserter_start(instr_inserter_InstrInserter* ii);
static uint32_t instr_inserter_InstrInserter_insert(instr_inserter_InstrInserter* ii, uint32_t loc);
static _Bool instr_inserter_InstrInserter_needsFixup(const instr_inserter_InstrInserter* ii);
static void instr_inserter_InstrInserter_dump(const instr_inserter_InstrInserter* ii);

static void instr_inserter_InstrInserter_create(instr_inserter_InstrInserter* ii)
{
   ii->count = 0;
   ii->cur = 0;
   ii->next_loc = 0;
   instr_inserter_InstrInserter_resize(ii, 16);
}

static void instr_inserter_InstrInserter_resize(instr_inserter_InstrInserter* ii, uint32_t capacity)
{
   ii->capacity = capacity;
   instr_inserter_InstrInsertion* ins2 = malloc((ii->capacity * 8));
   if (ii->count) {
      memcpy(ins2, ii->ins, (ii->count * 8));
      free(ii->ins);
   }
   ii->ins = ins2;
}

static void instr_inserter_InstrInserter_clear(instr_inserter_InstrInserter* ii)
{
   ii->count = 0;
   ii->cur = 0;
   ii->next_loc = 0;
}

static void instr_inserter_InstrInserter_free(instr_inserter_InstrInserter* ii)
{
   free(ii->ins);
}

static void instr_inserter_InstrInserter_add(instr_inserter_InstrInserter* ii, uint32_t location, uint32_t instr_idx)
{
   if ((ii->count == ii->capacity)) instr_inserter_InstrInserter_resize(ii, (ii->capacity * 2));
   instr_inserter_InstrInsertion* ins = &ii->ins[ii->count++];
   ins->location = location;
   ins->instr_idx = instr_idx;
}

static void instr_inserter_InstrInserter_start(instr_inserter_InstrInserter* ii)
{
   ii->cur = 0;
   if (ii->count) ii->next_loc = ii->ins[ii->cur].location;
}

static uint32_t instr_inserter_InstrInserter_insert(instr_inserter_InstrInserter* ii, uint32_t loc)
{
   if (((loc == ii->next_loc) && (ii->cur < ii->count))) {
      uint32_t instr_idx = ii->ins[ii->cur].instr_idx;
      ii->cur++;
      if ((ii->cur < ii->count)) ii->next_loc = ii->ins[ii->cur].location;
      return instr_idx;
   }
   return 0;
}

static _Bool instr_inserter_InstrInserter_needsFixup(const instr_inserter_InstrInserter* ii)
{
   return (ii->count != 0);
}

static void instr_inserter_InstrInserter_dump(const instr_inserter_InstrInserter* ii)
{
   printf("Insertions:\n");
   for (uint32_t i = 0; (i < ii->count); i++) {
      const instr_inserter_InstrInsertion* ins = &ii->ins[i];
      printf("  [%u] %3u  %u\n", i, ins->location, ins->instr_idx);
   }
}


// --- module lookup_table ---
typedef struct lookup_table_Table_ lookup_table_Table;

struct lookup_table_Table_ {
   uint32_t capacity;
   uint32_t* data;
};

static void lookup_table_Table_init(lookup_table_Table* t, uint32_t initial);
static void lookup_table_Table_free(lookup_table_Table* t);
static void lookup_table_Table_clear(lookup_table_Table* t, uint32_t amount);
static void lookup_table_Table_set(lookup_table_Table* t, uint32_t idx, uint32_t value);
static uint32_t lookup_table_Table_get(const lookup_table_Table* t, uint32_t idx);
static void lookup_table_Table_resize(lookup_table_Table* t, uint32_t capacity2, _Bool copy);

static void lookup_table_Table_init(lookup_table_Table* t, uint32_t initial)
{
   t->data = NULL;
   t->capacity = 0;
   lookup_table_Table_resize(t, initial, false);
}

static void lookup_table_Table_free(lookup_table_Table* t)
{
   free(t->data);
}

static void lookup_table_Table_clear(lookup_table_Table* t, uint32_t amount)
{
   if ((amount > t->capacity)) lookup_table_Table_resize(t, amount, false);
   memset(t->data, 0, (amount * 4));
}

static void lookup_table_Table_set(lookup_table_Table* t, uint32_t idx, uint32_t value)
{
   while ((idx >= t->capacity)) lookup_table_Table_resize(t, (t->capacity * 2), true);
   t->data[idx] = value;
}

static uint32_t lookup_table_Table_get(const lookup_table_Table* t, uint32_t idx)
{
   if ((idx >= t->capacity)) return 0;

   return t->data[idx];
}

static void lookup_table_Table_resize(lookup_table_Table* t, uint32_t capacity2, _Bool copy)
{
   uint32_t* data2 = calloc(capacity2, 4);
   if (t->data) {
      if (copy) memcpy(data2, t->data, (t->capacity * 4));
      free(t->data);
   }
   t->capacity = capacity2;
   t->data = data2;
}


// --- module git_version ---

static const char git_version_Describe[15] = "8d0a3163-dirty";



// --- module attr ---
typedef struct attr_Value_ attr_Value;
typedef struct attr_Attr_ attr_Attr;

typedef enum {
   attr_AttrKind_Unknown,
   attr_AttrKind_Export,
   attr_AttrKind_Packed,
   attr_AttrKind_Unused,
   attr_AttrKind_UnusedParams,
   attr_AttrKind_Section,
   attr_AttrKind_NoReturn,
   attr_AttrKind_Inline,
   attr_AttrKind_PrintfFormat,
   attr_AttrKind_Aligned,
   attr_AttrKind_Weak,
   attr_AttrKind_Opaque,
   attr_AttrKind_CName,
   attr_AttrKind_CDef,
   attr_AttrKind_NoTypeDef,
   attr_AttrKind_Constructor,
   attr_AttrKind_Destructor,
   attr_AttrKind_Pure,
   attr_AttrKind_AutoFile,
   attr_AttrKind_AutoLine,
   _attr_AttrKind_max = 255
} __attribute__((packed)) attr_AttrKind;

typedef enum {
   attr_ValueKind_None,
   attr_ValueKind_Number,
   attr_ValueKind_String,
   _attr_ValueKind_max = 255
} __attribute__((packed)) attr_ValueKind;

struct attr_Value_ {
   src_loc_SrcLoc loc;
   union {
      uint32_t text;
      uint32_t number;
   };
};

struct attr_Attr_ {
   uint32_t name;
   attr_AttrKind kind;
   attr_ValueKind value_kind;
   src_loc_SrcLoc loc;
   attr_Value value;
};

typedef enum {
   attr_AttrReq_NoArg = 0,
   attr_AttrReq_Arg,
   attr_AttrReq_Number,
   attr_AttrReq_String,
   attr_AttrReq_Power2,
   attr_AttrReq_Ok,
   _attr_AttrReq_max = 255
} __attribute__((packed)) attr_AttrReq;

static const char* attr_attrKind_names[20] = {
   "?",
   "export",
   "packed",
   "unused",
   "unused_params",
   "section",
   "noreturn",
   "inline",
   "printf_format",
   "aligned",
   "weak",
   "opaque",
   "cname",
   "cdef",
   "no_typedef",
   "constructor",
   "destructor",
   "pure",
   "auto_file",
   "auto_line"
};

static const uint32_t* attr_name_indexes = NULL;

static const attr_AttrReq attr_Required_arg[20] = {
   [attr_AttrKind_Unknown] = attr_AttrReq_NoArg,
   [attr_AttrKind_Export] = attr_AttrReq_NoArg,
   [attr_AttrKind_Packed] = attr_AttrReq_NoArg,
   [attr_AttrKind_Unused] = attr_AttrReq_NoArg,
   [attr_AttrKind_UnusedParams] = attr_AttrReq_NoArg,
   [attr_AttrKind_Section] = attr_AttrReq_String,
   [attr_AttrKind_NoReturn] = attr_AttrReq_NoArg,
   [attr_AttrKind_Inline] = attr_AttrReq_NoArg,
   [attr_AttrKind_PrintfFormat] = attr_AttrReq_NoArg,
   [attr_AttrKind_Aligned] = attr_AttrReq_Number,
   [attr_AttrKind_Weak] = attr_AttrReq_NoArg,
   [attr_AttrKind_Opaque] = attr_AttrReq_NoArg,
   [attr_AttrKind_CName] = attr_AttrReq_String,
   [attr_AttrKind_CDef] = attr_AttrReq_String,
   [attr_AttrKind_NoTypeDef] = attr_AttrReq_NoArg,
   [attr_AttrKind_Constructor] = attr_AttrReq_NoArg,
   [attr_AttrKind_Destructor] = attr_AttrReq_NoArg,
   [attr_AttrKind_Pure] = attr_AttrReq_NoArg,
   [attr_AttrKind_AutoFile] = attr_AttrReq_NoArg,
   [attr_AttrKind_AutoLine] = attr_AttrReq_NoArg
};

static const char* attr_kind2name(attr_AttrKind k);
static void attr_register(string_pool_Pool* pool, uint32_t* indexes);
static void attr_initialize(const uint32_t* indexes);
static attr_AttrKind attr_find(uint32_t name_idx);
static _Bool attr_isPowerOf2(uint32_t val);
static attr_AttrReq attr_check(const attr_Attr* a);

static const char* attr_kind2name(attr_AttrKind k)
{
   return attr_attrKind_names[k];
}

static void attr_register(string_pool_Pool* pool, uint32_t* indexes)
{
   indexes[0] = 0;
   for (uint32_t i = 1; (i < 20); i++) {
      indexes[i] = string_pool_Pool_addStr(pool, attr_attrKind_names[i], true);
   }
}

static void attr_initialize(const uint32_t* indexes)
{
   attr_name_indexes = indexes;
}

static attr_AttrKind attr_find(uint32_t name_idx)
{
   for (uint32_t i = 1; (i < 20); i++) {
      if ((name_idx == attr_name_indexes[i])) return ((attr_AttrKind)(i));

   }
   return attr_AttrKind_Unknown;
}

static _Bool attr_isPowerOf2(uint32_t val)
{
   return (val && !((val & ((val - 1)))));
}

static attr_AttrReq attr_check(const attr_Attr* a)
{
   switch (attr_Required_arg[a->kind]) {
   case attr_AttrReq_NoArg:
      if ((a->value_kind != attr_ValueKind_None)) return attr_AttrReq_NoArg;

      break;
   case attr_AttrReq_Number:
      switch (a->value_kind) {
      case attr_ValueKind_None:
         return attr_AttrReq_Arg;
      case attr_ValueKind_Number:
         if ((a->kind == attr_AttrKind_Aligned)) {
            if (!attr_isPowerOf2(a->value.number)) return attr_AttrReq_Power2;

         }
         break;
      case attr_ValueKind_String:
         return attr_AttrReq_Number;
      }
      break;
   case attr_AttrReq_String:
      switch (a->value_kind) {
      case attr_ValueKind_None:
         return attr_AttrReq_Arg;
      case attr_ValueKind_Number:
         return attr_AttrReq_String;
      case attr_ValueKind_String:
         break;
      }
      break;
   default:
      break;
   }
   return attr_AttrReq_Ok;
}


// --- module attr_table ---
typedef struct attr_table_Attr_ attr_table_Attr;
typedef struct attr_table_Table_ attr_table_Table;

struct attr_table_Attr_ {
   void* decl;
   attr_Value value;
   attr_AttrKind kind;
};

struct attr_table_Table_ {
   uint32_t count;
   uint32_t capacity;
   attr_table_Attr* attrs;
};

static attr_table_Table* attr_table_create(void);
static void attr_table_Table_free(attr_table_Table* t);
static void attr_table_Table_resize(attr_table_Table* t, uint32_t capacity);
static void attr_table_Table_add(attr_table_Table* t, void* decl, attr_AttrKind kind, const attr_Value* value);
static const attr_Value* attr_table_Table_find(const attr_table_Table* t, const void* decl, attr_AttrKind kind);

static attr_table_Table* attr_table_create(void)
{
   attr_table_Table* t = calloc(1, 16);
   attr_table_Table_resize(t, 2);
   return t;
}

static void attr_table_Table_free(attr_table_Table* t)
{
   free(t->attrs);
   free(t);
}

static void attr_table_Table_resize(attr_table_Table* t, uint32_t capacity)
{
   t->capacity = capacity;
   attr_table_Attr* attrs2 = malloc((capacity * 24));
   if (t->count) {
      memcpy(attrs2, t->attrs, (t->count * 24));
      free(t->attrs);
   }
   t->attrs = attrs2;
}

static void attr_table_Table_add(attr_table_Table* t, void* decl, attr_AttrKind kind, const attr_Value* value)
{
   if ((t->count == t->capacity)) attr_table_Table_resize(t, (t->capacity * 2));
   attr_table_Attr* a = &t->attrs[t->count];
   a->decl = decl;
   a->value = *value;
   a->kind = kind;
   t->count++;
}

static const attr_Value* attr_table_Table_find(const attr_table_Table* t, const void* decl, attr_AttrKind kind)
{
   for (uint32_t i = 0; (i < t->count); i++) {
      const attr_table_Attr* a = &t->attrs[i];
      if (((a->decl == decl) && (a->kind == kind))) return &a->value;

   }
   return NULL;
}


// --- module ast ---
typedef struct ast_DeclBits_ ast_DeclBits;
typedef struct ast_Decl_ ast_Decl;
typedef struct ast_AliasTypeDecl_ ast_AliasTypeDecl;
typedef struct ast_ArrayValue_ ast_ArrayValue;
typedef struct ast_DeclStmt_ ast_DeclStmt;
typedef struct ast_EnumConstantDeclBits_ ast_EnumConstantDeclBits;
typedef struct ast_EnumConstantDecl_ ast_EnumConstantDecl;
typedef struct ast_EnumTypeDeclBits_ ast_EnumTypeDeclBits;
typedef struct ast_EnumTypeDecl_ ast_EnumTypeDecl;
typedef struct ast_FunctionDeclBits_ ast_FunctionDeclBits;
typedef struct ast_FunctionDeclFlags_ ast_FunctionDeclFlags;
typedef struct ast_FunctionDecl_ ast_FunctionDecl;
typedef struct ast_FunctionTypeDecl_ ast_FunctionTypeDecl;
typedef struct ast_ImportDeclBits_ ast_ImportDeclBits;
typedef struct ast_ImportDecl_ ast_ImportDecl;
typedef struct ast_StaticAssert_ ast_StaticAssert;
typedef struct ast_StructTypeDeclBits_ ast_StructTypeDeclBits;
typedef struct ast_StructLayout_ ast_StructLayout;
typedef struct ast_StructTypeDecl_ ast_StructTypeDecl;
typedef struct ast_Value_ ast_Value;
typedef union ast_FP64_ ast_FP64;
typedef struct ast_VarDeclBits_ ast_VarDeclBits;
typedef struct ast_VarDecl_ ast_VarDecl;
typedef struct ast_StmtBits_ ast_StmtBits;
typedef struct ast_Stmt_ ast_Stmt;
typedef struct ast_AsmStmtBits_ ast_AsmStmtBits;
typedef struct ast_AsmStmt_ ast_AsmStmt;
typedef struct ast_AssertStmt_ ast_AssertStmt;
typedef struct ast_BreakStmt_ ast_BreakStmt;
typedef struct ast_CompoundStmtBits_ ast_CompoundStmtBits;
typedef struct ast_CompoundStmt_ ast_CompoundStmt;
typedef struct ast_ContinueStmt_ ast_ContinueStmt;
typedef struct ast_FallthroughStmt_ ast_FallthroughStmt;
typedef struct ast_ForStmt_ ast_ForStmt;
typedef struct ast_GotoStmt_ ast_GotoStmt;
typedef struct ast_IfStmtBits_ ast_IfStmtBits;
typedef struct ast_IfStmt_ ast_IfStmt;
typedef struct ast_LabelStmtBits_ ast_LabelStmtBits;
typedef struct ast_LabelStmt_ ast_LabelStmt;
typedef struct ast_ReturnStmtBits_ ast_ReturnStmtBits;
typedef struct ast_ReturnStmt_ ast_ReturnStmt;
typedef struct ast_SwitchCaseBits_ ast_SwitchCaseBits;
typedef struct ast_SwitchCase_ ast_SwitchCase;
typedef struct ast_SwitchStmtBits_ ast_SwitchStmtBits;
typedef struct ast_SwitchStmt_ ast_SwitchStmt;
typedef struct ast_WhileStmt_ ast_WhileStmt;
typedef struct ast_ExprBits_ ast_ExprBits;
typedef struct ast_Expr_ ast_Expr;
typedef struct ast_ArrayDesignatedInitExpr_ ast_ArrayDesignatedInitExpr;
typedef struct ast_ArraySubscriptExprBits_ ast_ArraySubscriptExprBits;
typedef struct ast_ArraySubscriptExpr_ ast_ArraySubscriptExpr;
typedef struct ast_BinaryOperatorBits_ ast_BinaryOperatorBits;
typedef struct ast_BinaryOperator_ ast_BinaryOperator;
typedef struct ast_BitOffsetExprBits_ ast_BitOffsetExprBits;
typedef struct ast_BitOffsetExpr_ ast_BitOffsetExpr;
typedef struct ast_BooleanLiteralBits_ ast_BooleanLiteralBits;
typedef struct ast_BooleanLiteral_ ast_BooleanLiteral;
typedef struct ast_BuiltinExprBits_ ast_BuiltinExprBits;
typedef struct ast_ToContainerData_ ast_ToContainerData;
typedef struct ast_OffsetOfData_ ast_OffsetOfData;
typedef struct ast_BuiltinExpr_ ast_BuiltinExpr;
typedef struct ast_CallExprBits_ ast_CallExprBits;
typedef struct ast_CallExpr_ ast_CallExpr;
typedef struct ast_CharLiteralBits_ ast_CharLiteralBits;
typedef struct ast_CharLiteral_ ast_CharLiteral;
typedef struct ast_ConditionalOperator_ ast_ConditionalOperator;
typedef struct ast_ExplicitCastExprBits_ ast_ExplicitCastExprBits;
typedef struct ast_ExplicitCastExpr_ ast_ExplicitCastExpr;
typedef struct ast_FieldDesignatorBits_ ast_FieldDesignatorBits;
typedef struct ast_FieldDesignatedInitExpr_ ast_FieldDesignatedInitExpr;
typedef struct ast_FloatLiteralBits_ ast_FloatLiteralBits;
typedef struct ast_FloatLiteral_ ast_FloatLiteral;
typedef struct ast_IdentifierExprBits_ ast_IdentifierExprBits;
typedef struct ast_IdentifierExpr_ ast_IdentifierExpr;
typedef struct ast_ImplicitCastBits_ ast_ImplicitCastBits;
typedef struct ast_ImplicitCastExpr_ ast_ImplicitCastExpr;
typedef struct ast_InitListExprBits_ ast_InitListExprBits;
typedef struct ast_InitListExpr_ ast_InitListExpr;
typedef struct ast_IntegerLiteralBits_ ast_IntegerLiteralBits;
typedef struct ast_IntegerLiteral_ ast_IntegerLiteral;
typedef struct ast_MemberExprBits_ ast_MemberExprBits;
typedef union ast_MemberRef_ ast_MemberRef;
typedef struct ast_MemberExpr_ ast_MemberExpr;
typedef struct ast_NilExpr_ ast_NilExpr;
typedef struct ast_ParenExprBits_ ast_ParenExprBits;
typedef struct ast_ParenExpr_ ast_ParenExpr;
typedef struct ast_RangeExpr_ ast_RangeExpr;
typedef struct ast_StringLiteralBits_ ast_StringLiteralBits;
typedef struct ast_StringLiteral_ ast_StringLiteral;
typedef struct ast_TypeExprBits_ ast_TypeExprBits;
typedef struct ast_TypeExpr_ ast_TypeExpr;
typedef struct ast_UnaryOperatorBits_ ast_UnaryOperatorBits;
typedef struct ast_UnaryOperator_ ast_UnaryOperator;
typedef struct ast_TypeBits_ ast_TypeBits;
typedef struct ast_Type_ ast_Type;
typedef struct ast_AliasType_ ast_AliasType;
typedef struct ast_ArrayTypeBits_ ast_ArrayTypeBits;
typedef struct ast_ArrayType_ ast_ArrayType;
typedef struct ast_BuiltinTypeBits_ ast_BuiltinTypeBits;
typedef struct ast_BuiltinType_ ast_BuiltinType;
typedef struct ast_EnumType_ ast_EnumType;
typedef struct ast_FunctionType_ ast_FunctionType;
typedef struct ast_ModuleType_ ast_ModuleType;
typedef struct ast_PointerType_ ast_PointerType;
typedef struct ast_QualType_ ast_QualType;
typedef struct ast_StructType_ ast_StructType;
typedef struct ast_TypeRefBits_ ast_TypeRefBits;
typedef struct ast_Ref_ ast_Ref;
typedef struct ast_TypeRef_ ast_TypeRef;
typedef struct ast_TypeRefHolder_ ast_TypeRefHolder;
typedef struct ast_ArrayValueList_ ast_ArrayValueList;
typedef struct ast_AST_ ast_AST;
typedef struct ast_DeclList_ ast_DeclList;
typedef struct ast_ExprList_ ast_ExprList;
typedef struct ast_FunctionDeclList_ ast_FunctionDeclList;
typedef struct ast_ImportDeclList_ ast_ImportDeclList;
typedef struct ast_TemplateInstance_ ast_TemplateInstance;
typedef struct ast_TemplateFunction_ ast_TemplateFunction;
typedef struct ast_InstanceTable_ ast_InstanceTable;
typedef struct ast_Instantiator_ ast_Instantiator;
typedef struct ast_Module_ ast_Module;
typedef struct ast_PointerPoolSlot_ ast_PointerPoolSlot;
typedef struct ast_PointerPool_ ast_PointerPool;
typedef struct ast_StaticAssertList_ ast_StaticAssertList;
typedef struct ast_Stat_ ast_Stat;
typedef struct ast_Stats_ ast_Stats;
typedef struct ast_StringTypeSlot_ ast_StringTypeSlot;
typedef struct ast_StringTypePool_ ast_StringTypePool;
typedef struct ast_SymbolTable_ ast_SymbolTable;
typedef struct ast_Globals_ ast_Globals;

typedef enum {
   ast_DeclKind_Function,
   ast_DeclKind_Import,
   ast_DeclKind_StructType,
   ast_DeclKind_EnumType,
   ast_DeclKind_EnumConstant,
   ast_DeclKind_FunctionType,
   ast_DeclKind_AliasType,
   ast_DeclKind_Variable,
   _ast_DeclKind_max = 255
} __attribute__((packed)) ast_DeclKind;

typedef enum {
   ast_DeclCheckState_Unchecked,
   ast_DeclCheckState_InProgress,
   ast_DeclCheckState_Checked,
   _ast_DeclCheckState_max = 255
} __attribute__((packed)) ast_DeclCheckState;

struct ast_DeclBits_ {
   uint32_t kind : 8;
   uint32_t check_state : 2;
   uint32_t is_public : 1;
   uint32_t is_used : 1;
   uint32_t is_used_public : 1;
   uint32_t has_attr : 1;
   uint32_t attr_export : 1;
   uint32_t attr_unused : 1;
   uint32_t is_external : 1;
   uint32_t is_generated : 1;
   uint32_t has_gen_idx : 1;
};

#define ast_NumDeclBits 19
struct ast_ImportDeclBits_ {
   uint32_t  : 19;
   uint32_t is_local : 1;
};

struct ast_FunctionDeclBits_ {
   uint32_t  : 19;
   uint32_t is_variadic : 1;
   uint32_t has_prefix : 1;
   uint32_t call_kind : 2;
   uint32_t has_return : 1;
   uint32_t is_template : 1;
   uint32_t is_type : 1;
};

struct ast_StructTypeDeclBits_ {
   uint32_t  : 19;
   uint32_t is_struct : 1;
   uint32_t is_global : 1;
   uint32_t attr_packed : 1;
   uint32_t attr_opaque : 1;
   uint32_t attr_notypedef : 1;
   uint32_t size_analysed : 1;
};

struct ast_EnumTypeDeclBits_ {
   uint32_t  : 19;
   uint32_t is_incremental : 1;
   uint32_t num_constants : 12;
};

struct ast_EnumConstantDeclBits_ {
   uint32_t  : 19;
   uint32_t has_init : 1;
   uint32_t enum_index : 12;
};

struct ast_VarDeclBits_ {
   uint32_t  : 19;
   uint32_t kind : 3;
   uint32_t has_init_or_bitfield : 1;
   uint32_t has_local : 1;
   uint32_t has_init_call : 1;
   uint32_t attr_weak : 1;
   uint32_t addr_used : 1;
   uint32_t auto_file : 1;
   uint32_t auto_line : 1;
   uint32_t printf_format : 1;
};

struct ast_QualType_ {
   size_t ptr;
};

struct ast_Decl_ {
   union {
      ast_DeclBits declBits;
      ast_ImportDeclBits importDeclBits;
      ast_FunctionDeclBits functionDeclBits;
      ast_StructTypeDeclBits structTypeDeclBits;
      ast_EnumTypeDeclBits enumTypeDeclBits;
      ast_EnumConstantDeclBits enumConstantDeclBits;
      ast_VarDeclBits varDeclBits;
      uint32_t bits;
   };
   union {
      src_loc_SrcLoc loc;
      uint32_t gen_idx;
   };
   uint32_t name_idx;
   uint32_t ast_idx;
   ast_QualType qt;
};

static const char* ast_declCheckState_names[3] = { "unchecked", "in-progress", "checked" };

static const char* ast_declKind_names[8] = {
   "FunctionDecl",
   "ImportDecl",
   "StructTypeDecl",
   "EnumTypeDecl",
   "EnumConstantDecl",
   "FunctionType",
   "AliasTypeDecl",
   "VarDecl"
};

static void ast_Decl_init(ast_Decl* d, ast_DeclKind k, uint32_t name_idx, src_loc_SrcLoc loc, _Bool is_public, ast_QualType qt, uint32_t ast_idx);
static _Bool ast_Decl_hasGenIdx(const ast_Decl* d);
static void ast_Decl_setGenIdx(ast_Decl* d, uint32_t idx);
static uint32_t ast_Decl_getGenIdx(const ast_Decl* d);
static ast_DeclKind ast_Decl_getKind(const ast_Decl* d);
static ast_DeclCheckState ast_Decl_getCheckState(const ast_Decl* d);
static _Bool ast_Decl_isChecked(const ast_Decl* d);
static _Bool ast_Decl_isCheckInProgress(const ast_Decl* d);
static void ast_Decl_setChecked(ast_Decl* d);
static void ast_Decl_setCheckInProgress(ast_Decl* d);
static void ast_Decl_setHasAttr(ast_Decl* d);
static _Bool ast_Decl_hasAttr(const ast_Decl* d);
static void ast_Decl_setAttrExport(ast_Decl* d);
static void ast_Decl_setExportedIfPublic(ast_Decl* d);
static _Bool ast_Decl_isExported(const ast_Decl* d);
static _Bool ast_Decl_isGlobal(const ast_Decl* d);
static void ast_Decl_setAttrUnused(ast_Decl* d);
static _Bool ast_Decl_hasAttrUnused(const ast_Decl* d);
static _Bool ast_Decl_isStructType(const ast_Decl* d);
static _Bool ast_Decl_isImport(const ast_Decl* d);
static _Bool ast_Decl_isEnum(const ast_Decl* d);
static _Bool ast_Decl_isEnumConstant(const ast_Decl* d);
static _Bool ast_Decl_isFunction(const ast_Decl* d);
static _Bool ast_Decl_isVariable(const ast_Decl* d);
static const char* ast_Decl_getName(const ast_Decl* d);
static uint32_t ast_Decl_getNameIdx(const ast_Decl* d);
static const char* ast_Decl_getModuleName(const ast_Decl* d);
static src_loc_SrcLoc ast_Decl_getLoc(const ast_Decl* d);
static ast_QualType ast_Decl_getType(const ast_Decl* d);
static void ast_Decl_setType(ast_Decl* d, ast_QualType qt);
static ast_AST* ast_Decl_getAST(const ast_Decl* d);
static uint32_t ast_Decl_getASTIdx(const ast_Decl* d);
static ast_Module* ast_Decl_getModule(const ast_Decl* d);
static _Bool ast_Decl_isPublic(const ast_Decl* d);
static _Bool ast_Decl_isUsed(const ast_Decl* d);
static _Bool ast_Decl_isUsedPublic(const ast_Decl* d);
static void ast_Decl_setUsed(ast_Decl* d);
static void ast_Decl_clearUsed(ast_Decl* d);
static void ast_Decl_setUsedPublic(ast_Decl* d);
static _Bool ast_Decl_isExternal(const ast_Decl* d);
static void ast_Decl_setExternal(ast_Decl* d);
static _Bool ast_Decl_isGenerated(const ast_Decl* d);
static void ast_Decl_setGenerated(ast_Decl* d);
static void ast_Decl_clearGenerated(ast_Decl* d);
static void ast_Decl_dump(const ast_Decl* d);
static _Bool ast_Decl_isTypeDecl(const ast_Decl* d);
static _Bool ast_Decl_isVarDecl(const ast_Decl* d);
static const char* ast_Decl_getKindName(const ast_Decl* d);
static const char* ast_Decl_getCName(const ast_Decl* d);
static const char* ast_Decl_getCDef(const ast_Decl* d);
static const char* ast_Decl_getSection(const ast_Decl* d);
static const char* ast_Decl_getFullName(const ast_Decl* d);
static void ast_Decl_print(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent);
static void ast_Decl_printKind(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent, _Bool print_type);
static void ast_Decl_printName(const ast_Decl* d, string_buffer_Buf* out);
static void ast_Decl_printBits(const ast_Decl* d, string_buffer_Buf* out);
static void ast_Decl_printAttrs(const ast_Decl* d, string_buffer_Buf* out);
static void ast_Decl_printUsed(const ast_Decl* d, string_buffer_Buf* out);
struct ast_TypeRefBits_ {
   uint32_t is_const : 1;
   uint32_t is_volatile : 1;
   uint32_t num_ptrs : 2;
   uint32_t num_arrays : 2;
   uint32_t incr_array : 1;
   uint32_t is_user : 1;
   uint32_t has_prefix : 1;
   uint32_t builtin_kind : 4;
};

struct ast_Ref_ {
   src_loc_SrcLoc loc;
   uint32_t name_idx;
   ast_Decl* decl;
};

struct ast_TypeRef_ {
   union {
      ast_TypeRefBits flags;
      uint32_t flagBits;
   };
   union {
      uint32_t dest;
      src_loc_SrcLoc loc;
   };
   ast_Ref refs[0];
};

struct ast_AliasTypeDecl_ {
   ast_Decl base;
   ast_TypeRef typeRef;
};

static ast_AliasTypeDecl* ast_AliasTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* ref);
static ast_Decl* ast_AliasTypeDecl_asDecl(ast_AliasTypeDecl* d);
static ast_TypeRef* ast_AliasTypeDecl_getTypeRef(ast_AliasTypeDecl* d);
static void ast_AliasTypeDecl_print(const ast_AliasTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_ArrayValue_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   ast_Expr* value;
};

static ast_ArrayValue* ast_ArrayValue_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value);
static uint32_t ast_ArrayValue_getNameIdx(const ast_ArrayValue* d);
static src_loc_SrcLoc ast_ArrayValue_getLoc(const ast_ArrayValue* d);
static ast_Expr* ast_ArrayValue_getValue(const ast_ArrayValue* d);
static void ast_ArrayValue_print(const ast_ArrayValue* d, string_buffer_Buf* out);
#define ast_NumStmtBits 4
struct ast_StmtBits_ {
   uint32_t kind : 4;
};

struct ast_AsmStmtBits_ {
   uint32_t  : 4;
   uint32_t is_basic : 1;
   uint32_t is_volatile : 1;
};

struct ast_CompoundStmtBits_ {
   uint32_t  : 4;
   uint32_t count : 28;
};

struct ast_IfStmtBits_ {
   uint32_t  : 4;
   uint32_t has_else : 1;
};

struct ast_LabelStmtBits_ {
   uint32_t  : 4;
   uint32_t is_used : 1;
};

struct ast_ReturnStmtBits_ {
   uint32_t  : 4;
   uint32_t has_value : 1;
};

struct ast_SwitchStmtBits_ {
   uint32_t  : 4;
   uint32_t is_string : 1;
   uint32_t has_default : 1;
   uint32_t num_cases : 26;
};

struct ast_ExprBits_ {
   uint32_t  : 4;
   uint32_t kind : 5;
   uint32_t is_ctv : 1;
   uint32_t is_ctc : 1;
   uint32_t valtype : 2;
   uint32_t has_effect : 1;
};

#define ast_NumExprBits (ast_NumStmtBits + 10)
struct ast_ArraySubscriptExprBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_BinaryOperatorBits_ {
   uint32_t  : 14;
   uint32_t kind : 5;
};

struct ast_BitOffsetExprBits_ {
   uint32_t  : 14;
   uint32_t width : 8;
};

struct ast_BooleanLiteralBits_ {
   uint32_t  : 14;
   uint32_t value : 1;
};

struct ast_BuiltinExprBits_ {
   uint32_t  : 14;
   uint32_t kind : 3;
   uint32_t src_len : 15;
};

struct ast_CallExprBits_ {
   uint32_t  : 14;
   uint32_t calls_type_func : 1;
   uint32_t calls_static_sf : 1;
   uint32_t is_template_call : 1;
   uint32_t printf_format : 4;
   uint32_t change_format : 1;
   uint32_t has_auto_args : 1;
   uint32_t is_noreturn : 1;
   uint32_t num_args : 8;
};

struct ast_CharLiteralBits_ {
   uint32_t  : 14;
   uint32_t value : 8;
   uint32_t radix : 2;
   uint32_t src_len : 8;
};

struct ast_ExplicitCastExprBits_ {
   uint32_t  : 14;
   uint32_t c_style : 1;
   uint32_t src_len : 17;
};

struct ast_FieldDesignatorBits_ {
   uint32_t  : 14;
   uint32_t is_bitfield : 1;
   uint32_t bitfield_len : 7;
};

struct ast_FloatLiteralBits_ {
   uint32_t  : 14;
   uint32_t radix : 2;
   uint32_t src_len : 16;
};

struct ast_IdentifierExprBits_ {
   uint32_t  : 14;
   uint32_t has_decl : 1;
   uint32_t kind : 3;
};

struct ast_ImplicitCastBits_ {
   uint32_t  : 14;
   uint32_t kind : 3;
};

struct ast_InitListExprBits_ {
   uint32_t  : 14;
   uint32_t is_array : 1;
   uint32_t has_designators : 1;
};

struct ast_IntegerLiteralBits_ {
   uint32_t  : 14;
   uint32_t radix : 2;
   uint32_t is_signed : 1;
   uint32_t src_len : 15;
};

struct ast_MemberExprBits_ {
   uint32_t  : 14;
   uint32_t kind : 3;
   uint32_t num_refs : 3;
   uint32_t num_decls : 3;
   uint32_t has_expr : 1;
   uint32_t is_struct_func : 1;
   uint32_t is_static_sf : 1;
   uint32_t is_const_base : 1;
   uint32_t conversion : 2;
};

struct ast_ParenExprBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_StringLiteralBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_TypeExprBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_UnaryOperatorBits_ {
   uint32_t  : 14;
   uint32_t kind : 4;
};

struct ast_Stmt_ {
   union {
      ast_StmtBits stmtBits;
      ast_AsmStmtBits asmStmtBits;
      ast_CompoundStmtBits compoundStmtBits;
      ast_IfStmtBits ifStmtBits;
      ast_LabelStmtBits labelStmtBits;
      ast_ReturnStmtBits returnStmtBits;
      ast_SwitchStmtBits switchStmtBits;
      ast_ExprBits exprBits;
      ast_ArraySubscriptExprBits arraySubscriptExprBits;
      ast_BinaryOperatorBits binaryOperatorBits;
      ast_BitOffsetExprBits bitOffsetBits;
      ast_BooleanLiteralBits booleanLiteralBits;
      ast_BuiltinExprBits builtinExprBits;
      ast_CallExprBits callExprBits;
      ast_CharLiteralBits charLiteralBits;
      ast_ExplicitCastExprBits explicitCastExprBits;
      ast_FieldDesignatorBits fieldDesignatorBits;
      ast_FloatLiteralBits floatLiteralBits;
      ast_IdentifierExprBits identifierExprBits;
      ast_ImplicitCastBits implicitCastBits;
      ast_InitListExprBits initListExprBits;
      ast_IntegerLiteralBits integerLiteralBits;
      ast_MemberExprBits memberExprBits;
      ast_ParenExprBits parenExprBits;
      ast_StringLiteralBits stringLiteralBits;
      ast_TypeExprBits typeExprBits;
      ast_UnaryOperatorBits unaryOperatorBits;
      uint32_t bits;
   };
   src_loc_SrcLoc loc;
};

struct ast_DeclStmt_ {
   ast_Stmt base;
   ast_VarDecl* decl;
};

static ast_DeclStmt* ast_DeclStmt_create(ast_context_Context* c, ast_VarDecl* decl);
static ast_Stmt* ast_DeclStmt_instantiate(ast_DeclStmt* s, ast_Instantiator* inst);
static ast_VarDecl* ast_DeclStmt_getDecl(const ast_DeclStmt* d);
static void ast_DeclStmt_print(const ast_DeclStmt* s, string_buffer_Buf* out, uint32_t indent);
typedef enum {
   ast_ValueKind_Integer,
   ast_ValueKind_Float,
   _ast_ValueKind_max = 255
} __attribute__((packed)) ast_ValueKind;

struct ast_Value_ {
   ast_ValueKind kind;
   _Bool negative;
   _Bool overflow;
   union {
      uint64_t uvalue;
      double fvalue;
   };
};

struct ast_EnumConstantDecl_ {
   ast_Decl base;
   ast_Value value;
   ast_Expr* init[0];
};

static ast_EnumConstantDecl* ast_EnumConstantDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, ast_Expr* initValue);
static ast_Decl* ast_EnumConstantDecl_asDecl(ast_EnumConstantDecl* d);
static ast_Value ast_EnumConstantDecl_getValue(const ast_EnumConstantDecl* d);
static void ast_EnumConstantDecl_setValue(ast_EnumConstantDecl* d, ast_Value value);
static void ast_EnumConstantDecl_setIndex(ast_EnumConstantDecl* d, uint32_t index);
static uint32_t ast_EnumConstantDecl_getIndex(const ast_EnumConstantDecl* d);
static ast_Expr* ast_EnumConstantDecl_getInit(const ast_EnumConstantDecl* d);
static ast_Expr** ast_EnumConstantDecl_getInit2(ast_EnumConstantDecl* d);
static void ast_EnumConstantDecl_print(const ast_EnumConstantDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_EnumTypeDecl_ {
   ast_Decl base;
   ast_QualType implType;
   uint32_t num_enum_functions;
   ast_FunctionDecl** enum_functions;
   ast_EnumConstantDecl* constants[0];
   ast_EnumConstantDecl** incr_constants[0];
};

static ast_EnumTypeDecl* ast_EnumTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, ast_QualType implType, _Bool is_incremental, ast_EnumConstantDecl** constants, uint32_t num_constants);
static ast_QualType ast_EnumTypeDecl_getImplType(const ast_EnumTypeDecl* d);
static ast_Decl* ast_EnumTypeDecl_asDecl(ast_EnumTypeDecl* d);
static _Bool ast_EnumTypeDecl_isIncremental(const ast_EnumTypeDecl* d);
static uint32_t ast_EnumTypeDecl_getNumConstants(const ast_EnumTypeDecl* d);
static ast_EnumConstantDecl** ast_EnumTypeDecl_getConstants(ast_EnumTypeDecl* d);
static void ast_EnumTypeDecl_setIncrConstants(ast_EnumTypeDecl* d, ast_context_Context* c, ast_IdentifierExpr** constants, uint32_t count);
static ast_EnumConstantDecl* ast_EnumTypeDecl_findConstant(ast_EnumTypeDecl* d, uint32_t name_idx);
static ast_EnumConstantDecl* ast_EnumTypeDecl_getConstant(const ast_EnumTypeDecl* d, uint32_t idx);
static void ast_EnumTypeDecl_setEnumFunctions(ast_EnumTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count);
static ast_Decl* ast_EnumTypeDecl_findFunction(const ast_EnumTypeDecl* d, uint32_t name_idx);
static void ast_EnumTypeDecl_print(ast_EnumTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
typedef enum {
   ast_CallKind_Invalid,
   ast_CallKind_Normal,
   ast_CallKind_TypeFunc,
   ast_CallKind_StaticTypeFunc,
   _ast_CallKind_max = 255
} __attribute__((packed)) ast_CallKind;

struct ast_FunctionDeclFlags_ {
   uint16_t instance_ast_idx : 16;
   uint32_t num_auto_args : 4;
   uint32_t attr_unused_params : 1;
   uint32_t attr_noreturn : 1;
   uint32_t attr_inline : 1;
   uint32_t attr_weak : 1;
   uint32_t attr_constructor : 1;
   uint32_t attr_destructor : 1;
   uint32_t attr_pure : 1;
};

struct ast_FunctionDecl_ {
   ast_Decl base;
   ast_CompoundStmt* body;
   ast_QualType rt;
   uint8_t num_params;
   uint8_t attr_printf_arg;
   uint16_t instance_idx;
   uint32_t template_name;
   src_loc_SrcLoc template_loc;
   union {
      ast_FunctionDeclFlags flags;
      uint32_t flagBits;
   };
   ast_Ref prefix;
   ast_TypeRef rtype;
};

static const char* ast_callKind_names[4] = { "Invalid", "Normal", "SF", "SSF" };

static ast_FunctionDecl* ast_FunctionDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic, _Bool is_type);
static ast_FunctionDecl* ast_FunctionDecl_createTemplate(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic);
static ast_FunctionDecl* ast_FunctionDecl_instantiate(const ast_FunctionDecl* fd, ast_Instantiator* inst);
static void ast_FunctionDecl_setBody(ast_FunctionDecl* d, ast_CompoundStmt* body);
static ast_CompoundStmt* ast_FunctionDecl_getBody(const ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_isInline(const ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_isType(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setRType(ast_FunctionDecl* d, ast_QualType rt);
static ast_QualType ast_FunctionDecl_getRType(const ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasReturn(const ast_FunctionDecl* d);
static ast_Decl* ast_FunctionDecl_asDecl(ast_FunctionDecl* d);
static ast_TypeRef* ast_FunctionDecl_getReturnTypeRef(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasPrefix(const ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_isTemplate(const ast_FunctionDecl* d);
static uint32_t ast_FunctionDecl_getTemplateNameIdx(const ast_FunctionDecl* d);
static src_loc_SrcLoc ast_FunctionDecl_getTemplateLoc(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setTemplateInstanceIdx(ast_FunctionDecl* d, uint16_t idx);
static uint16_t ast_FunctionDecl_getTemplateInstanceIdx(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setInstanceName(ast_FunctionDecl* d, uint32_t name_idx);
static ast_Module* ast_FunctionDecl_getInstanceModule(ast_FunctionDecl* d);
static ast_Ref* ast_FunctionDecl_getPrefix(ast_FunctionDecl* d);
static const char* ast_FunctionDecl_getPrefixName(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setCallKind(ast_FunctionDecl* d, ast_CallKind kind);
static ast_CallKind ast_FunctionDecl_getCallKind(const ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_isVariadic(const ast_FunctionDecl* d);
static uint32_t ast_FunctionDecl_getNumParams(const ast_FunctionDecl* d);
static ast_VarDecl** ast_FunctionDecl_getParams(const ast_FunctionDecl* d);
static uint32_t ast_FunctionDecl_getNumAutoArgs(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setNumAutoArgs(ast_FunctionDecl* d, uint32_t num);
static void ast_FunctionDecl_setAttrUnusedParams(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrUnusedParams(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrNoReturn(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrNoReturn(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrInline(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrInline(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrWeak(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrWeak(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrConstructor(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrConstructor(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrDestructor(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrDestructor(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrPure(ast_FunctionDecl* d);
static _Bool ast_FunctionDecl_hasAttrPure(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrPrintf(ast_FunctionDecl* d, uint8_t arg);
static uint8_t ast_FunctionDecl_getAttrPrintf(const ast_FunctionDecl* d);
static const char* ast_FunctionDecl_getDiagKind(const ast_FunctionDecl* d);
static void ast_FunctionDecl_print(const ast_FunctionDecl* d, string_buffer_Buf* out, uint32_t indent);
static void ast_FunctionDecl_printType(const ast_FunctionDecl* d, string_buffer_Buf* out);
struct ast_FunctionTypeDecl_ {
   ast_Decl base;
   ast_FunctionDecl* func;
};

static ast_FunctionTypeDecl* ast_FunctionTypeDecl_create(ast_context_Context* c, ast_FunctionDecl* func);
static ast_Decl* ast_FunctionTypeDecl_asDecl(ast_FunctionTypeDecl* t);
static ast_FunctionDecl* ast_FunctionTypeDecl_getDecl(const ast_FunctionTypeDecl* d);
static void ast_FunctionTypeDecl_print(const ast_FunctionTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_ImportDecl_ {
   ast_Decl base;
   uint32_t alias_idx;
   src_loc_SrcLoc alias_loc;
   ast_Module* dest;
};

static ast_ImportDecl* ast_ImportDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, uint32_t ast_idx, _Bool is_local);
static ast_Decl* ast_ImportDecl_asDecl(ast_ImportDecl* d);
static const char* ast_ImportDecl_getAliasName(const ast_ImportDecl* d);
static uint32_t ast_ImportDecl_getAliasNameIdx(const ast_ImportDecl* d);
static uint32_t ast_ImportDecl_getImportNameIdx(const ast_ImportDecl* d);
static src_loc_SrcLoc ast_ImportDecl_getLoc(const ast_ImportDecl* d);
static void ast_ImportDecl_setDest(ast_ImportDecl* d, ast_Module* mod);
static ast_Module* ast_ImportDecl_getDest(const ast_ImportDecl* d);
static _Bool ast_ImportDecl_isLocal(const ast_ImportDecl* d);
static void ast_ImportDecl_print(const ast_ImportDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_StaticAssert_ {
   uint32_t ast_idx;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_StaticAssert* ast_StaticAssert_create(ast_context_Context* c, uint32_t ast_idx, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_AST* ast_StaticAssert_getAST(const ast_StaticAssert* d);
static ast_Expr* ast_StaticAssert_getLhs(const ast_StaticAssert* d);
static ast_Expr* ast_StaticAssert_getRhs(const ast_StaticAssert* d);
static void ast_StaticAssert_print(const ast_StaticAssert* d, string_buffer_Buf* out, uint32_t indent);
struct ast_StructLayout_ {
   uint32_t size;
   uint32_t alignment;
   uint32_t attr_alignment;
   uint32_t member_offsets[0];
};

struct ast_StructTypeDecl_ {
   ast_Decl base;
   uint32_t num_members;
   uint32_t num_struct_functions;
   ast_FunctionDecl** struct_functions;
   ast_Decl* members[0];
};

static ast_StructTypeDecl* ast_StructTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, _Bool is_struct, _Bool is_global, ast_Decl** members, uint32_t num_members);
static ast_Decl* ast_StructTypeDecl_asDecl(ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getNumMembers(const ast_StructTypeDecl* d);
static ast_Decl** ast_StructTypeDecl_getMembers(ast_StructTypeDecl* d);
static _Bool ast_StructTypeDecl_isStruct(const ast_StructTypeDecl* d);
static _Bool ast_StructTypeDecl_isUnion(const ast_StructTypeDecl* d);
static const ast_FunctionDecl** ast_StructTypeDecl_getStructFunctions(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getNumStructFunctions(const ast_StructTypeDecl* d);
static ast_StructLayout* ast_StructTypeDecl_getLayoutPtr(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setMemberOffset(ast_StructTypeDecl* d, uint32_t member_idx, uint32_t offset);
static uint32_t ast_StructTypeDecl_getMemberOffset(const ast_StructTypeDecl* d, uint32_t member_idx);
static const uint32_t* ast_StructTypeDecl_getMemberOffsets(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getSize(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setSizeAlignment(ast_StructTypeDecl* d, uint32_t size, uint32_t alignment);
static uint32_t ast_StructTypeDecl_getAlignment(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getAttrAlignment(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setAttrAlignment(ast_StructTypeDecl* d, uint32_t alignment);
static void ast_StructTypeDecl_setPacked(ast_StructTypeDecl* d);
static _Bool ast_StructTypeDecl_isPacked(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setOpaque(ast_StructTypeDecl* d);
static _Bool ast_StructTypeDecl_isOpaque(const ast_StructTypeDecl* d);
static _Bool ast_StructTypeDecl_isGlobal(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setAttrNoTypeDef(ast_StructTypeDecl* d);
static _Bool ast_StructTypeDecl_hasAttrNoTypeDef(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setStructFunctions(ast_StructTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count);
static ast_Decl* ast_StructTypeDecl_findAny(const ast_StructTypeDecl* s, uint32_t name_idx, uint32_t* offset);
static ast_Decl* ast_StructTypeDecl_findMember(const ast_StructTypeDecl* s, uint32_t name_idx, uint32_t* offset);
static void ast_StructTypeDecl_print(const ast_StructTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
union ast_FP64_ {
   double d;
   uint64_t bits;
};

static void ast_Value_setUnsigned(ast_Value* v, uint64_t uvalue);
static void ast_Value_setSigned(ast_Value* v, int64_t svalue);
static void ast_Value_setFloat(ast_Value* v, double fvalue);
static _Bool ast_Value_isNegative(const ast_Value* v);
static _Bool ast_Value_isFloat(const ast_Value* v);
static _Bool ast_Value_isDecimal(const ast_Value* v);
static _Bool ast_Value_isZero(const ast_Value* v);
static double ast_Value_toFloat(const ast_Value* v);
static uint8_t ast_Value_as_u8(ast_Value* v);
static uint16_t ast_Value_as_u16(ast_Value* v);
static int32_t ast_Value_as_i32(ast_Value* v);
static uint32_t ast_Value_as_u32(ast_Value* v);
static uint64_t ast_Value_as_u64(ast_Value* v);
static uint8_t ast_Value_getWidth(const ast_Value* v);
static _Bool ast_Value_checkRange(const ast_Value* v, int64_t min, uint64_t max);
static ast_Value ast_Value_negate(const ast_Value* v);
static ast_Value ast_Value_bitnot(const ast_Value* v);
static ast_Value ast_Value_lnot(const ast_Value* v);
static ast_Value ast_Value_minus(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_add(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_multiply(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_divide(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_remainder(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_left_shift(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_right_shift(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_and(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_or(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_xor(const ast_Value* v1, const ast_Value* v2);
static _Bool ast_Value_to_bool(const ast_Value* v);
static _Bool ast_Value_is_equal(const ast_Value* v1, const ast_Value* v2);
static _Bool ast_Value_is_less(const ast_Value* v1, const ast_Value* v2);
static _Bool ast_Value_is_less_equal(const ast_Value* v1, const ast_Value* v2);
static _Bool ast_Value_is_greater(const ast_Value* v1, const ast_Value* v2);
static _Bool ast_Value_is_greater_equal(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_land(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_lor(const ast_Value* v1, const ast_Value* v2);
static void ast_Value_mask(ast_Value* v, uint32_t width);
static void ast_Value_truncate(ast_Value* orig, _Bool is_signed, uint32_t width);
static void ast_Value_incr(ast_Value* v);
static void ast_Value_decr(ast_Value* v);
static _Bool ast_isfinite(double d);
static int32_t ast_signbit(double d);
static double ast_fabs(double d);
static char* ast_ftoa(char* dest, size_t size, double d);
static const char* ast_Value_str(const ast_Value* v);
typedef enum {
   ast_VarDeclKind_GlobalVar,
   ast_VarDeclKind_LocalVar,
   ast_VarDeclKind_FunctionParam,
   ast_VarDeclKind_StructMember,
   _ast_VarDeclKind_max = 255
} __attribute__((packed)) ast_VarDeclKind;

struct ast_VarDecl_ {
   ast_Decl base;
   ast_TypeRef typeRef;
};

static const char* ast_varDeclNames[4] = { " global", " local", " parameter", " member" };

static ast_VarDecl* ast_VarDecl_create(ast_context_Context* c, ast_VarDeclKind kind, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, src_loc_SrcLoc assignLoc, ast_Expr* initValue);
static ast_VarDecl* ast_VarDecl_createStructMember(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, ast_Expr* bitfield);
static ast_VarDecl* ast_VarDecl_instantiate(const ast_VarDecl* vd, ast_Instantiator* inst);
static const char* ast_VarDecl_getName(const ast_VarDecl* d);
static ast_Decl* ast_VarDecl_asDecl(ast_VarDecl* d);
static ast_VarDeclKind ast_VarDecl_getKind(const ast_VarDecl* d);
static _Bool ast_VarDecl_isGlobal(const ast_VarDecl* d);
static _Bool ast_VarDecl_isLocal(const ast_VarDecl* d);
static _Bool ast_VarDecl_isParameter(const ast_VarDecl* d);
static _Bool ast_VarDecl_isStructMember(const ast_VarDecl* d);
static _Bool ast_VarDecl_isAddrUsed(const ast_VarDecl* d);
static void ast_VarDecl_setAddrUsed(ast_VarDecl* d);
static ast_TypeRef* ast_VarDecl_getTypeRef(ast_VarDecl* d);
static src_loc_SrcLoc ast_VarDecl_getAssignLoc(const ast_VarDecl* d);
static ast_Expr* ast_VarDecl_getInit(const ast_VarDecl* d);
static ast_Expr** ast_VarDecl_getInit2(ast_VarDecl* d);
static void ast_VarDecl_setInit(ast_VarDecl* d, ast_Expr* initValue);
static ast_Expr* ast_VarDecl_getBitfield(const ast_VarDecl* d);
static _Bool ast_VarDecl_hasLocalQualifier(const ast_VarDecl* d);
static void ast_VarDecl_setLocal(ast_VarDecl* d, _Bool has_local);
static void ast_VarDecl_setInitCall(ast_VarDecl* d, _Bool has_init_call);
static _Bool ast_VarDecl_hasInitCall(ast_VarDecl* d);
static void ast_VarDecl_setAttrWeak(ast_VarDecl* d);
static _Bool ast_VarDecl_hasAttrWeak(const ast_VarDecl* d);
static void ast_VarDecl_setAttrAutoFile(ast_VarDecl* d);
static _Bool ast_VarDecl_hasAttrAutoFile(const ast_VarDecl* d);
static void ast_VarDecl_setAttrAutoLine(ast_VarDecl* d);
static _Bool ast_VarDecl_hasAttrAutoLine(const ast_VarDecl* d);
static _Bool ast_VarDecl_hasAutoAttr(const ast_VarDecl* d);
static void ast_VarDecl_setPrintfFormat(ast_VarDecl* d);
static _Bool ast_VarDecl_hasPrintfFormat(const ast_VarDecl* d);
static void ast_VarDecl_print(const ast_VarDecl* d, string_buffer_Buf* out, uint32_t indent);
static void ast_VarDecl_printType(const ast_VarDecl* d, string_buffer_Buf* out);
typedef enum {
   ast_StmtKind_Return,
   ast_StmtKind_Expr,
   ast_StmtKind_If,
   ast_StmtKind_While,
   ast_StmtKind_For,
   ast_StmtKind_Switch,
   ast_StmtKind_Break,
   ast_StmtKind_Continue,
   ast_StmtKind_Fallthrough,
   ast_StmtKind_Label,
   ast_StmtKind_Goto,
   ast_StmtKind_Compound,
   ast_StmtKind_Decl,
   ast_StmtKind_Asm,
   ast_StmtKind_Assert,
   _ast_StmtKind_max = 255
} __attribute__((packed)) ast_StmtKind;

static const char* ast_stmtKind_names[15] = {
   "ReturnStmt",
   "ExprStmt",
   "IfStmt",
   "WhileStmt",
   "ForStmt",
   "SwitchStmt",
   "BreakStmt",
   "ContinueStmt",
   "FallthroughStmt",
   "LabelStmt",
   "GotoStmt",
   "CompoundStmt",
   "DeclStmt",
   "Asm",
   "AssertStmt"
};

static void ast_Stmt_init(ast_Stmt* s, ast_StmtKind k, src_loc_SrcLoc loc);
static ast_Stmt* ast_Stmt_instantiate(ast_Stmt* s, ast_Instantiator* inst);
static ast_StmtKind ast_Stmt_getKind(const ast_Stmt* s);
static _Bool ast_Stmt_isReturn(const ast_Stmt* s);
static _Bool ast_Stmt_isExpr(const ast_Stmt* s);
static _Bool ast_Stmt_isCompound(const ast_Stmt* s);
static _Bool ast_Stmt_isFallthrough(const ast_Stmt* s);
static _Bool ast_Stmt_isDecl(const ast_Stmt* s);
static _Bool ast_Stmt_isLabel(const ast_Stmt* s);
static src_loc_SrcLoc ast_Stmt_getLoc(const ast_Stmt* s);
static void ast_Stmt_dump(const ast_Stmt* s);
static void ast_Stmt_print(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent);
static void ast_Stmt_printKind(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_AsmStmt_ {
   ast_Stmt base;
   ast_StringLiteral* asm_string;
   uint8_t num_constraints;
   uint8_t num_exprs;
   uint8_t num_clobbers;
   uint8_t num_outputs;
   uint8_t num_inputs;
   uint8_t pad[2];
   ast_Expr* constraints[0];
   ast_Expr* exprs[0];
   ast_Expr* clobbers[0];
   uint32_t names[0];
};

static ast_AsmStmt* ast_AsmStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, _Bool is_basic, _Bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* str);
static ast_Stmt* ast_AsmStmt_instantiate(ast_AsmStmt* s, ast_Instantiator* inst);
static _Bool ast_AsmStmt_isVolatile(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumConstraints(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumClobbers(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumExprs(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumOutputs(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumInputs(const ast_AsmStmt* s);
static ast_StringLiteral* ast_AsmStmt_getString(const ast_AsmStmt* s);
static const ast_Expr** ast_AsmStmt_getConstraints(const ast_AsmStmt* s);
static ast_Expr** ast_AsmStmt_getExprs(const ast_AsmStmt* s);
static ast_Expr** ast_AsmStmt_getClobbers(const ast_AsmStmt* s);
static uint32_t* ast_AsmStmt_getNames(const ast_AsmStmt* s);
static void ast_AsmStmt_print(const ast_AsmStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_AssertStmt_ {
   ast_Stmt base;
   ast_Expr* inner;
};

static ast_AssertStmt* ast_AssertStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* inner);
static ast_Stmt* ast_AssertStmt_instantiate(ast_AssertStmt* s, ast_Instantiator* inst);
static ast_Expr* ast_AssertStmt_getInner(const ast_AssertStmt* s);
static ast_Expr** ast_AssertStmt_getInner2(ast_AssertStmt* s);
static void ast_AssertStmt_print(const ast_AssertStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_BreakStmt_ {
   ast_Stmt base;
};

static ast_BreakStmt* ast_BreakStmt_create(ast_context_Context* c, src_loc_SrcLoc loc);
static void ast_BreakStmt_print(const ast_BreakStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_CompoundStmt_ {
   ast_Stmt base;
   ast_Stmt* stmts[0];
};

static ast_CompoundStmt* ast_CompoundStmt_create(ast_context_Context* c, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count);
static ast_CompoundStmt* ast_CompoundStmt_instantiate(ast_CompoundStmt* s, ast_Instantiator* inst);
static uint32_t ast_CompoundStmt_getCount(const ast_CompoundStmt* s);
static ast_Stmt** ast_CompoundStmt_getStmts(ast_CompoundStmt* s);
static ast_Stmt* ast_CompoundStmt_getLastStmt(const ast_CompoundStmt* s);
static src_loc_SrcLoc ast_CompoundStmt_getEndLoc(const ast_CompoundStmt* e);
static void ast_CompoundStmt_print(const ast_CompoundStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_ContinueStmt_ {
   ast_Stmt base;
};

static ast_ContinueStmt* ast_ContinueStmt_create(ast_context_Context* c, src_loc_SrcLoc loc);
static void ast_ContinueStmt_print(const ast_ContinueStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_FallthroughStmt_ {
   ast_Stmt base;
};

static ast_FallthroughStmt* ast_FallthroughStmt_create(ast_context_Context* c, src_loc_SrcLoc loc);
static void ast_FallthroughStmt_print(const ast_FallthroughStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_ForStmt_ {
   ast_Stmt base;
   ast_Stmt* init;
   ast_Expr* cond;
   ast_Expr* cont;
   ast_Stmt* body;
};

static ast_ForStmt* ast_ForStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* cont, ast_Stmt* body);
static ast_Stmt* ast_ForStmt_instantiate(ast_ForStmt* s, ast_Instantiator* inst);
static ast_Stmt* ast_ForStmt_getInit(const ast_ForStmt* s);
static ast_Expr* ast_ForStmt_getCond(const ast_ForStmt* s);
static ast_Expr* ast_ForStmt_getCont(const ast_ForStmt* s);
static ast_Stmt* ast_ForStmt_getBody(const ast_ForStmt* s);
static ast_Stmt** ast_ForStmt_getInit2(ast_ForStmt* s);
static ast_Expr** ast_ForStmt_getCond2(ast_ForStmt* s);
static ast_Expr** ast_ForStmt_getCont2(ast_ForStmt* s);
static void ast_ForStmt_print(const ast_ForStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_GotoStmt_ {
   ast_Stmt base;
   uint32_t name;
};

static ast_GotoStmt* ast_GotoStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc);
static const char* ast_GotoStmt_getName(const ast_GotoStmt* g);
static uint32_t ast_GotoStmt_getNameIdx(const ast_GotoStmt* g);
static void ast_GotoStmt_print(const ast_GotoStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_IfStmt_ {
   ast_Stmt base;
   ast_Stmt* cond;
   ast_Stmt* then;
   ast_Stmt* else_stmt[0];
};

static ast_IfStmt* ast_IfStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt);
static ast_Stmt* ast_IfStmt_instantiate(ast_IfStmt* s, ast_Instantiator* inst);
static ast_Stmt* ast_IfStmt_getCond(const ast_IfStmt* s);
static ast_Stmt** ast_IfStmt_getCond2(ast_IfStmt* s);
static ast_Stmt* ast_IfStmt_getThen(const ast_IfStmt* s);
static ast_Stmt* ast_IfStmt_getElse(const ast_IfStmt* s);
static void ast_IfStmt_print(const ast_IfStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_LabelStmt_ {
   ast_Stmt base;
   uint32_t name;
   ast_Stmt* stmt;
};

static ast_LabelStmt* ast_LabelStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt);
static ast_Stmt* ast_LabelStmt_instantiate(ast_LabelStmt* s, ast_Instantiator* inst);
static void ast_LabelStmt_setUsed(ast_LabelStmt* s);
static _Bool ast_LabelStmt_isUsed(const ast_LabelStmt* s);
static const char* ast_LabelStmt_getName(const ast_LabelStmt* s);
static uint32_t ast_LabelStmt_getNameIdx(const ast_LabelStmt* s);
static ast_Stmt* ast_LabelStmt_getStmt(const ast_LabelStmt* s);
static void ast_LabelStmt_print(const ast_LabelStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_ReturnStmt_ {
   ast_Stmt base;
   ast_Expr* value[0];
};

static ast_ReturnStmt* ast_ReturnStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* value);
static ast_Stmt* ast_ReturnStmt_instantiate(ast_ReturnStmt* s, ast_Instantiator* inst);
static ast_Expr* ast_ReturnStmt_getValue(const ast_ReturnStmt* s);
static ast_Expr** ast_ReturnStmt_getValue2(ast_ReturnStmt* s);
static void ast_ReturnStmt_print(const ast_ReturnStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_SwitchCaseBits_ {
   uint32_t num_conds : 8;
   uint32_t num_stmts : 10;
   uint32_t is_default : 1;
   uint32_t has_decls : 1;
   uint32_t has_fallthrough : 1;
};

struct ast_SwitchCase_ {
   union {
      ast_SwitchCaseBits bits;
      uint32_t allbits;
   };
   src_loc_SrcLoc loc;
   ast_Expr* conds[0];
};

static ast_SwitchCase* ast_SwitchCase_create(ast_context_Context* c, src_loc_SrcLoc loc, _Bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts);
static ast_SwitchCase* ast_SwitchCase_instantiate(ast_SwitchCase* src, ast_Instantiator* inst);
static uint32_t ast_SwitchCase_getNumConds(const ast_SwitchCase* s);
static ast_Expr* ast_SwitchCase_getCond(ast_SwitchCase* s, uint32_t index);
static uint32_t ast_SwitchCase_getNumStmts(const ast_SwitchCase* s);
static ast_Stmt** ast_SwitchCase_getStmts(ast_SwitchCase* s);
static ast_Stmt* ast_SwitchCase_getStmt(const ast_SwitchCase* s, uint32_t n);
static _Bool ast_SwitchCase_isDefault(const ast_SwitchCase* s);
static _Bool ast_SwitchCase_hasDecls(const ast_SwitchCase* s);
static void ast_SwitchCase_setHasDecls(ast_SwitchCase* s);
static void ast_SwitchCase_setHasFallthrough(ast_SwitchCase* s);
static _Bool ast_SwitchCase_hasFallthrough(const ast_SwitchCase* s);
static src_loc_SrcLoc ast_SwitchCase_getLoc(const ast_SwitchCase* s);
static void ast_SwitchCase_print(const ast_SwitchCase* s, string_buffer_Buf* out, uint32_t indent);
struct ast_SwitchStmt_ {
   ast_Stmt base;
   ast_Expr* cond;
   ast_SwitchCase* cases[0];
};

static ast_SwitchStmt* ast_SwitchStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* cond, ast_SwitchCase** cases, uint32_t numCases, _Bool has_default);
static ast_Stmt* ast_SwitchStmt_instantiate(ast_SwitchStmt* s, ast_Instantiator* inst);
static ast_Expr* ast_SwitchStmt_getCond(const ast_SwitchStmt* s);
static ast_Expr** ast_SwitchStmt_getCond2(ast_SwitchStmt* s);
static _Bool ast_SwitchStmt_isString(const ast_SwitchStmt* s);
static void ast_SwitchStmt_setString(ast_SwitchStmt* s);
static _Bool ast_SwitchStmt_hasDefault(const ast_SwitchStmt* s);
static uint32_t ast_SwitchStmt_getNumCases(const ast_SwitchStmt* s);
static ast_SwitchCase** ast_SwitchStmt_getCases(ast_SwitchStmt* s);
static void ast_SwitchStmt_print(const ast_SwitchStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_WhileStmt_ {
   ast_Stmt base;
   ast_Stmt* cond;
   ast_Stmt* body;
};

static ast_WhileStmt* ast_WhileStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* body);
static ast_Stmt* ast_WhileStmt_instantiate(ast_WhileStmt* s, ast_Instantiator* inst);
static void ast_WhileStmt_print(const ast_WhileStmt* s, string_buffer_Buf* out, uint32_t indent);
static ast_Stmt* ast_WhileStmt_getCond(const ast_WhileStmt* s);
static ast_Stmt** ast_WhileStmt_getCond2(ast_WhileStmt* s);
static ast_Stmt* ast_WhileStmt_getBody(const ast_WhileStmt* s);
typedef enum {
   ast_ExprKind_IntegerLiteral,
   ast_ExprKind_FloatLiteral,
   ast_ExprKind_BooleanLiteral,
   ast_ExprKind_CharLiteral,
   ast_ExprKind_StringLiteral,
   ast_ExprKind_Nil,
   ast_ExprKind_Identifier,
   ast_ExprKind_Type,
   ast_ExprKind_Call,
   ast_ExprKind_InitList,
   ast_ExprKind_FieldDesignatedInit,
   ast_ExprKind_ArrayDesignatedInit,
   ast_ExprKind_BinaryOperator,
   ast_ExprKind_UnaryOperator,
   ast_ExprKind_ConditionalOperator,
   ast_ExprKind_Builtin,
   ast_ExprKind_ArraySubscript,
   ast_ExprKind_Member,
   ast_ExprKind_Paren,
   ast_ExprKind_BitOffset,
   ast_ExprKind_ExplicitCast,
   ast_ExprKind_ImplicitCast,
   ast_ExprKind_Range,
   _ast_ExprKind_max = 255
} __attribute__((packed)) ast_ExprKind;

typedef enum {
   ast_ValType_NValue,
   ast_ValType_RValue,
   ast_ValType_LValue,
   _ast_ValType_max = 255
} __attribute__((packed)) ast_ValType;

struct ast_Expr_ {
   ast_Stmt base;
   ast_QualType qt;
};

static const char* ast_exprKind_names[23] = {
   "IntegerLiteral",
   "FloatLiteral",
   "BooleanLiteral",
   "CharLiteral",
   "StringLiteral",
   "Nil",
   "Identifier",
   "TypeExpr",
   "Call",
   "InitList",
   "FieldDesignatedInit",
   "ArrayDesignatedInit",
   "BinaryOperator",
   "UnaryOperator",
   "ConditionalOp",
   "Builtin",
   "ArraySubscript",
   "Member",
   "Paren",
   "BitOffset",
   "ExplicitCast",
   "ImplicitCast",
   "RangeExpr"
};

static const char* ast_valType_names[3] = { "nvalue", "rvalue", "lvalue" };

static void ast_Expr_init(ast_Expr* e, ast_ExprKind k, src_loc_SrcLoc loc, _Bool ctv, _Bool ctc, _Bool has_effect, ast_ValType valtype);
static ast_Expr* ast_Expr_instantiate(ast_Expr* e, ast_Instantiator* inst);
static ast_Stmt* ast_Expr_asStmt(ast_Expr* e);
static ast_ExprKind ast_Expr_getKind(const ast_Expr* e);
static _Bool ast_Expr_isStringLiteral(const ast_Expr* e);
static _Bool ast_Expr_isNil(const ast_Expr* e);
static _Bool ast_Expr_isIdentifier(const ast_Expr* e);
static _Bool ast_Expr_isCall(const ast_Expr* e);
static _Bool ast_Expr_isUnaryOp(const ast_Expr* e);
static _Bool ast_Expr_isImplicitCast(const ast_Expr* e);
static _Bool ast_Expr_isType(const ast_Expr* e);
static _Bool ast_Expr_isInitList(const ast_Expr* e);
static _Bool ast_Expr_isTilde(const ast_Expr* e);
static _Bool ast_Expr_isBinaryOperator(const ast_Expr* e);
static _Bool ast_Expr_isMember(const ast_Expr* e);
static _Bool ast_Expr_isFieldDesignatedInit(const ast_Expr* e);
static _Bool ast_Expr_isArrayDesignatedInit(const ast_Expr* e);
static _Bool ast_Expr_isBitOffset(const ast_Expr* e);
static _Bool ast_Expr_isParen(const ast_Expr* e);
static _Bool ast_Expr_isRange(const ast_Expr* e);
static _Bool ast_Expr_isAssignment(const ast_Expr* e);
static _Bool ast_Expr_isInitlistAssignment(const ast_Expr* e);
static _Bool ast_Expr_isCtv(const ast_Expr* e);
static _Bool ast_Expr_isCtc(const ast_Expr* e);
static void ast_Expr_setCtv(ast_Expr* e);
static void ast_Expr_setCtc(ast_Expr* e);
static void ast_Expr_copyCtcFlags(ast_Expr* e, const ast_Expr* other);
static void ast_Expr_copyConstantFlags(ast_Expr* e, const ast_Expr* other);
static void ast_Expr_combineConstantFlags(ast_Expr* e, const ast_Expr* lhs, const ast_Expr* rhs);
static _Bool ast_Expr_hasEffect(const ast_Expr* e);
static ast_ValType ast_Expr_getValType(const ast_Expr* e);
static _Bool ast_Expr_isNValue(const ast_Expr* e);
static _Bool ast_Expr_isLValue(const ast_Expr* e);
static void ast_Expr_setLValue(ast_Expr* e);
static void ast_Expr_setRValue(ast_Expr* e);
static void ast_Expr_copyValType(ast_Expr* e, const ast_Expr* other);
static src_loc_SrcLoc ast_Expr_getLoc(const ast_Expr* e);
static src_loc_SrcLoc ast_Expr_getStartLoc(const ast_Expr* e);
static src_loc_SrcLoc ast_Expr_getEndLoc(const ast_Expr* e);
static src_loc_SrcRange ast_Expr_getRange(const ast_Expr* e);
static void ast_Expr_setType(ast_Expr* e, ast_QualType qt);
static ast_QualType ast_Expr_getType(const ast_Expr* e);
static void ast_Expr_dump(const ast_Expr* e);
static void ast_Expr_print(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_Expr_printLiteral(const ast_Expr* e, string_buffer_Buf* out);
static void ast_Expr_printKind(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_Expr_printTypeBits(const ast_Expr* e, string_buffer_Buf* out);
struct ast_ArrayDesignatedInitExpr_ {
   ast_Expr base;
   ast_Expr* designator;
   ast_Expr* initValue;
};

static ast_ArrayDesignatedInitExpr* ast_ArrayDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue);
static ast_Expr* ast_ArrayDesignatedInitExpr_instantiate(ast_ArrayDesignatedInitExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_ArrayDesignatedInitExpr_getDesignator(const ast_ArrayDesignatedInitExpr* e);
static ast_Expr** ast_ArrayDesignatedInitExpr_getDesignator2(ast_ArrayDesignatedInitExpr* e);
static ast_Expr* ast_ArrayDesignatedInitExpr_getInit(const ast_ArrayDesignatedInitExpr* e);
static ast_Expr** ast_ArrayDesignatedInitExpr_getInit2(ast_ArrayDesignatedInitExpr* e);
static src_loc_SrcLoc ast_ArrayDesignatedInitExpr_getEndLoc(const ast_ArrayDesignatedInitExpr* e);
static void ast_ArrayDesignatedInitExpr_print(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_ArrayDesignatedInitExpr_printLiteral(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out);
struct ast_ArraySubscriptExpr_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* idx;
};

static ast_ArraySubscriptExpr* ast_ArraySubscriptExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* lhs, ast_Expr* idx);
static ast_Expr* ast_ArraySubscriptExpr_instantiate(ast_ArraySubscriptExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_ArraySubscriptExpr_getBase(const ast_ArraySubscriptExpr* e);
static ast_Expr** ast_ArraySubscriptExpr_getBase2(ast_ArraySubscriptExpr* e);
static ast_Expr* ast_ArraySubscriptExpr_getIndex(const ast_ArraySubscriptExpr* e);
static ast_Expr** ast_ArraySubscriptExpr_getIndex2(ast_ArraySubscriptExpr* e);
static src_loc_SrcLoc ast_ArraySubscriptExpr_getStartLoc(const ast_ArraySubscriptExpr* e);
static src_loc_SrcLoc ast_ArraySubscriptExpr_getEndLoc(const ast_ArraySubscriptExpr* e);
static void ast_ArraySubscriptExpr_printLiteral(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out);
static void ast_ArraySubscriptExpr_print(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out, uint32_t indent);
typedef enum {
   ast_BinaryOpcode_Multiply,
   ast_BinaryOpcode_Divide,
   ast_BinaryOpcode_Remainder,
   ast_BinaryOpcode_Add,
   ast_BinaryOpcode_Subtract,
   ast_BinaryOpcode_ShiftLeft,
   ast_BinaryOpcode_ShiftRight,
   ast_BinaryOpcode_LessThan,
   ast_BinaryOpcode_GreaterThan,
   ast_BinaryOpcode_LessEqual,
   ast_BinaryOpcode_GreaterEqual,
   ast_BinaryOpcode_Equal,
   ast_BinaryOpcode_NotEqual,
   ast_BinaryOpcode_And,
   ast_BinaryOpcode_Xor,
   ast_BinaryOpcode_Or,
   ast_BinaryOpcode_LAnd,
   ast_BinaryOpcode_LOr,
   ast_BinaryOpcode_Assign,
   ast_BinaryOpcode_MulAssign,
   ast_BinaryOpcode_DivAssign,
   ast_BinaryOpcode_RemAssign,
   ast_BinaryOpcode_AddAssign,
   ast_BinaryOpcode_SubAssign,
   ast_BinaryOpcode_ShlAssign,
   ast_BinaryOpcode_ShrAssign,
   ast_BinaryOpcode_AndAssign,
   ast_BinaryOpcode_XorAssign,
   ast_BinaryOpcode_OrAssign,
   _ast_BinaryOpcode_max = 255
} __attribute__((packed)) ast_BinaryOpcode;

struct ast_BinaryOperator_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static const char* ast_binaryOpcode_names[29] = {
   "*",
   "/",
   "%",
   "+",
   "-",
   "<<",
   ">>",
   "<",
   ">",
   "<=",
   ">=",
   "==",
   "!=",
   "&",
   "^",
   "|",
   "&&",
   "||",
   "=",
   "*=",
   "/=",
   "%=",
   "+=",
   "-=",
   "<<=",
   ">>=",
   "&=",
   "^=",
   "|="
};

static _Bool ast_BinaryOpcode_isComparison(ast_BinaryOpcode opcode);
static ast_BinaryOperator* ast_BinaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_BinaryOpcode kind, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_BinaryOperator_instantiate(ast_BinaryOperator* e, ast_Instantiator* inst);
static ast_BinaryOpcode ast_BinaryOperator_getOpcode(const ast_BinaryOperator* e);
static ast_Expr* ast_BinaryOperator_getLHS(const ast_BinaryOperator* e);
static ast_Expr** ast_BinaryOperator_getLHS2(ast_BinaryOperator* e);
static ast_Expr* ast_BinaryOperator_getRHS(const ast_BinaryOperator* e);
static ast_Expr** ast_BinaryOperator_getRHS2(ast_BinaryOperator* e);
static const char* ast_BinaryOperator_getOpcodeStr(const ast_BinaryOperator* e);
static src_loc_SrcLoc ast_BinaryOperator_getStartLoc(const ast_BinaryOperator* e);
static src_loc_SrcLoc ast_BinaryOperator_getEndLoc(const ast_BinaryOperator* e);
static void ast_BinaryOperator_print(const ast_BinaryOperator* e, string_buffer_Buf* out, uint32_t indent);
static void ast_BinaryOperator_printLiteral(const ast_BinaryOperator* e, string_buffer_Buf* out);
static _Bool ast_BinaryOperator_needsSemi(const ast_BinaryOperator* e);
struct ast_BitOffsetExpr_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_BitOffsetExpr* ast_BitOffsetExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_BitOffsetExpr_instantiate(ast_BitOffsetExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_BitOffsetExpr_getLHS(ast_BitOffsetExpr* e);
static ast_Expr** ast_BitOffsetExpr_getLHS2(ast_BitOffsetExpr* e);
static ast_Expr* ast_BitOffsetExpr_getRHS(ast_BitOffsetExpr* e);
static ast_Expr** ast_BitOffsetExpr_getRHS2(ast_BitOffsetExpr* e);
static void ast_BitOffsetExpr_setWidth(ast_BitOffsetExpr* e, uint8_t width);
static uint32_t ast_BitOffsetExpr_getWidth(const ast_BitOffsetExpr* e);
static src_loc_SrcLoc ast_BitOffsetExpr_getStartLoc(const ast_BitOffsetExpr* e);
static src_loc_SrcLoc ast_BitOffsetExpr_getEndLoc(const ast_BitOffsetExpr* e);
static void ast_BitOffsetExpr_printLiteral(const ast_BitOffsetExpr* e, string_buffer_Buf* out);
static void ast_BitOffsetExpr_print(const ast_BitOffsetExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_BooleanLiteral_ {
   ast_Expr base;
};

static ast_BooleanLiteral* ast_BooleanLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, _Bool val);
static _Bool ast_BooleanLiteral_getValue(const ast_BooleanLiteral* e);
static src_loc_SrcLoc ast_BooleanLiteral_getEndLoc(const ast_BooleanLiteral* e);
static void ast_BooleanLiteral_print(const ast_BooleanLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_BooleanLiteral_printLiteral(const ast_BooleanLiteral* e, string_buffer_Buf* out);
typedef enum {
   ast_BuiltinExprKind_Sizeof,
   ast_BuiltinExprKind_Elemsof,
   ast_BuiltinExprKind_EnumMin,
   ast_BuiltinExprKind_EnumMax,
   ast_BuiltinExprKind_OffsetOf,
   ast_BuiltinExprKind_ToContainer,
   _ast_BuiltinExprKind_max = 255
} __attribute__((packed)) ast_BuiltinExprKind;

struct ast_ToContainerData_ {
   ast_Expr* member;
   ast_Expr* pointer;
};

struct ast_OffsetOfData_ {
   ast_Expr* member;
};

struct ast_BuiltinExpr_ {
   ast_Expr base;
   ast_Expr* inner;
   ast_Value value;
   ast_OffsetOfData offset[0];
   ast_ToContainerData container[0];
};

static const char* ast_builtin_names[6] = { "sizeof", "elemsof", "enum_min", "enum_max", "offsetof", "to_container" };

static ast_BuiltinExpr* ast_BuiltinExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind);
static ast_BuiltinExpr* ast_BuiltinExpr_createOffsetOf(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member);
static ast_BuiltinExpr* ast_BuiltinExpr_createToContainer(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member, ast_Expr* pointer);
static ast_Expr* ast_BuiltinExpr_instantiate(ast_BuiltinExpr* e, ast_Instantiator* inst);
static ast_BuiltinExprKind ast_BuiltinExpr_getKind(const ast_BuiltinExpr* e);
static ast_Value ast_BuiltinExpr_getValue(const ast_BuiltinExpr* e);
static void ast_BuiltinExpr_setValue(ast_BuiltinExpr* e, ast_Value value);
static void ast_BuiltinExpr_setUValue(ast_BuiltinExpr* e, uint64_t val);
static ast_Expr* ast_BuiltinExpr_getInner(const ast_BuiltinExpr* e);
static src_loc_SrcLoc ast_BuiltinExpr_getEndLoc(const ast_BuiltinExpr* e);
static ast_Expr* ast_BuiltinExpr_getOffsetOfMember(const ast_BuiltinExpr* b);
static ast_Expr* ast_BuiltinExpr_getToContainerMember(const ast_BuiltinExpr* b);
static ast_Expr* ast_BuiltinExpr_getToContainerPointer(const ast_BuiltinExpr* b);
static ast_Expr** ast_BuiltinExpr_getToContainerPointer2(ast_BuiltinExpr* b);
static void ast_BuiltinExpr_print(const ast_BuiltinExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_BuiltinExpr_printLiteral(const ast_BuiltinExpr* e, string_buffer_Buf* out);
struct ast_CallExpr_ {
   ast_Expr base;
   src_loc_SrcLoc endLoc;
   uint16_t template_idx;
   uint16_t instance_ast_idx;
   ast_Expr* func;
   ast_Expr* args[0];
};

static ast_CallExpr* ast_CallExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args);
static ast_CallExpr* ast_CallExpr_createTemplate(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, uint32_t ast_idx, const ast_TypeRefHolder* ref);
static ast_Expr* ast_CallExpr_instantiate(ast_CallExpr* e, ast_Instantiator* inst);
static void ast_CallExpr_setCallsTypeFunc(ast_CallExpr* e);
static _Bool ast_CallExpr_isTypeFunc(const ast_CallExpr* e);
static void ast_CallExpr_setCallsStaticTypeFunc(ast_CallExpr* e);
static _Bool ast_CallExpr_isStaticTypeFunc(const ast_CallExpr* e);
static _Bool ast_CallExpr_isTemplateCall(const ast_CallExpr* e);
static ast_TypeRef* ast_CallExpr_getTemplateArg(const ast_CallExpr* e);
static void ast_CallExpr_setTemplateIdx(ast_CallExpr* e, uint32_t idx);
static uint32_t ast_CallExpr_getTemplateIdx(const ast_CallExpr* e);
static uint16_t ast_CallExpr_getInstanceASTIdx(const ast_CallExpr* e);
static void ast_CallExpr_setNoreturn(ast_CallExpr* e);
static _Bool ast_CallExpr_isNoreturn(const ast_CallExpr* e);
static void ast_CallExpr_setPrintfFormat(ast_CallExpr* e, uint32_t format_idx, _Bool change_format);
static _Bool ast_CallExpr_isPrintfCall(const ast_CallExpr* e);
static uint32_t ast_CallExpr_getPrintfFormat(const ast_CallExpr* e);
static _Bool ast_CallExpr_needFormatChange(const ast_CallExpr* e);
static void ast_CallExpr_setHasAutoArgs(ast_CallExpr* e);
static _Bool ast_CallExpr_hasAutoArgs(const ast_CallExpr* e);
static src_loc_SrcLoc ast_CallExpr_getStartLoc(const ast_CallExpr* e);
static src_loc_SrcLoc ast_CallExpr_getEndLoc(const ast_CallExpr* e);
static ast_Expr* ast_CallExpr_getFunc(const ast_CallExpr* e);
static ast_Expr** ast_CallExpr_getFunc2(ast_CallExpr* e);
static uint32_t ast_CallExpr_getNumArgs(const ast_CallExpr* e);
static ast_Expr** ast_CallExpr_getArgs(ast_CallExpr* e);
static void ast_CallExpr_printLiteral(const ast_CallExpr* e, string_buffer_Buf* out);
static void ast_CallExpr_print(const ast_CallExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_CharLiteral_ {
   ast_Expr base;
};

static ast_CharLiteral* ast_CharLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint8_t val, number_radix_Radix radix);
static char ast_CharLiteral_getValue(const ast_CharLiteral* e);
static src_loc_SrcLoc ast_CharLiteral_getEndLoc(const ast_CharLiteral* e);
static void ast_CharLiteral_print(const ast_CharLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_CharLiteral_printLiteral(const ast_CharLiteral* e, string_buffer_Buf* out);
struct ast_ConditionalOperator_ {
   ast_Expr base;
   src_loc_SrcLoc colonLoc;
   ast_Expr* cond;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_ConditionalOperator* ast_ConditionalOperator_create(ast_context_Context* c, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_ConditionalOperator_instantiate(ast_ConditionalOperator* e, ast_Instantiator* inst);
static ast_Expr* ast_ConditionalOperator_getCond(const ast_ConditionalOperator* e);
static ast_Expr** ast_ConditionalOperator_getCond2(ast_ConditionalOperator* e);
static ast_Expr* ast_ConditionalOperator_getLHS(const ast_ConditionalOperator* e);
static ast_Expr** ast_ConditionalOperator_getLHS2(ast_ConditionalOperator* e);
static ast_Expr* ast_ConditionalOperator_getRHS(const ast_ConditionalOperator* e);
static ast_Expr** ast_ConditionalOperator_getRHS2(ast_ConditionalOperator* e);
static src_loc_SrcLoc ast_ConditionalOperator_getStartLoc(const ast_ConditionalOperator* e);
static src_loc_SrcLoc ast_ConditionalOperator_getEndLoc(const ast_ConditionalOperator* e);
static void ast_ConditionalOperator_printLiteral(const ast_ConditionalOperator* e, string_buffer_Buf* out);
static void ast_ConditionalOperator_print(const ast_ConditionalOperator* e, string_buffer_Buf* out, uint32_t indent);
struct ast_ExplicitCastExpr_ {
   ast_Expr base;
   ast_Expr* inner;
   ast_QualType dest_type;
   ast_TypeRef dest;
};

static ast_ExplicitCastExpr* ast_ExplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, _Bool c_style);
static ast_Expr* ast_ExplicitCastExpr_instantiate(ast_ExplicitCastExpr* e, ast_Instantiator* inst);
static void ast_ExplicitCastExpr_setDestType(ast_ExplicitCastExpr* e, ast_QualType qt);
static ast_QualType ast_ExplicitCastExpr_getDestType(const ast_ExplicitCastExpr* e);
static _Bool ast_ExplicitCastExpr_getCStyle(const ast_ExplicitCastExpr* e);
static ast_Expr* ast_ExplicitCastExpr_getInner(const ast_ExplicitCastExpr* e);
static ast_Expr** ast_ExplicitCastExpr_getInner2(ast_ExplicitCastExpr* e);
static ast_TypeRef* ast_ExplicitCastExpr_getTypeRef(ast_ExplicitCastExpr* e);
static src_loc_SrcLoc ast_ExplicitCastExpr_getEndLoc(const ast_ExplicitCastExpr* e);
static void ast_ExplicitCastExpr_printLiteral(const ast_ExplicitCastExpr* e, string_buffer_Buf* out);
static void ast_ExplicitCastExpr_print(const ast_ExplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_FieldDesignatedInitExpr_ {
   ast_Expr base;
   uint32_t field;
   uint32_t member_offset;
   ast_Expr* initValue;
   ast_Decl* decl;
};

static ast_FieldDesignatedInitExpr* ast_FieldDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue);
static ast_Expr* ast_FieldDesignatedInitExpr_instantiate(ast_FieldDesignatedInitExpr* e, ast_Instantiator* inst);
static uint32_t ast_FieldDesignatedInitExpr_getField(const ast_FieldDesignatedInitExpr* e);
static const char* ast_FieldDesignatedInitExpr_getFieldName(const ast_FieldDesignatedInitExpr* e);
static ast_Expr* ast_FieldDesignatedInitExpr_getInit(const ast_FieldDesignatedInitExpr* e);
static ast_Expr** ast_FieldDesignatedInitExpr_getInit2(ast_FieldDesignatedInitExpr* e);
static void ast_FieldDesignatedInitExpr_setDecl(ast_FieldDesignatedInitExpr* e, ast_Decl* d);
static ast_Decl* ast_FieldDesignatedInitExpr_getDecl(const ast_FieldDesignatedInitExpr* e);
static uint32_t ast_FieldDesignatedInitExpr_getMemberOffset(const ast_FieldDesignatedInitExpr* e);
static void ast_FieldDesignatedInitExpr_setMemberOffset(ast_FieldDesignatedInitExpr* e, uint32_t idx);
static src_loc_SrcLoc ast_FieldDesignatedInitExpr_getEndLoc(const ast_FieldDesignatedInitExpr* e);
static void ast_FieldDesignatedInitExpr_print(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_FieldDesignatedInitExpr_printLiteral(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out);
struct ast_FloatLiteral_ {
   ast_Expr base;
   double val;
};

static ast_FloatLiteral* ast_FloatLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, double val, number_radix_Radix radix);
static double ast_FloatLiteral_getValue(const ast_FloatLiteral* e);
static src_loc_SrcLoc ast_FloatLiteral_getEndLoc(const ast_FloatLiteral* e);
static void ast_FloatLiteral_print(const ast_FloatLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_FloatLiteral_printLiteral(const ast_FloatLiteral* e, string_buffer_Buf* out);
typedef enum {
   ast_IdentifierKind_Unresolved,
   ast_IdentifierKind_Module,
   ast_IdentifierKind_Function,
   ast_IdentifierKind_Type,
   ast_IdentifierKind_Var,
   ast_IdentifierKind_EnumConstant,
   ast_IdentifierKind_StructMember,
   ast_IdentifierKind_Label,
   _ast_IdentifierKind_max = 255
} __attribute__((packed)) ast_IdentifierKind;

struct ast_IdentifierExpr_ {
   ast_Expr base;
   union {
      uint32_t name_idx;
      ast_Decl* decl;
   };
};

static const char* ast_identifierKind_names[8] = {
   "Unresolved",
   "Module",
   "Function",
   "Type",
   "Var",
   "EnumConstant",
   "StructMember",
   "Label"
};

static ast_IdentifierExpr* ast_IdentifierExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t name);
static ast_Expr* ast_IdentifierExpr_instantiate(ast_IdentifierExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_IdentifierExpr_asExpr(ast_IdentifierExpr* e);
static void ast_IdentifierExpr_setDecl(ast_IdentifierExpr* e, ast_Decl* decl);
static ast_Decl* ast_IdentifierExpr_getDecl(const ast_IdentifierExpr* e);
static ast_Ref ast_IdentifierExpr_getRef(const ast_IdentifierExpr* e);
static void ast_IdentifierExpr_setKind(ast_IdentifierExpr* e, ast_IdentifierKind kind);
static ast_IdentifierKind ast_IdentifierExpr_getKind(const ast_IdentifierExpr* e);
static const char* ast_IdentifierExpr_getName(const ast_IdentifierExpr* e);
static src_loc_SrcLoc ast_IdentifierExpr_getEndLoc(const ast_IdentifierExpr* e);
static uint32_t ast_IdentifierExpr_getNameIdx(const ast_IdentifierExpr* e);
static void ast_IdentifierExpr_print(const ast_IdentifierExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_IdentifierExpr_printLiteral(const ast_IdentifierExpr* e, string_buffer_Buf* out);
typedef enum {
   ast_ImplicitCastKind_ArrayToPointerDecay,
   ast_ImplicitCastKind_LValueToRValue,
   ast_ImplicitCastKind_PointerToBoolean,
   ast_ImplicitCastKind_PointerToInteger,
   ast_ImplicitCastKind_IntegralCast,
   ast_ImplicitCastKind_BitCast,
   _ast_ImplicitCastKind_max = 255
} __attribute__((packed)) ast_ImplicitCastKind;

struct ast_ImplicitCastExpr_ {
   ast_Expr base;
   ast_Expr* inner;
};

static const char* ast_implicitCastKind_names[6] = { "ArrayToPointerDecay", "LValueToRValue", "PointerToBoolean", "PointerToInteger", "IntegralCast", "BitCast" };

static ast_ImplicitCastExpr* ast_ImplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_ImplicitCastKind kind, ast_Expr* inner);
static ast_ImplicitCastKind ast_ImplicitCastExpr_getKind(const ast_ImplicitCastExpr* e);
static _Bool ast_ImplicitCastExpr_isArrayToPointerDecay(const ast_ImplicitCastExpr* e);
static ast_Expr* ast_ImplicitCastExpr_getInner(const ast_ImplicitCastExpr* e);
static src_loc_SrcLoc ast_ImplicitCastExpr_getStartLoc(const ast_ImplicitCastExpr* e);
static src_loc_SrcLoc ast_ImplicitCastExpr_getEndLoc(const ast_ImplicitCastExpr* e);
static void ast_ImplicitCastExpr_printLiteral(const ast_ImplicitCastExpr* e, string_buffer_Buf* out);
static void ast_ImplicitCastExpr_print(const ast_ImplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_InitListExpr_ {
   ast_Expr base;
   src_loc_SrcLoc endLoc;
   uint32_t num_values;
   ast_Expr* values[0];
};

static ast_InitListExpr* ast_InitListExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values);
static ast_Expr* ast_InitListExpr_instantiate(ast_InitListExpr* e, ast_Instantiator* inst);
static _Bool ast_InitListExpr_isArray(const ast_InitListExpr* e);
static void ast_InitListExpr_setIsArray(ast_InitListExpr* e);
static _Bool ast_InitListExpr_hasDesignators(const ast_InitListExpr* e);
static void ast_InitListExpr_setHasDesignators(ast_InitListExpr* e);
static uint32_t ast_InitListExpr_getNumValues(const ast_InitListExpr* e);
static ast_Expr** ast_InitListExpr_getValues(ast_InitListExpr* e);
static const ast_Expr** ast_InitListExpr_getValues2(const ast_InitListExpr* e);
static src_loc_SrcLoc ast_InitListExpr_getEndLoc(const ast_InitListExpr* e);
static void ast_InitListExpr_print(const ast_InitListExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_InitListExpr_printLiteral(const ast_InitListExpr* e, string_buffer_Buf* out);
struct ast_IntegerLiteral_ {
   ast_Expr base;
   uint64_t val;
};

static ast_IntegerLiteral* ast_IntegerLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint64_t val, number_radix_Radix radix);
static ast_IntegerLiteral* ast_IntegerLiteral_createUnsignedConstant(ast_context_Context* c, src_loc_SrcLoc loc, uint64_t val, ast_QualType qt);
static ast_IntegerLiteral* ast_IntegerLiteral_createSignedConstant(ast_context_Context* c, src_loc_SrcLoc loc, int64_t val, ast_QualType qt);
static uint64_t ast_IntegerLiteral_getValue(const ast_IntegerLiteral* e);
static src_loc_SrcLoc ast_IntegerLiteral_getEndLoc(const ast_IntegerLiteral* e);
static _Bool ast_IntegerLiteral_isSigned(const ast_IntegerLiteral* e);
static void ast_printBinary(string_buffer_Buf* out, uint64_t value);
static void ast_printOctal(string_buffer_Buf* out, uint64_t value);
static void ast_IntegerLiteral_print(const ast_IntegerLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_IntegerLiteral_printLiteral(const ast_IntegerLiteral* e, string_buffer_Buf* out);
typedef enum {
   ast_MemberConversion_None,
   ast_MemberConversion_Addr,
   ast_MemberConversion_Deref,
   _ast_MemberConversion_max = 255
} __attribute__((packed)) ast_MemberConversion;

union ast_MemberRef_ {
   uint32_t name_idx;
   ast_Decl* decl;
   ast_Expr* expr;
};

struct ast_MemberExpr_ {
   ast_Expr base;
   ast_MemberRef refs[0];
};

#define ast_MemberExprMaxDepth 7
static ast_MemberExpr* ast_MemberExpr_create(ast_context_Context* c, ast_Expr* base, const ast_Ref* refs, uint32_t refcount);
static ast_Expr* ast_MemberExpr_instantiate(ast_MemberExpr* e, ast_Instantiator* inst);
static _Bool ast_MemberExpr_hasExpr(const ast_MemberExpr* e);
static ast_Expr* ast_MemberExpr_getExprBase(const ast_MemberExpr* e);
static void ast_MemberExpr_setConversion(ast_MemberExpr* e, ast_MemberConversion c);
static ast_MemberConversion ast_MemberExpr_getConversion(const ast_MemberExpr* e);
static const char* ast_MemberExpr_getName(const ast_MemberExpr* e, uint32_t ref_idx);
static uint32_t ast_MemberExpr_getNumRefs(const ast_MemberExpr* e);
static uint32_t ast_MemberExpr_getNameIdx(const ast_MemberExpr* e, uint32_t ref_idx);
static src_loc_SrcLoc ast_MemberExpr_getLoc(const ast_MemberExpr* e, uint32_t ref_idx);
static src_loc_SrcRange ast_MemberExpr_getRange(const ast_MemberExpr* e, uint32_t ref_idx);
static ast_Ref ast_MemberExpr_getRef(const ast_MemberExpr* e, uint32_t ref_idx);
static ast_IdentifierKind ast_MemberExpr_getKind(const ast_MemberExpr* e);
static void ast_MemberExpr_setKind(ast_MemberExpr* e, ast_IdentifierKind kind);
static void ast_MemberExpr_setIsTypeFunc(ast_MemberExpr* e);
static _Bool ast_MemberExpr_isTypeFunc(const ast_MemberExpr* e);
static void ast_MemberExpr_setIsStaticTypeFunc(ast_MemberExpr* e);
static _Bool ast_MemberExpr_isStaticTypeFunc(const ast_MemberExpr* e);
static void ast_MemberExpr_setConstBase(ast_MemberExpr* e, _Bool b);
static _Bool ast_MemberExpr_isConstBase(const ast_MemberExpr* e);
static ast_Decl* ast_MemberExpr_getPrevLastDecl(const ast_MemberExpr* e);
static ast_Decl* ast_MemberExpr_getFullDecl(const ast_MemberExpr* e);
static ast_Decl* ast_MemberExpr_getDecl(const ast_MemberExpr* e, uint32_t ref_idx);
static void ast_MemberExpr_setDecl(ast_MemberExpr* e, ast_Decl* d, uint32_t ref_idx);
static src_loc_SrcLoc ast_MemberExpr_getStartLoc(const ast_MemberExpr* e);
static src_loc_SrcLoc ast_MemberExpr_getLastLoc(const ast_MemberExpr* e);
static src_loc_SrcLoc ast_MemberExpr_getEndLoc(const ast_MemberExpr* e);
static ast_QualType ast_MemberExpr_getBaseType(const ast_MemberExpr* m);
static const char* ast_MemberExpr_getLastMemberName(const ast_MemberExpr* e);
static void ast_MemberExpr_print(const ast_MemberExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_MemberExpr_printLiteral(const ast_MemberExpr* e, string_buffer_Buf* out);
static void ast_MemberExpr_dump(const ast_MemberExpr* m);
struct ast_NilExpr_ {
   ast_Expr base;
};

static ast_NilExpr* ast_NilExpr_create(ast_context_Context* c, src_loc_SrcLoc loc);
static src_loc_SrcLoc ast_NilExpr_getEndLoc(const ast_NilExpr* e);
static void ast_NilExpr_print(const ast_NilExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_NilExpr_printLiteral(const ast_NilExpr* _arg0, string_buffer_Buf* out);
struct ast_ParenExpr_ {
   ast_Expr base;
   ast_Expr* inner;
};

static ast_ParenExpr* ast_ParenExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner);
static ast_Expr* ast_ParenExpr_instantiate(ast_ParenExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_ParenExpr_getInner(const ast_ParenExpr* e);
static ast_Expr** ast_ParenExpr_getInner2(ast_ParenExpr* e);
static void ast_ParenExpr_print(const ast_ParenExpr* e, string_buffer_Buf* out, uint32_t indent);
static src_loc_SrcLoc ast_ParenExpr_getEndLoc(const ast_ParenExpr* e);
static void ast_ParenExpr_printLiteral(const ast_ParenExpr* e, string_buffer_Buf* out);
struct ast_RangeExpr_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_RangeExpr* ast_RangeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_RangeExpr_instantiate(ast_RangeExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_RangeExpr_getLHS(const ast_RangeExpr* e);
static ast_Expr* ast_RangeExpr_getRHS(const ast_RangeExpr* e);
static src_loc_SrcLoc ast_RangeExpr_getStartLoc(const ast_RangeExpr* e);
static src_loc_SrcLoc ast_RangeExpr_getEndLoc(const ast_RangeExpr* e);
static void ast_RangeExpr_print(const ast_RangeExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_RangeExpr_printLiteral(const ast_RangeExpr* e, string_buffer_Buf* out);
struct ast_StringLiteral_ {
   ast_Expr base;
   uint32_t value;
   uint32_t size;
};

static ast_StringLiteral* ast_StringLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len);
static const char* ast_StringLiteral_getText(const ast_StringLiteral* e);
static uint32_t ast_StringLiteral_getTextIndex(const ast_StringLiteral* e);
static uint32_t ast_StringLiteral_getSize(const ast_StringLiteral* e);
static uint32_t ast_StringLiteral_strlen(const ast_StringLiteral* e);
static src_loc_SrcLoc ast_StringLiteral_getEndLoc(const ast_StringLiteral* e);
static void ast_StringLiteral_printLiteral(const ast_StringLiteral* e, string_buffer_Buf* out);
static void ast_StringLiteral_print(const ast_StringLiteral* e, string_buffer_Buf* out, uint32_t indent);
struct ast_TypeExpr_ {
   ast_Expr base;
   ast_TypeRef typeRef;
};

static ast_TypeExpr* ast_TypeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref);
static ast_Expr* ast_TypeExpr_instantiate(ast_TypeExpr* e, ast_Instantiator* inst);
static ast_TypeRef* ast_TypeExpr_getTypeRef(ast_TypeExpr* e);
static src_loc_SrcLoc ast_TypeExpr_getEndLoc(const ast_TypeExpr* e);
static void ast_TypeExpr_print(const ast_TypeExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_TypeExpr_printLiteral(const ast_TypeExpr* e, string_buffer_Buf* out, _Bool decay);
typedef enum {
   ast_UnaryOpcode_PostInc,
   ast_UnaryOpcode_PostDec,
   ast_UnaryOpcode_PreInc,
   ast_UnaryOpcode_PreDec,
   ast_UnaryOpcode_AddrOf,
   ast_UnaryOpcode_Deref,
   ast_UnaryOpcode_Plus,
   ast_UnaryOpcode_Minus,
   ast_UnaryOpcode_Not,
   ast_UnaryOpcode_LNot,
   _ast_UnaryOpcode_max = 255
} __attribute__((packed)) ast_UnaryOpcode;

struct ast_UnaryOperator_ {
   ast_Expr base;
   ast_Expr* inner;
};

static const char* ast_unaryOpcode_names[10] = {
   "++",
   "--",
   "++",
   "--",
   "&",
   "*",
   "+",
   "-",
   "~",
   "!"
};

static ast_UnaryOperator* ast_UnaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_UnaryOpcode kind, ast_Expr* inner);
static ast_Expr* ast_UnaryOperator_instantiate(ast_UnaryOperator* e, ast_Instantiator* inst);
static ast_UnaryOpcode ast_UnaryOperator_getOpcode(const ast_UnaryOperator* e);
static ast_Expr* ast_UnaryOperator_getInner(const ast_UnaryOperator* e);
static ast_Expr** ast_UnaryOperator_getInner2(ast_UnaryOperator* e);
static _Bool ast_UnaryOperator_isBefore(const ast_UnaryOperator* e);
static src_loc_SrcLoc ast_UnaryOperator_getStartLoc(const ast_UnaryOperator* e);
static src_loc_SrcLoc ast_UnaryOperator_getEndLoc(const ast_UnaryOperator* e);
static const char* ast_UnaryOperator_getOpcodeStr(const ast_UnaryOperator* e);
static _Bool ast_UnaryOperator_isAddrOf(const ast_UnaryOperator* e);
static void ast_UnaryOperator_print(const ast_UnaryOperator* e, string_buffer_Buf* out, uint32_t indent);
static void ast_UnaryOperator_printLiteral(const ast_UnaryOperator* e, string_buffer_Buf* out);
typedef enum {
   ast_TypeKind_Builtin,
   ast_TypeKind_Pointer,
   ast_TypeKind_Array,
   ast_TypeKind_Struct,
   ast_TypeKind_Enum,
   ast_TypeKind_Function,
   ast_TypeKind_Alias,
   ast_TypeKind_Module,
   _ast_TypeKind_max = 255
} __attribute__((packed)) ast_TypeKind;

struct ast_TypeBits_ {
   uint32_t kind : 8;
};

#define ast_NumTypeBits 8
struct ast_BuiltinTypeBits_ {
   uint32_t  : 8;
   uint32_t kind : 4;
};

struct ast_ArrayTypeBits_ {
   uint32_t  : 8;
   uint32_t has_size : 1;
   uint32_t is_incremental : 1;
};

struct ast_Type_ {
   union {
      ast_TypeBits typeBits;
      ast_BuiltinTypeBits builtinTypeBits;
      ast_ArrayTypeBits arrayTypeBits;
      uint32_t bits;
   };
   uint32_t ptr_pool_idx;
   ast_QualType canonicalType;
};

static const char* ast_typeKind_names[8] = {
   "Builtin",
   "Pointer",
   "Array",
   "Struct",
   "Enum",
   "Function",
   "Alias",
   "Module"
};

static void ast_Type_init(ast_Type* t, ast_TypeKind k);
static ast_TypeKind ast_Type_getKind(const ast_Type* t);
static ast_QualType ast_Type_getCanonicalType(const ast_Type* t);
static void ast_Type_setCanonicalType(ast_Type* t, ast_QualType canon);
static uint32_t ast_Type_getIndex(const ast_Type* t);
static _Bool ast_Type_isBuiltinType(const ast_Type* t);
static _Bool ast_Type_isArrayType(const ast_Type* t);
static _Bool ast_Type_isStructType(const ast_Type* t);
static _Bool ast_Type_isPointerType(const ast_Type* t);
static _Bool ast_Type_isFunctionType(const ast_Type* t);
static _Bool ast_Type_isEnumType(const ast_Type* t);
static _Bool ast_Type_isVoidType(const ast_Type* t);
static void ast_Type_dump(const ast_Type* t);
static uint32_t ast_Type_getAlignment(const ast_Type* t);
static uint32_t ast_Type_getSize(const ast_Type* t, _Bool deref_ptr);
static void ast_Type_print(const ast_Type* t, string_buffer_Buf* out);
static void ast_Type_fullPrint(const ast_Type* t, string_buffer_Buf* out, uint32_t indent);
struct ast_AliasType_ {
   ast_Type base;
   ast_AliasTypeDecl* decl;
};

static ast_AliasType* ast_AliasType_create(ast_context_Context* c, ast_AliasTypeDecl* decl);
static ast_AliasTypeDecl* ast_AliasType_getDecl(const ast_AliasType* t);
static void ast_AliasType_print(const ast_AliasType* t, string_buffer_Buf* out);
static void ast_AliasType_fullPrint(const ast_AliasType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_ArrayType_ {
   ast_Type base;
   ast_QualType elem;
   uint32_t size;
};

static ast_ArrayType* ast_ArrayType_create(ast_context_Context* c, ast_QualType elem, _Bool has_size, uint32_t size);
static ast_ArrayType* ast_ArrayType_createIncremental(ast_context_Context* c, ast_QualType elem);
static ast_QualType ast_ArrayType_getElemType(const ast_ArrayType* t);
static uint32_t ast_ArrayType_hasSize(const ast_ArrayType* t);
static uint32_t ast_ArrayType_getSize(const ast_ArrayType* t);
static void ast_ArrayType_setSize(ast_ArrayType* t, uint32_t size);
static void ast_ArrayType_printPreName(const ast_ArrayType* t, string_buffer_Buf* out);
static void ast_ArrayType_printPostName(const ast_ArrayType* t, string_buffer_Buf* out);
static void ast_ArrayType_print(const ast_ArrayType* t, string_buffer_Buf* out);
static void ast_ArrayType_fullPrint(const ast_ArrayType* t, string_buffer_Buf* out, uint32_t indent);
typedef enum {
   ast_BuiltinKind_Char,
   ast_BuiltinKind_Int8,
   ast_BuiltinKind_Int16,
   ast_BuiltinKind_Int32,
   ast_BuiltinKind_Int64,
   ast_BuiltinKind_UInt8,
   ast_BuiltinKind_UInt16,
   ast_BuiltinKind_UInt32,
   ast_BuiltinKind_UInt64,
   ast_BuiltinKind_Float32,
   ast_BuiltinKind_Float64,
   ast_BuiltinKind_ISize,
   ast_BuiltinKind_USize,
   ast_BuiltinKind_Bool,
   ast_BuiltinKind_Void,
   _ast_BuiltinKind_max = 255
} __attribute__((packed)) ast_BuiltinKind;

struct ast_BuiltinType_ {
   ast_Type base;
};

static const char* ast_builtinType_names[15] = {
   [ast_BuiltinKind_Char] = "char",
   [ast_BuiltinKind_Int8] = "i8",
   [ast_BuiltinKind_Int16] = "i16",
   [ast_BuiltinKind_Int32] = "i32",
   [ast_BuiltinKind_Int64] = "i64",
   [ast_BuiltinKind_UInt8] = "u8",
   [ast_BuiltinKind_UInt16] = "u16",
   [ast_BuiltinKind_UInt32] = "u32",
   [ast_BuiltinKind_UInt64] = "u64",
   [ast_BuiltinKind_Float32] = "f32",
   [ast_BuiltinKind_Float64] = "f64",
   [ast_BuiltinKind_ISize] = "isize",
   [ast_BuiltinKind_USize] = "usize",
   [ast_BuiltinKind_Bool] = "bool",
   [ast_BuiltinKind_Void] = "void"
};

static const _Bool ast_BuiltinType_promotable[15] = {
   [ast_BuiltinKind_Char] = true,
   [ast_BuiltinKind_Int8] = true,
   [ast_BuiltinKind_Int16] = true,
   [ast_BuiltinKind_Int32] = false,
   [ast_BuiltinKind_Int64] = false,
   [ast_BuiltinKind_UInt8] = true,
   [ast_BuiltinKind_UInt16] = true,
   [ast_BuiltinKind_UInt32] = false,
   [ast_BuiltinKind_UInt64] = false,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = false,
   [ast_BuiltinKind_ISize] = false,
   [ast_BuiltinKind_USize] = false,
   [ast_BuiltinKind_Bool] = true,
   [ast_BuiltinKind_Void] = false
};

static const _Bool ast_BuiltinType_signed[15] = {
   [ast_BuiltinKind_Char] = false,
   [ast_BuiltinKind_Int8] = true,
   [ast_BuiltinKind_Int16] = true,
   [ast_BuiltinKind_Int32] = true,
   [ast_BuiltinKind_Int64] = true,
   [ast_BuiltinKind_UInt8] = false,
   [ast_BuiltinKind_UInt16] = false,
   [ast_BuiltinKind_UInt32] = false,
   [ast_BuiltinKind_UInt64] = false,
   [ast_BuiltinKind_Float32] = true,
   [ast_BuiltinKind_Float64] = true,
   [ast_BuiltinKind_ISize] = true,
   [ast_BuiltinKind_USize] = false,
   [ast_BuiltinKind_Bool] = false,
   [ast_BuiltinKind_Void] = false
};

static const _Bool ast_BuiltinType_unsigned[15] = {
   [ast_BuiltinKind_Char] = true,
   [ast_BuiltinKind_Int8] = false,
   [ast_BuiltinKind_Int16] = false,
   [ast_BuiltinKind_Int32] = false,
   [ast_BuiltinKind_Int64] = false,
   [ast_BuiltinKind_UInt8] = true,
   [ast_BuiltinKind_UInt16] = true,
   [ast_BuiltinKind_UInt32] = true,
   [ast_BuiltinKind_UInt64] = true,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = false,
   [ast_BuiltinKind_ISize] = false,
   [ast_BuiltinKind_USize] = true,
   [ast_BuiltinKind_Bool] = false,
   [ast_BuiltinKind_Void] = false
};

static const _Bool ast_BuiltinType_integer[15] = {
   [ast_BuiltinKind_Char] = true,
   [ast_BuiltinKind_Int8] = true,
   [ast_BuiltinKind_Int16] = true,
   [ast_BuiltinKind_Int32] = true,
   [ast_BuiltinKind_Int64] = true,
   [ast_BuiltinKind_UInt8] = true,
   [ast_BuiltinKind_UInt16] = true,
   [ast_BuiltinKind_UInt32] = true,
   [ast_BuiltinKind_UInt64] = true,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = false,
   [ast_BuiltinKind_ISize] = true,
   [ast_BuiltinKind_USize] = true,
   [ast_BuiltinKind_Bool] = false,
   [ast_BuiltinKind_Void] = false
};

static const uint32_t ast_BuiltinType_default_sizes[15] = {
   [ast_BuiltinKind_Char] = 1,
   [ast_BuiltinKind_Int8] = 1,
   [ast_BuiltinKind_Int16] = 2,
   [ast_BuiltinKind_Int32] = 4,
   [ast_BuiltinKind_Int64] = 8,
   [ast_BuiltinKind_UInt8] = 1,
   [ast_BuiltinKind_UInt16] = 2,
   [ast_BuiltinKind_UInt32] = 4,
   [ast_BuiltinKind_UInt64] = 8,
   [ast_BuiltinKind_Float32] = 4,
   [ast_BuiltinKind_Float64] = 8,
   [ast_BuiltinKind_ISize] = 8,
   [ast_BuiltinKind_USize] = 8,
   [ast_BuiltinKind_Bool] = 1,
   [ast_BuiltinKind_Void] = 0
};

static const uint32_t ast_BuiltinType_default_widths[15] = {
   [ast_BuiltinKind_Char] = 8,
   [ast_BuiltinKind_Int8] = 7,
   [ast_BuiltinKind_Int16] = 15,
   [ast_BuiltinKind_Int32] = 31,
   [ast_BuiltinKind_Int64] = 63,
   [ast_BuiltinKind_UInt8] = 8,
   [ast_BuiltinKind_UInt16] = 16,
   [ast_BuiltinKind_UInt32] = 32,
   [ast_BuiltinKind_UInt64] = 64,
   [ast_BuiltinKind_Float32] = 0,
   [ast_BuiltinKind_Float64] = 0,
   [ast_BuiltinKind_ISize] = 63,
   [ast_BuiltinKind_USize] = 64,
   [ast_BuiltinKind_Bool] = 1,
   [ast_BuiltinKind_Void] = 0
};

static const uint32_t ast_BuiltinType_bitfield_sizes[15] = {
   [ast_BuiltinKind_Char] = 8,
   [ast_BuiltinKind_Int8] = 8,
   [ast_BuiltinKind_Int16] = 16,
   [ast_BuiltinKind_Int32] = 32,
   [ast_BuiltinKind_Int64] = 64,
   [ast_BuiltinKind_UInt8] = 8,
   [ast_BuiltinKind_UInt16] = 16,
   [ast_BuiltinKind_UInt32] = 32,
   [ast_BuiltinKind_UInt64] = 64,
   [ast_BuiltinKind_Float32] = 0,
   [ast_BuiltinKind_Float64] = 0,
   [ast_BuiltinKind_ISize] = 64,
   [ast_BuiltinKind_USize] = 64,
   [ast_BuiltinKind_Bool] = 1,
   [ast_BuiltinKind_Void] = 0
};

static _Bool ast_builtinKind2Signed(ast_BuiltinKind kind);
static ast_BuiltinType* ast_BuiltinType_create(ast_context_Context* c, ast_BuiltinKind kind);
static ast_BuiltinKind ast_BuiltinType_getKind(const ast_BuiltinType* b);
static ast_BuiltinKind ast_BuiltinType_getBaseKind(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isChar(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isInt8(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isUInt8(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isInt32(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isVoid(const ast_BuiltinType* b);
static const char* ast_BuiltinType_kind2str(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isPromotableIntegerType(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isInteger(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isIntegerOrBool(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isFloatingPoint(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isSigned(const ast_BuiltinType* b);
static _Bool ast_BuiltinType_isUnsigned(const ast_BuiltinType* b);
static uint32_t ast_BuiltinType_getAlignment(const ast_BuiltinType* b);
static uint32_t ast_BuiltinType_getWidth(const ast_BuiltinType* b);
static uint32_t ast_BuiltinType_getBitfieldSize(const ast_BuiltinType* b);
static void ast_BuiltinType_print(const ast_BuiltinType* b, string_buffer_Buf* out);
static void ast_BuiltinType_fullPrint(const ast_BuiltinType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_EnumType_ {
   ast_Type base;
   ast_EnumTypeDecl* decl;
};

static ast_EnumType* ast_EnumType_create(ast_context_Context* c, ast_EnumTypeDecl* decl);
static ast_EnumTypeDecl* ast_EnumType_getDecl(const ast_EnumType* t);
static ast_QualType ast_EnumType_getImplType(const ast_EnumType* t);
static const char* ast_EnumType_getName(const ast_EnumType* t);
static void ast_EnumType_print(const ast_EnumType* t, string_buffer_Buf* out);
static void ast_EnumType_fullPrint(const ast_EnumType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_FunctionType_ {
   ast_Type base;
   ast_FunctionDecl* decl;
};

static ast_FunctionType* ast_FunctionType_create(ast_context_Context* c, ast_FunctionDecl* decl);
static ast_FunctionDecl* ast_FunctionType_getDecl(const ast_FunctionType* t);
static ast_Type* ast_FunctionType_asType(ast_FunctionType* t);
static void ast_FunctionType_print(const ast_FunctionType* t, string_buffer_Buf* out);
static void ast_FunctionType_fullPrint(const ast_FunctionType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_ModuleType_ {
   ast_Type base;
   ast_Module* mod;
};

static ast_ModuleType* ast_ModuleType_create(ast_context_Context* c, ast_Module* mod);
static ast_Module* ast_ModuleType_getModule(const ast_ModuleType* t);
static void ast_ModuleType_print(const ast_ModuleType* t, string_buffer_Buf* out);
static void ast_ModuleType_fullPrint(const ast_ModuleType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_PointerType_ {
   ast_Type base;
   ast_QualType inner;
};

static ast_PointerType* ast_PointerType_create(ast_context_Context* c, ast_QualType inner);
static ast_QualType ast_PointerType_getInner(const ast_PointerType* t);
static void ast_PointerType_print(const ast_PointerType* t, string_buffer_Buf* out);
static void ast_PointerType_fullPrint(const ast_PointerType* t, string_buffer_Buf* out, uint32_t indent);
#define ast_QualType_Const 0x1
#define ast_QualType_Volatile 0x2
#define ast_QualType_Mask 0x3
static ast_QualType ast_QualType_create(ast_Type* t);
static void ast_QualType_set(ast_QualType* qt, ast_Type* t);
static void ast_QualType_setConst(ast_QualType* qt);
static void ast_QualType_unsetConst(ast_QualType* qt);
static _Bool ast_QualType_isConst(ast_QualType* qt);
static _Bool ast_QualType_isVolatile(ast_QualType* qt);
static void ast_QualType_setVolatile(ast_QualType* qt);
static uint32_t ast_QualType_getQuals(const ast_QualType* qt);
static void ast_QualType_copyQuals(ast_QualType* qt, ast_QualType other);
static void ast_QualType_clearQuals(ast_QualType* qt);
static _Bool ast_QualType_isConstant(const ast_QualType* qt);
static _Bool ast_QualType_isValid(const ast_QualType* qt);
static _Bool ast_QualType_isInvalid(const ast_QualType* qt);
static uint32_t ast_QualType_getBitFieldWidth(const ast_QualType* qt);
static _Bool ast_QualType_isScalar(const ast_QualType* qt);
static _Bool ast_QualType_isUnsigned(const ast_QualType* qt);
static ast_Type* ast_QualType_getType(const ast_QualType* qt);
static ast_Type* ast_QualType_getTypeOrNil(const ast_QualType* qt);
static _Bool ast_QualType_hasCanonicalType(const ast_QualType* qt);
static ast_QualType ast_QualType_getCanonicalType(const ast_QualType* qt);
static void ast_QualType_setCanonicalType(ast_QualType* qt, ast_QualType canon);
static _Bool ast_QualType_isConstPtr(ast_QualType* qt);
static ast_TypeKind ast_QualType_getKind(ast_QualType* qt);
static uint32_t ast_QualType_getIndex(ast_QualType* qt);
static uint32_t ast_QualType_getAlignment(ast_QualType* qt);
static uint32_t ast_QualType_getSize(ast_QualType* qt, _Bool deref_ptr);
static _Bool ast_QualType_isBool(const ast_QualType* qt);
static _Bool ast_QualType_isBuiltin(const ast_QualType* qt);
static _Bool ast_QualType_isArray(const ast_QualType* qt);
static _Bool ast_QualType_isStruct(const ast_QualType* qt);
static _Bool ast_QualType_isInteger(const ast_QualType* qt);
static _Bool ast_QualType_isFloat(const ast_QualType* qt);
static _Bool ast_QualType_isCharPointer(const ast_QualType* qt);
static _Bool ast_QualType_isPointer(const ast_QualType* qt);
static ast_QualType ast_QualType_getPointerBaseType(const ast_QualType* qt);
static _Bool ast_QualType_isFunction(const ast_QualType* qt);
static _Bool ast_QualType_isEnum(const ast_QualType* qt);
static _Bool ast_QualType_isVoid(const ast_QualType* qt);
static ast_BuiltinType* ast_QualType_getBuiltin(const ast_QualType* qt);
static ast_BuiltinType* ast_QualType_getBuiltinTypeOrNil(const ast_QualType* qt);
static ast_StructType* ast_QualType_getStructType(const ast_QualType* qt);
static ast_PointerType* ast_QualType_getPointerType(const ast_QualType* qt);
static ast_FunctionType* ast_QualType_getFunctionType(const ast_QualType* qt);
static ast_ArrayType* ast_QualType_getArrayType(const ast_QualType* qt);
static ast_EnumType* ast_QualType_getEnum(const ast_QualType* qt);
static ast_FunctionType* ast_QualType_getFunctionTypeOrNil(const ast_QualType* qt);
static ast_StructType* ast_QualType_getStructTypeOrNil(const ast_QualType* qt);
static ast_ArrayType* ast_QualType_getArrayTypeOrNil(const ast_QualType* qt);
static ast_EnumType* ast_QualType_getEnumType(const ast_QualType* qt);
static ast_EnumType* ast_QualType_getEnumTypeOrNil(const ast_QualType* qt);
static _Bool ast_QualType_isChar(const ast_QualType* qt);
static _Bool ast_QualType_isInt8(const ast_QualType* qt);
static _Bool ast_QualType_isUInt8(const ast_QualType* qt);
static _Bool ast_QualType_promotesToInt32(const ast_QualType* qt);
static _Bool ast_QualType_needsCtvInit(const ast_QualType* qt);
static const char* ast_QualType_diagName(const ast_QualType* qt);
static const char* ast_QualType_diagNameBare(const ast_QualType* qt);
static void ast_QualType_dump(const ast_QualType* qt);
static void ast_QualType_dump_full(const ast_QualType* qt);
static void ast_QualType_printQuoted(const ast_QualType* qt, string_buffer_Buf* out);
static void ast_QualType_print(const ast_QualType* qt, string_buffer_Buf* out);
static void ast_QualType_printInner(const ast_QualType* qt, string_buffer_Buf* out, _Bool printCanon, _Bool printModifiers, _Bool print_error);
static void ast_QualType_fullPrint(const ast_QualType* qt, string_buffer_Buf* out, uint32_t indent);
struct ast_StructType_ {
   ast_Type base;
   ast_StructTypeDecl* decl;
};

static ast_StructType* ast_StructType_create(ast_context_Context* c, ast_StructTypeDecl* decl);
static ast_StructTypeDecl* ast_StructType_getDecl(const ast_StructType* t);
static ast_Type* ast_StructType_asType(ast_StructType* t);
static void ast_StructType_print(const ast_StructType* t, string_buffer_Buf* out);
static void ast_StructType_fullPrint(const ast_StructType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_TypeRefHolder_ {
   uint64_t ref;
   ast_Ref user;
   ast_Ref prefix;
   ast_Expr* arrays[3];
};

typedef void (*ast_ExprPrinter)(void* arg, const ast_Expr* e, string_buffer_Buf* out);

static const char* ast_Ref_getName(const ast_Ref* r);
static void ast_TypeRefHolder_init(ast_TypeRefHolder* h);
static uint32_t ast_TypeRefHolder_getExtraSize(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_setQualifiers(ast_TypeRefHolder* h, uint32_t qualifiers);
static void ast_TypeRefHolder_setConst(ast_TypeRefHolder* h);
static void ast_TypeRefHolder_setVolatile(ast_TypeRefHolder* h);
static void ast_TypeRefHolder_addPointer(ast_TypeRefHolder* h);
static _Bool ast_TypeRefHolder_isIncrArray(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_setIncrArray(ast_TypeRefHolder* h);
static uint32_t ast_TypeRefHolder_getNumArrays(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_addArray(ast_TypeRefHolder* h, ast_Expr* array);
static void ast_TypeRefHolder_setBuiltin(ast_TypeRefHolder* h, ast_BuiltinKind kind, src_loc_SrcLoc loc);
static void ast_TypeRefHolder_setUser(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx);
static void ast_TypeRefHolder_setPrefix(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx);
static void ast_TypeRefHolder_dump(const ast_TypeRefHolder* h);
static void ast_TypeRef_init(ast_TypeRef* dest, const ast_TypeRefHolder* h);
static _Bool ast_TypeRef_matchesTemplate(const ast_TypeRef* r, uint32_t template_arg);
static void ast_TypeRef_instantiate(ast_TypeRef* r, const ast_TypeRef* r1, ast_Instantiator* inst);
static void ast_TypeRef_setDest(ast_TypeRef* r, uint32_t dest);
static uint32_t ast_TypeRef_getExtraSize(const ast_TypeRef* r);
static void* ast_TypeRef_getPointerAfter(const ast_TypeRef* r);
static _Bool ast_TypeRef_isConst(const ast_TypeRef* r);
static _Bool ast_TypeRef_isVolatile(const ast_TypeRef* r);
static _Bool ast_TypeRef_isUser(const ast_TypeRef* r);
static _Bool ast_TypeRef_isVoid(const ast_TypeRef* r);
static _Bool ast_TypeRef_isConstCharPtr(const ast_TypeRef* r);
static _Bool ast_TypeRef_isU32(const ast_TypeRef* r);
static _Bool ast_TypeRef_hasPrefix(const ast_TypeRef* r);
static _Bool ast_TypeRef_isIncrArray(const ast_TypeRef* r);
static _Bool ast_TypeRef_isPointerTo(const ast_TypeRef* r, uint32_t ptr_idx);
static ast_BuiltinKind ast_TypeRef_getBuiltinKind(const ast_TypeRef* r);
static src_loc_SrcLoc ast_TypeRef_getLoc(const ast_TypeRef* r);
static uint32_t ast_TypeRef_getNumPointers(const ast_TypeRef* r);
static const ast_Ref* ast_TypeRef_getUser(const ast_TypeRef* r);
static const ast_Decl* ast_TypeRef_getUserDecl(const ast_TypeRef* r);
static const ast_Ref* ast_TypeRef_getPrefix(const ast_TypeRef* r);
static void ast_TypeRef_setPrefix(ast_TypeRef* r, ast_Decl* d);
static void ast_TypeRef_setUser(ast_TypeRef* r, ast_Decl* d);
static uint32_t ast_TypeRef_getNumArrays(const ast_TypeRef* r);
static ast_Expr* ast_TypeRef_getArray(const ast_TypeRef* r, uint32_t idx);
static ast_Expr** ast_TypeRef_getArray2(ast_TypeRef* r, uint32_t idx);
static void ast_TypeRef_printLiteral(const ast_TypeRef* r, string_buffer_Buf* out, _Bool print_prefix, _Bool decay);
static void ast_TypeRef_printLiteral2(const ast_TypeRef* r, string_buffer_Buf* out, _Bool print_prefix, ast_ExprPrinter print_expr, void* arg);
static void ast_TypeRef_print(const ast_TypeRef* r, string_buffer_Buf* out, _Bool filled);
static void ast_TypeRef_dump(const ast_TypeRef* r);
static void ast_TypeRef_dump_full(const ast_TypeRef* r);
static const char* ast_TypeRef_diagName(const ast_TypeRef* r);
struct ast_ArrayValueList_ {
   uint32_t count;
   uint32_t capacity;
   ast_ArrayValue** values;
};

static void ast_ArrayValueList_init(ast_ArrayValueList* l, uint32_t initial_size);
static void ast_ArrayValueList_free(ast_ArrayValueList* l);
static void ast_ArrayValueList_add(ast_ArrayValueList* l, ast_ArrayValue* v);
static uint32_t ast_ArrayValueList_getCount(const ast_ArrayValueList* l);
static ast_ArrayValue** ast_ArrayValueList_get(ast_ArrayValueList* l);
struct ast_ImportDeclList_ {
   uint32_t count;
   uint32_t capacity;
   ast_ImportDecl** decls;
};

struct ast_DeclList_ {
   uint32_t count;
   uint32_t capacity;
   ast_Decl** decls;
   ast_Decl* stash[4];
};

struct ast_FunctionDeclList_ {
   uint32_t count;
   uint32_t capacity;
   ast_FunctionDecl** decls;
};

struct ast_StaticAssertList_ {
   uint32_t count;
   uint32_t capacity;
   ast_StaticAssert** asserts;
};

struct ast_AST_ {
   ast_Module* mod;
   string_pool_Pool* auxPool;
   void* ptr;
   uint32_t name;
   uint32_t idx;
   _Bool is_generated;
   ast_ImportDeclList imports;
   ast_DeclList types;
   ast_DeclList variables;
   ast_FunctionDeclList functions;
   ast_StaticAssertList static_asserts;
   ast_ArrayValueList array_values;
   attr_table_Table* attrs;
};

typedef void (*ast_ImportVisitor)(void* arg, ast_ImportDecl* d);

typedef void (*ast_ArrayValueVisitor)(void* arg, ast_ArrayValue* avd);

typedef void (*ast_FunctionVisitor)(void* arg, ast_FunctionDecl* d);

typedef void (*ast_TypeDeclVisitor)(void* arg, ast_Decl* d);

typedef void (*ast_VarDeclVisitor)(void* arg, ast_VarDecl* d);

typedef void (*ast_StaticAssertVisitor)(void* arg, ast_StaticAssert* d);

typedef void (*ast_DeclVisitor)(void* arg, ast_Decl* d);

static ast_AST* ast_AST_create(string_pool_Pool* auxPool, uint32_t name, ast_Module* mod, _Bool is_generated);
static void ast_AST_free(ast_AST* a);
static const char* ast_AST_getFilename(const ast_AST* a);
static uint32_t ast_AST_getIdx(const ast_AST* a);
static const char* ast_AST_getName(const ast_AST* a);
static uint32_t ast_AST_getNameIdx(const ast_AST* a);
static src_loc_SrcLoc ast_AST_getLoc(const ast_AST* a);
static void ast_AST_setPtr(ast_AST* a, void* ptr);
static void* ast_AST_getPtr(const ast_AST* a);
static ast_Module* ast_AST_getMod(const ast_AST* a);
static void ast_AST_addImport(ast_AST* a, ast_ImportDecl* d);
static ast_ImportDecl* ast_AST_findImport(const ast_AST* a, uint32_t name);
static _Bool ast_AST_isGenerated(const ast_AST* a);
static void ast_AST_addFunc(ast_AST* a, ast_FunctionDecl* d);
static void ast_AST_addTypeDecl(ast_AST* a, ast_Decl* d);
static void ast_AST_addVarDecl(ast_AST* a, ast_Decl* d);
static void ast_AST_addStaticAssert(ast_AST* a, ast_StaticAssert* s);
static void ast_AST_addArrayValue(ast_AST* a, ast_ArrayValue* v);
static void ast_AST_visitImports(const ast_AST* a, ast_ImportVisitor visitor, void* arg);
static const ast_ImportDeclList* ast_AST_getImports(const ast_AST* a);
static void ast_AST_visitArrayValues(ast_AST* a, ast_ArrayValueVisitor visitor, void* arg);
static void ast_AST_visitTypeFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg);
static void ast_AST_visitFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg);
static void ast_AST_visitTypeDecls(const ast_AST* a, ast_TypeDeclVisitor visitor, void* arg);
static void ast_AST_visitVarDecls(const ast_AST* a, ast_VarDeclVisitor visitor, void* arg);
static void ast_AST_visitStaticAsserts(ast_AST* a, ast_StaticAssertVisitor visitor, void* arg);
static void ast_AST_visitDecls(const ast_AST* a, ast_DeclVisitor visitor, void* arg);
static void ast_AST_visitDeclsWithoutImports(const ast_AST* a, ast_DeclVisitor visitor, void* arg);
static ast_Decl* ast_AST_findType(const ast_AST* a, uint32_t name_idx);
static void ast_AST_storeAttr(ast_AST* a, ast_Decl* d, attr_AttrKind kind, const attr_Value* value);
static const attr_Value* ast_AST_getAttr(const ast_AST* a, const ast_Decl* d, attr_AttrKind kind);
static void ast_AST_print(const ast_AST* a, string_buffer_Buf* out, _Bool show_funcs);
static void ast_AST_setExported(ast_AST* a);
static void ast_DeclList_init(ast_DeclList* l);
static void ast_DeclList_free(ast_DeclList* l);
static void ast_DeclList_add(ast_DeclList* l, ast_Decl* d);
static void ast_DeclList_clear(ast_DeclList* l);
static uint32_t ast_DeclList_size(const ast_DeclList* l);
static ast_Decl* ast_DeclList_get(const ast_DeclList* l, uint32_t idx);
static ast_Decl** ast_DeclList_getDecls(const ast_DeclList* l);
struct ast_ExprList_ {
   uint32_t count;
   uint32_t capacity;
   ast_Expr** exprs;
   ast_Expr* stash[4];
};

static void ast_ExprList_init(ast_ExprList* l);
static void ast_ExprList_free(ast_ExprList* l);
static void ast_ExprList_add(ast_ExprList* l, ast_Expr* d);
static uint32_t ast_ExprList_size(const ast_ExprList* l);
static ast_Expr** ast_ExprList_getExprs(const ast_ExprList* l);
static void ast_FunctionDeclList_init(ast_FunctionDeclList* l);
static void ast_FunctionDeclList_free(ast_FunctionDeclList* l);
static void ast_FunctionDeclList_clear(ast_FunctionDeclList* l);
static void ast_FunctionDeclList_add(ast_FunctionDeclList* l, ast_FunctionDecl* d);
static uint32_t ast_FunctionDeclList_size(const ast_FunctionDeclList* l);
static ast_FunctionDecl** ast_FunctionDeclList_getDecls(const ast_FunctionDeclList* l);
static ast_FunctionDecl* ast_FunctionDeclList_find(const ast_FunctionDeclList* l, uint32_t name_idx);
static void ast_ImportDeclList_init(ast_ImportDeclList* l);
static void ast_ImportDeclList_free(ast_ImportDeclList* l);
static void ast_ImportDeclList_add(ast_ImportDeclList* l, ast_ImportDecl* d);
static uint32_t ast_ImportDeclList_size(const ast_ImportDeclList* l);
static ast_ImportDecl** ast_ImportDeclList_getDecls(const ast_ImportDeclList* l);
static ast_ImportDecl* ast_ImportDeclList_find(const ast_ImportDeclList* l, uint32_t name_idx);
static ast_ImportDecl* ast_ImportDeclList_findAny(const ast_ImportDeclList* l, uint32_t name_idx);
struct ast_TemplateInstance_ {
   ast_QualType qt;
   ast_FunctionDecl* instance;
};

struct ast_TemplateFunction_ {
   const ast_FunctionDecl* fd;
   uint16_t count;
   uint16_t capacity;
   ast_TemplateInstance* instances;
};

struct ast_InstanceTable_ {
   uint32_t count;
   uint32_t capacity;
   ast_TemplateFunction* funcs;
};

static void ast_TemplateFunction_init(ast_TemplateFunction* f, const ast_FunctionDecl* fd);
static void ast_TemplateFunction_resize(ast_TemplateFunction* f, uint16_t capacity);
static uint16_t ast_TemplateFunction_add(ast_TemplateFunction* f, ast_QualType qt, ast_FunctionDecl* instance);
static ast_FunctionDecl* ast_TemplateFunction_find(const ast_TemplateFunction* f, ast_QualType qt);
static ast_FunctionDecl* ast_TemplateFunction_get(const ast_TemplateFunction* f, uint32_t idx);
static void ast_InstanceTable_init(ast_InstanceTable* t);
static void ast_InstanceTable_free(ast_InstanceTable* t);
static void ast_InstanceTable_resize(ast_InstanceTable* t, uint32_t capacity);
static ast_TemplateFunction* ast_InstanceTable_findFunc(const ast_InstanceTable* t, const ast_FunctionDecl* fd);
static ast_FunctionDecl* ast_InstanceTable_find(const ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt);
static ast_FunctionDecl* ast_InstanceTable_get(const ast_InstanceTable* t, const ast_FunctionDecl* fd, uint32_t idx);
static uint16_t ast_InstanceTable_add(ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance);
typedef void (*ast_OpaqueErrorfn)(void* arg, src_loc_SrcLoc loc, ast_Decl* decl);

struct ast_Instantiator_ {
   ast_context_Context* c;
   const ast_TypeRef* ref;
   uint32_t template_name;
   uint16_t instance_ast_idx;
   _Bool used_opaque;
   void* arg;
   ast_OpaqueErrorfn on_error;
};

static void ast_Instantiator_on_opaque(ast_Instantiator* inst, src_loc_SrcLoc loc, ast_Decl* decl);
struct ast_SymbolTable_ {
   uint32_t num_public;
   uint32_t num_private;
   uint32_t capacity;
   uint32_t* symbols;
   ast_Decl** decls;
};

struct ast_Module_ {
   uint32_t name_idx;
   _Bool is_used;
   _Bool is_external;
   _Bool is_internal;
   _Bool is_direct;
   _Bool is_exported;
   _Bool is_loaded;
   ast_ModuleType* mt;
   ast_AST** files;
   uint32_t num_files;
   uint32_t max_files;
   ast_SymbolTable symbols;
   ast_InstanceTable instances;
};

typedef void (*ast_ASTVisitor)(void* arg, ast_AST* d);

static ast_Module* ast_Module_create(ast_context_Context* c, uint32_t name_idx, _Bool is_external, _Bool is_direct);
static void ast_Module_free(ast_Module* m);
static void ast_Module_setUsed(ast_Module* m);
static _Bool ast_Module_isUsed(const ast_Module* m);
static void ast_Module_setInternal(ast_Module* m);
static _Bool ast_Module_isInternal(const ast_Module* m);
static _Bool ast_Module_isExternal(const ast_Module* m);
static void ast_Module_setLoaded(ast_Module* m);
static _Bool ast_Module_isLoaded(const ast_Module* m);
static void ast_Module_setExported(ast_Module* m);
static _Bool ast_Module_isExported(const ast_Module* m);
static _Bool ast_Module_isDirect(const ast_Module* m);
static const ast_SymbolTable* ast_Module_getSymbols(const ast_Module* m);
static ast_ModuleType* ast_Module_getType(const ast_Module* m);
static const char* ast_Module_getFirstFilename(const ast_Module* m);
static void ast_Module_visitASTs(const ast_Module* m, ast_ASTVisitor visitor, void* arg);
static void ast_Module_visitImports(const ast_Module* m, ast_ImportVisitor visitor, void* arg);
static void ast_Module_visitArrayValues(const ast_Module* m, ast_ArrayValueVisitor visitor, void* arg);
static void ast_Module_visitTypeFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg);
static void ast_Module_visitFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg);
static void ast_Module_visitTypeDecls(const ast_Module* m, ast_TypeDeclVisitor visitor, void* arg);
static void ast_Module_visitVarDecls(const ast_Module* m, ast_VarDeclVisitor visitor, void* arg);
static void ast_Module_visitStaticAsserts(const ast_Module* m, ast_StaticAssertVisitor visitor, void* arg);
static void ast_Module_visitDecls(const ast_Module* m, ast_DeclVisitor visitor, void* arg);
static void ast_Module_visitDeclsWithoutImports(const ast_Module* m, ast_DeclVisitor visitor, void* arg);
static ast_Decl* ast_Module_findType(const ast_Module* m, uint32_t name_idx);
static const char* ast_Module_getName(const ast_Module* m);
static uint32_t ast_Module_getNameIdx(const ast_Module* m);
static void ast_Module_resizeFiles(ast_Module* m, uint32_t cap);
static ast_AST* ast_Module_add(ast_Module* m, string_pool_Pool* auxPool, uint32_t filename, _Bool is_generated);
static void ast_Module_addSymbol(ast_Module* m, uint32_t name_idx, ast_Decl* d);
static ast_Decl* ast_Module_findSymbol(const ast_Module* m, uint32_t name_idx);
static ast_Decl* ast_Module_findPublicSymbol(const ast_Module* m, uint32_t name_idx);
static ast_Decl* ast_Module_findPrivateSymbol(const ast_Module* m, uint32_t name_idx);
static ast_FunctionDecl* ast_Module_findInstance(const ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt);
static uint16_t ast_Module_addInstance(ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance);
static ast_FunctionDecl* ast_Module_getInstance(const ast_Module* m, ast_FunctionDecl* fd, uint32_t idx);
static void ast_Module_print(const ast_Module* m, string_buffer_Buf* out, _Bool show_funcs);
struct ast_PointerPoolSlot_ {
   ast_Type* ptrs[4];
};

struct ast_PointerPool_ {
   ast_context_Context* context;
   uint32_t count;
   uint32_t capacity;
   ast_PointerPoolSlot* slots;
};

static void ast_PointerPool_init(ast_PointerPool* p, ast_context_Context* c);
static void ast_PointerPool_clear(ast_PointerPool* p);
static void ast_PointerPool_resize(ast_PointerPool* p, uint32_t cap);
static ast_Type* ast_PointerPool_getPointer(ast_PointerPool* p, ast_QualType qt);
static void ast_StaticAssertList_init(ast_StaticAssertList* l, uint32_t initial_size);
static void ast_StaticAssertList_free(ast_StaticAssertList* l);
static void ast_StaticAssertList_add(ast_StaticAssertList* l, ast_StaticAssert* v);
static uint32_t ast_StaticAssertList_getCount(const ast_StaticAssertList* l);
static ast_StaticAssert* ast_StaticAssertList_getAt(const ast_StaticAssertList* l, uint32_t idx);
static ast_StaticAssert** ast_StaticAssertList_get(ast_StaticAssertList* l);
struct ast_Stat_ {
   uint32_t count;
   uint32_t size;
};

struct ast_Stats_ {
   ast_Stat types[8];
   ast_Stat exprs[23];
   ast_Stat stmts[15];
   ast_Stat decls[8];
   ast_Stat others[3];
};

static const char* ast_other_names[3] = { "ArrayValue", "StaticAssert", "SwitchCase" };

static void ast_Stats_reset(ast_Stats* s);
static void ast_Stats_addType(ast_TypeKind kind, uint32_t size);
static void ast_Stats_addExpr(ast_ExprKind kind, uint32_t size);
static void ast_Stats_addStmt(ast_StmtKind kind, uint32_t size);
static void ast_Stats_addDecl(ast_DeclKind kind, uint32_t size);
static void ast_Stats_addArrayValue(uint32_t size);
static void ast_Stats_addStaticAssert(uint32_t size);
static void ast_Stats_addSwitchCase(uint32_t size);
static void ast_Stats_dump(const ast_Stats* s);
struct ast_StringTypeSlot_ {
   uint32_t len;
   ast_Type* type_;
};

struct ast_StringTypePool_ {
   uint32_t count;
   uint32_t capacity;
   ast_StringTypeSlot* slots;
   ast_context_Context* context;
};

static void ast_StringTypePool_init(ast_StringTypePool* p, ast_context_Context* c);
static void ast_StringTypePool_clear(ast_StringTypePool* p);
static void ast_StringTypePool_resize(ast_StringTypePool* p, uint32_t cap);
static ast_QualType ast_StringTypePool_get(ast_StringTypePool* p, uint32_t len);
static void ast_SymbolTable_init(ast_SymbolTable* t, uint32_t initial);
static void ast_SymbolTable_free(ast_SymbolTable* t);
static uint32_t ast_SymbolTable_size(const ast_SymbolTable* t);
static ast_Decl** ast_SymbolTable_getDecls(const ast_SymbolTable* t);
static void ast_SymbolTable_resize(ast_SymbolTable* t, uint32_t capacity);
static void ast_SymbolTable_add(ast_SymbolTable* t, uint32_t name_idx, ast_Decl* d);
static ast_Decl* ast_SymbolTable_find(const ast_SymbolTable* t, uint32_t name_idx);
static ast_Decl* ast_SymbolTable_findPublic(const ast_SymbolTable* t, uint32_t name_idx);
static ast_Decl* ast_SymbolTable_findPrivate(const ast_SymbolTable* t, uint32_t name_idx);
static void ast_SymbolTable_print(const ast_SymbolTable* t, string_buffer_Buf* out);
static void ast_SymbolTable_dump(const ast_SymbolTable* t);
struct ast_Globals_ {
   string_pool_Pool* names_pool;
   ast_PointerPool pointers;
   ast_StringTypePool string_types;
   uint32_t wordsize;
   _Bool use_color;
   uint32_t ast_count;
   uint32_t ast_capacity;
   ast_AST** ast_list;
   uint32_t builtinType_sizes[15];
   uint32_t builtinType_width[15];
   uint32_t builtinType_bitfield_sizes[15];
   ast_BuiltinKind builtinType_baseTypes[15];
   uint32_t attr_name_indexes[20];
   ast_Stats stats;
};

typedef _Bool (*ast_AttrHandlerFn)(void* arg, ast_Decl* d, const attr_Attr* a);

static const ast_QualType ast_QualType_Invalid = { };

static ast_Globals* ast_globals = NULL;

static ast_QualType* ast_builtins = NULL;

static const char* ast_col_Stmt = color_Bmagenta;

static const char* ast_col_Decl = color_Bgreen;

static const char* ast_col_Expr = color_Bmagenta;

static const char* ast_col_Attr = color_Blue;

static const char* ast_col_Template = color_Green;

static const char* ast_col_Type = color_Green;

static const char* ast_col_Value = color_Bcyan;

static const char* ast_col_Error = color_Red;

static const char* ast_col_Calc = color_Yellow;

static const char* ast_col_Normal = color_Normal;

static ast_Globals* ast_getGlobals(void);
static void ast_setGlobals(ast_Globals* g);
static void ast_initialize(ast_context_Context* c, string_pool_Pool* astPool, uint32_t wordsize, _Bool use_color);
static void ast_deinit(_Bool print_stats);
static uint32_t ast_getWordSize(void);
static _Bool ast_useColor(void);
static ast_QualType ast_getStringType(uint32_t len);
static const char* ast_idx2name(uint32_t idx);
static ast_QualType ast_getVoidPtr(void);
static ast_Type* ast_getPointerType(ast_QualType inner);
static uint32_t ast_addAST(ast_AST* ast_);
static ast_AST* ast_idx2ast(uint32_t idx);
static void ast_setTypePublicUsed(ast_QualType qt);
static ast_QualType ast_getNativeType(void);

static void ast_Decl_init(ast_Decl* d, ast_DeclKind k, uint32_t name_idx, src_loc_SrcLoc loc, _Bool is_public, ast_QualType qt, uint32_t ast_idx)
{
   d->bits = 0;
   d->declBits.kind = k;
   d->declBits.is_public = is_public;
   d->loc = loc;
   d->name_idx = name_idx;
   d->ast_idx = ast_idx;
   d->qt = qt;
}

static _Bool ast_Decl_hasGenIdx(const ast_Decl* d)
{
   return d->declBits.has_gen_idx;
}

static void ast_Decl_setGenIdx(ast_Decl* d, uint32_t idx)
{
   d->declBits.has_gen_idx = 1;
   d->gen_idx = idx;
}

static uint32_t ast_Decl_getGenIdx(const ast_Decl* d)
{
   if (d->declBits.has_gen_idx) return d->gen_idx;

   return 0;
}

static ast_DeclKind ast_Decl_getKind(const ast_Decl* d)
{
   return ((ast_DeclKind)(d->declBits.kind));
}

static ast_DeclCheckState ast_Decl_getCheckState(const ast_Decl* d)
{
   return ((ast_DeclCheckState)(d->declBits.check_state));
}

static _Bool ast_Decl_isChecked(const ast_Decl* d)
{
   return (d->declBits.check_state == ast_DeclCheckState_Checked);
}

static _Bool ast_Decl_isCheckInProgress(const ast_Decl* d)
{
   return (d->declBits.check_state == ast_DeclCheckState_InProgress);
}

static void ast_Decl_setChecked(ast_Decl* d)
{
   d->declBits.check_state = ast_DeclCheckState_Checked;
}

static void ast_Decl_setCheckInProgress(ast_Decl* d)
{
   d->declBits.check_state = ast_DeclCheckState_InProgress;
}

static void ast_Decl_setHasAttr(ast_Decl* d)
{
   d->declBits.has_attr = 1;
}

static _Bool ast_Decl_hasAttr(const ast_Decl* d)
{
   return d->declBits.has_attr;
}

static void ast_Decl_setAttrExport(ast_Decl* d)
{
   d->declBits.attr_export = 1;
}

static void ast_Decl_setExportedIfPublic(ast_Decl* d)
{
   if (d->declBits.is_public) d->declBits.attr_export = 1;
}

static _Bool ast_Decl_isExported(const ast_Decl* d)
{
   return d->declBits.attr_export;
}

static _Bool ast_Decl_isGlobal(const ast_Decl* d)
{
   if (!ast_Decl_isVarDecl(d)) return true;

   const ast_VarDecl* vd = ((ast_VarDecl*)(d));
   return (ast_VarDecl_isGlobal(vd) || ast_VarDecl_isStructMember(vd));
}

static void ast_Decl_setAttrUnused(ast_Decl* d)
{
   d->declBits.attr_unused = 1;
}

static _Bool ast_Decl_hasAttrUnused(const ast_Decl* d)
{
   return d->declBits.attr_unused;
}

static _Bool ast_Decl_isStructType(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_StructType);
}

static _Bool ast_Decl_isImport(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_Import);
}

static _Bool ast_Decl_isEnum(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_EnumType);
}

static _Bool ast_Decl_isEnumConstant(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_EnumConstant);
}

static _Bool ast_Decl_isFunction(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_Function);
}

static _Bool ast_Decl_isVariable(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_Variable);
}

static const char* ast_Decl_getName(const ast_Decl* d)
{
   return ast_idx2name(d->name_idx);
}

static uint32_t ast_Decl_getNameIdx(const ast_Decl* d)
{
   return d->name_idx;
}

static const char* ast_Decl_getModuleName(const ast_Decl* d)
{
   if ((d->ast_idx == 0)) return NULL;

   const ast_AST* a = ast_Decl_getAST(d);
   const ast_Module* mod = ast_AST_getMod(a);
   return ast_Module_getName(mod);
}

static src_loc_SrcLoc ast_Decl_getLoc(const ast_Decl* d)
{
   return d->loc;
}

static ast_QualType ast_Decl_getType(const ast_Decl* d)
{
   return d->qt;
}

static void ast_Decl_setType(ast_Decl* d, ast_QualType qt)
{
   d->qt = qt;
}

static ast_AST* ast_Decl_getAST(const ast_Decl* d)
{
   return ast_idx2ast(d->ast_idx);
}

static uint32_t ast_Decl_getASTIdx(const ast_Decl* d)
{
   return d->ast_idx;
}

static ast_Module* ast_Decl_getModule(const ast_Decl* d)
{
   return ast_idx2ast(d->ast_idx)->mod;
}

static _Bool ast_Decl_isPublic(const ast_Decl* d)
{
   return d->declBits.is_public;
}

static _Bool ast_Decl_isUsed(const ast_Decl* d)
{
   return d->declBits.is_used;
}

static _Bool ast_Decl_isUsedPublic(const ast_Decl* d)
{
   return d->declBits.is_used_public;
}

static void ast_Decl_setUsed(ast_Decl* d)
{
   d->declBits.is_used = true;
}

static void ast_Decl_clearUsed(ast_Decl* d)
{
   d->declBits.is_used = false;
}

static void ast_Decl_setUsedPublic(ast_Decl* d)
{
   d->declBits.is_used_public = true;
}

static _Bool ast_Decl_isExternal(const ast_Decl* d)
{
   return d->declBits.is_external;
}

static void ast_Decl_setExternal(ast_Decl* d)
{
   d->declBits.is_external = 1;
}

static _Bool ast_Decl_isGenerated(const ast_Decl* d)
{
   return d->declBits.is_generated;
}

static void ast_Decl_setGenerated(ast_Decl* d)
{
   d->declBits.is_generated = 1;
}

static void ast_Decl_clearGenerated(ast_Decl* d)
{
   d->declBits.is_generated = 0;
}

static void ast_Decl_dump(const ast_Decl* d)
{
   string_buffer_Buf* out = string_buffer_create((10 * 4096), ast_useColor(), 2);
   ast_Decl_print(d, out, 0);
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static _Bool ast_Decl_isTypeDecl(const ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      return true;
   case ast_DeclKind_EnumType:
      return true;
   case ast_DeclKind_EnumConstant:
      break;
   case ast_DeclKind_FunctionType:
      return true;
   case ast_DeclKind_AliasType:
      return true;
   case ast_DeclKind_Variable:
      break;
   }
   return false;
}

static _Bool ast_Decl_isVarDecl(const ast_Decl* d)
{
   return (ast_Decl_getKind(d) == ast_DeclKind_Variable);
}

static const char* ast_Decl_getKindName(const ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      return "function";
   case ast_DeclKind_Import:
      return "import";
   case ast_DeclKind_StructType:
      return "type";
   case ast_DeclKind_EnumType:
      return "type";
   case ast_DeclKind_EnumConstant:
      return "enum constant";
   case ast_DeclKind_FunctionType:
      return "type";
   case ast_DeclKind_AliasType:
      return "type";
   case ast_DeclKind_Variable:
      return "variable";
   }
   return "";
}

static const char* ast_Decl_getCName(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return NULL;

   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Value* cname = ast_AST_getAttr(a, d, attr_AttrKind_CName);
   if (cname) return ast_idx2name(cname->text);

   return NULL;
}

static const char* ast_Decl_getCDef(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return NULL;

   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Value* cdef = ast_AST_getAttr(a, d, attr_AttrKind_CDef);
   if (cdef) return ast_idx2name(cdef->text);

   return NULL;
}

static const char* ast_Decl_getSection(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return NULL;

   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Value* section = ast_AST_getAttr(a, d, attr_AttrKind_Section);
   if (section) return ast_idx2name(section->text);

   return NULL;
}

static const char* ast_Decl_getFullName(const ast_Decl* d)
{
   static char tmp_buf[4][128];
   static uint32_t tmp_id = 0;
   uint32_t tmp_size = 128;
   char* tmp = tmp_buf[(tmp_id++ & 3)];
   const char* modname = ast_Decl_getModuleName(d);
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function: {
      const ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
      if (ast_FunctionDecl_hasPrefix(fd)) {
         snprintf(tmp, tmp_size, "%s.%s.%s", modname, ast_FunctionDecl_getPrefixName(fd), ast_Decl_getName(d));
      } else {
         snprintf(tmp, tmp_size, "%s.%s", modname, ast_Decl_getName(d));
      }
      break;
   }
   case ast_DeclKind_Import:
      snprintf(tmp, tmp_size, "%s", ast_Decl_getName(d));
      break;
   case ast_DeclKind_EnumConstant: {
      ast_QualType qt = ast_Decl_getType(d);
      ast_EnumType* et = ast_QualType_getEnumType(&qt);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_Decl* ed = ((ast_Decl*)(etd));
      snprintf(tmp, tmp_size, "%s.%s.%s", modname, ast_Decl_getName(ed), ast_Decl_getName(d));
      break;
   }
   default:
      snprintf(tmp, tmp_size, "%s.%s", modname, ast_Decl_getName(d));
      break;
   }
   return tmp;
}

static void ast_Decl_print(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      ast_FunctionDecl_print(((ast_FunctionDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_Import:
      ast_ImportDecl_print(((ast_ImportDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_StructType:
      ast_StructTypeDecl_print(((ast_StructTypeDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_EnumType:
      ast_EnumTypeDecl_print(((ast_EnumTypeDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_EnumConstant:
      ast_EnumConstantDecl_print(((ast_EnumConstantDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_FunctionType:
      ast_FunctionTypeDecl_print(((ast_FunctionTypeDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_AliasType:
      ast_AliasTypeDecl_print(((ast_AliasTypeDecl*)(d)), out, indent);
      break;
   case ast_DeclKind_Variable:
      ast_VarDecl_print(((ast_VarDecl*)(d)), out, indent);
      break;
   }
}

static void ast_Decl_printKind(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent, _Bool print_type)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, ast_declKind_names[ast_Decl_getKind(d)]);
   if (print_type) {
      string_buffer_Buf_space(out);
      ast_QualType_printQuoted(&d->qt, out);
   }
}

static void ast_Decl_printName(const ast_Decl* d, string_buffer_Buf* out)
{
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   if (d->name_idx) {
      string_buffer_Buf_add(out, ast_Decl_getName(d));
   } else {
      string_buffer_Buf_add(out, "(nil)");
   }
}

static void ast_Decl_printBits(const ast_Decl* d, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Attr);
   if (ast_Decl_isPublic(d)) string_buffer_Buf_add(out, " public");
   ast_DeclCheckState cs = ast_Decl_getCheckState(d);
   if ((cs != ast_DeclCheckState_Checked)) {
      string_buffer_Buf_space(out);
      string_buffer_Buf_add(out, ast_declCheckState_names[cs]);
   }
   if (d->declBits.attr_unused) {
      string_buffer_Buf_add(out, " unused");
   }
   if (d->declBits.has_attr) string_buffer_Buf_add(out, " attr");
   if (d->declBits.attr_export) string_buffer_Buf_add(out, " export");
   if (!ast_Decl_isUsed(d)) {
      string_buffer_Buf_color(out, ast_col_Expr);
      string_buffer_Buf_add(out, " unused");
   }
}

static void ast_Decl_printAttrs(const ast_Decl* d, string_buffer_Buf* out)
{
   if (!ast_Decl_hasAttr(d)) return;

   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Value* cname = ast_AST_getAttr(a, d, attr_AttrKind_CName);
   if (cname) {
      string_buffer_Buf_print(out, " cname='%s'", ast_idx2name(cname->text));
   }
   const attr_Value* cdef = ast_AST_getAttr(a, d, attr_AttrKind_CDef);
   if (cdef) {
      string_buffer_Buf_print(out, " cdef='%s'", ast_idx2name(cdef->text));
   }
   const attr_Value* section = ast_AST_getAttr(a, d, attr_AttrKind_Section);
   if (section) {
      string_buffer_Buf_print(out, " section='%s'", ast_idx2name(section->text));
   }
}

static void ast_Decl_printUsed(const ast_Decl* d, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_print(out, " used=%u/%u", ast_Decl_isUsed(d), ast_Decl_isUsedPublic(d));
}

static ast_AliasTypeDecl* ast_AliasTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* ref)
{
   uint32_t size = (32 + ast_TypeRefHolder_getExtraSize(ref));
   ast_AliasTypeDecl* d = ast_context_Context_alloc(c, size);
   ast_AliasType* at = ast_AliasType_create(c, d);
   ast_Decl_init(&d->base, ast_DeclKind_AliasType, name, loc, is_public, ast_QualType_create(((ast_Type*)(at))), ast_idx);
   ast_TypeRef_init(&d->typeRef, ref);
   ast_Stats_addDecl(ast_DeclKind_AliasType, size);
   return d;
}

static ast_Decl* ast_AliasTypeDecl_asDecl(ast_AliasTypeDecl* d)
{
   return &d->base;
}

static ast_TypeRef* ast_AliasTypeDecl_getTypeRef(ast_AliasTypeDecl* d)
{
   return &d->typeRef;
}

static void ast_AliasTypeDecl_print(const ast_AliasTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   ast_Decl_printAttrs(&d->base, out);
   ast_Decl_printName(&d->base, out);
   if (ast_QualType_isInvalid(&d->base.qt)) {
      string_buffer_Buf_space(out);
      ast_TypeRef_print(&d->typeRef, out, true);
      string_buffer_Buf_newline(out);
   }
}

static ast_ArrayValue* ast_ArrayValue_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value)
{
   ast_ArrayValue* d = ast_context_Context_alloc(c, 16);
   d->name_idx = name;
   d->loc = loc;
   d->value = value;
   ast_Stats_addArrayValue(16);
   return d;
}

static uint32_t ast_ArrayValue_getNameIdx(const ast_ArrayValue* d)
{
   return d->name_idx;
}

static src_loc_SrcLoc ast_ArrayValue_getLoc(const ast_ArrayValue* d)
{
   return d->loc;
}

static ast_Expr* ast_ArrayValue_getValue(const ast_ArrayValue* d)
{
   return d->value;
}

static void ast_ArrayValue_print(const ast_ArrayValue* d, string_buffer_Buf* out)
{
}

static ast_DeclStmt* ast_DeclStmt_create(ast_context_Context* c, ast_VarDecl* decl)
{
   ast_DeclStmt* s = ast_context_Context_alloc(c, 16);
   ast_Stmt_init(&s->base, ast_StmtKind_Decl, ast_Decl_getLoc(ast_VarDecl_asDecl(decl)));
   s->decl = decl;
   ast_Stats_addStmt(ast_StmtKind_Decl, 16);
   return s;
}

static ast_Stmt* ast_DeclStmt_instantiate(ast_DeclStmt* s, ast_Instantiator* inst)
{
   ast_VarDecl* decl2 = ast_VarDecl_instantiate(s->decl, inst);
   return ((ast_Stmt*)(ast_DeclStmt_create(inst->c, decl2)));
}

static ast_VarDecl* ast_DeclStmt_getDecl(const ast_DeclStmt* d)
{
   return d->decl;
}

static void ast_DeclStmt_print(const ast_DeclStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_VarDecl_print(s->decl, out, (indent + 1));
}

static ast_EnumConstantDecl* ast_EnumConstantDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, ast_Expr* initValue)
{
   uint32_t size = 40;
   if (initValue) size += 8;
   ast_EnumConstantDecl* d = ast_context_Context_alloc(c, size);
   ast_Decl_init(&d->base, ast_DeclKind_EnumConstant, name, loc, is_public, ast_QualType_Invalid, ast_idx);
   ast_Value_setUnsigned(&d->value, 0);
   if (initValue) {
      d->base.enumConstantDeclBits.has_init = 1;
      d->init[0] = initValue;
   }
   ast_Stats_addDecl(ast_DeclKind_EnumConstant, size);
   return d;
}

static ast_Decl* ast_EnumConstantDecl_asDecl(ast_EnumConstantDecl* d)
{
   return &d->base;
}

static ast_Value ast_EnumConstantDecl_getValue(const ast_EnumConstantDecl* d)
{
   return d->value;
}

static void ast_EnumConstantDecl_setValue(ast_EnumConstantDecl* d, ast_Value value)
{
   d->value = value;
}

static void ast_EnumConstantDecl_setIndex(ast_EnumConstantDecl* d, uint32_t index)
{
   d->base.enumConstantDeclBits.enum_index = index;
}

static uint32_t ast_EnumConstantDecl_getIndex(const ast_EnumConstantDecl* d)
{
   return d->base.enumConstantDeclBits.enum_index;
}

static ast_Expr* ast_EnumConstantDecl_getInit(const ast_EnumConstantDecl* d)
{
   if (d->base.enumConstantDeclBits.has_init) return d->init[0];

   return NULL;
}

static ast_Expr** ast_EnumConstantDecl_getInit2(ast_EnumConstantDecl* d)
{
   if (d->base.enumConstantDeclBits.has_init) return &d->init[0];

   return NULL;
}

static void ast_EnumConstantDecl_print(const ast_EnumConstantDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   ast_Decl_printName(&d->base, out);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, " [%u] %s", ast_EnumConstantDecl_getIndex(d), ast_Value_str(&d->value));
   string_buffer_Buf_newline(out);
   if (d->base.enumConstantDeclBits.has_init) ast_Expr_print(d->init[0], out, (indent + 1));
}

static ast_EnumTypeDecl* ast_EnumTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, ast_QualType implType, _Bool is_incremental, ast_EnumConstantDecl** constants, uint32_t num_constants)
{
   uint32_t size = (48 + (num_constants * 8));
   if (is_incremental) size += 8;
   ast_EnumTypeDecl* d = ast_context_Context_alloc(c, size);
   ast_EnumType* etype = ast_EnumType_create(c, d);
   ast_QualType qt = ast_QualType_create(((ast_Type*)(etype)));
   ast_Decl_init(&d->base, ast_DeclKind_EnumType, name, loc, is_public, qt, ast_idx);
   d->base.enumTypeDeclBits.is_incremental = is_incremental;
   d->base.enumTypeDeclBits.num_constants = num_constants;
   d->implType = implType;
   d->num_enum_functions = 0;
   d->enum_functions = NULL;
   if (is_incremental) {
      ((num_constants == 0)) || c2_assert("ast/enum_type_decl.c2", 61, "ast.EnumTypeDecl.create", "num_constants == 0");
      d->incr_constants[0] = NULL;
   } else {
      memcpy(d->constants, constants, (num_constants * 8));
      for (uint32_t i = 0; (i < num_constants); i++) {
         ast_Decl_setType(ast_EnumConstantDecl_asDecl(constants[i]), qt);
      }
   }
   ast_Stats_addDecl(ast_DeclKind_EnumType, size);
   return d;
}

static ast_QualType ast_EnumTypeDecl_getImplType(const ast_EnumTypeDecl* d)
{
   return d->implType;
}

static ast_Decl* ast_EnumTypeDecl_asDecl(ast_EnumTypeDecl* d)
{
   return &d->base;
}

static _Bool ast_EnumTypeDecl_isIncremental(const ast_EnumTypeDecl* d)
{
   return d->base.enumTypeDeclBits.is_incremental;
}

static uint32_t ast_EnumTypeDecl_getNumConstants(const ast_EnumTypeDecl* d)
{
   return d->base.enumTypeDeclBits.num_constants;
}

static ast_EnumConstantDecl** ast_EnumTypeDecl_getConstants(ast_EnumTypeDecl* d)
{
   if (ast_EnumTypeDecl_isIncremental(d)) {
      return d->incr_constants[0];
   }
   return d->constants;
}

static void ast_EnumTypeDecl_setIncrConstants(ast_EnumTypeDecl* d, ast_context_Context* c, ast_IdentifierExpr** constants, uint32_t count)
{
   const uint32_t size = (count * 8);
   ast_EnumConstantDecl** decls = ast_context_Context_alloc(c, size);
   ast_QualType qt = ast_Decl_getType(&d->base);
   for (uint32_t i = 0; (i < count); i++) {
      ast_IdentifierExpr* id = constants[i];
      decls[i] = ast_EnumConstantDecl_create(c, ast_IdentifierExpr_getNameIdx(id), ast_Expr_getLoc(ast_IdentifierExpr_asExpr(id)), ast_Decl_isPublic(&d->base), d->base.ast_idx, NULL);
      ast_Decl_setType(ast_EnumConstantDecl_asDecl(decls[i]), qt);
   }
   d->incr_constants[0] = decls;
   d->base.enumTypeDeclBits.num_constants = count;
}

static ast_EnumConstantDecl* ast_EnumTypeDecl_findConstant(ast_EnumTypeDecl* d, uint32_t name_idx)
{
   ast_EnumConstantDecl** constants = d->constants;
   if (ast_EnumTypeDecl_isIncremental(d)) constants = d->incr_constants[0];
   for (uint32_t i = 0; (i < ast_EnumTypeDecl_getNumConstants(d)); i++) {
      ast_EnumConstantDecl* ecd = constants[i];
      ast_Decl* ed = ((ast_Decl*)(ecd));
      if ((ast_Decl_getNameIdx(ed) == name_idx)) return ecd;

   }
   return NULL;
}

static ast_EnumConstantDecl* ast_EnumTypeDecl_getConstant(const ast_EnumTypeDecl* d, uint32_t idx)
{
   if (ast_EnumTypeDecl_isIncremental(d)) return d->incr_constants[0][idx];

   return d->constants[idx];
}

static void ast_EnumTypeDecl_setEnumFunctions(ast_EnumTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count)
{
   const uint32_t size = (count * 8);
   void* dest = ast_context_Context_alloc(c, size);
   memcpy(dest, funcs, size);
   d->enum_functions = dest;
   d->num_enum_functions = count;
}

static ast_Decl* ast_EnumTypeDecl_findFunction(const ast_EnumTypeDecl* d, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < d->num_enum_functions); i++) {
      ast_Decl* ef = ((ast_Decl*)(d->enum_functions[i]));
      if ((ast_Decl_getNameIdx(ef) == name_idx)) return ef;

   }
   return NULL;
}

static void ast_EnumTypeDecl_print(ast_EnumTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   if (ast_EnumTypeDecl_isIncremental(d)) string_buffer_Buf_add(out, " incremental");
   ast_Decl_printAttrs(&d->base, out);
   ast_Decl_printName(&d->base, out);
   string_buffer_Buf_space(out);
   ast_QualType_print(&d->implType, out);
   string_buffer_Buf_newline(out);
   ast_EnumConstantDecl** constants = d->constants;
   if (ast_EnumTypeDecl_isIncremental(d)) constants = d->incr_constants[0];
   for (uint32_t i = 0; (i < d->base.enumTypeDeclBits.num_constants); i++) {
      ast_EnumConstantDecl_print(constants[i], out, (indent + 1));
   }
}

static ast_FunctionDecl* ast_FunctionDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic, _Bool is_type)
{
   uint32_t size = ((80 + (num_params * 8)) + ast_TypeRefHolder_getExtraSize(rtype));
   ast_FunctionDecl* d = ast_context_Context_alloc(c, size);
   ast_FunctionType* ftype = ast_FunctionType_create(c, d);
   ast_QualType qt = ast_QualType_create(ast_FunctionType_asType(ftype));
   ast_Decl_init(&d->base, ast_DeclKind_Function, name, loc, is_public, qt, ast_idx);
   d->base.functionDeclBits.is_variadic = is_variadic;
   d->base.functionDeclBits.call_kind = prefix ? ast_CallKind_StaticTypeFunc : ast_CallKind_Normal;
   d->base.functionDeclBits.is_type = is_type;
   d->flagBits = 0;
   d->num_params = ((uint8_t)(num_params));
   d->attr_printf_arg = 0;
   d->instance_idx = 0;
   d->template_name = 0;
   d->template_loc = 0;
   d->rt = ast_QualType_Invalid;
   ast_TypeRef_init(&d->rtype, rtype);
   d->body = NULL;
   uint8_t* tail = ast_TypeRef_getPointerAfter(&d->rtype);
   if (prefix) {
      d->base.functionDeclBits.has_prefix = 1;
      d->prefix = *prefix;
   }
   if (num_params) {
      memcpy(tail, params, (num_params * 8));
   }
   ast_Stats_addDecl(ast_DeclKind_Function, size);
   return d;
}

static ast_FunctionDecl* ast_FunctionDecl_createTemplate(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic)
{
   uint32_t size = ((80 + (num_params * 8)) + ast_TypeRefHolder_getExtraSize(rtype));
   ast_FunctionDecl* d = ast_context_Context_alloc(c, size);
   ast_FunctionType* ftype = ast_FunctionType_create(c, d);
   ast_QualType qt = ast_QualType_create(ast_FunctionType_asType(ftype));
   ast_Decl_init(&d->base, ast_DeclKind_Function, name, loc, is_public, qt, ast_idx);
   d->base.functionDeclBits.is_variadic = is_variadic;
   d->base.functionDeclBits.call_kind = ast_CallKind_Normal;
   d->base.functionDeclBits.is_template = 1;
   d->base.functionDeclBits.is_type = false;
   d->flagBits = 0;
   d->num_params = ((uint8_t)(num_params));
   d->attr_printf_arg = 0;
   d->instance_idx = 0;
   d->template_name = template_name;
   d->template_loc = template_loc;
   d->rt = ast_QualType_Invalid;
   ast_TypeRef_init(&d->rtype, rtype);
   d->body = NULL;
   uint8_t* tail = ast_TypeRef_getPointerAfter(&d->rtype);
   if (num_params) {
      memcpy(tail, params, (num_params * 8));
   }
   ast_Stats_addDecl(ast_DeclKind_Function, size);
   return d;
}

static ast_FunctionDecl* ast_FunctionDecl_instantiate(const ast_FunctionDecl* fd, ast_Instantiator* inst)
{
   _Bool rtype_matches = ast_TypeRef_matchesTemplate(&fd->rtype, fd->template_name);
   uint32_t extra = rtype_matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&fd->rtype);
   uint32_t size = ((80 + (fd->num_params * 8)) + extra);
   ast_FunctionDecl* fd2 = ast_context_Context_alloc(inst->c, size);
   memcpy(&fd2->base, &fd->base, 24);
   fd2->base.functionDeclBits.is_template = 0;
   ast_FunctionType* ftype = ast_FunctionType_create(inst->c, fd2);
   fd2->base.qt = ast_QualType_create(ast_FunctionType_asType(ftype));
   fd2->body = ast_CompoundStmt_instantiate(fd->body, inst);
   fd2->rt = ast_QualType_Invalid;
   fd2->num_params = fd->num_params;
   fd2->attr_printf_arg = fd->attr_printf_arg;
   fd2->instance_idx = 0;
   fd2->template_name = 0;
   fd2->template_loc = fd->template_loc;
   fd2->flagBits = fd->flagBits;
   fd2->flags.instance_ast_idx = ((uint16_t)(inst->instance_ast_idx));
   fd2->prefix = fd->prefix;
   ast_TypeRef_instantiate(&fd2->rtype, &fd->rtype, inst);
   ast_VarDecl** src = ((ast_VarDecl**)(ast_TypeRef_getPointerAfter(&fd->rtype)));
   ast_VarDecl** dst = ((ast_VarDecl**)(ast_TypeRef_getPointerAfter(&fd2->rtype)));
   for (uint32_t i = 0; (i < fd2->num_params); i++) {
      dst[i] = ast_VarDecl_instantiate(src[i], inst);
   }
   ast_Stats_addDecl(ast_DeclKind_Function, size);
   return fd2;
}

static void ast_FunctionDecl_setBody(ast_FunctionDecl* d, ast_CompoundStmt* body)
{
   d->body = body;
}

static ast_CompoundStmt* ast_FunctionDecl_getBody(const ast_FunctionDecl* d)
{
   return d->body;
}

static _Bool ast_FunctionDecl_isInline(const ast_FunctionDecl* d)
{
   if (!ast_FunctionDecl_getBody(d)) return false;

   if (!ast_FunctionDecl_hasAttrInline(d)) return false;

   if (!ast_Decl_isPublic(&d->base)) return false;

   return true;
}

static _Bool ast_FunctionDecl_isType(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.is_type;
}

static void ast_FunctionDecl_setRType(ast_FunctionDecl* d, ast_QualType rt)
{
   if (!ast_QualType_isVoid(&rt)) d->base.functionDeclBits.has_return = 1;
   d->rt = rt;
}

static ast_QualType ast_FunctionDecl_getRType(const ast_FunctionDecl* d)
{
   return d->rt;
}

static _Bool ast_FunctionDecl_hasReturn(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.has_return;
}

static ast_Decl* ast_FunctionDecl_asDecl(ast_FunctionDecl* d)
{
   return &d->base;
}

static ast_TypeRef* ast_FunctionDecl_getReturnTypeRef(ast_FunctionDecl* d)
{
   return &d->rtype;
}

static _Bool ast_FunctionDecl_hasPrefix(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.has_prefix;
}

static _Bool ast_FunctionDecl_isTemplate(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.is_template;
}

static uint32_t ast_FunctionDecl_getTemplateNameIdx(const ast_FunctionDecl* d)
{
   return d->template_name;
}

static src_loc_SrcLoc ast_FunctionDecl_getTemplateLoc(const ast_FunctionDecl* d)
{
   return d->template_loc;
}

static void ast_FunctionDecl_setTemplateInstanceIdx(ast_FunctionDecl* d, uint16_t idx)
{
   d->instance_idx = idx;
}

static uint16_t ast_FunctionDecl_getTemplateInstanceIdx(const ast_FunctionDecl* d)
{
   return d->instance_idx;
}

static void ast_FunctionDecl_setInstanceName(ast_FunctionDecl* d, uint32_t name_idx)
{
   d->base.name_idx = name_idx;
}

static ast_Module* ast_FunctionDecl_getInstanceModule(ast_FunctionDecl* d)
{
   if (d->flags.instance_ast_idx) return ast_AST_getMod(ast_idx2ast(d->flags.instance_ast_idx));

   return NULL;
}

static ast_Ref* ast_FunctionDecl_getPrefix(ast_FunctionDecl* d)
{
   if (ast_FunctionDecl_hasPrefix(d)) return &d->prefix;

   return NULL;
}

static const char* ast_FunctionDecl_getPrefixName(const ast_FunctionDecl* d)
{
   if (!ast_FunctionDecl_hasPrefix(d)) return NULL;

   return ast_Ref_getName(&d->prefix);
}

static void ast_FunctionDecl_setCallKind(ast_FunctionDecl* d, ast_CallKind kind)
{
   d->base.functionDeclBits.call_kind = kind;
}

static ast_CallKind ast_FunctionDecl_getCallKind(const ast_FunctionDecl* d)
{
   return ((ast_CallKind)(d->base.functionDeclBits.call_kind));
}

static _Bool ast_FunctionDecl_isVariadic(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.is_variadic;
}

static uint32_t ast_FunctionDecl_getNumParams(const ast_FunctionDecl* d)
{
   return d->num_params;
}

static ast_VarDecl** ast_FunctionDecl_getParams(const ast_FunctionDecl* d)
{
   uint8_t* tail = ast_TypeRef_getPointerAfter(&d->rtype);
   ast_VarDecl** params = ((ast_VarDecl**)(tail));
   return params;
}

static uint32_t ast_FunctionDecl_getNumAutoArgs(const ast_FunctionDecl* d)
{
   return d->flags.num_auto_args;
}

static void ast_FunctionDecl_setNumAutoArgs(ast_FunctionDecl* d, uint32_t num)
{
   ((num < 16)) || c2_assert("ast/function_decl.c2", 328, "ast.FunctionDecl.setNumAutoArgs", "num < 16");
   d->flags.num_auto_args = num;
}

static void ast_FunctionDecl_setAttrUnusedParams(ast_FunctionDecl* d)
{
   d->flags.attr_unused_params = 1;
}

static _Bool ast_FunctionDecl_hasAttrUnusedParams(const ast_FunctionDecl* d)
{
   return d->flags.attr_unused_params;
}

static void ast_FunctionDecl_setAttrNoReturn(ast_FunctionDecl* d)
{
   d->flags.attr_noreturn = 1;
}

static _Bool ast_FunctionDecl_hasAttrNoReturn(const ast_FunctionDecl* d)
{
   return d->flags.attr_noreturn;
}

static void ast_FunctionDecl_setAttrInline(ast_FunctionDecl* d)
{
   d->flags.attr_inline = 1;
}

static _Bool ast_FunctionDecl_hasAttrInline(const ast_FunctionDecl* d)
{
   return d->flags.attr_inline;
}

static void ast_FunctionDecl_setAttrWeak(ast_FunctionDecl* d)
{
   d->flags.attr_weak = 1;
}

static _Bool ast_FunctionDecl_hasAttrWeak(const ast_FunctionDecl* d)
{
   return d->flags.attr_weak;
}

static void ast_FunctionDecl_setAttrConstructor(ast_FunctionDecl* d)
{
   d->flags.attr_constructor = 1;
}

static _Bool ast_FunctionDecl_hasAttrConstructor(const ast_FunctionDecl* d)
{
   return d->flags.attr_constructor;
}

static void ast_FunctionDecl_setAttrDestructor(ast_FunctionDecl* d)
{
   d->flags.attr_destructor = 1;
}

static _Bool ast_FunctionDecl_hasAttrDestructor(const ast_FunctionDecl* d)
{
   return d->flags.attr_destructor;
}

static void ast_FunctionDecl_setAttrPure(ast_FunctionDecl* d)
{
   d->flags.attr_pure = 1;
}

static _Bool ast_FunctionDecl_hasAttrPure(const ast_FunctionDecl* d)
{
   return d->flags.attr_pure;
}

static void ast_FunctionDecl_setAttrPrintf(ast_FunctionDecl* d, uint8_t arg)
{
   d->attr_printf_arg = arg;
}

static uint8_t ast_FunctionDecl_getAttrPrintf(const ast_FunctionDecl* d)
{
   return d->attr_printf_arg;
}

static const char* ast_FunctionDecl_getDiagKind(const ast_FunctionDecl* d)
{
   ast_CallKind ck = ast_FunctionDecl_getCallKind(d);
   if ((ck == ast_CallKind_TypeFunc)) return "type-";

   return "";
}

static void ast_FunctionDecl_print(const ast_FunctionDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   _Bool valid_type = ast_QualType_isValid(&d->base.qt);
   ast_Decl_printKind(&d->base, out, indent, valid_type);
   if (!valid_type) {
      string_buffer_Buf_add(out, " ");
      ast_TypeRef_print(&d->rtype, out, true);
   }
   ast_Decl_printBits(&d->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, ast_callKind_names[ast_FunctionDecl_getCallKind(d)]);
   ast_Decl_printAttrs(&d->base, out);
   if (d->base.functionDeclBits.is_type) string_buffer_Buf_add(out, " Type");
   string_buffer_Buf_color(out, ast_col_Expr);
   if (ast_FunctionDecl_hasAttrUnusedParams(d)) string_buffer_Buf_add(out, " unused-params");
   if (ast_FunctionDecl_hasAttrNoReturn(d)) string_buffer_Buf_add(out, " noreturn");
   if (ast_FunctionDecl_hasAttrInline(d)) string_buffer_Buf_add(out, " inline");
   if (ast_FunctionDecl_hasAttrWeak(d)) string_buffer_Buf_add(out, " weak");
   if ((d->attr_printf_arg != 0)) string_buffer_Buf_print(out, " printf_format=%u", d->attr_printf_arg);
   if (ast_FunctionDecl_hasAttrConstructor(d)) string_buffer_Buf_add(out, " constructor");
   if (ast_FunctionDecl_hasAttrDestructor(d)) string_buffer_Buf_add(out, " destructor");
   if (ast_FunctionDecl_hasAttrPure(d)) string_buffer_Buf_add(out, " pure");
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   const uint8_t* tail = ast_TypeRef_getPointerAfter(&d->rtype);
   if (ast_FunctionDecl_hasPrefix(d)) {
      string_buffer_Buf_add(out, ast_Ref_getName(&d->prefix));
      string_buffer_Buf_add1(out, '.');
   }
   string_buffer_Buf_add(out, ast_Decl_getName(&d->base));
   string_buffer_Buf_newline(out);
   if (d->base.functionDeclBits.is_template) {
      string_buffer_Buf_indent(out, (indent + 1));
      string_buffer_Buf_color(out, ast_col_Template);
      string_buffer_Buf_print(out, "template %s\n", ast_idx2name(d->template_name));
   }
   ast_VarDecl** params = ((ast_VarDecl**)(tail));
   for (uint32_t i = 0; (i < d->num_params); i++) {
      ast_VarDecl_print(params[i], out, (indent + 1));
   }
   if (d->body) {
      ast_CompoundStmt_print(d->body, out, (indent + 1));
   }
}

static void ast_FunctionDecl_printType(const ast_FunctionDecl* d, string_buffer_Buf* out)
{
   if (ast_FunctionDecl_isType(d)) {
      string_buffer_Buf_add(out, ast_Decl_getName(&d->base));
      return;
   }
   if (ast_QualType_isValid(&d->rt)) {
      ast_QualType_print(&d->rt, out);
   } else {
      ast_TypeRef_print(&d->rtype, out, true);
   }
   string_buffer_Buf_add(out, " (");
   const uint8_t* tail = ast_TypeRef_getPointerAfter(&d->rtype);
   ast_VarDecl** params = ((ast_VarDecl**)(tail));
   for (uint32_t i = 0; (i < d->num_params); i++) {
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      ast_VarDecl_printType(params[i], out);
   }
   if (d->base.functionDeclBits.is_variadic) string_buffer_Buf_add(out, ", ...");
   string_buffer_Buf_rparen(out);
}

static ast_FunctionTypeDecl* ast_FunctionTypeDecl_create(ast_context_Context* c, ast_FunctionDecl* func)
{
   ast_FunctionTypeDecl* ftd = ast_context_Context_alloc(c, 32);
   ast_Decl* d = ast_FunctionDecl_asDecl(func);
   ast_Decl_init(&ftd->base, ast_DeclKind_FunctionType, ast_Decl_getNameIdx(d), ast_Decl_getLoc(d), ast_Decl_isPublic(d), ast_Decl_getType(d), ast_Decl_getASTIdx(d));
   ftd->func = func;
   ast_Stats_addDecl(ast_DeclKind_FunctionType, 32);
   return ftd;
}

static ast_Decl* ast_FunctionTypeDecl_asDecl(ast_FunctionTypeDecl* t)
{
   return &t->base;
}

static ast_FunctionDecl* ast_FunctionTypeDecl_getDecl(const ast_FunctionTypeDecl* d)
{
   return d->func;
}

static void ast_FunctionTypeDecl_print(const ast_FunctionTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, "FunctionTypeDecl");
   ast_Decl_printAttrs(&d->base, out);
   string_buffer_Buf_newline(out);
   ast_FunctionDecl_print(d->func, out, (indent + 1));
}

static ast_ImportDecl* ast_ImportDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, uint32_t ast_idx, _Bool is_local)
{
   ast_ImportDecl* d = ast_context_Context_alloc(c, 40);
   ast_Decl_init(&d->base, ast_DeclKind_Import, name, loc, false, ast_QualType_Invalid, ast_idx);
   d->base.importDeclBits.is_local = is_local;
   d->alias_idx = alias_name;
   d->alias_loc = alias_loc;
   d->dest = NULL;
   ast_Stats_addDecl(ast_DeclKind_Import, 40);
   return d;
}

static ast_Decl* ast_ImportDecl_asDecl(ast_ImportDecl* d)
{
   return &d->base;
}

static const char* ast_ImportDecl_getAliasName(const ast_ImportDecl* d)
{
   return ast_idx2name(d->alias_idx);
}

static uint32_t ast_ImportDecl_getAliasNameIdx(const ast_ImportDecl* d)
{
   return d->alias_idx;
}

static uint32_t ast_ImportDecl_getImportNameIdx(const ast_ImportDecl* d)
{
   if (d->alias_idx) return d->alias_idx;

   return d->base.name_idx;
}

static src_loc_SrcLoc ast_ImportDecl_getLoc(const ast_ImportDecl* d)
{
   if (d->alias_idx) return d->alias_loc;

   return ast_Decl_getLoc(&d->base);
}

static void ast_ImportDecl_setDest(ast_ImportDecl* d, ast_Module* mod)
{
   d->dest = mod;
}

static ast_Module* ast_ImportDecl_getDest(const ast_ImportDecl* d)
{
   return d->dest;
}

static _Bool ast_ImportDecl_isLocal(const ast_ImportDecl* d)
{
   return d->base.importDeclBits.is_local;
}

static void ast_ImportDecl_print(const ast_ImportDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, "ImportDecl");
   ast_Decl_printUsed(&d->base, out);
   string_buffer_Buf_add(out, " module=");
   if (d->dest) {
      string_buffer_Buf_add(out, ast_Module_getName(d->dest));
   } else {
      string_buffer_Buf_add(out, "<nil>");
   }
   if (d->base.importDeclBits.is_local) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " local");
   }
   ast_Decl_printName(&d->base, out);
   if (d->alias_idx) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " as ");
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_print(out, "%s", ast_idx2name(d->alias_idx));
   }
   string_buffer_Buf_newline(out);
}

static ast_StaticAssert* ast_StaticAssert_create(ast_context_Context* c, uint32_t ast_idx, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_StaticAssert* d = ast_context_Context_alloc(c, 24);
   d->ast_idx = ast_idx;
   d->lhs = lhs;
   d->rhs = rhs;
   ast_Stats_addStaticAssert(24);
   return d;
}

static ast_AST* ast_StaticAssert_getAST(const ast_StaticAssert* d)
{
   return ast_idx2ast(d->ast_idx);
}

static ast_Expr* ast_StaticAssert_getLhs(const ast_StaticAssert* d)
{
   return d->lhs;
}

static ast_Expr* ast_StaticAssert_getRhs(const ast_StaticAssert* d)
{
   return d->rhs;
}

static void ast_StaticAssert_print(const ast_StaticAssert* d, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_print(out, "StaticAssert\n");
   ast_Expr_print(d->lhs, out, (indent + 1));
   ast_Expr_print(d->rhs, out, (indent + 1));
}

static ast_StructTypeDecl* ast_StructTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, uint32_t ast_idx, _Bool is_struct, _Bool is_global, ast_Decl** members, uint32_t num_members)
{
   uint32_t size = (40 + (num_members * 8));
   size += 12;
   size += (num_members * 4);
   size = (((size + 7)) & ~0x7);
   ast_StructTypeDecl* d = ast_context_Context_alloc(c, size);
   ast_StructType* stype = ast_StructType_create(c, d);
   ast_QualType qt = ast_QualType_create(ast_StructType_asType(stype));
   ast_Type_setCanonicalType(ast_StructType_asType(stype), qt);
   ast_Decl_init(&d->base, ast_DeclKind_StructType, name, loc, is_public, qt, ast_idx);
   d->base.structTypeDeclBits.is_struct = is_struct;
   d->base.structTypeDeclBits.is_global = is_global;
   if (!is_global) ast_Decl_setUsed(&d->base);
   d->num_members = num_members;
   d->num_struct_functions = 0;
   d->struct_functions = NULL;
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   layout->size = 0;
   layout->alignment = 0;
   layout->attr_alignment = 1;
   uint32_t* member_offsets = ((uint32_t*)(&d->members[d->num_members]));
   if (num_members) {
      memcpy(d->members, members, (num_members * 8));
      memset(layout->member_offsets, 0, (num_members * 4));
   }
   ast_Stats_addDecl(ast_DeclKind_StructType, size);
   return d;
}

static ast_Decl* ast_StructTypeDecl_asDecl(ast_StructTypeDecl* d)
{
   return &d->base;
}

static uint32_t ast_StructTypeDecl_getNumMembers(const ast_StructTypeDecl* d)
{
   return d->num_members;
}

static ast_Decl** ast_StructTypeDecl_getMembers(ast_StructTypeDecl* d)
{
   return d->members;
}

static _Bool ast_StructTypeDecl_isStruct(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.is_struct;
}

static _Bool ast_StructTypeDecl_isUnion(const ast_StructTypeDecl* d)
{
   return !d->base.structTypeDeclBits.is_struct;
}

static const ast_FunctionDecl** ast_StructTypeDecl_getStructFunctions(const ast_StructTypeDecl* d)
{
   return ((const ast_FunctionDecl**)(d->struct_functions));
}

static uint32_t ast_StructTypeDecl_getNumStructFunctions(const ast_StructTypeDecl* d)
{
   return d->num_struct_functions;
}

static ast_StructLayout* ast_StructTypeDecl_getLayoutPtr(const ast_StructTypeDecl* d)
{
   return ((ast_StructLayout*)(&d->members[d->num_members]));
}

static void ast_StructTypeDecl_setMemberOffset(ast_StructTypeDecl* d, uint32_t member_idx, uint32_t offset)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   layout->member_offsets[member_idx] = offset;
}

static uint32_t ast_StructTypeDecl_getMemberOffset(const ast_StructTypeDecl* d, uint32_t member_idx)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   return layout->member_offsets[member_idx];
}

static const uint32_t* ast_StructTypeDecl_getMemberOffsets(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   return layout->member_offsets;
}

static uint32_t ast_StructTypeDecl_getSize(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   return layout->size;
}

static void ast_StructTypeDecl_setSizeAlignment(ast_StructTypeDecl* d, uint32_t size, uint32_t alignment)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   d->base.structTypeDeclBits.size_analysed = true;
   layout->size = size;
   layout->alignment = alignment;
}

static uint32_t ast_StructTypeDecl_getAlignment(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   return layout->alignment;
}

static uint32_t ast_StructTypeDecl_getAttrAlignment(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   return layout->attr_alignment;
}

static void ast_StructTypeDecl_setAttrAlignment(ast_StructTypeDecl* d, uint32_t alignment)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
   layout->attr_alignment = alignment;
}

static void ast_StructTypeDecl_setPacked(ast_StructTypeDecl* d)
{
   d->base.structTypeDeclBits.attr_packed = 1;
}

static _Bool ast_StructTypeDecl_isPacked(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.attr_packed;
}

static void ast_StructTypeDecl_setOpaque(ast_StructTypeDecl* d)
{
   d->base.structTypeDeclBits.attr_opaque = 1;
}

static _Bool ast_StructTypeDecl_isOpaque(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.attr_opaque;
}

static _Bool ast_StructTypeDecl_isGlobal(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.is_global;
}

static void ast_StructTypeDecl_setAttrNoTypeDef(ast_StructTypeDecl* d)
{
   d->base.structTypeDeclBits.attr_notypedef = 1;
}

static _Bool ast_StructTypeDecl_hasAttrNoTypeDef(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.attr_notypedef;
}

static void ast_StructTypeDecl_setStructFunctions(ast_StructTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count)
{
   const uint32_t size = (count * 8);
   void* dest = ast_context_Context_alloc(c, size);
   memcpy(dest, funcs, size);
   d->struct_functions = dest;
   d->num_struct_functions = count;
}

static ast_Decl* ast_StructTypeDecl_findAny(const ast_StructTypeDecl* s, uint32_t name_idx, uint32_t* offset)
{
   for (uint32_t i = 0; (i < ast_StructTypeDecl_getNumMembers(s)); i++) {
      ast_Decl* d = s->members[i];
      uint32_t member_name = ast_Decl_getNameIdx(d);
      if ((member_name == name_idx)) {
         if (offset) *offset += ast_StructTypeDecl_getMemberOffset(s, i);
         return d;
      }
      if (((member_name == 0) && ast_Decl_isStructType(d))) {
         ast_StructTypeDecl* sub = ((ast_StructTypeDecl*)(d));
         d = ast_StructTypeDecl_findAny(sub, name_idx, offset);
         if (d) {
            if (offset) *offset += ast_StructTypeDecl_getMemberOffset(s, i);
            return d;
         }
      }
   }
   if (s->base.structTypeDeclBits.is_global) {
      for (uint32_t i = 0; (i < s->num_struct_functions); i++) {
         ast_Decl* sf = ((ast_Decl*)(s->struct_functions[i]));
         if ((ast_Decl_getNameIdx(sf) == name_idx)) return sf;

      }
   }
   return NULL;
}

static ast_Decl* ast_StructTypeDecl_findMember(const ast_StructTypeDecl* s, uint32_t name_idx, uint32_t* offset)
{
   for (uint32_t i = 0; (i < ast_StructTypeDecl_getNumMembers(s)); i++) {
      ast_Decl* d = s->members[i];
      uint32_t member_name = ast_Decl_getNameIdx(d);
      if ((member_name == name_idx)) {
         if (offset) *offset += ast_StructTypeDecl_getMemberOffset(s, i);
         return d;
      }
      if (((member_name == 0) && ast_Decl_isStructType(d))) {
         ast_StructTypeDecl* sub = ((ast_StructTypeDecl*)(d));
         d = ast_StructTypeDecl_findMember(sub, name_idx, offset);
         if (d) {
            if (offset) *offset += ast_StructTypeDecl_getMemberOffset(s, i);
            return d;
         }
      }
   }
   return NULL;
}

static void ast_StructTypeDecl_print(const ast_StructTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   _Bool is_global = d->base.structTypeDeclBits.is_global;
   if (is_global) string_buffer_Buf_add(out, " global");
   if (d->base.structTypeDeclBits.is_struct) string_buffer_Buf_add(out, " struct");
   else string_buffer_Buf_add(out, " union");
   if (ast_StructTypeDecl_isPacked(d)) string_buffer_Buf_add(out, " packed");
   if (ast_StructTypeDecl_isOpaque(d)) string_buffer_Buf_add(out, " opaque");
   if (ast_StructTypeDecl_hasAttrNoTypeDef(d)) string_buffer_Buf_add(out, " notypedef");
   if (is_global) ast_Decl_printAttrs(&d->base, out);
   if (d->base.structTypeDeclBits.size_analysed) {
      string_buffer_Buf_color(out, ast_col_Calc);
      ast_StructLayout* layout = ast_StructTypeDecl_getLayoutPtr(d);
      string_buffer_Buf_print(out, " size=%u align=%u", layout->size, layout->alignment);
   }
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   if (ast_Decl_getName(&d->base)) string_buffer_Buf_add(out, ast_Decl_getName(&d->base));
   else string_buffer_Buf_add(out, "<anonymous>");
   string_buffer_Buf_newline(out);
   for (uint32_t i = 0; (i < d->num_members); i++) {
      string_buffer_Buf_indent(out, (indent + 1));
      string_buffer_Buf_color(out, ast_col_Calc);
      string_buffer_Buf_print(out, "offset=%u\n", ast_StructTypeDecl_getMemberOffset(d, i));
      ast_Decl_print(d->members[i], out, (indent + 1));
   }
}

static void ast_Value_setUnsigned(ast_Value* v, uint64_t uvalue)
{
   v->kind = ast_ValueKind_Integer;
   v->overflow = false;
   v->negative = false;
   v->uvalue = uvalue;
}

static void ast_Value_setSigned(ast_Value* v, int64_t svalue)
{
   v->kind = ast_ValueKind_Integer;
   v->overflow = false;
   if ((svalue < 0)) {
      v->negative = true;
      v->uvalue = (~svalue + 1);
   } else {
      v->negative = false;
      v->uvalue = ((uint64_t)(svalue));
   }
}

static void ast_Value_setFloat(ast_Value* v, double fvalue)
{
   v->kind = ast_ValueKind_Float;
   v->overflow = false;
   v->negative = false;
   v->fvalue = fvalue;
}

static _Bool ast_Value_isNegative(const ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      return v->negative;
   case ast_ValueKind_Float:
      return (v->fvalue < 0);
   }
   return false;
}

static _Bool ast_Value_isFloat(const ast_Value* v)
{
   return (v->kind == ast_ValueKind_Float);
}

static _Bool ast_Value_isDecimal(const ast_Value* v)
{
   return (v->kind == ast_ValueKind_Integer);
}

static _Bool ast_Value_isZero(const ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      return (!v->negative && (v->uvalue == 0));
   case ast_ValueKind_Float:
      return (v->fvalue == 0);
   }
   return false;
}

static double ast_Value_toFloat(const ast_Value* v)
{
   if ((v->kind == ast_ValueKind_Integer)) {
      double f = ((double)(v->uvalue));
      return (v->negative) ? -f : f;
   } else {
      return v->fvalue;
   }
}

static uint8_t ast_Value_as_u8(ast_Value* v)
{
   ((v->kind == ast_ValueKind_Integer)) || c2_assert("ast/value.c2", 103, "ast.Value.as_u8", "v.kind == ValueKind.Integer");
   uint8_t res = ((uint8_t)(v->uvalue));
   if (v->negative) res = (~res + 1);
   return res;
}

static uint16_t ast_Value_as_u16(ast_Value* v)
{
   ((v->kind == ast_ValueKind_Integer)) || c2_assert("ast/value.c2", 110, "ast.Value.as_u16", "v.kind == ValueKind.Integer");
   uint16_t res = ((uint16_t)(v->uvalue));
   if (v->negative) res = (~res + 1);
   return res;
}

static int32_t ast_Value_as_i32(ast_Value* v)
{
   int32_t res = 0;
   if ((v->kind == ast_ValueKind_Integer)) {
      res = ((int32_t)(v->uvalue));
      if (v->negative) res = (~res + 1);
   }
   return res;
}

static uint32_t ast_Value_as_u32(ast_Value* v)
{
   uint32_t res = 0;
   if ((v->kind == ast_ValueKind_Integer)) {
      res = ((uint32_t)(v->uvalue));
      if (v->negative) res = (~res + 1);
   }
   return res;
}

static uint64_t ast_Value_as_u64(ast_Value* v)
{
   uint64_t res = 0;
   if ((v->kind == ast_ValueKind_Integer)) {
      res = v->uvalue;
      if (v->negative) res = (~res + 1);
   }
   return res;
}

static uint8_t ast_Value_getWidth(const ast_Value* v)
{
   if ((v->kind != ast_ValueKind_Integer)) return 64;

   uint64_t value = v->negative ? v->uvalue : (v->uvalue - 1);
   if ((value <= 65535)) {
      if ((value <= 255)) {
         if ((value <= 127)) return 7;
         else return 8;

      }
      if ((value <= 32767)) return 15;
      else return 16;

   }
   if ((value <= 4294967295)) {
      if ((value <= 2147483647)) return 31;
      else return 32;

   }
   if ((value <= 9223372036854775807lu)) return 63;

   return 64;
}

static _Bool ast_Value_checkRange(const ast_Value* v, int64_t min, uint64_t max)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      if (v->negative) return ((v->uvalue <= (((uint64_t)(~min)) + 1)));
      else return ((v->uvalue <= max));

      break;
   case ast_ValueKind_Float:
      return (((v->fvalue >= ((double)(min))) && (v->fvalue < (((double)(max)) + 1))));
   }
   return false;
}

static ast_Value ast_Value_negate(const ast_Value* v)
{
   ast_Value result = *v;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      if (result.uvalue) {
         result.negative = !result.negative;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue = -result.fvalue;
      break;
   }
   return result;
}

static ast_Value ast_Value_bitnot(const ast_Value* v)
{
   ast_Value result = *v;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      if (result.negative) {
         result.uvalue = (~result.uvalue + 1);
         result.uvalue = ~result.uvalue;
         result.negative = false;
      } else {
         result.uvalue = ~result.uvalue;
         result.uvalue = (~result.uvalue + 1);
         result.negative = true;
      }
      break;
   case ast_ValueKind_Float:
      (0) || c2_assert("ast/value.c2", 211, "ast.Value.bitnot", "0");
      break;
   }
   return result;
}

static ast_Value ast_Value_lnot(const ast_Value* v)
{
   ast_Value result;
   ast_Value_setUnsigned(&result, ast_Value_isZero(v));
   result.overflow = v->overflow;
   return result;
}

static ast_Value ast_Value_minus(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value tmp = ast_Value_negate(v2);
   return ast_Value_add(v1, &tmp);
}

static ast_Value ast_Value_add(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if ((result.negative != v2->negative)) {
            if ((result.uvalue > v2->uvalue)) {
               result.uvalue -= v2->uvalue;
            } else {
               result.uvalue = (v2->uvalue - result.uvalue);
               result.negative = (v2->negative && result.uvalue);
            }
         } else {
            if ((result.uvalue > (c2_max_u64 - v2->uvalue))) {
               result.overflow = true;
            }
            result.uvalue += v2->uvalue;
         }
         break;
      case ast_ValueKind_Float:
         result.fvalue = (ast_Value_toFloat(&result) + v2->fvalue);
         result.kind = ast_ValueKind_Float;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue += ast_Value_toFloat(v2);
      break;
   }
   return result;
}

static ast_Value ast_Value_multiply(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (result.uvalue) {
            if (!v2->uvalue) result.negative = false;
            else result.negative ^= v2->negative;
            if (((c2_max_u64 / result.uvalue) > v2->uvalue)) result.overflow = true;
            result.uvalue *= v2->uvalue;
         }
         break;
      case ast_ValueKind_Float:
         result.fvalue = (ast_Value_toFloat(&result) * v2->fvalue);
         result.kind = ast_ValueKind_Float;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue *= ast_Value_toFloat(v2);
      break;
   }
   return result;
}

static ast_Value ast_Value_divide(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if ((v2->uvalue == 0)) {
            result.overflow = true;
            result.uvalue = c2_max_u64;
         } else {
            result.uvalue /= v2->uvalue;
            result.negative = (result.uvalue && (result.negative != v2->negative));
         }
         break;
      case ast_ValueKind_Float:
         result.fvalue = (ast_Value_toFloat(&result) / v2->fvalue);
         result.kind = ast_ValueKind_Float;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue /= ast_Value_toFloat(v2);
      break;
   }
   return result;
}

static ast_Value ast_Value_remainder(const ast_Value* v1, const ast_Value* v2)
{
   (ast_Value_isDecimal(v1)) || c2_assert("ast/value.c2", 322, "ast.Value.remainder", "v1.isDecimal()");
   (ast_Value_isDecimal(v2)) || c2_assert("ast/value.c2", 323, "ast.Value.remainder", "v2.isDecimal()");
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   if ((v2->uvalue == 0)) {
      result.overflow = true;
      result.uvalue = 0;
   } else {
      result.uvalue %= v2->uvalue;
      if ((result.uvalue == 0)) result.negative = false;
   }
   return result;
}

static ast_Value ast_Value_left_shift(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (!v2->negative) {
            uint8_t shift = (v2->uvalue & 63);
            if (result.negative) {
               result.uvalue = (~result.uvalue + 1);
               result.uvalue <<= shift;
               result.uvalue = (~result.uvalue + 1);
               if ((result.uvalue == 0)) result.negative = false;
            } else {
               result.uvalue <<= shift;
            }
         }
         break;
      case ast_ValueKind_Float:
         ast_Value_setUnsigned(&result, 0);
         break;
      }
      break;
   case ast_ValueKind_Float:
      ast_Value_setUnsigned(&result, 0);
      break;
   }
   return result;
}

static ast_Value ast_Value_right_shift(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (!v2->negative) {
            uint8_t shift = (v2->uvalue & 63);
            if (result.negative) {
               uint64_t mask = 0;
               result.uvalue = (~result.uvalue + 1);
               result.uvalue >>= shift;
               result.uvalue |= ~((~mask >> shift));
               result.uvalue = (~result.uvalue + 1);
            } else {
               result.uvalue >>= shift;
            }
         }
         break;
      case ast_ValueKind_Float:
         ast_Value_setUnsigned(&result, 0);
         break;
      }
      break;
   case ast_ValueKind_Float:
      ast_Value_setUnsigned(&result, 0);
      break;
   }
   return result;
}

static ast_Value ast_Value_and(const ast_Value* v1, const ast_Value* v2)
{
   (ast_Value_isDecimal(v1)) || c2_assert("ast/value.c2", 410, "ast.Value.and", "v1.isDecimal()");
   (ast_Value_isDecimal(v2)) || c2_assert("ast/value.c2", 411, "ast.Value.and", "v2.isDecimal()");
   ast_Value result = *v1;
   ast_Value r2 = *v2;
   if (result.negative) result.uvalue = (~result.uvalue + 1);
   if (r2.negative) r2.uvalue = (~r2.uvalue + 1);
   result.overflow |= v2->overflow;
   result.negative &= r2.negative;
   result.uvalue &= r2.uvalue;
   if (result.negative) result.uvalue = (~result.uvalue + 1);
   return result;
}

static ast_Value ast_Value_or(const ast_Value* v1, const ast_Value* v2)
{
   (ast_Value_isDecimal(v1)) || c2_assert("ast/value.c2", 425, "ast.Value.or", "v1.isDecimal()");
   (ast_Value_isDecimal(v2)) || c2_assert("ast/value.c2", 426, "ast.Value.or", "v2.isDecimal()");
   ast_Value result = *v1;
   ast_Value r2 = *v2;
   if (result.negative) result.uvalue = (~result.uvalue + 1);
   if (r2.negative) r2.uvalue = (~r2.uvalue + 1);
   result.overflow |= v2->overflow;
   result.negative |= r2.negative;
   result.uvalue |= r2.uvalue;
   if (result.negative) result.uvalue = (~result.uvalue + 1);
   return result;
}

static ast_Value ast_Value_xor(const ast_Value* v1, const ast_Value* v2)
{
   (ast_Value_isDecimal(v1)) || c2_assert("ast/value.c2", 440, "ast.Value.xor", "v1.isDecimal()");
   (ast_Value_isDecimal(v2)) || c2_assert("ast/value.c2", 441, "ast.Value.xor", "v2.isDecimal()");
   ast_Value result = *v1;
   ast_Value r2 = *v2;
   if (result.negative) result.uvalue = (~result.uvalue + 1);
   if (r2.negative) r2.uvalue = (~r2.uvalue + 1);
   result.overflow |= v2->overflow;
   result.negative ^= r2.negative;
   result.uvalue ^= r2.uvalue;
   if (result.negative) result.uvalue = (~result.uvalue + 1);
   return result;
}

static _Bool ast_Value_to_bool(const ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      return (v->uvalue != 0);
   case ast_ValueKind_Float:
      return (v->fvalue != 0);
   }
   return false;
}

static _Bool ast_Value_is_equal(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         return ((v1->negative == v2->negative) && (v1->uvalue == v2->uvalue));
      case ast_ValueKind_Float:
         return (ast_Value_toFloat(v1) == v2->fvalue);
      }
      break;
   case ast_ValueKind_Float:
      return (v1->fvalue == ast_Value_toFloat(v2));
   }
   return false;
}

static _Bool ast_Value_is_less(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return (!v2->negative || (v1->uvalue > v2->uvalue));
         else return (!v2->negative && (v1->uvalue < v2->uvalue));

         break;
      case ast_ValueKind_Float:
         return (ast_Value_toFloat(v1) < v2->fvalue);
      }
      break;
   case ast_ValueKind_Float:
      return (v1->fvalue < ast_Value_toFloat(v2));
   }
   return false;
}

static _Bool ast_Value_is_less_equal(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return (!v2->negative || (v1->uvalue >= v2->uvalue));
         else return (!v2->negative && (v1->uvalue <= v2->uvalue));

         break;
      case ast_ValueKind_Float:
         return (ast_Value_toFloat(v1) <= v2->fvalue);
      }
      break;
   case ast_ValueKind_Float:
      return (v1->fvalue <= ast_Value_toFloat(v2));
   }
   return false;
}

static _Bool ast_Value_is_greater(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return (v2->negative && (v1->uvalue < v2->uvalue));
         else return (v2->negative || (v1->uvalue > v2->uvalue));

         break;
      case ast_ValueKind_Float:
         return (ast_Value_toFloat(v1) > v2->fvalue);
      }
      break;
   case ast_ValueKind_Float:
      return (v1->fvalue > ast_Value_toFloat(v2));
   }
   return false;
}

static _Bool ast_Value_is_greater_equal(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return (v2->negative && (v1->uvalue <= v2->uvalue));
         else return (v2->negative || (v1->uvalue >= v2->uvalue));

         break;
      case ast_ValueKind_Float:
         return (ast_Value_toFloat(v1) >= v2->fvalue);
      }
      break;
   case ast_ValueKind_Float:
      return (v1->fvalue >= ast_Value_toFloat(v2));
   }
   return false;
}

static ast_Value ast_Value_land(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result;
   result.kind = ast_ValueKind_Integer;
   result.negative = false;
   result.overflow = v1->overflow;
   result.uvalue = ast_Value_to_bool(v1);
   if (result.uvalue) {
      result.overflow |= v2->overflow;
      result.uvalue = ast_Value_to_bool(v2);
   }
   return result;
}

static ast_Value ast_Value_lor(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result;
   result.kind = ast_ValueKind_Integer;
   result.negative = false;
   result.overflow = v1->overflow;
   result.uvalue = ast_Value_to_bool(v1);
   if (!result.uvalue) {
      result.overflow |= v2->overflow;
      result.uvalue = ast_Value_to_bool(v2);
   }
   return result;
}

static void ast_Value_mask(ast_Value* v, uint32_t width)
{
   if (v->negative) {
      v->uvalue = (~v->uvalue + 1);
      v->negative = false;
   }
   if ((width < 64)) {
      uint64_t one = 1;
      v->uvalue &= (((one << width)) - 1);
   }
}

static void ast_Value_truncate(ast_Value* orig, _Bool is_signed, uint32_t width)
{
   (ast_Value_isDecimal(orig)) || c2_assert("ast/value.c2", 599, "ast.Value.truncate", "orig.isDecimal()");
   uint64_t uvalue = ast_Value_as_u64(orig);
   uint64_t mask = 1;
   uint64_t sbit = 0;
   switch (width) {
   case 1:
      uvalue = ((uvalue != 0)) ? 1 : 0;
      break;
   case 7:
      sbit = 0x80;
      fallthrough;
   case 8:
      mask = 0xff;
      break;
   case 15:
      sbit = 0x8000;
      fallthrough;
   case 16:
      mask = 0xffff;
      break;
   case 31:
      sbit = 0x80000000;
      fallthrough;
   case 32:
      mask = 0xffffffff;
      break;
   case 63:
      sbit = 0x8000000000000000;
      fallthrough;
   case 64:
      mask = 0xffffffffffffffff;
      break;
   }
   if ((uvalue & sbit)) ast_Value_setSigned(orig, ((int64_t)((((uvalue & ((sbit - 1)))) - sbit))));
   else ast_Value_setUnsigned(orig, (uvalue & mask));
}

static void ast_Value_incr(ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      if (v->negative) {
         if ((v->uvalue == 1)) v->negative = false;
         v->uvalue--;
      } else {
         if ((v->uvalue == c2_max_u64)) v->overflow = true;
         v->uvalue++;
      }
      break;
   case ast_ValueKind_Float:
      v->fvalue += 1;
      break;
   }
}

static void ast_Value_decr(ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      if (v->negative) {
         if ((v->uvalue == c2_max_u64)) v->overflow = true;
         v->uvalue++;
      } else {
         if ((v->uvalue == 0)) {
            v->negative = true;
            v->uvalue = 1;
         } else {
            v->uvalue--;
         }
      }
      break;
   case ast_ValueKind_Float:
      v->fvalue -= 1;
      break;
   }
}

static _Bool ast_isfinite(double d)
{
   ast_FP64 u = { .d = d };
   return (((((u.bits >> 52)) & 0x7ff)) != 0x7ff);
}

static int32_t ast_signbit(double d)
{
   ast_FP64 u = { .d = d };
   return (((u.bits >> 63)) & 1);
}

static double ast_fabs(double d)
{
   ast_FP64 u = { .d = d };
   u.bits = ((u.bits << 1) >> 1);
   return u.d;
}

static char* ast_ftoa(char* dest, size_t size, double d)
{
   char buf[32];
   size_t pos = 0;
   if ((size < 2)) {
      if (size) *dest = '\0';
      return dest;
   }
   if (!ast_isfinite(d)) {
      snprintf(dest, size, "%lf", d);
      return dest;
   }
   if (ast_signbit(d)) {
      dest[pos++] = '-';
      d = ast_fabs(d);
   }
   if (!d) {
      snprintf((dest + pos), (size - pos), "0.0");
      return dest;
   }
   if (((d < 0.0001) || (d > 1000000))) {
      for (int32_t prec = 14; (prec < 17); prec++) {
         snprintf(buf, 32, "%.*le", prec, d);
         if ((atof(buf) == d)) break;

      }
   } else {
      for (int32_t prec = (17 - 4); (prec < (17 + 4)); prec++) {
         snprintf(buf, 32, "%.*lf", prec, d);
         if ((atof(buf) == d)) break;

      }
   }
   char* dot = (buf + 1);
   while ((*dot && (*dot != '.'))) dot++;
   char* exp = dot;
   while ((*exp && (*exp != 'e'))) exp++;
   char* decimals = exp;
   while (((decimals > (dot + 2)) && (decimals[-1] == '0'))) decimals--;
   size_t len = (size - 1);
   for (char* p = buf; ((p < decimals) && (pos < len)); p++) {
      dest[pos++] = *p;
   }
   for (char* p = exp; (*p && (pos < len)); p++) {
      dest[pos++] = *p;
   }
   dest[pos] = '\0';
   return dest;
}

static const char* ast_Value_str(const ast_Value* v)
{
   static char text[4][64];
   static uint8_t index = 0;
   char* out = text[index];
   index = (((index + 1)) % 4);
   switch (v->kind) {
   case ast_ValueKind_Integer:
      *out = '-';
      snprintf((out + v->negative), (64 - 1), "%lu", v->uvalue);
      break;
   case ast_ValueKind_Float:
      ast_ftoa(out, 64, v->fvalue);
      break;
   }
   return out;
}

static ast_VarDecl* ast_VarDecl_create(ast_context_Context* c, ast_VarDeclKind kind, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, src_loc_SrcLoc assignLoc, ast_Expr* initValue)
{
   uint32_t size = (32 + ast_TypeRefHolder_getExtraSize(ref));
   if ((initValue || ast_TypeRefHolder_isIncrArray(ref))) size += (8 + 8);
   ((kind != ast_VarDeclKind_StructMember)) || c2_assert("ast/var_decl.c2", 73, "ast.VarDecl.create", "kind != VarDeclKind.StructMember");
   ast_VarDecl* d = ast_context_Context_alloc(c, size);
   ast_Decl_init(&d->base, ast_DeclKind_Variable, name, loc, is_public, ast_QualType_Invalid, ast_idx);
   d->base.varDeclBits.kind = kind;
   ast_TypeRef_init(&d->typeRef, ref);
   if (initValue) {
      d->base.varDeclBits.has_init_or_bitfield = 1;
      src_loc_SrcLoc* locpos = ast_TypeRef_getPointerAfter(&d->typeRef);
      *locpos = assignLoc;
      ast_Expr** i = ast_VarDecl_getInit2(d);
      *i = initValue;
   }
   ast_Stats_addDecl(ast_DeclKind_Variable, size);
   return d;
}

static ast_VarDecl* ast_VarDecl_createStructMember(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, ast_Expr* bitfield)
{
   uint32_t size = (32 + ast_TypeRefHolder_getExtraSize(ref));
   if (bitfield) size += (8 + 8);
   size = (((size + 7)) & ~0x7);
   ast_VarDecl* d = ast_context_Context_alloc(c, size);
   ast_Decl_init(&d->base, ast_DeclKind_Variable, name, loc, is_public, ast_QualType_Invalid, ast_idx);
   d->base.varDeclBits.kind = ast_VarDeclKind_StructMember;
   if ((name == 0)) ast_Decl_setUsed(&d->base);
   ast_TypeRef_init(&d->typeRef, ref);
   if (bitfield) {
      d->base.varDeclBits.has_init_or_bitfield = 1;
      ast_Expr** i = ast_VarDecl_getInit2(d);
      *i = bitfield;
   }
   ast_Stats_addDecl(ast_DeclKind_Variable, size);
   return d;
}

static ast_VarDecl* ast_VarDecl_instantiate(const ast_VarDecl* vd, ast_Instantiator* inst)
{
   _Bool matches = ast_TypeRef_matchesTemplate(&vd->typeRef, inst->template_name);
   uint32_t extra = matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&vd->typeRef);
   uint32_t size = (32 + extra);
   ast_VarDecl* vd2 = ast_context_Context_alloc(inst->c, size);
   vd2->base = vd->base;
   ast_TypeRef_instantiate(&vd2->typeRef, &vd->typeRef, inst);
   ast_Expr* ie = ast_VarDecl_getInit(vd);
   if (ie) {
      ast_Expr** ie2 = ast_VarDecl_getInit2(vd2);
      *ie2 = ast_Expr_instantiate(ie, inst);
   }
   ast_Stats_addDecl(ast_DeclKind_Variable, size);
   return vd2;
}

static const char* ast_VarDecl_getName(const ast_VarDecl* d)
{
   return ast_idx2name(d->base.name_idx);
}

static ast_Decl* ast_VarDecl_asDecl(ast_VarDecl* d)
{
   return &d->base;
}

static ast_VarDeclKind ast_VarDecl_getKind(const ast_VarDecl* d)
{
   return ((ast_VarDeclKind)(d->base.varDeclBits.kind));
}

static _Bool ast_VarDecl_isGlobal(const ast_VarDecl* d)
{
   return (ast_VarDecl_getKind(d) == ast_VarDeclKind_GlobalVar);
}

static _Bool ast_VarDecl_isLocal(const ast_VarDecl* d)
{
   return (ast_VarDecl_getKind(d) == ast_VarDeclKind_LocalVar);
}

static _Bool ast_VarDecl_isParameter(const ast_VarDecl* d)
{
   return (ast_VarDecl_getKind(d) == ast_VarDeclKind_FunctionParam);
}

static _Bool ast_VarDecl_isStructMember(const ast_VarDecl* d)
{
   return (ast_VarDecl_getKind(d) == ast_VarDeclKind_StructMember);
}

static _Bool ast_VarDecl_isAddrUsed(const ast_VarDecl* d)
{
   return d->base.varDeclBits.addr_used;
}

static void ast_VarDecl_setAddrUsed(ast_VarDecl* d)
{
   d->base.varDeclBits.addr_used = 1;
}

static ast_TypeRef* ast_VarDecl_getTypeRef(ast_VarDecl* d)
{
   return &d->typeRef;
}

static src_loc_SrcLoc ast_VarDecl_getAssignLoc(const ast_VarDecl* d)
{
   if (d->base.varDeclBits.has_init_or_bitfield) {
      src_loc_SrcLoc* locpos = ast_TypeRef_getPointerAfter(&d->typeRef);
      return *locpos;
   }
   return 0;
}

static ast_Expr* ast_VarDecl_getInit(const ast_VarDecl* d)
{
   if (d->base.varDeclBits.has_init_or_bitfield) {
      uint8_t* tail = ast_TypeRef_getPointerAfter(&d->typeRef);
      tail += 8;
      ast_Expr** e = ((ast_Expr**)(tail));
      return *e;
   }
   return NULL;
}

static ast_Expr** ast_VarDecl_getInit2(ast_VarDecl* d)
{
   if (d->base.varDeclBits.has_init_or_bitfield) {
      uint8_t* tail = ast_TypeRef_getPointerAfter(&d->typeRef);
      tail += 8;
      return ((ast_Expr**)(tail));
   }
   return NULL;
}

static void ast_VarDecl_setInit(ast_VarDecl* d, ast_Expr* initValue)
{
   d->base.varDeclBits.has_init_or_bitfield = 1;
   ast_Expr** i = ast_VarDecl_getInit2(d);
   *i = initValue;
}

static ast_Expr* ast_VarDecl_getBitfield(const ast_VarDecl* d)
{
   if (ast_VarDecl_isStructMember(d)) return ast_VarDecl_getInit(d);

   return NULL;
}

static _Bool ast_VarDecl_hasLocalQualifier(const ast_VarDecl* d)
{
   return d->base.varDeclBits.has_local;
}

static void ast_VarDecl_setLocal(ast_VarDecl* d, _Bool has_local)
{
   d->base.varDeclBits.has_local = has_local;
}

static void ast_VarDecl_setInitCall(ast_VarDecl* d, _Bool has_init_call)
{
   d->base.varDeclBits.has_init_call = has_init_call;
}

static _Bool ast_VarDecl_hasInitCall(ast_VarDecl* d)
{
   return d->base.varDeclBits.has_init_call;
}

static void ast_VarDecl_setAttrWeak(ast_VarDecl* d)
{
   d->base.varDeclBits.attr_weak = 1;
}

static _Bool ast_VarDecl_hasAttrWeak(const ast_VarDecl* d)
{
   return d->base.varDeclBits.attr_weak;
}

static void ast_VarDecl_setAttrAutoFile(ast_VarDecl* d)
{
   d->base.varDeclBits.auto_file = 1;
}

static _Bool ast_VarDecl_hasAttrAutoFile(const ast_VarDecl* d)
{
   return d->base.varDeclBits.auto_file;
}

static void ast_VarDecl_setAttrAutoLine(ast_VarDecl* d)
{
   d->base.varDeclBits.auto_line = 1;
}

static _Bool ast_VarDecl_hasAttrAutoLine(const ast_VarDecl* d)
{
   return d->base.varDeclBits.auto_line;
}

static _Bool ast_VarDecl_hasAutoAttr(const ast_VarDecl* d)
{
   return (d->base.varDeclBits.auto_file || d->base.varDeclBits.auto_line);
}

static void ast_VarDecl_setPrintfFormat(ast_VarDecl* d)
{
   d->base.varDeclBits.printf_format = 1;
}

static _Bool ast_VarDecl_hasPrintfFormat(const ast_VarDecl* d)
{
   return d->base.varDeclBits.printf_format;
}

static void ast_VarDecl_print(const ast_VarDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   _Bool valid_type = ast_QualType_isValid(&d->base.qt);
   ast_Decl_printKind(&d->base, out, indent, valid_type);
   if (!valid_type) {
      string_buffer_Buf_space(out);
      ast_TypeRef_print(&d->typeRef, out, true);
   }
   string_buffer_Buf_color(out, ast_col_Attr);
   ast_VarDeclKind k = ast_VarDecl_getKind(d);
   string_buffer_Buf_add(out, ast_varDeclNames[k]);
   _Bool has_init_or_bitfield = d->base.varDeclBits.has_init_or_bitfield;
   if (((k == ast_VarDeclKind_StructMember) && has_init_or_bitfield)) string_buffer_Buf_add(out, " bitfield");
   if (ast_VarDecl_hasLocalQualifier(d)) string_buffer_Buf_add(out, " (local)");
   if (d->base.varDeclBits.attr_weak) string_buffer_Buf_add(out, " weak");
   if (d->base.varDeclBits.addr_used) string_buffer_Buf_add(out, " addr_used");
   if (d->base.varDeclBits.auto_file) string_buffer_Buf_add(out, " auto_file");
   if (d->base.varDeclBits.auto_line) string_buffer_Buf_add(out, " auto_line");
   if (d->base.varDeclBits.printf_format) string_buffer_Buf_add(out, " printf_format");
   if (d->base.varDeclBits.has_init_call) string_buffer_Buf_add(out, " init_call");
   ast_Decl_printBits(&d->base, out);
   ast_Decl_printAttrs(&d->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_Decl_printName(&d->base, out);
   string_buffer_Buf_newline(out);
   if (has_init_or_bitfield) {
      ast_Expr* i = ast_VarDecl_getInit(d);
      ast_Expr_print(i, out, (indent + 1));
   }
}

static void ast_VarDecl_printType(const ast_VarDecl* d, string_buffer_Buf* out)
{
   if (ast_QualType_isValid(&d->base.qt)) {
      ast_QualType_printQuoted(&d->base.qt, out);
   } else {
      ast_TypeRef_print(&d->typeRef, out, true);
   }
}

static void ast_Stmt_init(ast_Stmt* s, ast_StmtKind k, src_loc_SrcLoc loc)
{
   s->bits = 0;
   s->stmtBits.kind = k;
   s->loc = loc;
}

static ast_Stmt* ast_Stmt_instantiate(ast_Stmt* s, ast_Instantiator* inst)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      return ast_ReturnStmt_instantiate(((ast_ReturnStmt*)(s)), inst);
   case ast_StmtKind_Expr:
      return ((ast_Stmt*)(ast_Expr_instantiate(((ast_Expr*)(s)), inst)));
   case ast_StmtKind_If:
      return ast_IfStmt_instantiate(((ast_IfStmt*)(s)), inst);
   case ast_StmtKind_While:
      return ast_WhileStmt_instantiate(((ast_WhileStmt*)(s)), inst);
   case ast_StmtKind_For:
      return ast_ForStmt_instantiate(((ast_ForStmt*)(s)), inst);
   case ast_StmtKind_Switch:
      return ast_SwitchStmt_instantiate(((ast_SwitchStmt*)(s)), inst);
   case ast_StmtKind_Break:
      return s;
   case ast_StmtKind_Continue:
      return s;
   case ast_StmtKind_Fallthrough:
      return s;
   case ast_StmtKind_Label:
      return ast_LabelStmt_instantiate(((ast_LabelStmt*)(s)), inst);
   case ast_StmtKind_Goto:
      return s;
   case ast_StmtKind_Compound:
      return ((ast_Stmt*)(ast_CompoundStmt_instantiate(((ast_CompoundStmt*)(s)), inst)));
   case ast_StmtKind_Decl:
      return ast_DeclStmt_instantiate(((ast_DeclStmt*)(s)), inst);
   case ast_StmtKind_Asm:
      break;
   case ast_StmtKind_Assert:
      return ast_AssertStmt_instantiate(((ast_AssertStmt*)(s)), inst);
   }
   ast_Stmt_dump(s);
   (0) || c2_assert("ast/stmt.c2", 142, "ast.Stmt.instantiate", "0");
   return NULL;
}

static ast_StmtKind ast_Stmt_getKind(const ast_Stmt* s)
{
   return ((ast_StmtKind)(s->stmtBits.kind));
}

static _Bool ast_Stmt_isReturn(const ast_Stmt* s)
{
   return (ast_Stmt_getKind(s) == ast_StmtKind_Return);
}

static _Bool ast_Stmt_isExpr(const ast_Stmt* s)
{
   return (ast_Stmt_getKind(s) == ast_StmtKind_Expr);
}

static _Bool ast_Stmt_isCompound(const ast_Stmt* s)
{
   return (ast_Stmt_getKind(s) == ast_StmtKind_Compound);
}

static _Bool ast_Stmt_isFallthrough(const ast_Stmt* s)
{
   return (ast_Stmt_getKind(s) == ast_StmtKind_Fallthrough);
}

static _Bool ast_Stmt_isDecl(const ast_Stmt* s)
{
   return (ast_Stmt_getKind(s) == ast_StmtKind_Decl);
}

static _Bool ast_Stmt_isLabel(const ast_Stmt* s)
{
   return (ast_Stmt_getKind(s) == ast_StmtKind_Label);
}

static src_loc_SrcLoc ast_Stmt_getLoc(const ast_Stmt* s)
{
   return s->loc;
}

static void ast_Stmt_dump(const ast_Stmt* s)
{
   string_buffer_Buf* out = string_buffer_create((10 * 4096), ast_useColor(), 2);
   ast_Stmt_print(s, out, 0);
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ast_Stmt_print(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      ast_ReturnStmt_print(((ast_ReturnStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Expr:
      ast_Expr_print(((ast_Expr*)(s)), out, indent);
      break;
   case ast_StmtKind_If:
      ast_IfStmt_print(((ast_IfStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_While:
      ast_WhileStmt_print(((ast_WhileStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_For:
      ast_ForStmt_print(((ast_ForStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Switch:
      ast_SwitchStmt_print(((ast_SwitchStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Break:
      ast_BreakStmt_print(((ast_BreakStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Continue:
      ast_ContinueStmt_print(((ast_ContinueStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Fallthrough:
      ast_FallthroughStmt_print(((ast_FallthroughStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Label:
      ast_LabelStmt_print(((ast_LabelStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Goto:
      ast_GotoStmt_print(((ast_GotoStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Compound:
      ast_CompoundStmt_print(((ast_CompoundStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Decl:
      ast_DeclStmt_print(((ast_DeclStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Asm:
      ast_AsmStmt_print(((ast_AsmStmt*)(s)), out, indent);
      break;
   case ast_StmtKind_Assert:
      ast_AssertStmt_print(((ast_AssertStmt*)(s)), out, indent);
      break;
   }
}

static void ast_Stmt_printKind(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Stmt);
   string_buffer_Buf_add(out, ast_stmtKind_names[ast_Stmt_getKind(s)]);
}

static ast_AsmStmt* ast_AsmStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, _Bool is_basic, _Bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* str)
{
   uint32_t size = 24;
   size += ((ast_ExprList_size(constraints) * 8));
   size += ((ast_ExprList_size(exprs) * 8));
   size += ((ast_ExprList_size(clobbers) * 8));
   size += (((num_inputs + num_outputs)) * 4);
   ast_AsmStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Asm, loc);
   s->base.asmStmtBits.is_basic = is_basic;
   s->base.asmStmtBits.is_volatile = is_volatile;
   s->num_outputs = ((uint8_t)(num_outputs));
   s->num_inputs = ((uint8_t)(num_inputs));
   s->num_constraints = ((uint8_t)(ast_ExprList_size(constraints)));
   s->num_exprs = ((uint8_t)(ast_ExprList_size(exprs)));
   s->num_clobbers = ((uint8_t)(ast_ExprList_size(clobbers)));
   s->asm_string = ((ast_StringLiteral*)(str));
   uint8_t* tail = ((uint8_t*)(s->constraints));
   if (ast_ExprList_size(constraints)) {
      uint32_t sz = (ast_ExprList_size(constraints) * 8);
      memcpy(tail, ast_ExprList_getExprs(constraints), sz);
      tail += sz;
   }
   if (ast_ExprList_size(exprs)) {
      uint32_t sz = (ast_ExprList_size(exprs) * 8);
      memcpy(tail, ast_ExprList_getExprs(exprs), sz);
      tail += sz;
   }
   if (ast_ExprList_size(clobbers)) {
      uint32_t sz = (ast_ExprList_size(clobbers) * 8);
      memcpy(tail, ast_ExprList_getExprs(clobbers), sz);
      tail += sz;
   }
   uint32_t num_names = (num_outputs + num_inputs);
   if (num_names) {
      memcpy(tail, names, (num_names * 4));
   }
   ast_Stats_addStmt(ast_StmtKind_Asm, size);
   return s;
}

static ast_Stmt* ast_AsmStmt_instantiate(ast_AsmStmt* s, ast_Instantiator* inst)
{
   return ((ast_Stmt*)(s));
}

static _Bool ast_AsmStmt_isVolatile(const ast_AsmStmt* s)
{
   return s->base.asmStmtBits.is_volatile;
}

static uint32_t ast_AsmStmt_getNumConstraints(const ast_AsmStmt* s)
{
   return s->num_constraints;
}

static uint32_t ast_AsmStmt_getNumClobbers(const ast_AsmStmt* s)
{
   return s->num_clobbers;
}

static uint32_t ast_AsmStmt_getNumExprs(const ast_AsmStmt* s)
{
   return s->num_exprs;
}

static uint32_t ast_AsmStmt_getNumOutputs(const ast_AsmStmt* s)
{
   return s->num_outputs;
}

static uint32_t ast_AsmStmt_getNumInputs(const ast_AsmStmt* s)
{
   return s->num_inputs;
}

static ast_StringLiteral* ast_AsmStmt_getString(const ast_AsmStmt* s)
{
   return s->asm_string;
}

static const ast_Expr** ast_AsmStmt_getConstraints(const ast_AsmStmt* s)
{
   return ((const ast_Expr**)(s->constraints));
}

static ast_Expr** ast_AsmStmt_getExprs(const ast_AsmStmt* s)
{
   uint8_t* tail = ((uint8_t*)(s->constraints));
   tail += (s->num_constraints * 8);
   return ((ast_Expr**)(tail));
}

static ast_Expr** ast_AsmStmt_getClobbers(const ast_AsmStmt* s)
{
   uint8_t* tail = ((uint8_t*)(s->constraints));
   tail += (s->num_constraints * 8);
   tail += (s->num_exprs * 8);
   return ((ast_Expr**)(tail));
}

static uint32_t* ast_AsmStmt_getNames(const ast_AsmStmt* s)
{
   uint8_t* tail = ((uint8_t*)(s->constraints));
   tail += (s->num_constraints * 8);
   tail += (s->num_exprs * 8);
   tail += (s->num_clobbers * 8);
   return ((uint32_t*)(tail));
}

static void ast_AsmStmt_print(const ast_AsmStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, indent);
   ast_StringLiteral_print(s->asm_string, out, 0);
   if (s->num_outputs) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "outputs\n");
      const uint32_t* names = ast_AsmStmt_getNames(s);
      const ast_Expr** constraints = ast_AsmStmt_getConstraints(s);
      ast_Expr** exprs = ast_AsmStmt_getExprs(s);
      for (uint32_t i = 0; (i < s->num_outputs); i++) {
         string_buffer_Buf_indent(out, (indent + 1));
         if (names[i]) {
            string_buffer_Buf_color(out, ast_col_Value);
            string_buffer_Buf_add(out, ast_idx2name(names[i]));
            string_buffer_Buf_space(out);
         }
         string_buffer_Buf_color(out, ast_col_Value);
         const ast_StringLiteral* sl = ((ast_StringLiteral*)(constraints[i]));
         ast_StringLiteral_printLiteral(sl, out);
         string_buffer_Buf_newline(out);
         const ast_Expr* e = exprs[i];
         ast_Expr_print(e, out, (indent + 1));
      }
   }
   if (s->num_inputs) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "inputs\n");
      const uint32_t* names = ast_AsmStmt_getNames(s);
      const ast_Expr** constraints = ast_AsmStmt_getConstraints(s);
      ast_Expr** exprs = ast_AsmStmt_getExprs(s);
      for (uint32_t i = 0; (i < s->num_inputs); i++) {
         string_buffer_Buf_indent(out, (indent + 1));
         if (names[(i + s->num_outputs)]) {
            string_buffer_Buf_color(out, ast_col_Value);
            string_buffer_Buf_add(out, ast_idx2name(names[(i + s->num_outputs)]));
            string_buffer_Buf_space(out);
         }
         string_buffer_Buf_color(out, ast_col_Value);
         const ast_StringLiteral* sl = ((ast_StringLiteral*)(constraints[(i + s->num_outputs)]));
         ast_StringLiteral_printLiteral(sl, out);
         string_buffer_Buf_newline(out);
         const ast_Expr* e = exprs[(i + s->num_outputs)];
         ast_Expr_print(e, out, (indent + 1));
      }
   }
   if (s->num_clobbers) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "clobbers: ");
      ast_Expr** clobbers = ast_AsmStmt_getClobbers(s);
      for (uint32_t i = 0; (i < s->num_clobbers); i++) {
         if ((i != 0)) string_buffer_Buf_space(out);
         ast_Expr_print(clobbers[i], out, (indent + 1));
      }
   }
}

static ast_AssertStmt* ast_AssertStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* inner)
{
   ast_AssertStmt* s = ast_context_Context_alloc(c, 16);
   ast_Stmt_init(&s->base, ast_StmtKind_Assert, loc);
   s->inner = inner;
   ast_Stats_addStmt(ast_StmtKind_Assert, 16);
   return s;
}

static ast_Stmt* ast_AssertStmt_instantiate(ast_AssertStmt* s, ast_Instantiator* inst)
{
   ast_AssertStmt* s2 = ast_AssertStmt_create(inst->c, s->base.loc, ast_Expr_instantiate(s->inner, inst));
   return ((ast_Stmt*)(s2));
}

static ast_Expr* ast_AssertStmt_getInner(const ast_AssertStmt* s)
{
   return s->inner;
}

static ast_Expr** ast_AssertStmt_getInner2(ast_AssertStmt* s)
{
   return &s->inner;
}

static void ast_AssertStmt_print(const ast_AssertStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_Expr_print(s->inner, out, (indent + 1));
}

static ast_BreakStmt* ast_BreakStmt_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_BreakStmt* s = ast_context_Context_alloc(c, 8);
   ast_Stmt_init(&s->base, ast_StmtKind_Break, loc);
   ast_Stats_addStmt(ast_StmtKind_Break, 8);
   return s;
}

static void ast_BreakStmt_print(const ast_BreakStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
}

static ast_CompoundStmt* ast_CompoundStmt_create(ast_context_Context* c, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count)
{
   ((count < 65556)) || c2_assert("ast/compound_stmt.c2", 35, "ast.CompoundStmt.create", "count < 65556");
   uint32_t size = (8 + (count * 8));
   ast_CompoundStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Compound, endLoc);
   s->base.compoundStmtBits.count = count;
   if (count) {
      memcpy(s->stmts, stmts, (count * 8));
   }
   ast_Stats_addStmt(ast_StmtKind_Compound, size);
   return s;
}

static ast_CompoundStmt* ast_CompoundStmt_instantiate(ast_CompoundStmt* s, ast_Instantiator* inst)
{
   const uint32_t count = s->base.compoundStmtBits.count;
   uint32_t size = (8 + (count * 8));
   ast_CompoundStmt* s2 = ast_context_Context_alloc(inst->c, size);
   s2->base = s->base;
   for (uint32_t i = 0; (i < count); i++) {
      s2->stmts[i] = ast_Stmt_instantiate(s->stmts[i], inst);
   }
   return s2;
}

static uint32_t ast_CompoundStmt_getCount(const ast_CompoundStmt* s)
{
   return s->base.compoundStmtBits.count;
}

static ast_Stmt** ast_CompoundStmt_getStmts(ast_CompoundStmt* s)
{
   if (ast_CompoundStmt_getCount(s)) return s->stmts;

   return NULL;
}

static ast_Stmt* ast_CompoundStmt_getLastStmt(const ast_CompoundStmt* s)
{
   uint32_t count = ast_CompoundStmt_getCount(s);
   if (count) return s->stmts[(count - 1)];

   return NULL;
}

static src_loc_SrcLoc ast_CompoundStmt_getEndLoc(const ast_CompoundStmt* e)
{
   return (e->base.loc + 1);
}

static void ast_CompoundStmt_print(const ast_CompoundStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   const uint32_t count = s->base.compoundStmtBits.count;
   for (uint32_t i = 0; (i < count); i++) {
      ast_Stmt_print(s->stmts[i], out, (indent + 1));
   }
}

static ast_ContinueStmt* ast_ContinueStmt_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_ContinueStmt* s = ast_context_Context_alloc(c, 8);
   ast_Stmt_init(&s->base, ast_StmtKind_Continue, loc);
   ast_Stats_addStmt(ast_StmtKind_Continue, 8);
   return s;
}

static void ast_ContinueStmt_print(const ast_ContinueStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
}

static ast_FallthroughStmt* ast_FallthroughStmt_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_FallthroughStmt* s = ast_context_Context_alloc(c, 8);
   ast_Stmt_init(&s->base, ast_StmtKind_Fallthrough, loc);
   ast_Stats_addStmt(ast_StmtKind_Fallthrough, 8);
   return s;
}

static void ast_FallthroughStmt_print(const ast_FallthroughStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
}

static ast_ForStmt* ast_ForStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* cont, ast_Stmt* body)
{
   ast_ForStmt* s = ast_context_Context_alloc(c, 40);
   ast_Stmt_init(&s->base, ast_StmtKind_For, loc);
   s->init = init;
   s->cond = cond;
   s->cont = cont;
   s->body = body;
   ast_Stats_addStmt(ast_StmtKind_For, 40);
   return s;
}

static ast_Stmt* ast_ForStmt_instantiate(ast_ForStmt* s, ast_Instantiator* inst)
{
   ast_Stmt* init2 = s->init ? ast_Stmt_instantiate(s->init, inst) : NULL;
   ast_Expr* cond2 = s->cond ? ast_Expr_instantiate(s->cond, inst) : NULL;
   ast_Expr* cont2 = s->cont ? ast_Expr_instantiate(s->cont, inst) : NULL;
   ast_Stmt* body2 = s->body ? ast_Stmt_instantiate(s->body, inst) : NULL;
   return ((ast_Stmt*)(ast_ForStmt_create(inst->c, s->base.loc, init2, cond2, cont2, body2)));
}

static ast_Stmt* ast_ForStmt_getInit(const ast_ForStmt* s)
{
   return s->init;
}

static ast_Expr* ast_ForStmt_getCond(const ast_ForStmt* s)
{
   return s->cond;
}

static ast_Expr* ast_ForStmt_getCont(const ast_ForStmt* s)
{
   return s->cont;
}

static ast_Stmt* ast_ForStmt_getBody(const ast_ForStmt* s)
{
   return s->body;
}

static ast_Stmt** ast_ForStmt_getInit2(ast_ForStmt* s)
{
   return s->init ? &s->init : NULL;
}

static ast_Expr** ast_ForStmt_getCond2(ast_ForStmt* s)
{
   return s->cond ? &s->cond : NULL;
}

static ast_Expr** ast_ForStmt_getCont2(ast_ForStmt* s)
{
   return s->cont ? &s->cont : NULL;
}

static void ast_ForStmt_print(const ast_ForStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   if (s->init) ast_Stmt_print(s->init, out, (indent + 1));
   if (s->cond) ast_Expr_print(s->cond, out, (indent + 1));
   if (s->cont) ast_Expr_print(s->cont, out, (indent + 1));
   if (s->body) ast_Stmt_print(s->body, out, (indent + 1));
}

static ast_GotoStmt* ast_GotoStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc)
{
   ast_GotoStmt* s = ast_context_Context_alloc(c, 12);
   ast_Stmt_init(&s->base, ast_StmtKind_Goto, loc);
   s->name = name;
   ast_Stats_addStmt(ast_StmtKind_Goto, 12);
   return s;
}

static const char* ast_GotoStmt_getName(const ast_GotoStmt* g)
{
   return ast_idx2name(g->name);
}

static uint32_t ast_GotoStmt_getNameIdx(const ast_GotoStmt* g)
{
   return g->name;
}

static void ast_GotoStmt_print(const ast_GotoStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_print(out, " %s\n", ast_idx2name(s->name));
}

static ast_IfStmt* ast_IfStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt)
{
   uint32_t size = 24;
   if (else_stmt) size += 8;
   ast_IfStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_If, loc);
   s->cond = cond;
   s->then = then;
   if (else_stmt) {
      s->base.ifStmtBits.has_else = 1;
      s->else_stmt[0] = else_stmt;
   }
   ast_Stats_addStmt(ast_StmtKind_If, size);
   return s;
}

static ast_Stmt* ast_IfStmt_instantiate(ast_IfStmt* s, ast_Instantiator* inst)
{
   ast_Stmt* cond2 = ast_Stmt_instantiate(s->cond, inst);
   ast_Stmt* then2 = ast_Stmt_instantiate(s->then, inst);
   ast_Stmt* else2 = NULL;
   if (s->base.ifStmtBits.has_else) else2 = ast_Stmt_instantiate(s->else_stmt[0], inst);
   return ((ast_Stmt*)(ast_IfStmt_create(inst->c, s->base.loc, cond2, then2, else2)));
}

static ast_Stmt* ast_IfStmt_getCond(const ast_IfStmt* s)
{
   return s->cond;
}

static ast_Stmt** ast_IfStmt_getCond2(ast_IfStmt* s)
{
   return &s->cond;
}

static ast_Stmt* ast_IfStmt_getThen(const ast_IfStmt* s)
{
   return s->then;
}

static ast_Stmt* ast_IfStmt_getElse(const ast_IfStmt* s)
{
   if (s->base.ifStmtBits.has_else) return s->else_stmt[0];

   return NULL;
}

static void ast_IfStmt_print(const ast_IfStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_Stmt_print(s->cond, out, (indent + 1));
   if (s->then) ast_Stmt_print(s->then, out, (indent + 1));
   if (s->base.ifStmtBits.has_else) ast_Stmt_print(s->else_stmt[0], out, (indent + 1));
}

static ast_LabelStmt* ast_LabelStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt)
{
   ast_LabelStmt* s = ast_context_Context_alloc(c, 24);
   ast_Stmt_init(&s->base, ast_StmtKind_Label, loc);
   s->name = name;
   s->stmt = stmt;
   ast_Stats_addStmt(ast_StmtKind_Label, 24);
   return s;
}

static ast_Stmt* ast_LabelStmt_instantiate(ast_LabelStmt* s, ast_Instantiator* inst)
{
   if (!s->stmt) return ((ast_Stmt*)(s));

   return ((ast_Stmt*)(ast_LabelStmt_create(inst->c, s->name, s->base.loc, ast_Stmt_instantiate(s->stmt, inst))));
}

static void ast_LabelStmt_setUsed(ast_LabelStmt* s)
{
   s->base.labelStmtBits.is_used = true;
}

static _Bool ast_LabelStmt_isUsed(const ast_LabelStmt* s)
{
   return s->base.labelStmtBits.is_used;
}

static const char* ast_LabelStmt_getName(const ast_LabelStmt* s)
{
   return ast_idx2name(s->name);
}

static uint32_t ast_LabelStmt_getNameIdx(const ast_LabelStmt* s)
{
   return s->name;
}

static ast_Stmt* ast_LabelStmt_getStmt(const ast_LabelStmt* s)
{
   return s->stmt;
}

static void ast_LabelStmt_print(const ast_LabelStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, (indent - 1));
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_idx2name(s->name));
   if (!ast_LabelStmt_isUsed(s)) {
      string_buffer_Buf_space(out);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "unused");
   }
   string_buffer_Buf_newline(out);
   if (s->stmt) ast_Stmt_print(s->stmt, out, indent);
}

static ast_ReturnStmt* ast_ReturnStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* value)
{
   uint32_t size = 8;
   if (value) size += 8;
   ast_ReturnStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Return, loc);
   if (value) {
      s->base.returnStmtBits.has_value = 1;
      s->value[0] = value;
   }
   ast_Stats_addStmt(ast_StmtKind_Return, size);
   return s;
}

static ast_Stmt* ast_ReturnStmt_instantiate(ast_ReturnStmt* s, ast_Instantiator* inst)
{
   if (!s->base.returnStmtBits.has_value) return ((ast_Stmt*)(s));

   return ((ast_Stmt*)(ast_ReturnStmt_create(inst->c, s->base.loc, ast_Expr_instantiate(s->value[0], inst))));
}

static ast_Expr* ast_ReturnStmt_getValue(const ast_ReturnStmt* s)
{
   if (s->base.returnStmtBits.has_value) return s->value[0];

   return NULL;
}

static ast_Expr** ast_ReturnStmt_getValue2(ast_ReturnStmt* s)
{
   if (s->base.returnStmtBits.has_value) return &s->value[0];

   return NULL;
}

static void ast_ReturnStmt_print(const ast_ReturnStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   if (s->base.returnStmtBits.has_value) {
      ast_Expr_print(s->value[0], out, (indent + 1));
   }
}

static ast_SwitchCase* ast_SwitchCase_create(ast_context_Context* c, src_loc_SrcLoc loc, _Bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts)
{
   ((num_stmts < 1024)) || c2_assert("ast/switch_case.c2", 48, "ast.SwitchCase.create", "num_stmts < 1024");
   ((num_conds < 256)) || c2_assert("ast/switch_case.c2", 49, "ast.SwitchCase.create", "num_conds < 256");
   uint32_t size = ((8 + (num_conds * 8)) + (num_stmts * 8));
   ast_SwitchCase* s = ast_context_Context_alloc(c, size);
   s->allbits = 0;
   s->bits.num_conds = num_conds;
   s->bits.num_stmts = num_stmts;
   s->bits.is_default = is_default;
   s->loc = loc;
   memcpy(s->conds, conds, (num_conds * 8));
   ast_Stmt** dst_stmts = ast_SwitchCase_getStmts(s);
   memcpy(dst_stmts, stmts, (num_stmts * 8));
   ast_Stats_addSwitchCase(size);
   return s;
}

static ast_SwitchCase* ast_SwitchCase_instantiate(ast_SwitchCase* src, ast_Instantiator* inst)
{
   uint32_t num_conds = src->bits.num_conds;
   uint32_t num_stmts = src->bits.num_stmts;
   uint32_t size = ((8 + (num_conds * 8)) + (num_stmts * 8));
   ast_SwitchCase* dst = ast_context_Context_alloc(inst->c, size);
   dst->allbits = src->allbits;
   dst->loc = src->loc;
   for (uint32_t i = 0; (i < num_conds); i++) {
      dst->conds[i] = ast_Expr_instantiate(src->conds[i], inst);
   }
   ast_Stmt** src_stmts = ast_SwitchCase_getStmts(src);
   ast_Stmt** dst_stmts = ast_SwitchCase_getStmts(dst);
   for (uint32_t i = 0; (i < num_stmts); i++) {
      dst_stmts[i] = ast_Stmt_instantiate(src_stmts[i], inst);
   }
   ast_Stats_addSwitchCase(size);
   return dst;
}

static uint32_t ast_SwitchCase_getNumConds(const ast_SwitchCase* s)
{
   return s->bits.num_conds;
}

static ast_Expr* ast_SwitchCase_getCond(ast_SwitchCase* s, uint32_t index)
{
   return (index < s->bits.num_conds) ? s->conds[index] : NULL;
}

static uint32_t ast_SwitchCase_getNumStmts(const ast_SwitchCase* s)
{
   return s->bits.num_stmts;
}

static ast_Stmt** ast_SwitchCase_getStmts(ast_SwitchCase* s)
{
   return ((ast_Stmt**)(&s->conds[s->bits.num_conds]));
}

static ast_Stmt* ast_SwitchCase_getStmt(const ast_SwitchCase* s, uint32_t n)
{
   if ((n < s->bits.num_stmts)) {
      ast_Stmt** stmts = ((ast_Stmt**)(&s->conds[s->bits.num_conds]));
      return stmts[n];
   }
   return NULL;
}

static _Bool ast_SwitchCase_isDefault(const ast_SwitchCase* s)
{
   return s->bits.is_default;
}

static _Bool ast_SwitchCase_hasDecls(const ast_SwitchCase* s)
{
   return s->bits.has_decls;
}

static void ast_SwitchCase_setHasDecls(ast_SwitchCase* s)
{
   s->bits.has_decls = 1;
}

static void ast_SwitchCase_setHasFallthrough(ast_SwitchCase* s)
{
   s->bits.has_fallthrough = 1;
}

static _Bool ast_SwitchCase_hasFallthrough(const ast_SwitchCase* s)
{
   return s->bits.has_fallthrough;
}

static src_loc_SrcLoc ast_SwitchCase_getLoc(const ast_SwitchCase* s)
{
   return s->loc;
}

static void ast_SwitchCase_print(const ast_SwitchCase* s, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Stmt);
   string_buffer_Buf_add(out, "SwitchCase");
   if (s->bits.is_default) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " default");
   }
   if (s->bits.has_decls) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " decls");
   }
   if ((s->bits.num_conds > 1)) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " multi");
   }
   if (s->bits.has_fallthrough) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " fallthrough");
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, (indent + 1));
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, " cond");
   for (uint32_t i = 0; (i < s->bits.num_conds); i++) {
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      ast_Expr_print(s->conds[i], out, (indent + 1));
   }
   for (uint32_t i = 0; (i < s->bits.num_stmts); i++) {
      ast_Stmt_print(ast_SwitchCase_getStmt(s, i), out, (indent + 2));
   }
}

static ast_SwitchStmt* ast_SwitchStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* cond, ast_SwitchCase** cases, uint32_t numCases, _Bool has_default)
{
   uint32_t size = (16 + (numCases * 8));
   ast_SwitchStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Switch, loc);
   s->base.switchStmtBits.has_default = has_default;
   s->base.switchStmtBits.num_cases = numCases;
   s->cond = cond;
   memcpy(s->cases, cases, (numCases * 8));
   ast_Stats_addStmt(ast_StmtKind_Switch, size);
   return s;
}

static ast_Stmt* ast_SwitchStmt_instantiate(ast_SwitchStmt* s, ast_Instantiator* inst)
{
   uint32_t numCases = ast_SwitchStmt_getNumCases(s);
   uint32_t size = (16 + (numCases * 8));
   ast_SwitchStmt* s2 = ast_context_Context_alloc(inst->c, size);
   s2->base = s->base;
   s2->cond = ast_Expr_instantiate(s->cond, inst);
   for (uint32_t i = 0; (i < numCases); i++) {
      s2->cases[i] = ast_SwitchCase_instantiate(s->cases[i], inst);
   }
   ast_Stats_addStmt(ast_StmtKind_Switch, size);
   return ((ast_Stmt*)(s2));
}

static ast_Expr* ast_SwitchStmt_getCond(const ast_SwitchStmt* s)
{
   return s->cond;
}

static ast_Expr** ast_SwitchStmt_getCond2(ast_SwitchStmt* s)
{
   return s->cond ? &s->cond : NULL;
}

static _Bool ast_SwitchStmt_isString(const ast_SwitchStmt* s)
{
   return s->base.switchStmtBits.is_string;
}

static void ast_SwitchStmt_setString(ast_SwitchStmt* s)
{
   s->base.switchStmtBits.is_string = true;
}

static _Bool ast_SwitchStmt_hasDefault(const ast_SwitchStmt* s)
{
   return s->base.switchStmtBits.has_default;
}

static uint32_t ast_SwitchStmt_getNumCases(const ast_SwitchStmt* s)
{
   return s->base.switchStmtBits.num_cases;
}

static ast_SwitchCase** ast_SwitchStmt_getCases(ast_SwitchStmt* s)
{
   return s->cases;
}

static void ast_SwitchStmt_print(const ast_SwitchStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   if (ast_SwitchStmt_isString(s)) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " string");
   }
   if (ast_SwitchStmt_hasDefault(s)) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " has_default");
   }
   string_buffer_Buf_newline(out);
   ast_Expr_print(s->cond, out, (indent + 1));
   for (uint32_t i = 0; (i < s->base.switchStmtBits.num_cases); i++) {
      ast_SwitchCase_print(s->cases[i], out, (indent + 1));
   }
}

static ast_WhileStmt* ast_WhileStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* body)
{
   ast_WhileStmt* s = ast_context_Context_alloc(c, 24);
   ast_Stmt_init(&s->base, ast_StmtKind_While, loc);
   s->cond = cond;
   s->body = body;
   ast_Stats_addStmt(ast_StmtKind_While, 24);
   return s;
}

static ast_Stmt* ast_WhileStmt_instantiate(ast_WhileStmt* s, ast_Instantiator* inst)
{
   ast_Stmt* cond2 = ast_Stmt_instantiate(s->cond, inst);
   ast_Stmt* body2 = ast_Stmt_instantiate(s->body, inst);
   return ((ast_Stmt*)(ast_WhileStmt_create(inst->c, s->base.loc, cond2, body2)));
}

static void ast_WhileStmt_print(const ast_WhileStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_Stmt_print(s->cond, out, (indent + 1));
   ast_Stmt_print(s->body, out, (indent + 1));
}

static ast_Stmt* ast_WhileStmt_getCond(const ast_WhileStmt* s)
{
   return s->cond;
}

static ast_Stmt** ast_WhileStmt_getCond2(ast_WhileStmt* s)
{
   return &s->cond;
}

static ast_Stmt* ast_WhileStmt_getBody(const ast_WhileStmt* s)
{
   return s->body;
}

static void ast_Expr_init(ast_Expr* e, ast_ExprKind k, src_loc_SrcLoc loc, _Bool ctv, _Bool ctc, _Bool has_effect, ast_ValType valtype)
{
   ast_Stmt_init(&e->base, ast_StmtKind_Expr, loc);
   e->base.exprBits.kind = k;
   e->base.exprBits.is_ctv = ctv;
   e->base.exprBits.is_ctc = ctc;
   e->base.exprBits.has_effect = has_effect;
   e->base.exprBits.valtype = valtype;
   e->qt.ptr = 0;
}

static ast_Expr* ast_Expr_instantiate(ast_Expr* e, ast_Instantiator* inst)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      fallthrough;
   case ast_ExprKind_StringLiteral:
      fallthrough;
   case ast_ExprKind_Nil:
      return e;
   case ast_ExprKind_Identifier:
      return ast_IdentifierExpr_instantiate(((ast_IdentifierExpr*)e), inst);
   case ast_ExprKind_Type:
      return ast_TypeExpr_instantiate(((ast_TypeExpr*)e), inst);
   case ast_ExprKind_Call:
      return ast_CallExpr_instantiate(((ast_CallExpr*)e), inst);
   case ast_ExprKind_InitList:
      return ast_InitListExpr_instantiate(((ast_InitListExpr*)e), inst);
   case ast_ExprKind_FieldDesignatedInit:
      return ast_FieldDesignatedInitExpr_instantiate(((ast_FieldDesignatedInitExpr*)e), inst);
   case ast_ExprKind_ArrayDesignatedInit:
      return ast_ArrayDesignatedInitExpr_instantiate(((ast_ArrayDesignatedInitExpr*)e), inst);
   case ast_ExprKind_BinaryOperator:
      return ast_BinaryOperator_instantiate(((ast_BinaryOperator*)e), inst);
   case ast_ExprKind_UnaryOperator:
      return ast_UnaryOperator_instantiate(((ast_UnaryOperator*)e), inst);
   case ast_ExprKind_ConditionalOperator:
      return ast_ConditionalOperator_instantiate(((ast_ConditionalOperator*)e), inst);
   case ast_ExprKind_Builtin:
      return ast_BuiltinExpr_instantiate(((ast_BuiltinExpr*)e), inst);
   case ast_ExprKind_ArraySubscript:
      return ast_ArraySubscriptExpr_instantiate(((ast_ArraySubscriptExpr*)e), inst);
   case ast_ExprKind_Member:
      return ast_MemberExpr_instantiate(((ast_MemberExpr*)e), inst);
   case ast_ExprKind_Paren:
      return ast_ParenExpr_instantiate(((ast_ParenExpr*)e), inst);
   case ast_ExprKind_BitOffset:
      return ast_BitOffsetExpr_instantiate(((ast_BitOffsetExpr*)e), inst);
   case ast_ExprKind_ExplicitCast:
      return ast_ExplicitCastExpr_instantiate(((ast_ExplicitCastExpr*)e), inst);
   case ast_ExprKind_ImplicitCast:
      break;
   case ast_ExprKind_Range:
      return ast_RangeExpr_instantiate(((ast_RangeExpr*)e), inst);
   }
   ast_Expr_dump(e);
   (0) || c2_assert("ast/expr.c2", 187, "ast.Expr.instantiate", "0");
   return NULL;
}

static ast_Stmt* ast_Expr_asStmt(ast_Expr* e)
{
   return &e->base;
}

static ast_ExprKind ast_Expr_getKind(const ast_Expr* e)
{
   return ((ast_ExprKind)e->base.exprBits.kind);
}

static _Bool ast_Expr_isStringLiteral(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_StringLiteral);
}

static _Bool ast_Expr_isNil(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Nil);
}

static _Bool ast_Expr_isIdentifier(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Identifier);
}

static _Bool ast_Expr_isCall(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Call);
}

static _Bool ast_Expr_isUnaryOp(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_UnaryOperator);
}

static _Bool ast_Expr_isImplicitCast(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_ImplicitCast);
}

static _Bool ast_Expr_isType(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Type);
}

static _Bool ast_Expr_isInitList(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_InitList);
}

static _Bool ast_Expr_isTilde(const ast_Expr* e)
{
   while (ast_Expr_isParen(e)) {
      const ast_ParenExpr* p = ((ast_ParenExpr*)e);
      e = ast_ParenExpr_getInner(p);
   }
   if ((ast_Expr_getKind(e) == ast_ExprKind_UnaryOperator)) {
      const ast_UnaryOperator* u = ((ast_UnaryOperator*)e);
      return ((ast_UnaryOperator_getOpcode(u) == ast_UnaryOpcode_Not));
   }
   return false;
}

static _Bool ast_Expr_isBinaryOperator(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_BinaryOperator);
}

static _Bool ast_Expr_isMember(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Member);
}

static _Bool ast_Expr_isFieldDesignatedInit(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_FieldDesignatedInit);
}

static _Bool ast_Expr_isArrayDesignatedInit(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_ArrayDesignatedInit);
}

static _Bool ast_Expr_isBitOffset(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_BitOffset);
}

static _Bool ast_Expr_isParen(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Paren);
}

static _Bool ast_Expr_isRange(const ast_Expr* e)
{
   return (ast_Expr_getKind(e) == ast_ExprKind_Range);
}

static _Bool ast_Expr_isAssignment(const ast_Expr* e)
{
   return (ast_Expr_isBinaryOperator(e) && (ast_BinaryOperator_getOpcode((((ast_BinaryOperator*)e))) == ast_BinaryOpcode_Assign));
}

static _Bool ast_Expr_isInitlistAssignment(const ast_Expr* e)
{
   return (ast_Expr_isAssignment(e) && ast_Expr_isInitList(ast_BinaryOperator_getRHS((((ast_BinaryOperator*)e)))));
}

static _Bool ast_Expr_isCtv(const ast_Expr* e)
{
   return e->base.exprBits.is_ctv;
}

static _Bool ast_Expr_isCtc(const ast_Expr* e)
{
   return e->base.exprBits.is_ctc;
}

static void ast_Expr_setCtv(ast_Expr* e)
{
   e->base.exprBits.is_ctv = true;
}

static void ast_Expr_setCtc(ast_Expr* e)
{
   e->base.exprBits.is_ctc = true;
}

static void ast_Expr_copyCtcFlags(ast_Expr* e, const ast_Expr* other)
{
   e->base.exprBits.is_ctc = other->base.exprBits.is_ctc;
}

static void ast_Expr_copyConstantFlags(ast_Expr* e, const ast_Expr* other)
{
   e->base.exprBits.is_ctc = other->base.exprBits.is_ctc;
   e->base.exprBits.is_ctv = other->base.exprBits.is_ctv;
}

static void ast_Expr_combineConstantFlags(ast_Expr* e, const ast_Expr* lhs, const ast_Expr* rhs)
{
   e->base.exprBits.is_ctc = (lhs->base.exprBits.is_ctc & rhs->base.exprBits.is_ctc);
   e->base.exprBits.is_ctv = (lhs->base.exprBits.is_ctv & rhs->base.exprBits.is_ctv);
}

static _Bool ast_Expr_hasEffect(const ast_Expr* e)
{
   return e->base.exprBits.has_effect;
}

static ast_ValType ast_Expr_getValType(const ast_Expr* e)
{
   return ((ast_ValType)e->base.exprBits.valtype);
}

static _Bool ast_Expr_isNValue(const ast_Expr* e)
{
   return (ast_Expr_getValType(e) == ast_ValType_NValue);
}

static _Bool ast_Expr_isLValue(const ast_Expr* e)
{
   return (ast_Expr_getValType(e) == ast_ValType_LValue);
}

static void ast_Expr_setLValue(ast_Expr* e)
{
   e->base.exprBits.valtype = ast_ValType_LValue;
}

static void ast_Expr_setRValue(ast_Expr* e)
{
   e->base.exprBits.valtype = ast_ValType_RValue;
}

static void ast_Expr_copyValType(ast_Expr* e, const ast_Expr* other)
{
   e->base.exprBits.valtype = other->base.exprBits.valtype;
}

static src_loc_SrcLoc ast_Expr_getLoc(const ast_Expr* e)
{
   return e->base.loc;
}

static src_loc_SrcLoc ast_Expr_getStartLoc(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      fallthrough;
   case ast_ExprKind_StringLiteral:
      fallthrough;
   case ast_ExprKind_Nil:
      fallthrough;
   case ast_ExprKind_Identifier:
      fallthrough;
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      return ast_CallExpr_getStartLoc((((ast_CallExpr*)(e))));
   case ast_ExprKind_InitList:
      fallthrough;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return ast_BinaryOperator_getStartLoc((((ast_BinaryOperator*)(e))));
   case ast_ExprKind_UnaryOperator:
      return ast_UnaryOperator_getStartLoc((((ast_UnaryOperator*)(e))));
   case ast_ExprKind_ConditionalOperator:
      return ast_ConditionalOperator_getStartLoc((((ast_ConditionalOperator*)(e))));
   case ast_ExprKind_Builtin:
      break;
   case ast_ExprKind_ArraySubscript:
      return ast_ArraySubscriptExpr_getStartLoc((((ast_ArraySubscriptExpr*)(e))));
   case ast_ExprKind_Member:
      return ast_MemberExpr_getStartLoc((((ast_MemberExpr*)(e))));
   case ast_ExprKind_Paren:
      break;
   case ast_ExprKind_BitOffset:
      return ast_BitOffsetExpr_getStartLoc((((ast_BitOffsetExpr*)(e))));
   case ast_ExprKind_ExplicitCast:
      break;
   case ast_ExprKind_ImplicitCast:
      return ast_ImplicitCastExpr_getStartLoc((((ast_ImplicitCastExpr*)(e))));
   case ast_ExprKind_Range:
      return ast_RangeExpr_getStartLoc((((ast_RangeExpr*)(e))));
   }
   return e->base.loc;
}

static src_loc_SrcLoc ast_Expr_getEndLoc(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      return ast_IntegerLiteral_getEndLoc((((ast_IntegerLiteral*)(e))));
   case ast_ExprKind_FloatLiteral:
      return ast_FloatLiteral_getEndLoc((((ast_FloatLiteral*)(e))));
   case ast_ExprKind_BooleanLiteral:
      return ast_BooleanLiteral_getEndLoc((((ast_BooleanLiteral*)(e))));
   case ast_ExprKind_CharLiteral:
      return ast_CharLiteral_getEndLoc((((ast_CharLiteral*)(e))));
   case ast_ExprKind_StringLiteral:
      return ast_StringLiteral_getEndLoc((((ast_StringLiteral*)(e))));
   case ast_ExprKind_Nil:
      return ast_NilExpr_getEndLoc((((ast_NilExpr*)(e))));
   case ast_ExprKind_Identifier:
      return ast_IdentifierExpr_getEndLoc((((ast_IdentifierExpr*)(e))));
   case ast_ExprKind_Type:
      return ast_TypeExpr_getEndLoc((((ast_TypeExpr*)(e))));
   case ast_ExprKind_Call:
      return ast_CallExpr_getEndLoc((((ast_CallExpr*)(e))));
   case ast_ExprKind_InitList:
      return ast_InitListExpr_getEndLoc((((ast_InitListExpr*)(e))));
   case ast_ExprKind_FieldDesignatedInit:
      return ast_FieldDesignatedInitExpr_getEndLoc((((ast_FieldDesignatedInitExpr*)(e))));
   case ast_ExprKind_ArrayDesignatedInit:
      return ast_ArrayDesignatedInitExpr_getEndLoc((((ast_ArrayDesignatedInitExpr*)(e))));
   case ast_ExprKind_BinaryOperator:
      return ast_BinaryOperator_getEndLoc((((ast_BinaryOperator*)(e))));
   case ast_ExprKind_UnaryOperator:
      return ast_UnaryOperator_getEndLoc((((ast_UnaryOperator*)(e))));
   case ast_ExprKind_ConditionalOperator:
      return ast_ConditionalOperator_getEndLoc((((ast_ConditionalOperator*)(e))));
   case ast_ExprKind_Builtin:
      return ast_BuiltinExpr_getEndLoc((((ast_BuiltinExpr*)(e))));
   case ast_ExprKind_ArraySubscript:
      return ast_ArraySubscriptExpr_getEndLoc((((ast_ArraySubscriptExpr*)(e))));
   case ast_ExprKind_Member:
      return ast_MemberExpr_getEndLoc((((ast_MemberExpr*)(e))));
   case ast_ExprKind_Paren:
      return ast_ParenExpr_getEndLoc((((ast_ParenExpr*)(e))));
   case ast_ExprKind_BitOffset:
      return ast_BitOffsetExpr_getEndLoc((((ast_BitOffsetExpr*)(e))));
   case ast_ExprKind_ExplicitCast:
      return ast_ExplicitCastExpr_getEndLoc((((ast_ExplicitCastExpr*)(e))));
   case ast_ExprKind_ImplicitCast:
      return ast_ImplicitCastExpr_getEndLoc((((ast_ImplicitCastExpr*)(e))));
   case ast_ExprKind_Range:
      return ast_RangeExpr_getEndLoc((((ast_RangeExpr*)(e))));
   }
   return e->base.loc;
}

static src_loc_SrcRange ast_Expr_getRange(const ast_Expr* e)
{
   src_loc_SrcRange range = { ast_Expr_getStartLoc(e), ast_Expr_getEndLoc(e) };
   return range;
}

static void ast_Expr_setType(ast_Expr* e, ast_QualType qt)
{
   e->qt = qt;
}

static ast_QualType ast_Expr_getType(const ast_Expr* e)
{
   return e->qt;
}

static void ast_Expr_dump(const ast_Expr* e)
{
   string_buffer_Buf* out = string_buffer_create((10 * 4096), ast_useColor(), 2);
   ast_Expr_print(e, out, 0);
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ast_Expr_print(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      ast_IntegerLiteral_print(((ast_IntegerLiteral*)(e)), out, indent);
      break;
   case ast_ExprKind_FloatLiteral:
      ast_FloatLiteral_print(((ast_FloatLiteral*)(e)), out, indent);
      break;
   case ast_ExprKind_BooleanLiteral:
      ast_BooleanLiteral_print(((ast_BooleanLiteral*)(e)), out, indent);
      break;
   case ast_ExprKind_CharLiteral:
      ast_CharLiteral_print(((ast_CharLiteral*)(e)), out, indent);
      break;
   case ast_ExprKind_StringLiteral:
      ast_StringLiteral_print(((ast_StringLiteral*)(e)), out, indent);
      break;
   case ast_ExprKind_Nil:
      ast_NilExpr_print(((ast_NilExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_Identifier:
      ast_IdentifierExpr_print(((ast_IdentifierExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_Type:
      ast_TypeExpr_print(((ast_TypeExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_Call:
      ast_CallExpr_print(((ast_CallExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_InitList:
      ast_InitListExpr_print(((ast_InitListExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_FieldDesignatedInit:
      ast_FieldDesignatedInitExpr_print(((ast_FieldDesignatedInitExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      ast_ArrayDesignatedInitExpr_print(((ast_ArrayDesignatedInitExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_BinaryOperator:
      ast_BinaryOperator_print(((ast_BinaryOperator*)(e)), out, indent);
      break;
   case ast_ExprKind_UnaryOperator:
      ast_UnaryOperator_print(((ast_UnaryOperator*)(e)), out, indent);
      break;
   case ast_ExprKind_ConditionalOperator:
      ast_ConditionalOperator_print(((ast_ConditionalOperator*)(e)), out, indent);
      break;
   case ast_ExprKind_Builtin:
      ast_BuiltinExpr_print(((ast_BuiltinExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_ArraySubscript:
      ast_ArraySubscriptExpr_print(((ast_ArraySubscriptExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_Member:
      ast_MemberExpr_print(((ast_MemberExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_Paren:
      ast_ParenExpr_print(((ast_ParenExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_BitOffset:
      ast_BitOffsetExpr_print(((ast_BitOffsetExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_ExplicitCast:
      ast_ExplicitCastExpr_print(((ast_ExplicitCastExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_ImplicitCast:
      ast_ImplicitCastExpr_print(((ast_ImplicitCastExpr*)(e)), out, indent);
      break;
   case ast_ExprKind_Range:
      ast_RangeExpr_print(((ast_RangeExpr*)(e)), out, indent);
      break;
   }
}

static void ast_Expr_printLiteral(const ast_Expr* e, string_buffer_Buf* out)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      ast_IntegerLiteral_printLiteral(((ast_IntegerLiteral*)(e)), out);
      return;
   case ast_ExprKind_FloatLiteral:
      ast_FloatLiteral_printLiteral(((ast_FloatLiteral*)(e)), out);
      return;
   case ast_ExprKind_BooleanLiteral:
      ast_BooleanLiteral_printLiteral(((ast_BooleanLiteral*)(e)), out);
      return;
   case ast_ExprKind_CharLiteral:
      ast_CharLiteral_printLiteral(((ast_CharLiteral*)(e)), out);
      return;
   case ast_ExprKind_StringLiteral:
      ast_StringLiteral_printLiteral(((ast_StringLiteral*)(e)), out);
      return;
   case ast_ExprKind_Nil:
      ast_NilExpr_printLiteral(((ast_NilExpr*)(e)), out);
      return;
   case ast_ExprKind_Identifier:
      ast_IdentifierExpr_printLiteral(((ast_IdentifierExpr*)(e)), out);
      return;
   case ast_ExprKind_Type:
      ast_TypeExpr_printLiteral(((ast_TypeExpr*)(e)), out, false);
      return;
   case ast_ExprKind_Call:
      ast_CallExpr_printLiteral(((ast_CallExpr*)(e)), out);
      return;
   case ast_ExprKind_InitList:
      ast_InitListExpr_printLiteral(((ast_InitListExpr*)(e)), out);
      return;
   case ast_ExprKind_FieldDesignatedInit:
      ast_FieldDesignatedInitExpr_printLiteral(((ast_FieldDesignatedInitExpr*)(e)), out);
      return;
   case ast_ExprKind_ArrayDesignatedInit:
      ast_ArrayDesignatedInitExpr_printLiteral(((ast_ArrayDesignatedInitExpr*)(e)), out);
      return;
   case ast_ExprKind_BinaryOperator:
      ast_BinaryOperator_printLiteral(((ast_BinaryOperator*)(e)), out);
      return;
   case ast_ExprKind_UnaryOperator:
      ast_UnaryOperator_printLiteral(((ast_UnaryOperator*)(e)), out);
      return;
   case ast_ExprKind_ConditionalOperator:
      ast_ConditionalOperator_printLiteral(((ast_ConditionalOperator*)(e)), out);
      return;
   case ast_ExprKind_Builtin:
      ast_BuiltinExpr_printLiteral(((ast_BuiltinExpr*)(e)), out);
      return;
   case ast_ExprKind_ArraySubscript:
      ast_ArraySubscriptExpr_printLiteral(((ast_ArraySubscriptExpr*)(e)), out);
      return;
   case ast_ExprKind_Member:
      ast_MemberExpr_printLiteral(((ast_MemberExpr*)(e)), out);
      return;
   case ast_ExprKind_Paren:
      ast_ParenExpr_printLiteral(((ast_ParenExpr*)(e)), out);
      return;
   case ast_ExprKind_BitOffset:
      ast_BitOffsetExpr_printLiteral(((ast_BitOffsetExpr*)(e)), out);
      return;
   case ast_ExprKind_ExplicitCast:
      ast_ExplicitCastExpr_printLiteral(((ast_ExplicitCastExpr*)(e)), out);
      return;
   case ast_ExprKind_ImplicitCast:
      ast_ImplicitCastExpr_printLiteral(((ast_ImplicitCastExpr*)(e)), out);
      return;
   case ast_ExprKind_Range:
      ast_RangeExpr_printLiteral(((ast_RangeExpr*)(e)), out);
      return;
   }
   string_buffer_Buf_print(out, "<<kind=%u>>", ast_Expr_getKind(e));
}

static void ast_Expr_printKind(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Expr);
   string_buffer_Buf_add(out, ast_exprKind_names[ast_Expr_getKind(e)]);
}

static void ast_Expr_printTypeBits(const ast_Expr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_space(out);
   ast_QualType_printQuoted(&e->qt, out);
   string_buffer_Buf_color(out, ast_col_Attr);
   if (e->base.exprBits.is_ctc) string_buffer_Buf_add(out, " CTC");
   if (e->base.exprBits.is_ctv) string_buffer_Buf_add(out, " CTV");
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_valType_names[ast_Expr_getValType(e)]);
}

static ast_ArrayDesignatedInitExpr* ast_ArrayDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue)
{
   ast_ArrayDesignatedInitExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_ArrayDesignatedInit, loc, 0, 0, 0, ast_ValType_RValue);
   e->designator = designator;
   e->initValue = initValue;
   ast_Stats_addExpr(ast_ExprKind_ArrayDesignatedInit, 32);
   return e;
}

static ast_Expr* ast_ArrayDesignatedInitExpr_instantiate(ast_ArrayDesignatedInitExpr* e, ast_Instantiator* inst)
{
   ast_ArrayDesignatedInitExpr* f = ast_ArrayDesignatedInitExpr_create(inst->c, e->base.base.loc, ast_Expr_instantiate(e->designator, inst), ast_Expr_instantiate(e->initValue, inst));
   return ((ast_Expr*)(f));
}

static ast_Expr* ast_ArrayDesignatedInitExpr_getDesignator(const ast_ArrayDesignatedInitExpr* e)
{
   return e->designator;
}

static ast_Expr** ast_ArrayDesignatedInitExpr_getDesignator2(ast_ArrayDesignatedInitExpr* e)
{
   return &e->designator;
}

static ast_Expr* ast_ArrayDesignatedInitExpr_getInit(const ast_ArrayDesignatedInitExpr* e)
{
   return e->initValue;
}

static ast_Expr** ast_ArrayDesignatedInitExpr_getInit2(ast_ArrayDesignatedInitExpr* e)
{
   return &e->initValue;
}

static src_loc_SrcLoc ast_ArrayDesignatedInitExpr_getEndLoc(const ast_ArrayDesignatedInitExpr* e)
{
   return ast_Expr_getEndLoc(e->initValue);
}

static void ast_ArrayDesignatedInitExpr_print(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->designator, out, (indent + 1));
   ast_Expr_print(e->initValue, out, (indent + 1));
}

static void ast_ArrayDesignatedInitExpr_printLiteral(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '[');
   ast_Expr_printLiteral(ast_ArrayDesignatedInitExpr_getDesignator(e), out);
   string_buffer_Buf_add(out, "] = ");
   ast_Expr_printLiteral(ast_ArrayDesignatedInitExpr_getInit(e), out);
}

static ast_ArraySubscriptExpr* ast_ArraySubscriptExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* lhs, ast_Expr* idx)
{
   ast_ArraySubscriptExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_ArraySubscript, loc, 0, 0, 0, ast_ValType_LValue);
   e->base.base.arraySubscriptExprBits.src_len = src_len;
   e->lhs = lhs;
   e->idx = idx;
   ast_Stats_addExpr(ast_ExprKind_ArraySubscript, 32);
   return e;
}

static ast_Expr* ast_ArraySubscriptExpr_instantiate(ast_ArraySubscriptExpr* e, ast_Instantiator* inst)
{
   ast_ArraySubscriptExpr* a = ast_ArraySubscriptExpr_create(inst->c, e->base.base.loc, e->base.base.arraySubscriptExprBits.src_len, ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->idx, inst));
   return ((ast_Expr*)(a));
}

static ast_Expr* ast_ArraySubscriptExpr_getBase(const ast_ArraySubscriptExpr* e)
{
   return e->lhs;
}

static ast_Expr** ast_ArraySubscriptExpr_getBase2(ast_ArraySubscriptExpr* e)
{
   return &e->lhs;
}

static ast_Expr* ast_ArraySubscriptExpr_getIndex(const ast_ArraySubscriptExpr* e)
{
   return e->idx;
}

static ast_Expr** ast_ArraySubscriptExpr_getIndex2(ast_ArraySubscriptExpr* e)
{
   return &e->idx;
}

static src_loc_SrcLoc ast_ArraySubscriptExpr_getStartLoc(const ast_ArraySubscriptExpr* e)
{
   return ast_Expr_getStartLoc(ast_ArraySubscriptExpr_getBase(e));
}

static src_loc_SrcLoc ast_ArraySubscriptExpr_getEndLoc(const ast_ArraySubscriptExpr* e)
{
   return (e->base.base.loc + e->base.base.arraySubscriptExprBits.src_len);
}

static void ast_ArraySubscriptExpr_printLiteral(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add1(out, '[');
   ast_Expr_printLiteral(e->idx, out);
   string_buffer_Buf_add1(out, ']');
}

static void ast_ArraySubscriptExpr_print(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->lhs, out, (indent + 1));
   ast_Expr_print(e->idx, out, (indent + 1));
}

static _Bool ast_BinaryOpcode_isComparison(ast_BinaryOpcode opcode)
{
   return ((opcode >= ast_BinaryOpcode_LessThan) && (opcode <= ast_BinaryOpcode_NotEqual));
}

static ast_BinaryOperator* ast_BinaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_BinaryOpcode kind, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_BinaryOperator* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_BinaryOperator, loc, 0, 0, (kind >= ast_BinaryOpcode_Assign), ast_ValType_RValue);
   e->base.base.binaryOperatorBits.kind = kind;
   e->lhs = lhs;
   e->rhs = rhs;
   ast_Stats_addExpr(ast_ExprKind_BinaryOperator, 32);
   return e;
}

static ast_Expr* ast_BinaryOperator_instantiate(ast_BinaryOperator* e, ast_Instantiator* inst)
{
   return ((ast_Expr*)(ast_BinaryOperator_create(inst->c, e->base.base.loc, ast_BinaryOperator_getOpcode(e), ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst))));
}

static ast_BinaryOpcode ast_BinaryOperator_getOpcode(const ast_BinaryOperator* e)
{
   return ((ast_BinaryOpcode)(e->base.base.binaryOperatorBits.kind));
}

static ast_Expr* ast_BinaryOperator_getLHS(const ast_BinaryOperator* e)
{
   return e->lhs;
}

static ast_Expr** ast_BinaryOperator_getLHS2(ast_BinaryOperator* e)
{
   return &e->lhs;
}

static ast_Expr* ast_BinaryOperator_getRHS(const ast_BinaryOperator* e)
{
   return e->rhs;
}

static ast_Expr** ast_BinaryOperator_getRHS2(ast_BinaryOperator* e)
{
   return &e->rhs;
}

static const char* ast_BinaryOperator_getOpcodeStr(const ast_BinaryOperator* e)
{
   return ast_binaryOpcode_names[ast_BinaryOperator_getOpcode(e)];
}

static src_loc_SrcLoc ast_BinaryOperator_getStartLoc(const ast_BinaryOperator* e)
{
   return ast_Expr_getStartLoc(ast_BinaryOperator_getLHS(e));
}

static src_loc_SrcLoc ast_BinaryOperator_getEndLoc(const ast_BinaryOperator* e)
{
   return ast_Expr_getEndLoc(ast_BinaryOperator_getRHS(e));
}

static void ast_BinaryOperator_print(const ast_BinaryOperator* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_binaryOpcode_names[ast_BinaryOperator_getOpcode(e)]);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, (indent + 1));
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, "LHS=\n");
   ast_Expr_print(e->lhs, out, (indent + 1));
   string_buffer_Buf_indent(out, (indent + 1));
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, "RHS=\n");
   ast_Expr_print(e->rhs, out, (indent + 1));
}

static void ast_BinaryOperator_printLiteral(const ast_BinaryOperator* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_binaryOpcode_names[ast_BinaryOperator_getOpcode(e)]);
   string_buffer_Buf_space(out);
   ast_Expr_printLiteral(e->rhs, out);
}

static _Bool ast_BinaryOperator_needsSemi(const ast_BinaryOperator* e)
{
   ast_BinaryOpcode opcode = ast_BinaryOperator_getOpcode(e);
   if ((opcode != ast_BinaryOpcode_Assign)) return true;

   if (ast_Expr_isBinaryOperator(e->rhs)) {
      ast_BinaryOperator* b = ((ast_BinaryOperator*)e->rhs);
      return ast_BinaryOperator_needsSemi(b);
   }
   return !ast_Expr_isInitList(e->rhs);
}

static ast_BitOffsetExpr* ast_BitOffsetExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_BitOffsetExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_BitOffset, loc, 0, 0, 0, ast_ValType_RValue);
   e->lhs = lhs;
   e->rhs = rhs;
   ast_Stats_addExpr(ast_ExprKind_BitOffset, 32);
   return e;
}

static ast_Expr* ast_BitOffsetExpr_instantiate(ast_BitOffsetExpr* e, ast_Instantiator* inst)
{
   ast_BitOffsetExpr* b = ast_BitOffsetExpr_create(inst->c, e->base.base.loc, ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst));
   return ((ast_Expr*)(b));
}

static ast_Expr* ast_BitOffsetExpr_getLHS(ast_BitOffsetExpr* e)
{
   return e->lhs;
}

static ast_Expr** ast_BitOffsetExpr_getLHS2(ast_BitOffsetExpr* e)
{
   return &e->lhs;
}

static ast_Expr* ast_BitOffsetExpr_getRHS(ast_BitOffsetExpr* e)
{
   return e->rhs;
}

static ast_Expr** ast_BitOffsetExpr_getRHS2(ast_BitOffsetExpr* e)
{
   return &e->rhs;
}

static void ast_BitOffsetExpr_setWidth(ast_BitOffsetExpr* e, uint8_t width)
{
   e->base.base.bitOffsetBits.width = width;
}

static uint32_t ast_BitOffsetExpr_getWidth(const ast_BitOffsetExpr* e)
{
   return e->base.base.bitOffsetBits.width;
}

static src_loc_SrcLoc ast_BitOffsetExpr_getStartLoc(const ast_BitOffsetExpr* e)
{
   return ast_Expr_getStartLoc(e->lhs);
}

static src_loc_SrcLoc ast_BitOffsetExpr_getEndLoc(const ast_BitOffsetExpr* e)
{
   return ast_Expr_getEndLoc(e->rhs);
}

static void ast_BitOffsetExpr_printLiteral(const ast_BitOffsetExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add1(out, ':');
   ast_Expr_printLiteral(e->rhs, out);
}

static void ast_BitOffsetExpr_print(const ast_BitOffsetExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, "%u", e->base.base.bitOffsetBits.width);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->lhs, out, (indent + 1));
   ast_Expr_print(e->rhs, out, (indent + 1));
}

static ast_BooleanLiteral* ast_BooleanLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, _Bool val)
{
   ast_BooleanLiteral* e = ast_context_Context_alloc(c, 16);
   ast_Expr_init(&e->base, ast_ExprKind_BooleanLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   e->base.base.booleanLiteralBits.value = val;
   ast_Expr_setType(&e->base, ast_builtins[ast_BuiltinKind_Bool]);
   ast_Stats_addExpr(ast_ExprKind_BooleanLiteral, 16);
   return e;
}

static _Bool ast_BooleanLiteral_getValue(const ast_BooleanLiteral* e)
{
   return e->base.base.booleanLiteralBits.value;
}

static src_loc_SrcLoc ast_BooleanLiteral_getEndLoc(const ast_BooleanLiteral* e)
{
   return (e->base.base.loc + (e->base.base.booleanLiteralBits.value ? 4 : 5));
}

static void ast_BooleanLiteral_print(const ast_BooleanLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_add(out, e->base.base.booleanLiteralBits.value ? "true" : "false");
   string_buffer_Buf_newline(out);
}

static void ast_BooleanLiteral_printLiteral(const ast_BooleanLiteral* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, e->base.base.booleanLiteralBits.value ? "true" : "false");
}

static ast_BuiltinExpr* ast_BuiltinExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind)
{
   const uint32_t size = 40;
   ast_BuiltinExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Builtin, loc, true, true, false, ast_ValType_RValue);
   e->base.base.builtinExprBits.kind = kind;
   e->base.base.builtinExprBits.src_len = src_len;
   e->inner = inner;
   ast_Value_setUnsigned(&e->value, 0);
   ast_Stats_addExpr(ast_ExprKind_Builtin, size);
   return e;
}

static ast_BuiltinExpr* ast_BuiltinExpr_createOffsetOf(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member)
{
   const uint32_t size = (40 + 8);
   ast_BuiltinExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Builtin, loc, true, true, false, ast_ValType_RValue);
   e->base.base.builtinExprBits.kind = ast_BuiltinExprKind_OffsetOf;
   e->base.base.builtinExprBits.src_len = src_len;
   e->inner = typeExpr;
   ast_Value_setUnsigned(&e->value, 0);
   e->offset[0].member = member;
   ast_Stats_addExpr(ast_ExprKind_Builtin, size);
   return e;
}

static ast_BuiltinExpr* ast_BuiltinExpr_createToContainer(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member, ast_Expr* pointer)
{
   const uint32_t size = (40 + 16);
   ast_BuiltinExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Builtin, loc, false, false, false, ast_ValType_RValue);
   e->base.base.builtinExprBits.kind = ast_BuiltinExprKind_ToContainer;
   e->base.base.builtinExprBits.src_len = src_len;
   e->inner = typeExpr;
   e->container[0].member = member;
   e->container[0].pointer = pointer;
   ast_Stats_addExpr(ast_ExprKind_Builtin, size);
   return e;
}

static ast_Expr* ast_BuiltinExpr_instantiate(ast_BuiltinExpr* e, ast_Instantiator* inst)
{
   ast_BuiltinExpr* bi = NULL;
   switch (ast_BuiltinExpr_getKind(e)) {
   case ast_BuiltinExprKind_Sizeof:
      fallthrough;
   case ast_BuiltinExprKind_Elemsof:
      fallthrough;
   case ast_BuiltinExprKind_EnumMin:
      fallthrough;
   case ast_BuiltinExprKind_EnumMax:
      bi = ast_BuiltinExpr_create(inst->c, e->base.base.loc, e->base.base.builtinExprBits.src_len, ast_Expr_instantiate(e->inner, inst), ast_BuiltinExpr_getKind(e));
      break;
   case ast_BuiltinExprKind_OffsetOf:
      bi = ast_BuiltinExpr_createOffsetOf(inst->c, e->base.base.loc, e->base.base.builtinExprBits.src_len, ast_Expr_instantiate(e->inner, inst), ast_Expr_instantiate(e->offset[0].member, inst));
      break;
   case ast_BuiltinExprKind_ToContainer:
      bi = ast_BuiltinExpr_createToContainer(inst->c, e->base.base.loc, e->base.base.builtinExprBits.src_len, ast_Expr_instantiate(e->inner, inst), ast_Expr_instantiate(e->container[0].member, inst), ast_Expr_instantiate(e->container[0].pointer, inst));
      break;
   }
   return ((ast_Expr*)(bi));
}

static ast_BuiltinExprKind ast_BuiltinExpr_getKind(const ast_BuiltinExpr* e)
{
   return ((ast_BuiltinExprKind)(e->base.base.builtinExprBits.kind));
}

static ast_Value ast_BuiltinExpr_getValue(const ast_BuiltinExpr* e)
{
   return e->value;
}

static void ast_BuiltinExpr_setValue(ast_BuiltinExpr* e, ast_Value value)
{
   e->value = value;
}

static void ast_BuiltinExpr_setUValue(ast_BuiltinExpr* e, uint64_t val)
{
   ast_Value_setUnsigned(&e->value, val);
}

static ast_Expr* ast_BuiltinExpr_getInner(const ast_BuiltinExpr* e)
{
   return e->inner;
}

static src_loc_SrcLoc ast_BuiltinExpr_getEndLoc(const ast_BuiltinExpr* e)
{
   return (e->base.base.loc + e->base.base.builtinExprBits.src_len);
}

static ast_Expr* ast_BuiltinExpr_getOffsetOfMember(const ast_BuiltinExpr* b)
{
   ((ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_OffsetOf)) || c2_assert("ast/builtin_expr.c2", 155, "ast.BuiltinExpr.getOffsetOfMember", "b.getKind() == BuiltinExprKind.OffsetOf");
   return b->offset[0].member;
}

static ast_Expr* ast_BuiltinExpr_getToContainerMember(const ast_BuiltinExpr* b)
{
   ((ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_ToContainer)) || c2_assert("ast/builtin_expr.c2", 160, "ast.BuiltinExpr.getToContainerMember", "b.getKind() == BuiltinExprKind.ToContainer");
   return b->container[0].member;
}

static ast_Expr* ast_BuiltinExpr_getToContainerPointer(const ast_BuiltinExpr* b)
{
   ((ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_ToContainer)) || c2_assert("ast/builtin_expr.c2", 165, "ast.BuiltinExpr.getToContainerPointer", "b.getKind() == BuiltinExprKind.ToContainer");
   return b->container[0].pointer;
}

static ast_Expr** ast_BuiltinExpr_getToContainerPointer2(ast_BuiltinExpr* b)
{
   ((ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_ToContainer)) || c2_assert("ast/builtin_expr.c2", 170, "ast.BuiltinExpr.getToContainerPointer2", "b.getKind() == BuiltinExprKind.ToContainer");
   return &b->container[0].pointer;
}

static void ast_BuiltinExpr_print(const ast_BuiltinExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_print(out, " %s", ast_builtin_names[ast_BuiltinExpr_getKind(e)]);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, " %s", ast_Value_str(&e->value));
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, (indent + 1));
   switch (ast_BuiltinExpr_getKind(e)) {
   case ast_BuiltinExprKind_Sizeof:
      break;
   case ast_BuiltinExprKind_Elemsof:
      break;
   case ast_BuiltinExprKind_EnumMin:
      break;
   case ast_BuiltinExprKind_EnumMax:
      break;
   case ast_BuiltinExprKind_OffsetOf:
      ast_Expr_print(e->offset[0].member, out, (indent + 1));
      break;
   case ast_BuiltinExprKind_ToContainer:
      ast_Expr_print(e->container[0].member, out, (indent + 1));
      ast_Expr_print(e->container[0].pointer, out, (indent + 1));
      break;
   }
}

static void ast_BuiltinExpr_printLiteral(const ast_BuiltinExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_builtin_names[ast_BuiltinExpr_getKind(e)]);
   string_buffer_Buf_lparen(out);
   switch (ast_BuiltinExpr_getKind(e)) {
   case ast_BuiltinExprKind_Sizeof:
      ast_Expr_printLiteral(e->inner, out);
      break;
   case ast_BuiltinExprKind_Elemsof:
      fallthrough;
   case ast_BuiltinExprKind_EnumMin:
      fallthrough;
   case ast_BuiltinExprKind_EnumMax:
      ast_Expr_printLiteral(e->inner, out);
      break;
   case ast_BuiltinExprKind_OffsetOf:
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->offset[0].member, out);
      break;
   case ast_BuiltinExprKind_ToContainer:
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->container[0].member, out);
      string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->container[0].pointer, out);
      break;
   }
   string_buffer_Buf_rparen(out);
}

static ast_CallExpr* ast_CallExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args)
{
   uint32_t size = (32 + (num_args * 8));
   ast_CallExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Call, loc, 0, 0, 1, ast_ValType_RValue);
   e->base.base.callExprBits.num_args = ((uint8_t)(num_args));
   e->endLoc = endLoc;
   e->template_idx = 0;
   e->instance_ast_idx = 0;
   e->func = func;
   memcpy(e->args, args, (num_args * 8));
   ast_Stats_addExpr(ast_ExprKind_Call, size);
   return e;
}

static ast_CallExpr* ast_CallExpr_createTemplate(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, uint32_t ast_idx, const ast_TypeRefHolder* ref)
{
   uint32_t size = (32 + (num_args * 8));
   size += (8 + ast_TypeRefHolder_getExtraSize(ref));
   ast_CallExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Call, loc, 0, 0, 1, ast_ValType_RValue);
   e->base.base.callExprBits.is_template_call = 1;
   e->base.base.callExprBits.num_args = ((uint8_t)(num_args));
   e->endLoc = endLoc;
   e->template_idx = 0;
   e->instance_ast_idx = ((uint16_t)(ast_idx));
   e->func = func;
   memcpy(e->args, args, (num_args * 8));
   ast_TypeRef* destRef = ((ast_TypeRef*)(&e->args[num_args]));
   ast_TypeRef_init(destRef, ref);
   ast_Stats_addExpr(ast_ExprKind_Call, size);
   return e;
}

static ast_Expr* ast_CallExpr_instantiate(ast_CallExpr* e, ast_Instantiator* inst)
{
   (!ast_CallExpr_isTemplateCall(e)) || c2_assert("ast/call_expr.c2", 96, "ast.CallExpr.instantiate", "!e.isTemplateCall()");
   uint32_t num_args = e->base.base.callExprBits.num_args;
   uint32_t size = (32 + (num_args * 8));
   ast_CallExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   e2->endLoc = e->endLoc;
   e2->template_idx = 0;
   e2->instance_ast_idx = e->instance_ast_idx;
   e2->func = ast_Expr_instantiate(e->func, inst);
   for (uint32_t i = 0; (i < num_args); i++) {
      e2->args[i] = ast_Expr_instantiate(e->args[i], inst);
   }
   ast_Stats_addExpr(ast_ExprKind_Call, size);
   return ((ast_Expr*)(e2));
}

static void ast_CallExpr_setCallsTypeFunc(ast_CallExpr* e)
{
   e->base.base.callExprBits.calls_type_func = 1;
}

static _Bool ast_CallExpr_isTypeFunc(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.calls_type_func;
}

static void ast_CallExpr_setCallsStaticTypeFunc(ast_CallExpr* e)
{
   e->base.base.callExprBits.calls_static_sf = 1;
}

static _Bool ast_CallExpr_isStaticTypeFunc(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.calls_static_sf;
}

static _Bool ast_CallExpr_isTemplateCall(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.is_template_call;
}

static ast_TypeRef* ast_CallExpr_getTemplateArg(const ast_CallExpr* e)
{
   if (ast_CallExpr_isTemplateCall(e)) return ((ast_TypeRef*)(&e->args[e->base.base.callExprBits.num_args]));

   return NULL;
}

static void ast_CallExpr_setTemplateIdx(ast_CallExpr* e, uint32_t idx)
{
   e->template_idx = ((uint16_t)(idx));
}

static uint32_t ast_CallExpr_getTemplateIdx(const ast_CallExpr* e)
{
   return e->template_idx;
}

static uint16_t ast_CallExpr_getInstanceASTIdx(const ast_CallExpr* e)
{
   return e->instance_ast_idx;
}

static void ast_CallExpr_setNoreturn(ast_CallExpr* e)
{
   e->base.base.callExprBits.is_noreturn = 1;
}

static _Bool ast_CallExpr_isNoreturn(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.is_noreturn;
}

static void ast_CallExpr_setPrintfFormat(ast_CallExpr* e, uint32_t format_idx, _Bool change_format)
{
   e->base.base.callExprBits.printf_format = (format_idx + 1);
   e->base.base.callExprBits.change_format = change_format;
}

static _Bool ast_CallExpr_isPrintfCall(const ast_CallExpr* e)
{
   return (e->base.base.callExprBits.printf_format != 0);
}

static uint32_t ast_CallExpr_getPrintfFormat(const ast_CallExpr* e)
{
   return (e->base.base.callExprBits.printf_format - 1);
}

static _Bool ast_CallExpr_needFormatChange(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.change_format;
}

static void ast_CallExpr_setHasAutoArgs(ast_CallExpr* e)
{
   e->base.base.callExprBits.has_auto_args = 1;
}

static _Bool ast_CallExpr_hasAutoArgs(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.has_auto_args;
}

static src_loc_SrcLoc ast_CallExpr_getStartLoc(const ast_CallExpr* e)
{
   return ast_Expr_getStartLoc(e->func);
}

static src_loc_SrcLoc ast_CallExpr_getEndLoc(const ast_CallExpr* e)
{
   return e->endLoc;
}

static ast_Expr* ast_CallExpr_getFunc(const ast_CallExpr* e)
{
   return e->func;
}

static ast_Expr** ast_CallExpr_getFunc2(ast_CallExpr* e)
{
   return &e->func;
}

static uint32_t ast_CallExpr_getNumArgs(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.num_args;
}

static ast_Expr** ast_CallExpr_getArgs(ast_CallExpr* e)
{
   return e->args;
}

static void ast_CallExpr_printLiteral(const ast_CallExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->func, out);
   string_buffer_Buf_lparen(out);
   for (uint32_t i = 0; (i < ast_CallExpr_getNumArgs(e)); i++) {
      if (i) string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->args[i], out);
   }
   string_buffer_Buf_rparen(out);
}

static void ast_CallExpr_print(const ast_CallExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   if (e->base.base.callExprBits.calls_type_func) string_buffer_Buf_add(out, " TF");
   if (e->base.base.callExprBits.calls_static_sf) string_buffer_Buf_add(out, " STF");
   if (e->base.base.callExprBits.is_noreturn) string_buffer_Buf_add(out, " noreturn");
   if (ast_CallExpr_isPrintfCall(e)) {
      string_buffer_Buf_print(out, " printf=%u|%u", ast_CallExpr_getPrintfFormat(e), ast_CallExpr_needFormatChange(e));
   }
   if (ast_CallExpr_hasAutoArgs(e)) string_buffer_Buf_add(out, " auto-args");
   string_buffer_Buf_newline(out);
   if (e->base.base.callExprBits.is_template_call) {
      string_buffer_Buf_indent(out, (indent + 1));
      string_buffer_Buf_color(out, ast_col_Template);
      string_buffer_Buf_add(out, "template ");
      ast_TypeRef* ref = ((ast_TypeRef*)(&e->args[e->base.base.callExprBits.num_args]));
      ast_TypeRef_print(ref, out, true);
      string_buffer_Buf_newline(out);
   }
   ast_Expr_print(e->func, out, (indent + 1));
   for (uint32_t i = 0; (i < ast_CallExpr_getNumArgs(e)); i++) {
      ast_Expr_print(e->args[i], out, (indent + 1));
   }
}

static ast_CharLiteral* ast_CharLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint8_t val, number_radix_Radix radix)
{
   ast_CharLiteral* e = ast_context_Context_alloc(c, 16);
   ast_Expr_init(&e->base, ast_ExprKind_CharLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   e->base.base.charLiteralBits.value = val;
   e->base.base.charLiteralBits.radix = radix;
   e->base.base.charLiteralBits.src_len = src_len;
   ast_Stats_addExpr(ast_ExprKind_CharLiteral, 16);
   ast_Expr_setType(&e->base, ast_builtins[ast_BuiltinKind_Char]);
   return e;
}

static char ast_CharLiteral_getValue(const ast_CharLiteral* e)
{
   return ((char)(e->base.base.charLiteralBits.value));
}

static src_loc_SrcLoc ast_CharLiteral_getEndLoc(const ast_CharLiteral* e)
{
   return (e->base.base.loc + e->base.base.charLiteralBits.src_len);
}

static void ast_CharLiteral_print(const ast_CharLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_CharLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static void ast_CharLiteral_printLiteral(const ast_CharLiteral* e, string_buffer_Buf* out)
{
   uint8_t c = ((uint8_t)(e->base.base.charLiteralBits.value));
   switch (e->base.base.charLiteralBits.radix) {
   case number_radix_Radix_Octal:
      string_buffer_Buf_print(out, "'\\%o'", c);
      return;
   case number_radix_Radix_Hex:
      string_buffer_Buf_print(out, "'\\x%02x'", c);
      return;
   default: {
      string_buffer_Buf_add1(out, '\'');
      char cc = c;
      string_buffer_Buf_encodeBytes(out, &cc, 1, '\'');
      string_buffer_Buf_add1(out, '\'');
      return;
   }
   }
}

static ast_ConditionalOperator* ast_ConditionalOperator_create(ast_context_Context* c, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_ConditionalOperator* e = ast_context_Context_alloc(c, 48);
   ast_Expr_init(&e->base, ast_ExprKind_ConditionalOperator, questionLoc, 0, 1, 1, ast_ValType_RValue);
   e->colonLoc = colonLoc;
   e->cond = cond;
   e->lhs = lhs;
   e->rhs = rhs;
   ast_Stats_addExpr(ast_ExprKind_ConditionalOperator, 48);
   return e;
}

static ast_Expr* ast_ConditionalOperator_instantiate(ast_ConditionalOperator* e, ast_Instantiator* inst)
{
   ast_ConditionalOperator* o = ast_ConditionalOperator_create(inst->c, e->base.base.loc, e->colonLoc, ast_Expr_instantiate(e->cond, inst), ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst));
   return ((ast_Expr*)(o));
}

static ast_Expr* ast_ConditionalOperator_getCond(const ast_ConditionalOperator* e)
{
   return e->cond;
}

static ast_Expr** ast_ConditionalOperator_getCond2(ast_ConditionalOperator* e)
{
   return &e->cond;
}

static ast_Expr* ast_ConditionalOperator_getLHS(const ast_ConditionalOperator* e)
{
   return e->lhs;
}

static ast_Expr** ast_ConditionalOperator_getLHS2(ast_ConditionalOperator* e)
{
   return &e->lhs;
}

static ast_Expr* ast_ConditionalOperator_getRHS(const ast_ConditionalOperator* e)
{
   return e->rhs;
}

static ast_Expr** ast_ConditionalOperator_getRHS2(ast_ConditionalOperator* e)
{
   return &e->rhs;
}

static src_loc_SrcLoc ast_ConditionalOperator_getStartLoc(const ast_ConditionalOperator* e)
{
   return ast_Expr_getStartLoc(ast_ConditionalOperator_getCond(e));
}

static src_loc_SrcLoc ast_ConditionalOperator_getEndLoc(const ast_ConditionalOperator* e)
{
   return ast_Expr_getEndLoc(ast_ConditionalOperator_getRHS(e));
}

static void ast_ConditionalOperator_printLiteral(const ast_ConditionalOperator* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->cond, out);
   string_buffer_Buf_add(out, " ? ");
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add(out, " : ");
   ast_Expr_printLiteral(e->rhs, out);
}

static void ast_ConditionalOperator_print(const ast_ConditionalOperator* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->cond, out, (indent + 1));
   ast_Expr_print(e->lhs, out, (indent + 1));
   ast_Expr_print(e->rhs, out, (indent + 1));
}

static ast_ExplicitCastExpr* ast_ExplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, _Bool c_style)
{
   uint32_t size = (40 + ast_TypeRefHolder_getExtraSize(ref));
   ast_ExplicitCastExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_ExplicitCast, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.explicitCastExprBits.c_style = c_style;
   e->base.base.explicitCastExprBits.src_len = src_len;
   e->dest_type = ast_QualType_Invalid;
   e->inner = inner;
   ast_TypeRef_init(&e->dest, ref);
   ast_Stats_addExpr(ast_ExprKind_ExplicitCast, size);
   return e;
}

static ast_Expr* ast_ExplicitCastExpr_instantiate(ast_ExplicitCastExpr* e, ast_Instantiator* inst)
{
   _Bool matches = ast_TypeRef_matchesTemplate(&e->dest, inst->template_name);
   uint32_t extra = matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&e->dest);
   uint32_t size = (40 + extra);
   ast_ExplicitCastExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   e2->inner = ast_Expr_instantiate(e->inner, inst);
   ast_TypeRef_instantiate(&e2->dest, &e->dest, inst);
   return ((ast_Expr*)(e2));
}

static void ast_ExplicitCastExpr_setDestType(ast_ExplicitCastExpr* e, ast_QualType qt)
{
   e->dest_type = qt;
}

static ast_QualType ast_ExplicitCastExpr_getDestType(const ast_ExplicitCastExpr* e)
{
   return e->dest_type;
}

static _Bool ast_ExplicitCastExpr_getCStyle(const ast_ExplicitCastExpr* e)
{
   return e->base.base.explicitCastExprBits.c_style;
}

static ast_Expr* ast_ExplicitCastExpr_getInner(const ast_ExplicitCastExpr* e)
{
   return e->inner;
}

static ast_Expr** ast_ExplicitCastExpr_getInner2(ast_ExplicitCastExpr* e)
{
   return &e->inner;
}

static ast_TypeRef* ast_ExplicitCastExpr_getTypeRef(ast_ExplicitCastExpr* e)
{
   return &e->dest;
}

static src_loc_SrcLoc ast_ExplicitCastExpr_getEndLoc(const ast_ExplicitCastExpr* e)
{
   return (e->base.base.loc + e->base.base.explicitCastExprBits.src_len);
}

static void ast_ExplicitCastExpr_printLiteral(const ast_ExplicitCastExpr* e, string_buffer_Buf* out)
{
   if (e->base.base.explicitCastExprBits.c_style) {
      string_buffer_Buf_add1(out, '(');
      ast_TypeRef_print(&e->dest, out, true);
      string_buffer_Buf_add1(out, ')');
      ast_Expr_printLiteral(e->inner, out);
   } else {
      string_buffer_Buf_add(out, "cast<");
      ast_TypeRef_print(&e->dest, out, true);
      string_buffer_Buf_add(out, ">(");
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add1(out, ')');
   }
}

static void ast_ExplicitCastExpr_print(const ast_ExplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_add(out, " -> ");
   if (ast_QualType_isValid(&e->dest_type)) {
      ast_QualType_printQuoted(&e->dest_type, out);
   } else {
      ast_TypeRef_print(&e->dest, out, true);
   }
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, (indent + 1));
}

static ast_FieldDesignatedInitExpr* ast_FieldDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue)
{
   ast_FieldDesignatedInitExpr* e = ast_context_Context_alloc(c, 40);
   ast_Expr_init(&e->base, ast_ExprKind_FieldDesignatedInit, loc, 0, 0, 0, ast_ValType_RValue);
   e->field = field;
   e->member_offset = 0;
   e->initValue = initValue;
   e->decl = NULL;
   ast_Stats_addExpr(ast_ExprKind_FieldDesignatedInit, 40);
   return e;
}

static ast_Expr* ast_FieldDesignatedInitExpr_instantiate(ast_FieldDesignatedInitExpr* e, ast_Instantiator* inst)
{
   return ((ast_Expr*)(ast_FieldDesignatedInitExpr_create(inst->c, e->base.base.loc, e->field, ast_Expr_instantiate(e->initValue, inst))));
}

static uint32_t ast_FieldDesignatedInitExpr_getField(const ast_FieldDesignatedInitExpr* e)
{
   return e->field;
}

static const char* ast_FieldDesignatedInitExpr_getFieldName(const ast_FieldDesignatedInitExpr* e)
{
   return ast_idx2name(e->field);
}

static ast_Expr* ast_FieldDesignatedInitExpr_getInit(const ast_FieldDesignatedInitExpr* e)
{
   return e->initValue;
}

static ast_Expr** ast_FieldDesignatedInitExpr_getInit2(ast_FieldDesignatedInitExpr* e)
{
   return &e->initValue;
}

static void ast_FieldDesignatedInitExpr_setDecl(ast_FieldDesignatedInitExpr* e, ast_Decl* d)
{
   e->decl = d;
}

static ast_Decl* ast_FieldDesignatedInitExpr_getDecl(const ast_FieldDesignatedInitExpr* e)
{
   return e->decl;
}

static uint32_t ast_FieldDesignatedInitExpr_getMemberOffset(const ast_FieldDesignatedInitExpr* e)
{
   return e->member_offset;
}

static void ast_FieldDesignatedInitExpr_setMemberOffset(ast_FieldDesignatedInitExpr* e, uint32_t idx)
{
   e->member_offset = idx;
}

static src_loc_SrcLoc ast_FieldDesignatedInitExpr_getEndLoc(const ast_FieldDesignatedInitExpr* e)
{
   return ast_Expr_getEndLoc(e->initValue);
}

static void ast_FieldDesignatedInitExpr_print(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_print(out, " %s", ast_idx2name(e->field));
   if (!e->decl) {
      string_buffer_Buf_color(out, ast_col_Error);
      string_buffer_Buf_add(out, " ??");
   }
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, " %u", e->member_offset);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->initValue, out, (indent + 1));
}

static void ast_FieldDesignatedInitExpr_printLiteral(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_FieldDesignatedInitExpr_getFieldName(e));
   string_buffer_Buf_add(out, " = ");
   ast_Expr_printLiteral(ast_FieldDesignatedInitExpr_getInit(e), out);
}

static ast_FloatLiteral* ast_FloatLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, double val, number_radix_Radix radix)
{
   ast_FloatLiteral* i = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&i->base, ast_ExprKind_FloatLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   i->base.base.floatLiteralBits.radix = radix;
   i->base.base.floatLiteralBits.src_len = src_len;
   i->val = val;
   ast_Stats_addExpr(ast_ExprKind_FloatLiteral, 24);
   ast_Expr_setType(&i->base, ast_builtins[ast_BuiltinKind_Float32]);
   return i;
}

static double ast_FloatLiteral_getValue(const ast_FloatLiteral* e)
{
   return e->val;
}

static src_loc_SrcLoc ast_FloatLiteral_getEndLoc(const ast_FloatLiteral* e)
{
   return (e->base.base.loc + e->base.base.floatLiteralBits.src_len);
}

static void ast_FloatLiteral_print(const ast_FloatLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   ast_FloatLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static void ast_FloatLiteral_printLiteral(const ast_FloatLiteral* e, string_buffer_Buf* out)
{
   switch (e->base.base.floatLiteralBits.radix) {
   case number_radix_Radix_Hex:
      string_buffer_Buf_print(out, "%la", e->val);
      break;
   default: {
      char buf[32];
      string_buffer_Buf_add(out, ast_ftoa(buf, 32, e->val));
      break;
   }
   }
}

static ast_IdentifierExpr* ast_IdentifierExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t name)
{
   ast_IdentifierExpr* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_Identifier, loc, 0, 0, 0, ast_ValType_NValue);
   e->name_idx = name;
   ast_Stats_addExpr(ast_ExprKind_Identifier, 24);
   return e;
}

static ast_Expr* ast_IdentifierExpr_instantiate(ast_IdentifierExpr* e, ast_Instantiator* inst)
{
   return ((ast_Expr*)(ast_IdentifierExpr_create(inst->c, e->base.base.loc, e->name_idx)));
}

static ast_Expr* ast_IdentifierExpr_asExpr(ast_IdentifierExpr* e)
{
   return &e->base;
}

static void ast_IdentifierExpr_setDecl(ast_IdentifierExpr* e, ast_Decl* decl)
{
   e->decl = decl;
   e->base.base.identifierExprBits.has_decl = true;
}

static ast_Decl* ast_IdentifierExpr_getDecl(const ast_IdentifierExpr* e)
{
   if (!e->base.base.identifierExprBits.has_decl) return NULL;

   return e->decl;
}

static ast_Ref ast_IdentifierExpr_getRef(const ast_IdentifierExpr* e)
{
   ast_Ref ref = { e->base.base.loc, ast_IdentifierExpr_getNameIdx(e), ast_IdentifierExpr_getDecl(e) };
   return ref;
}

static void ast_IdentifierExpr_setKind(ast_IdentifierExpr* e, ast_IdentifierKind kind)
{
   e->base.base.identifierExprBits.kind = kind;
}

static ast_IdentifierKind ast_IdentifierExpr_getKind(const ast_IdentifierExpr* e)
{
   return ((ast_IdentifierKind)(e->base.base.identifierExprBits.kind));
}

static const char* ast_IdentifierExpr_getName(const ast_IdentifierExpr* e)
{
   if (e->base.base.identifierExprBits.has_decl) return ast_Decl_getName(e->decl);

   return ast_idx2name(e->name_idx);
}

static src_loc_SrcLoc ast_IdentifierExpr_getEndLoc(const ast_IdentifierExpr* e)
{
   return (e->base.base.loc + ((uint32_t)(strlen(ast_IdentifierExpr_getName(e)))));
}

static uint32_t ast_IdentifierExpr_getNameIdx(const ast_IdentifierExpr* e)
{
   if (e->base.base.identifierExprBits.has_decl) return ast_Decl_getNameIdx(e->decl);

   return e->name_idx;
}

static void ast_IdentifierExpr_print(const ast_IdentifierExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   ast_IdentifierKind kind = ast_IdentifierExpr_getKind(e);
   if ((kind == ast_IdentifierKind_Unresolved)) string_buffer_Buf_color(out, ast_col_Error);
   else string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, ast_identifierKind_names[kind]);
   string_buffer_Buf_space(out);
   if (e->base.base.identifierExprBits.has_decl) {
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_add(out, ast_Decl_getName(e->decl));
   } else {
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_add(out, ast_idx2name(e->name_idx));
   }
   string_buffer_Buf_newline(out);
}

static void ast_IdentifierExpr_printLiteral(const ast_IdentifierExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_IdentifierExpr_getName(e));
}

static ast_ImplicitCastExpr* ast_ImplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_ImplicitCastKind kind, ast_Expr* inner)
{
   ast_ImplicitCastExpr* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_ImplicitCast, loc, 0, 0, 0, ast_ValType_RValue);
   e->base.base.implicitCastBits.kind = kind;
   e->inner = inner;
   ast_Expr_copyConstantFlags(&e->base, inner);
   switch (kind) {
   case ast_ImplicitCastKind_ArrayToPointerDecay:
      ast_Expr_copyValType(&e->base, inner);
      e->base.base.exprBits.is_ctv = false;
      break;
   case ast_ImplicitCastKind_LValueToRValue:
      e->base.base.exprBits.is_ctc = false;
      break;
   case ast_ImplicitCastKind_PointerToBoolean:
      ast_Expr_copyValType(&e->base, inner);
      break;
   case ast_ImplicitCastKind_PointerToInteger:
      ast_Expr_copyValType(&e->base, inner);
      break;
   case ast_ImplicitCastKind_IntegralCast:
      ast_Expr_copyValType(&e->base, inner);
      break;
   case ast_ImplicitCastKind_BitCast:
      e->base.base.exprBits.is_ctc = false;
      break;
   }
   ast_Stats_addExpr(ast_ExprKind_ImplicitCast, 24);
   return e;
}

static ast_ImplicitCastKind ast_ImplicitCastExpr_getKind(const ast_ImplicitCastExpr* e)
{
   return ((ast_ImplicitCastKind)(e->base.base.implicitCastBits.kind));
}

static _Bool ast_ImplicitCastExpr_isArrayToPointerDecay(const ast_ImplicitCastExpr* e)
{
   return (ast_ImplicitCastExpr_getKind(e) == ast_ImplicitCastKind_ArrayToPointerDecay);
}

static ast_Expr* ast_ImplicitCastExpr_getInner(const ast_ImplicitCastExpr* e)
{
   return e->inner;
}

static src_loc_SrcLoc ast_ImplicitCastExpr_getStartLoc(const ast_ImplicitCastExpr* e)
{
   return ast_Expr_getStartLoc(ast_ImplicitCastExpr_getInner(e));
}

static src_loc_SrcLoc ast_ImplicitCastExpr_getEndLoc(const ast_ImplicitCastExpr* e)
{
   return ast_Expr_getEndLoc(ast_ImplicitCastExpr_getInner(e));
}

static void ast_ImplicitCastExpr_printLiteral(const ast_ImplicitCastExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->inner, out);
}

static void ast_ImplicitCastExpr_print(const ast_ImplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_add(out, ast_implicitCastKind_names[ast_ImplicitCastExpr_getKind(e)]);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, (indent + 1));
}

static ast_InitListExpr* ast_InitListExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values)
{
   uint32_t size = (24 + (num_values * 8));
   ast_InitListExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_InitList, loc, 0, 0, 0, ast_ValType_RValue);
   e->num_values = num_values;
   e->endLoc = endLoc;
   if (num_values) {
      memcpy(e->values, values, (num_values * 8));
   }
   ast_Stats_addExpr(ast_ExprKind_InitList, size);
   return e;
}

static ast_Expr* ast_InitListExpr_instantiate(ast_InitListExpr* e, ast_Instantiator* inst)
{
   uint32_t num_values = ast_InitListExpr_getNumValues(e);
   uint32_t size = (24 + (num_values * 8));
   ast_InitListExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   e2->num_values = num_values;
   e2->endLoc = e->endLoc;
   for (uint32_t i = 0; (i < num_values); i++) {
      e2->values[i] = ast_Expr_instantiate(e->values[i], inst);
   }
   ast_Stats_addExpr(ast_ExprKind_InitList, size);
   return ((ast_Expr*)(e2));
}

static _Bool ast_InitListExpr_isArray(const ast_InitListExpr* e)
{
   return e->base.base.initListExprBits.is_array;
}

static void ast_InitListExpr_setIsArray(ast_InitListExpr* e)
{
   e->base.base.initListExprBits.is_array = 1;
}

static _Bool ast_InitListExpr_hasDesignators(const ast_InitListExpr* e)
{
   return e->base.base.initListExprBits.has_designators;
}

static void ast_InitListExpr_setHasDesignators(ast_InitListExpr* e)
{
   e->base.base.initListExprBits.has_designators = 1;
}

static uint32_t ast_InitListExpr_getNumValues(const ast_InitListExpr* e)
{
   return e->num_values;
}

static ast_Expr** ast_InitListExpr_getValues(ast_InitListExpr* e)
{
   return e->values;
}

static const ast_Expr** ast_InitListExpr_getValues2(const ast_InitListExpr* e)
{
   return ((const ast_Expr**)(e->values));
}

static src_loc_SrcLoc ast_InitListExpr_getEndLoc(const ast_InitListExpr* e)
{
   return e->endLoc;
}

static void ast_InitListExpr_print(const ast_InitListExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   if (ast_InitListExpr_isArray(e)) string_buffer_Buf_add(out, " array");
   else string_buffer_Buf_add(out, " struct");
   if (ast_InitListExpr_hasDesignators(e)) string_buffer_Buf_add(out, " designators");
   string_buffer_Buf_newline(out);
   for (uint32_t i = 0; (i < e->num_values); i++) {
      ast_Expr_print(e->values[i], out, (indent + 1));
   }
}

static void ast_InitListExpr_printLiteral(const ast_InitListExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "{ ");
   for (uint32_t i = 0; (i < e->num_values); i++) {
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->values[i], out);
   }
   string_buffer_Buf_add1(out, '}');
}

static ast_IntegerLiteral* ast_IntegerLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint64_t val, number_radix_Radix radix)
{
   ast_IntegerLiteral* i = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&i->base, ast_ExprKind_IntegerLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   i->base.base.integerLiteralBits.radix = radix;
   i->base.base.integerLiteralBits.src_len = src_len;
   i->val = val;
   ast_Stats_addExpr(ast_ExprKind_IntegerLiteral, 24);
   ast_Expr_setType(&i->base, ast_builtins[ast_BuiltinKind_Int32]);
   return i;
}

static ast_IntegerLiteral* ast_IntegerLiteral_createUnsignedConstant(ast_context_Context* c, src_loc_SrcLoc loc, uint64_t val, ast_QualType qt)
{
   ast_IntegerLiteral* i = ast_IntegerLiteral_create(c, loc, 0, val, number_radix_Radix_Default);
   ast_Expr_setCtv(&i->base);
   ast_Expr_setCtc(&i->base);
   ast_Expr_setType(&i->base, qt);
   return i;
}

static ast_IntegerLiteral* ast_IntegerLiteral_createSignedConstant(ast_context_Context* c, src_loc_SrcLoc loc, int64_t val, ast_QualType qt)
{
   ast_IntegerLiteral* i = ast_IntegerLiteral_create(c, loc, 0, ((uint64_t)(val)), number_radix_Radix_Default);
   i->base.base.integerLiteralBits.is_signed = 1;
   ast_Expr_setCtv(&i->base);
   ast_Expr_setCtc(&i->base);
   ast_Expr_setType(&i->base, qt);
   return i;
}

static uint64_t ast_IntegerLiteral_getValue(const ast_IntegerLiteral* e)
{
   return e->val;
}

static src_loc_SrcLoc ast_IntegerLiteral_getEndLoc(const ast_IntegerLiteral* e)
{
   return (e->base.base.loc + e->base.base.integerLiteralBits.src_len);
}

static _Bool ast_IntegerLiteral_isSigned(const ast_IntegerLiteral* e)
{
   return e->base.base.integerLiteralBits.is_signed;
}

static void ast_printBinary(string_buffer_Buf* out, uint64_t value)
{
   char tmp[34];
   char* cp = &tmp[(34 - 1)];
   *cp = '\0';
   for (;;) {
      *--cp = ('0' + ((value & 0x1)));
      value /= 2;
      if ((value == 0)) break;

   }
   *--cp = 'b';
   *--cp = '0';
   string_buffer_Buf_add(out, cp);
}

static void ast_printOctal(string_buffer_Buf* out, uint64_t value)
{
   char tmp[24];
   char* cp = &tmp[(24 - 1)];
   *cp = '\0';
   while (value) {
      *--cp = ('0' + ((value & 0x7)));
      value /= 8;
   }
   *--cp = '0';
   string_buffer_Buf_add(out, cp);
}

static void ast_IntegerLiteral_print(const ast_IntegerLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   ast_IntegerLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static void ast_IntegerLiteral_printLiteral(const ast_IntegerLiteral* e, string_buffer_Buf* out)
{
   switch (e->base.base.integerLiteralBits.radix) {
   case number_radix_Radix_Default:
      if (e->base.base.integerLiteralBits.is_signed) {
         int64_t sval = ((int64_t)(e->val));
         if (((sval >= -2147483647) && (sval <= 2147483647))) string_buffer_Buf_print(out, "%ld", sval);
         else if ((sval == (-2147483647 - 1))) string_buffer_Buf_print(out, "(-2147483647-1)");
         else if ((e->val == 0x8000000000000000)) string_buffer_Buf_print(out, "(-9223372036854775807l-1)");
         else string_buffer_Buf_print(out, "%ldl", sval);


      } else {
         if ((e->val > 4294967295)) string_buffer_Buf_print(out, "%lulu", e->val);
         else string_buffer_Buf_print(out, "%lu", e->val);
      }
      break;
   case number_radix_Radix_Hex:
      string_buffer_Buf_print(out, "0x%lx", e->val);
      break;
   case number_radix_Radix_Octal:
      ast_printOctal(out, e->val);
      break;
   case number_radix_Radix_Binary:
      ast_printBinary(out, e->val);
      break;
   }
}

static ast_MemberExpr* ast_MemberExpr_create(ast_context_Context* c, ast_Expr* base, const ast_Ref* refs, uint32_t refcount)
{
   uint32_t size = ((16 + (refcount * 8)) + (((refcount - 1)) * 4));
   if (base) size += 8;
   size = (((size + 7)) & ~0x7);
   ast_MemberExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Member, refs[0].loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.memberExprBits.num_refs = refcount;
   uint32_t offset = 0;
   if (base) {
      offset = 1;
      e->refs[0].expr = base;
      e->base.base.memberExprBits.has_expr = 1;
   }
   for (uint32_t i = 0; (i < refcount); i++) {
      e->refs[(i + offset)].name_idx = refs[i].name_idx;
   }
   src_loc_SrcLoc* locs = ((src_loc_SrcLoc*)(&e->refs[(refcount + offset)]));
   for (uint32_t i = 0; (i < (refcount - 1)); i++) {
      locs[i] = refs[(i + 1)].loc;
   }
   ast_Stats_addExpr(ast_ExprKind_Member, size);
   return e;
}

static ast_Expr* ast_MemberExpr_instantiate(ast_MemberExpr* e, ast_Instantiator* inst)
{
   uint32_t refcount = e->base.base.memberExprBits.num_refs;
   ast_Expr* base = ast_MemberExpr_getExprBase(e);
   uint32_t size = ((16 + (refcount * 8)) + (((refcount - 1)) * 4));
   if (base) size += 8;
   size = (((size + 7)) & ~0x7);
   ast_MemberExpr* e2 = ast_context_Context_alloc(inst->c, size);
   memcpy(e2, e, size);
   if (base) e2->refs[0].expr = ast_Expr_instantiate(base, inst);
   return ((ast_Expr*)(e2));
}

static _Bool ast_MemberExpr_hasExpr(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.has_expr;
}

static ast_Expr* ast_MemberExpr_getExprBase(const ast_MemberExpr* e)
{
   if (ast_MemberExpr_hasExpr(e)) return e->refs[0].expr;

   return NULL;
}

static void ast_MemberExpr_setConversion(ast_MemberExpr* e, ast_MemberConversion c)
{
   e->base.base.memberExprBits.conversion = c;
}

static ast_MemberConversion ast_MemberExpr_getConversion(const ast_MemberExpr* e)
{
   return ((ast_MemberConversion)(e->base.base.memberExprBits.conversion));
}

static const char* ast_MemberExpr_getName(const ast_MemberExpr* e, uint32_t ref_idx)
{
   const ast_MemberRef* ref = &e->refs[(ref_idx + ast_MemberExpr_hasExpr(e))];
   if ((e->base.base.memberExprBits.num_decls > ref_idx)) {
      return ast_Decl_getName(ref->decl);
   }
   return ast_idx2name(ref->name_idx);
}

static uint32_t ast_MemberExpr_getNumRefs(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.num_refs;
}

static uint32_t ast_MemberExpr_getNameIdx(const ast_MemberExpr* e, uint32_t ref_idx)
{
   const ast_MemberRef* ref = &e->refs[(ref_idx + ast_MemberExpr_hasExpr(e))];
   if ((e->base.base.memberExprBits.num_decls > ref_idx)) {
      ast_Decl* d = ref->decl;
      if (ast_Decl_isImport(d)) {
         const ast_ImportDecl* id = ((ast_ImportDecl*)(d));
         uint32_t alias_idx = ast_ImportDecl_getAliasNameIdx(id);
         if (alias_idx) return alias_idx;

      }
      return ast_Decl_getNameIdx(d);
   }
   return ref->name_idx;
}

static src_loc_SrcLoc ast_MemberExpr_getLoc(const ast_MemberExpr* e, uint32_t ref_idx)
{
   if ((ref_idx == 0)) return ast_Expr_getLoc(&e->base);

   src_loc_SrcLoc* locs = ((src_loc_SrcLoc*)(&e->refs[(ast_MemberExpr_getNumRefs(e) + ast_MemberExpr_hasExpr(e))]));
   return locs[(ref_idx - 1)];
}

static src_loc_SrcRange ast_MemberExpr_getRange(const ast_MemberExpr* e, uint32_t ref_idx)
{
   src_loc_SrcRange range = { ast_MemberExpr_getStartLoc(e), (ast_MemberExpr_getLoc(e, ref_idx) - 1) };
   return range;
}

static ast_Ref ast_MemberExpr_getRef(const ast_MemberExpr* e, uint32_t ref_idx)
{
   ast_Ref ref;
   ref.loc = ast_MemberExpr_getLoc(e, ref_idx);
   ref.name_idx = ast_MemberExpr_getNameIdx(e, ref_idx);
   ref.decl = ast_MemberExpr_getDecl(e, ref_idx);
   return ref;
}

static ast_IdentifierKind ast_MemberExpr_getKind(const ast_MemberExpr* e)
{
   return ((ast_IdentifierKind)(e->base.base.memberExprBits.kind));
}

static void ast_MemberExpr_setKind(ast_MemberExpr* e, ast_IdentifierKind kind)
{
   e->base.base.memberExprBits.kind = kind;
}

static void ast_MemberExpr_setIsTypeFunc(ast_MemberExpr* e)
{
   e->base.base.memberExprBits.is_struct_func = 1;
}

static _Bool ast_MemberExpr_isTypeFunc(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_struct_func;
}

static void ast_MemberExpr_setIsStaticTypeFunc(ast_MemberExpr* e)
{
   e->base.base.memberExprBits.is_static_sf = 1;
}

static _Bool ast_MemberExpr_isStaticTypeFunc(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_static_sf;
}

static void ast_MemberExpr_setConstBase(ast_MemberExpr* e, _Bool b)
{
   e->base.base.memberExprBits.is_const_base = b;
}

static _Bool ast_MemberExpr_isConstBase(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_const_base;
}

static ast_Decl* ast_MemberExpr_getPrevLastDecl(const ast_MemberExpr* e)
{
   uint32_t num = ast_MemberExpr_getNumRefs(e);
   if ((e->base.base.memberExprBits.num_decls < num)) return NULL;

   num += ast_MemberExpr_hasExpr(e);
   return e->refs[(num - 2)].decl;
}

static ast_Decl* ast_MemberExpr_getFullDecl(const ast_MemberExpr* e)
{
   uint32_t num = ast_MemberExpr_getNumRefs(e);
   if ((e->base.base.memberExprBits.num_decls < num)) return NULL;

   num += ast_MemberExpr_hasExpr(e);
   return e->refs[(num - 1)].decl;
}

static ast_Decl* ast_MemberExpr_getDecl(const ast_MemberExpr* e, uint32_t ref_idx)
{
   if ((e->base.base.memberExprBits.num_decls <= ref_idx)) return NULL;

   return e->refs[(ref_idx + ast_MemberExpr_hasExpr(e))].decl;
}

static void ast_MemberExpr_setDecl(ast_MemberExpr* e, ast_Decl* d, uint32_t ref_idx)
{
   e->base.base.memberExprBits.num_decls = (ref_idx + 1);
   e->refs[(ref_idx + ast_MemberExpr_hasExpr(e))].decl = d;
}

static src_loc_SrcLoc ast_MemberExpr_getStartLoc(const ast_MemberExpr* e)
{
   if (ast_MemberExpr_hasExpr(e)) return ast_Expr_getStartLoc(e->refs[0].expr);

   return ast_Expr_getLoc(&e->base);
}

static src_loc_SrcLoc ast_MemberExpr_getLastLoc(const ast_MemberExpr* e)
{
   return ast_MemberExpr_getLoc(e, (ast_MemberExpr_getNumRefs(e) - 1));
}

static src_loc_SrcLoc ast_MemberExpr_getEndLoc(const ast_MemberExpr* e)
{
   uint32_t last = (ast_MemberExpr_getNumRefs(e) - 1);
   return (ast_MemberExpr_getLoc(e, last) + ((uint32_t)(strlen(ast_MemberExpr_getName(e, last)))));
}

static ast_QualType ast_MemberExpr_getBaseType(const ast_MemberExpr* m)
{
   uint32_t numRefs = ast_MemberExpr_getNumRefs(m);
   ast_QualType qt;
   if ((ast_MemberExpr_hasExpr(m) && (numRefs == 1))) {
      qt = ast_Expr_getType(m->refs[0].expr);
   } else {
      qt = ast_Decl_getType(m->refs[((ast_MemberExpr_hasExpr(m) + numRefs) - 2)].decl);
   }
   if (ast_MemberExpr_isConstBase(m)) ast_QualType_setConst(&qt);
   return qt;
}

static const char* ast_MemberExpr_getLastMemberName(const ast_MemberExpr* e)
{
   return ast_MemberExpr_getName(e, (ast_MemberExpr_getNumRefs(e) - 1));
}

static void ast_MemberExpr_print(const ast_MemberExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   ast_IdentifierKind kind = ast_MemberExpr_getKind(e);
   if ((kind == ast_IdentifierKind_Unresolved)) string_buffer_Buf_color(out, ast_col_Error);
   else string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, ast_identifierKind_names[kind]);
   string_buffer_Buf_color(out, ast_col_Attr);
   if (ast_MemberExpr_isTypeFunc(e)) string_buffer_Buf_add(out, " TF");
   if (ast_MemberExpr_isStaticTypeFunc(e)) string_buffer_Buf_add(out, " STF");
   if (ast_MemberExpr_isConstBase(e)) string_buffer_Buf_add(out, " const-base");
   switch (ast_MemberExpr_getConversion(e)) {
   case ast_MemberConversion_None:
      break;
   case ast_MemberConversion_Addr:
      string_buffer_Buf_add(out, " Addr");
      break;
   case ast_MemberConversion_Deref:
      string_buffer_Buf_add(out, " Deref");
      break;
   }
   string_buffer_Buf_print(out, " refs=%u/%u ", e->base.base.memberExprBits.num_decls, ast_MemberExpr_getNumRefs(e));
   string_buffer_Buf_color(out, ast_col_Value);
   ast_MemberExpr_printLiteral(e, out);
   string_buffer_Buf_newline(out);
   if (ast_MemberExpr_hasExpr(e)) ast_Expr_print(e->refs[0].expr, out, (indent + 1));
}

static void ast_MemberExpr_printLiteral(const ast_MemberExpr* e, string_buffer_Buf* out)
{
   if (ast_MemberExpr_hasExpr(e)) {
      ast_Expr_printLiteral(e->refs[0].expr, out);
      string_buffer_Buf_add1(out, '.');
   }
   for (uint32_t i = 0; (i < ast_MemberExpr_getNumRefs(e)); i++) {
      if ((i != 0)) string_buffer_Buf_add1(out, '.');
      string_buffer_Buf_add(out, ast_MemberExpr_getName(e, i));
   }
}

static void ast_MemberExpr_dump(const ast_MemberExpr* m)
{
   string_buffer_Buf* out = string_buffer_create(4096, ast_useColor(), 2);
   string_buffer_Buf_color(out, ast_col_Expr);
   string_buffer_Buf_print(out, "MemberExpr expr %u ref %u/%u\n", ast_MemberExpr_hasExpr(m), m->base.base.memberExprBits.num_decls, ast_MemberExpr_getNumRefs(m));
   if (ast_MemberExpr_hasExpr(m)) {
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_print(out, "<expr>\n");
      ast_Expr* e = ast_MemberExpr_getExprBase(m);
      ast_Expr_print(e, out, 1);
   }
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_print(out, "[0]   (loc %u)\n", ast_Expr_getLoc(&m->base));
   for (uint32_t i = 0; (i < ast_MemberExpr_getNumRefs(m)); i++) {
      const ast_MemberRef* ref = &m->refs[(i + ast_MemberExpr_hasExpr(m))];
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_color(out, ast_col_Expr);
      if ((m->base.base.memberExprBits.num_decls > i)) {
         string_buffer_Buf_print(out, "[%u]\n", i);
         ast_Decl_print(ref->decl, out, 1);
      } else {
         string_buffer_Buf_print(out, "[%u] %s  (loc %u)\n", i, ast_idx2name(ref->name_idx), ast_MemberExpr_getLoc(m, i));
      }
   }
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static ast_NilExpr* ast_NilExpr_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_NilExpr* e = ast_context_Context_alloc(c, 16);
   ast_Expr_init(&e->base, ast_ExprKind_Nil, loc, 1, 1, 0, ast_ValType_RValue);
   ast_Expr_setType(&e->base, ast_getVoidPtr());
   ast_Stats_addExpr(ast_ExprKind_Nil, 16);
   return e;
}

static src_loc_SrcLoc ast_NilExpr_getEndLoc(const ast_NilExpr* e)
{
   return (e->base.base.loc + 3);
}

static void ast_NilExpr_print(const ast_NilExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
}

static void ast_NilExpr_printLiteral(const ast_NilExpr* _arg0, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "nil");
}

static ast_ParenExpr* ast_ParenExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner)
{
   ast_ParenExpr* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_Paren, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.parenExprBits.src_len = src_len;
   e->inner = inner;
   ast_Stats_addExpr(ast_ExprKind_Paren, 24);
   return e;
}

static ast_Expr* ast_ParenExpr_instantiate(ast_ParenExpr* e, ast_Instantiator* inst)
{
   return ((ast_Expr*)(ast_ParenExpr_create(inst->c, e->base.base.loc, e->base.base.parenExprBits.src_len, ast_Expr_instantiate(e->inner, inst))));
}

static ast_Expr* ast_ParenExpr_getInner(const ast_ParenExpr* e)
{
   return e->inner;
}

static ast_Expr** ast_ParenExpr_getInner2(ast_ParenExpr* e)
{
   return &e->inner;
}

static void ast_ParenExpr_print(const ast_ParenExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, (indent + 1));
}

static src_loc_SrcLoc ast_ParenExpr_getEndLoc(const ast_ParenExpr* e)
{
   return (e->base.base.loc + e->base.base.parenExprBits.src_len);
}

static void ast_ParenExpr_printLiteral(const ast_ParenExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_lparen(out);
   ast_Expr_printLiteral(e->inner, out);
   string_buffer_Buf_rparen(out);
}

static ast_RangeExpr* ast_RangeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_RangeExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_Range, loc, 0, 0, false, ast_ValType_RValue);
   e->lhs = lhs;
   e->rhs = rhs;
   ast_Stats_addExpr(ast_ExprKind_Range, 32);
   return e;
}

static ast_Expr* ast_RangeExpr_instantiate(ast_RangeExpr* e, ast_Instantiator* inst)
{
   return ((ast_Expr*)(ast_RangeExpr_create(inst->c, e->base.base.loc, ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst))));
}

static ast_Expr* ast_RangeExpr_getLHS(const ast_RangeExpr* e)
{
   return e->lhs;
}

static ast_Expr* ast_RangeExpr_getRHS(const ast_RangeExpr* e)
{
   return e->rhs;
}

static src_loc_SrcLoc ast_RangeExpr_getStartLoc(const ast_RangeExpr* e)
{
   return ast_Expr_getStartLoc(ast_RangeExpr_getLHS(e));
}

static src_loc_SrcLoc ast_RangeExpr_getEndLoc(const ast_RangeExpr* e)
{
   return ast_Expr_getEndLoc(ast_RangeExpr_getRHS(e));
}

static void ast_RangeExpr_print(const ast_RangeExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, "Range");
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, (indent + 1));
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, "LHS=\n");
   ast_Expr_print(e->lhs, out, (indent + 1));
   string_buffer_Buf_indent(out, (indent + 1));
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, "RHS=\n");
   ast_Expr_print(e->rhs, out, (indent + 1));
}

static void ast_RangeExpr_printLiteral(const ast_RangeExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add(out, " ... ");
   ast_Expr_printLiteral(e->rhs, out);
}

static ast_StringLiteral* ast_StringLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len)
{
   ast_StringLiteral* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_StringLiteral, loc, 0, 1, 0, ast_ValType_LValue);
   e->base.base.stringLiteralBits.src_len = src_len;
   e->value = value;
   e->size = (len + 1);
   ast_Stats_addExpr(ast_ExprKind_StringLiteral, 24);
   ast_Expr_setType(&e->base, ast_getStringType((len + 1)));
   return e;
}

static const char* ast_StringLiteral_getText(const ast_StringLiteral* e)
{
   return ast_idx2name(e->value);
}

static uint32_t ast_StringLiteral_getTextIndex(const ast_StringLiteral* e)
{
   return e->value;
}

static uint32_t ast_StringLiteral_getSize(const ast_StringLiteral* e)
{
   return e->size;
}

static uint32_t ast_StringLiteral_strlen(const ast_StringLiteral* e)
{
   return (e->size - 1);
}

static src_loc_SrcLoc ast_StringLiteral_getEndLoc(const ast_StringLiteral* e)
{
   return (e->base.base.loc + e->base.base.stringLiteralBits.src_len);
}

static void ast_StringLiteral_printLiteral(const ast_StringLiteral* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '"');
   string_buffer_Buf_encodeBytes(out, ast_idx2name(e->value), (e->size - 1), '"');
   string_buffer_Buf_add1(out, '"');
}

static void ast_StringLiteral_print(const ast_StringLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_StringLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static ast_TypeExpr* ast_TypeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref)
{
   uint32_t size = (24 + ast_TypeRefHolder_getExtraSize(ref));
   ast_TypeExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Type, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.typeExprBits.src_len = src_len;
   ast_TypeRef_init(&e->typeRef, ref);
   ast_Stats_addExpr(ast_ExprKind_Type, size);
   return e;
}

static ast_Expr* ast_TypeExpr_instantiate(ast_TypeExpr* e, ast_Instantiator* inst)
{
   _Bool matches = ast_TypeRef_matchesTemplate(&e->typeRef, inst->template_name);
   uint32_t extra = matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&e->typeRef);
   uint32_t size = (24 + extra);
   ast_TypeExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   ast_TypeRef_instantiate(&e2->typeRef, &e->typeRef, inst);
   ast_Stats_addExpr(ast_ExprKind_Type, size);
   return ((ast_Expr*)(e2));
}

static ast_TypeRef* ast_TypeExpr_getTypeRef(ast_TypeExpr* e)
{
   return &e->typeRef;
}

static src_loc_SrcLoc ast_TypeExpr_getEndLoc(const ast_TypeExpr* e)
{
   return (e->base.base.loc + e->base.base.typeExprBits.src_len);
}

static void ast_TypeExpr_print(const ast_TypeExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   ast_TypeRef_print(&e->typeRef, out, true);
   string_buffer_Buf_newline(out);
}

static void ast_TypeExpr_printLiteral(const ast_TypeExpr* e, string_buffer_Buf* out, _Bool decay)
{
   ast_TypeRef_printLiteral(&e->typeRef, out, true, decay);
}

static ast_UnaryOperator* ast_UnaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_UnaryOpcode kind, ast_Expr* inner)
{
   ast_UnaryOperator* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_UnaryOperator, loc, 0, 0, (kind <= ast_UnaryOpcode_PreDec), (kind == ast_UnaryOpcode_Deref) ? ast_ValType_LValue : ast_ValType_RValue);
   e->base.base.unaryOperatorBits.kind = kind;
   e->inner = inner;
   ast_Stats_addExpr(ast_ExprKind_UnaryOperator, 24);
   return e;
}

static ast_Expr* ast_UnaryOperator_instantiate(ast_UnaryOperator* e, ast_Instantiator* inst)
{
   return ((ast_Expr*)(ast_UnaryOperator_create(inst->c, e->base.base.loc, ast_UnaryOperator_getOpcode(e), ast_Expr_instantiate(e->inner, inst))));
}

static ast_UnaryOpcode ast_UnaryOperator_getOpcode(const ast_UnaryOperator* e)
{
   return ((ast_UnaryOpcode)(e->base.base.unaryOperatorBits.kind));
}

static ast_Expr* ast_UnaryOperator_getInner(const ast_UnaryOperator* e)
{
   return e->inner;
}

static ast_Expr** ast_UnaryOperator_getInner2(ast_UnaryOperator* e)
{
   return &e->inner;
}

static _Bool ast_UnaryOperator_isBefore(const ast_UnaryOperator* e)
{
   switch (ast_UnaryOperator_getOpcode(e)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec:
      return false;
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec:
      fallthrough;
   case ast_UnaryOpcode_AddrOf:
      fallthrough;
   case ast_UnaryOpcode_Deref:
      fallthrough;
   case ast_UnaryOpcode_Plus:
      fallthrough;
   case ast_UnaryOpcode_Minus:
      fallthrough;
   case ast_UnaryOpcode_Not:
      fallthrough;
   case ast_UnaryOpcode_LNot:
      return true;
   }
   return true;
}

static src_loc_SrcLoc ast_UnaryOperator_getStartLoc(const ast_UnaryOperator* e)
{
   if (ast_UnaryOperator_isBefore(e)) return ast_Expr_getLoc(&e->base);

   return ast_Expr_getStartLoc(e->inner);
}

static src_loc_SrcLoc ast_UnaryOperator_getEndLoc(const ast_UnaryOperator* e)
{
   if (ast_UnaryOperator_isBefore(e)) return ast_Expr_getEndLoc(e->inner);

   return (ast_Expr_getLoc(&e->base) + 2);
}

static const char* ast_UnaryOperator_getOpcodeStr(const ast_UnaryOperator* e)
{
   return ast_unaryOpcode_names[ast_UnaryOperator_getOpcode(e)];
}

static _Bool ast_UnaryOperator_isAddrOf(const ast_UnaryOperator* e)
{
   return (ast_UnaryOperator_getOpcode(e) == ast_UnaryOpcode_AddrOf);
}

static void ast_UnaryOperator_print(const ast_UnaryOperator* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_add(out, ast_unaryOpcode_names[ast_UnaryOperator_getOpcode(e)]);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, (indent + 1));
}

static void ast_UnaryOperator_printLiteral(const ast_UnaryOperator* e, string_buffer_Buf* out)
{
   const char* opcode = ast_unaryOpcode_names[ast_UnaryOperator_getOpcode(e)];
   if (ast_UnaryOperator_isBefore(e)) {
      string_buffer_Buf_add(out, opcode);
      ast_Expr_printLiteral(e->inner, out);
   } else {
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add(out, opcode);
   }
}

static void ast_Type_init(ast_Type* t, ast_TypeKind k)
{
   t->bits = 0;
   t->typeBits.kind = k;
   t->ptr_pool_idx = 0;
   t->canonicalType.ptr = 0;
}

static ast_TypeKind ast_Type_getKind(const ast_Type* t)
{
   return ((ast_TypeKind)(t->typeBits.kind));
}

static ast_QualType ast_Type_getCanonicalType(const ast_Type* t)
{
   return t->canonicalType;
}

static void ast_Type_setCanonicalType(ast_Type* t, ast_QualType canon)
{
   t->canonicalType = canon;
}

static uint32_t ast_Type_getIndex(const ast_Type* t)
{
   return t->ptr_pool_idx;
}

static _Bool ast_Type_isBuiltinType(const ast_Type* t)
{
   return ((ast_Type_getKind(t) == ast_TypeKind_Builtin));
}

static _Bool ast_Type_isArrayType(const ast_Type* t)
{
   return ((ast_Type_getKind(t) == ast_TypeKind_Array));
}

static _Bool ast_Type_isStructType(const ast_Type* t)
{
   return ((ast_Type_getKind(t) == ast_TypeKind_Struct));
}

static _Bool ast_Type_isPointerType(const ast_Type* t)
{
   return ((ast_Type_getKind(t) == ast_TypeKind_Pointer));
}

static _Bool ast_Type_isFunctionType(const ast_Type* t)
{
   return ((ast_Type_getKind(t) == ast_TypeKind_Function));
}

static _Bool ast_Type_isEnumType(const ast_Type* t)
{
   return ((ast_Type_getKind(t) == ast_TypeKind_Enum));
}

static _Bool ast_Type_isVoidType(const ast_Type* t)
{
   return (t == ast_QualType_getTypeOrNil(&ast_builtins[ast_BuiltinKind_Void]));
}

static void ast_Type_dump(const ast_Type* t)
{
   string_buffer_Buf* out = string_buffer_create(256, ast_useColor(), 2);
   ast_Type_print(t, out);
   string_buffer_Buf_color(out, color_Normal);
   printf("%s\n", string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static uint32_t ast_Type_getAlignment(const ast_Type* t)
{
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin: {
      const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
      return ast_BuiltinType_getAlignment(bi);
   }
   case ast_TypeKind_Pointer:
      break;
   case ast_TypeKind_Array: {
      const ast_ArrayType* at = ((ast_ArrayType*)(t));
      ast_QualType elem = ast_ArrayType_getElemType(at);
      return ast_QualType_getAlignment(&elem);
   }
   case ast_TypeKind_Struct: {
      const ast_StructType* s = ((ast_StructType*)(t));
      const ast_StructTypeDecl* std = ast_StructType_getDecl(s);
      return ast_StructTypeDecl_getAlignment(std);
   }
   case ast_TypeKind_Enum: {
      const ast_EnumType* e = ((ast_EnumType*)(t));
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(e);
      ast_QualType it = ast_EnumTypeDecl_getImplType(etd);
      return ast_Type_getAlignment(ast_QualType_getTypeOrNil(&it));
   }
   case ast_TypeKind_Function:
      break;
   case ast_TypeKind_Alias: {
      ast_QualType canon = ast_Type_getCanonicalType(t);
      return ast_QualType_getAlignment(&canon);
   }
   case ast_TypeKind_Module:
      return 0;
   }
   return ast_getWordSize();
}

static uint32_t ast_Type_getSize(const ast_Type* t, _Bool deref_ptr)
{
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin: {
      const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
      return ast_BuiltinType_getAlignment(bi);
   }
   case ast_TypeKind_Pointer:
      if (deref_ptr) {
         const ast_PointerType* pt = ((ast_PointerType*)(t));
         ast_QualType inner = ast_PointerType_getInner(pt);
         return ast_QualType_getSize(&inner, deref_ptr);
      }
      break;
   case ast_TypeKind_Array: {
      const ast_ArrayType* at = ((ast_ArrayType*)(t));
      ast_QualType elem = ast_ArrayType_getElemType(at);
      return (ast_ArrayType_getSize(at) * ast_QualType_getSize(&elem, false));
   }
   case ast_TypeKind_Struct: {
      const ast_StructType* s = ((ast_StructType*)(t));
      const ast_StructTypeDecl* std = ast_StructType_getDecl(s);
      return ast_StructTypeDecl_getSize(std);
   }
   case ast_TypeKind_Enum: {
      const ast_EnumType* e = ((ast_EnumType*)(t));
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(e);
      ast_QualType it = ast_EnumTypeDecl_getImplType(etd);
      return ast_Type_getSize(ast_QualType_getTypeOrNil(&it), false);
   }
   case ast_TypeKind_Function:
      break;
   case ast_TypeKind_Alias: {
      ast_QualType canon = ast_Type_getCanonicalType(t);
      return ast_QualType_getAlignment(&canon);
   }
   case ast_TypeKind_Module:
      return 0;
   }
   return ast_getWordSize();
}

static void ast_Type_print(const ast_Type* t, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Type);
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      ast_BuiltinType_print(((ast_BuiltinType*)(t)), out);
      break;
   case ast_TypeKind_Pointer:
      ast_PointerType_print(((ast_PointerType*)(t)), out);
      break;
   case ast_TypeKind_Array:
      ast_ArrayType_print(((ast_ArrayType*)(t)), out);
      break;
   case ast_TypeKind_Struct:
      ast_StructType_print(((ast_StructType*)(t)), out);
      break;
   case ast_TypeKind_Enum:
      ast_EnumType_print(((ast_EnumType*)(t)), out);
      break;
   case ast_TypeKind_Function:
      ast_FunctionType_print(((ast_FunctionType*)(t)), out);
      break;
   case ast_TypeKind_Alias:
      ast_AliasType_print(((ast_AliasType*)(t)), out);
      break;
   case ast_TypeKind_Module:
      ast_ModuleType_print(((ast_ModuleType*)(t)), out);
      break;
   }
}

static void ast_Type_fullPrint(const ast_Type* t, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      ast_BuiltinType_fullPrint(((ast_BuiltinType*)(t)), out, indent);
      break;
   case ast_TypeKind_Pointer:
      ast_PointerType_fullPrint(((ast_PointerType*)(t)), out, indent);
      break;
   case ast_TypeKind_Array:
      ast_ArrayType_fullPrint(((ast_ArrayType*)(t)), out, indent);
      break;
   case ast_TypeKind_Struct:
      ast_StructType_fullPrint(((ast_StructType*)(t)), out, indent);
      break;
   case ast_TypeKind_Enum:
      ast_EnumType_fullPrint(((ast_EnumType*)(t)), out, indent);
      break;
   case ast_TypeKind_Function:
      ast_FunctionType_fullPrint(((ast_FunctionType*)(t)), out, indent);
      break;
   case ast_TypeKind_Alias:
      ast_AliasType_fullPrint(((ast_AliasType*)(t)), out, indent);
      break;
   case ast_TypeKind_Module:
      ast_ModuleType_fullPrint(((ast_ModuleType*)(t)), out, indent);
      break;
   }
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_add(out, "canonical=");
   ast_Type* canon = ast_QualType_getTypeOrNil(&t->canonicalType);
   if (canon) {
      if ((canon == t)) {
         string_buffer_Buf_add(out, "this\n");
      } else {
         ast_Type_fullPrint(canon, out, (indent + 1));
      }
   } else {
      string_buffer_Buf_add(out, "NIL\n");
   }
}

static ast_AliasType* ast_AliasType_create(ast_context_Context* c, ast_AliasTypeDecl* decl)
{
   ast_AliasType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Alias);
   t->decl = decl;
   ast_Stats_addType(ast_TypeKind_Alias, 24);
   return t;
}

static ast_AliasTypeDecl* ast_AliasType_getDecl(const ast_AliasType* t)
{
   return t->decl;
}

static void ast_AliasType_print(const ast_AliasType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "(alias)");
   string_buffer_Buf_add(out, ast_Decl_getModuleName(&t->decl->base));
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_Decl_getName(&t->decl->base));
}

static void ast_AliasType_fullPrint(const ast_AliasType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "AliasType [%p] %s\n", t, ast_Decl_getName(ast_AliasTypeDecl_asDecl(t->decl)));
}

static ast_ArrayType* ast_ArrayType_create(ast_context_Context* c, ast_QualType elem, _Bool has_size, uint32_t size)
{
   ast_ArrayType* t = ast_context_Context_alloc(c, 32);
   ast_Type_init(&t->base, ast_TypeKind_Array);
   t->base.arrayTypeBits.is_incremental = false;
   t->base.arrayTypeBits.has_size = has_size;
   t->elem = elem;
   t->size = size;
   ast_Stats_addType(ast_TypeKind_Array, 32);
   return t;
}

static ast_ArrayType* ast_ArrayType_createIncremental(ast_context_Context* c, ast_QualType elem)
{
   ast_ArrayType* t = ast_context_Context_alloc(c, 32);
   ast_Type_init(&t->base, ast_TypeKind_Array);
   t->base.arrayTypeBits.is_incremental = true;
   t->base.arrayTypeBits.has_size = false;
   t->elem = elem;
   t->size = 0;
   ast_Stats_addType(ast_TypeKind_Array, 32);
   return t;
}

static ast_QualType ast_ArrayType_getElemType(const ast_ArrayType* t)
{
   return t->elem;
}

static uint32_t ast_ArrayType_hasSize(const ast_ArrayType* t)
{
   return t->base.arrayTypeBits.has_size;
}

static uint32_t ast_ArrayType_getSize(const ast_ArrayType* t)
{
   return t->size;
}

static void ast_ArrayType_setSize(ast_ArrayType* t, uint32_t size)
{
   t->base.arrayTypeBits.has_size = true;
   t->size = size;
}

static void ast_ArrayType_printPreName(const ast_ArrayType* t, string_buffer_Buf* out)
{
   ast_QualType_print(&t->elem, out);
}

static void ast_ArrayType_printPostName(const ast_ArrayType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '[');
   if (t->base.arrayTypeBits.is_incremental) {
      string_buffer_Buf_add(out, "+");
   } else {
      string_buffer_Buf_print(out, "%u", t->size);
   }
   string_buffer_Buf_add1(out, ']');
}

static void ast_ArrayType_print(const ast_ArrayType* t, string_buffer_Buf* out)
{
   ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(&t->elem);
   if (at) ast_ArrayType_printPreName(at, out);
   else ast_QualType_printInner(&t->elem, out, false, true, true);
   ast_ArrayType_printPostName(t, out);
   if (at) ast_ArrayType_printPostName(at, out);
}

static void ast_ArrayType_fullPrint(const ast_ArrayType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "ArrayType [%p]", t);
   if (t->base.arrayTypeBits.has_size) string_buffer_Buf_print(out, " size=%u", t->size);
   string_buffer_Buf_newline(out);
   ast_QualType_fullPrint(&t->elem, out, (indent + 1));
}

static _Bool ast_builtinKind2Signed(ast_BuiltinKind kind)
{
   return ast_BuiltinType_signed[kind];
}

static ast_BuiltinType* ast_BuiltinType_create(ast_context_Context* c, ast_BuiltinKind kind)
{
   ast_BuiltinType* b = ast_context_Context_alloc(c, 16);
   ast_Type_init(&b->base, ast_TypeKind_Builtin);
   b->base.builtinTypeBits.kind = kind;
   ast_Type_setCanonicalType(&b->base, ast_QualType_create(&b->base));
   ast_Stats_addType(ast_TypeKind_Builtin, 16);
   return b;
}

static ast_BuiltinKind ast_BuiltinType_getKind(const ast_BuiltinType* b)
{
   return ((ast_BuiltinKind)(b->base.builtinTypeBits.kind));
}

static ast_BuiltinKind ast_BuiltinType_getBaseKind(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_baseTypes[ast_BuiltinType_getKind(b)];
}

static _Bool ast_BuiltinType_isChar(const ast_BuiltinType* b)
{
   return (b->base.builtinTypeBits.kind == ast_BuiltinKind_Char);
}

static _Bool ast_BuiltinType_isInt8(const ast_BuiltinType* b)
{
   return (b->base.builtinTypeBits.kind == ast_BuiltinKind_Int8);
}

static _Bool ast_BuiltinType_isUInt8(const ast_BuiltinType* b)
{
   return (b->base.builtinTypeBits.kind == ast_BuiltinKind_UInt8);
}

static _Bool ast_BuiltinType_isInt32(const ast_BuiltinType* b)
{
   return (b->base.builtinTypeBits.kind == ast_BuiltinKind_Int32);
}

static _Bool ast_BuiltinType_isVoid(const ast_BuiltinType* b)
{
   return (b->base.builtinTypeBits.kind == ast_BuiltinKind_Void);
}

static const char* ast_BuiltinType_kind2str(const ast_BuiltinType* b)
{
   return ast_builtinType_names[ast_BuiltinType_getKind(b)];
}

static _Bool ast_BuiltinType_isPromotableIntegerType(const ast_BuiltinType* b)
{
   return ast_BuiltinType_promotable[ast_BuiltinType_getKind(b)];
}

static _Bool ast_BuiltinType_isInteger(const ast_BuiltinType* b)
{
   return ast_BuiltinType_integer[ast_BuiltinType_getKind(b)];
}

static _Bool ast_BuiltinType_isIntegerOrBool(const ast_BuiltinType* b)
{
   return (ast_BuiltinType_isInteger(b) || (ast_BuiltinType_getKind(b) == ast_BuiltinKind_Bool));
}

static _Bool ast_BuiltinType_isFloatingPoint(const ast_BuiltinType* b)
{
   return (((ast_BuiltinType_getKind(b) == ast_BuiltinKind_Float32) || (ast_BuiltinType_getKind(b) == ast_BuiltinKind_Float64)));
}

static _Bool ast_BuiltinType_isSigned(const ast_BuiltinType* b)
{
   return ast_BuiltinType_signed[ast_BuiltinType_getKind(b)];
}

static _Bool ast_BuiltinType_isUnsigned(const ast_BuiltinType* b)
{
   return ast_BuiltinType_unsigned[ast_BuiltinType_getKind(b)];
}

static uint32_t ast_BuiltinType_getAlignment(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_sizes[ast_BuiltinType_getKind(b)];
}

static uint32_t ast_BuiltinType_getWidth(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_width[ast_BuiltinType_getKind(b)];
}

static uint32_t ast_BuiltinType_getBitfieldSize(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_bitfield_sizes[ast_BuiltinType_getKind(b)];
}

static void ast_BuiltinType_print(const ast_BuiltinType* b, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_builtinType_names[ast_BuiltinType_getKind(b)]);
}

static void ast_BuiltinType_fullPrint(const ast_BuiltinType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "BuiltinType [%p] %s\n", t, ast_BuiltinType_kind2str(t));
}

static ast_EnumType* ast_EnumType_create(ast_context_Context* c, ast_EnumTypeDecl* decl)
{
   ast_EnumType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Enum);
   t->decl = decl;
   ast_Stats_addType(ast_TypeKind_Enum, 24);
   ast_Type_setCanonicalType(&t->base, ast_QualType_create(((ast_Type*)(t))));
   return t;
}

static ast_EnumTypeDecl* ast_EnumType_getDecl(const ast_EnumType* t)
{
   return t->decl;
}

static ast_QualType ast_EnumType_getImplType(const ast_EnumType* t)
{
   return ast_EnumTypeDecl_getImplType(t->decl);
}

static const char* ast_EnumType_getName(const ast_EnumType* t)
{
   return ast_Decl_getName(&t->decl->base);
}

static void ast_EnumType_print(const ast_EnumType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_Decl_getModuleName(&t->decl->base));
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_Decl_getName(&t->decl->base));
}

static void ast_EnumType_fullPrint(const ast_EnumType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "EnumType [%p] %s\n", t, ast_Decl_getName(ast_EnumTypeDecl_asDecl(t->decl)));
}

static ast_FunctionType* ast_FunctionType_create(ast_context_Context* c, ast_FunctionDecl* decl)
{
   ast_FunctionType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Function);
   t->decl = NULL;
   t->decl = decl;
   ast_Type_setCanonicalType(&t->base, ast_QualType_create(&t->base));
   ast_Stats_addType(ast_TypeKind_Function, 24);
   return t;
}

static ast_FunctionDecl* ast_FunctionType_getDecl(const ast_FunctionType* t)
{
   return t->decl;
}

static ast_Type* ast_FunctionType_asType(ast_FunctionType* t)
{
   return &t->base;
}

static void ast_FunctionType_print(const ast_FunctionType* t, string_buffer_Buf* out)
{
   ast_FunctionDecl_printType(t->decl, out);
}

static void ast_FunctionType_fullPrint(const ast_FunctionType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "FunctionType [%p] %s\n", t, ast_Decl_getName(ast_FunctionDecl_asDecl(t->decl)));
}

static ast_ModuleType* ast_ModuleType_create(ast_context_Context* c, ast_Module* mod)
{
   ast_ModuleType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Module);
   t->mod = mod;
   ast_Type_setCanonicalType(&t->base, ast_QualType_create(&t->base));
   ast_Stats_addType(ast_TypeKind_Module, 24);
   return t;
}

static ast_Module* ast_ModuleType_getModule(const ast_ModuleType* t)
{
   return t->mod;
}

static void ast_ModuleType_print(const ast_ModuleType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_print(out, "Module %s", ast_Module_getName(t->mod));
}

static void ast_ModuleType_fullPrint(const ast_ModuleType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "ModuleType %s\n", ast_Module_getName(t->mod));
}

static ast_PointerType* ast_PointerType_create(ast_context_Context* c, ast_QualType inner)
{
   ast_PointerType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Pointer);
   t->inner = inner;
   ast_Stats_addType(ast_TypeKind_Pointer, 24);
   return t;
}

static ast_QualType ast_PointerType_getInner(const ast_PointerType* t)
{
   return t->inner;
}

static void ast_PointerType_print(const ast_PointerType* t, string_buffer_Buf* out)
{
   ast_QualType_printInner(&t->inner, out, false, true, true);
   string_buffer_Buf_add1(out, '*');
}

static void ast_PointerType_fullPrint(const ast_PointerType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "PointerType [%p]\n", t);
   ast_QualType_fullPrint(&t->inner, out, (indent + 1));
}

static ast_QualType ast_QualType_create(ast_Type* t)
{
   ast_QualType qt = { ((size_t)(t)) };
   return qt;
}

static void ast_QualType_set(ast_QualType* qt, ast_Type* t)
{
   qt->ptr = ((size_t)(t));
}

static void ast_QualType_setConst(ast_QualType* qt)
{
   qt->ptr |= ast_QualType_Const;
}

static void ast_QualType_unsetConst(ast_QualType* qt)
{
   qt->ptr &= ~ast_QualType_Const;
}

static _Bool ast_QualType_isConst(ast_QualType* qt)
{
   return (((qt->ptr & ast_QualType_Const)) != 0);
}

static _Bool ast_QualType_isVolatile(ast_QualType* qt)
{
   return (((qt->ptr & ast_QualType_Volatile)) != 0);
}

static void ast_QualType_setVolatile(ast_QualType* qt)
{
   qt->ptr |= ast_QualType_Volatile;
}

static uint32_t ast_QualType_getQuals(const ast_QualType* qt)
{
   return (qt->ptr & ast_QualType_Mask);
}

static void ast_QualType_copyQuals(ast_QualType* qt, ast_QualType other)
{
   qt->ptr &= ~ast_QualType_Mask;
   qt->ptr |= ((other.ptr & ast_QualType_Mask));
}

static void ast_QualType_clearQuals(ast_QualType* qt)
{
   qt->ptr &= ~ast_QualType_Mask;
}

static _Bool ast_QualType_isConstant(const ast_QualType* qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(&canon);
   if (ast_QualType_isConst(&canon)) return true;

   if ((ast_Type_getKind(t) == ast_TypeKind_Array)) {
      const ast_ArrayType* at = ((ast_ArrayType*)(t));
      canon = ast_ArrayType_getElemType(at);
      return ast_QualType_isConstant(&canon);
   }
   return false;
}

static _Bool ast_QualType_isValid(const ast_QualType* qt)
{
   return (qt->ptr != 0);
}

static _Bool ast_QualType_isInvalid(const ast_QualType* qt)
{
   return (qt->ptr == 0);
}

static uint32_t ast_QualType_getBitFieldWidth(const ast_QualType* qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(&canon);
   if (ast_Type_isBuiltinType(t)) {
      ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
      return ast_BuiltinType_getBitfieldSize(bi);
   }
   if (ast_Type_isEnumType(t)) {
      ast_EnumType* et = ((ast_EnumType*)(t));
      ast_QualType impl = ast_EnumType_getImplType(et);
      return ast_QualType_getBitFieldWidth(&impl);
   }
   return 0;
}

static _Bool ast_QualType_isScalar(const ast_QualType* qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(&canon);
   if (ast_Type_isBuiltinType(t)) {
      ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
      return !ast_BuiltinType_isVoid(bi);
   }
   if (ast_QualType_isPointer(&canon)) return true;

   if (ast_QualType_isFunction(&canon)) return true;

   if (ast_QualType_isEnum(&canon)) return true;

   return false;
}

static _Bool ast_QualType_isUnsigned(const ast_QualType* qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(&canon);
   if (!ast_Type_isBuiltinType(t)) return false;

   ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ast_BuiltinType_isUnsigned(bi);
}

static ast_Type* ast_QualType_getType(const ast_QualType* qt)
{
   size_t t = (qt->ptr & ~ast_QualType_Mask);
   (t) || c2_assert("ast/qualtype.c2", 134, "ast.QualType.getType", "t");
   return ((ast_Type*)(t));
}

static ast_Type* ast_QualType_getTypeOrNil(const ast_QualType* qt)
{
   size_t temp = (qt->ptr & ~ast_QualType_Mask);
   return ((ast_Type*)(temp));
}

static _Bool ast_QualType_hasCanonicalType(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return (t->canonicalType.ptr != 0);
}

static ast_QualType ast_QualType_getCanonicalType(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   ast_QualType canon = t->canonicalType;
   ast_QualType_copyQuals(&canon, *qt);
   return canon;
}

static void ast_QualType_setCanonicalType(ast_QualType* qt, ast_QualType canon)
{
   ast_Type* t = ast_QualType_getType(qt);
   ast_Type_setCanonicalType(t, canon);
}

static _Bool ast_QualType_isConstPtr(ast_QualType* qt)
{
   ast_PointerType* pt = ast_QualType_getPointerType(qt);
   return ast_QualType_isConst(&pt->inner);
}

static ast_TypeKind ast_QualType_getKind(ast_QualType* qt)
{
   ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getKind(t);
}

static uint32_t ast_QualType_getIndex(ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getIndex(t);
}

static uint32_t ast_QualType_getAlignment(ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getAlignment(t);
}

static uint32_t ast_QualType_getSize(ast_QualType* qt, _Bool deref_ptr)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getSize(t, deref_ptr);
}

static _Bool ast_QualType_isBool(const ast_QualType* qt)
{
   return (ast_QualType_getTypeOrNil(qt) == ast_QualType_getTypeOrNil(&ast_builtins[ast_BuiltinKind_Bool]));
}

static _Bool ast_QualType_isBuiltin(const ast_QualType* qt)
{
   return ast_Type_isBuiltinType(ast_QualType_getTypeOrNil(qt));
}

static _Bool ast_QualType_isArray(const ast_QualType* qt)
{
   return ast_Type_isArrayType(ast_QualType_getTypeOrNil(qt));
}

static _Bool ast_QualType_isStruct(const ast_QualType* qt)
{
   return ast_Type_isStructType(ast_QualType_getTypeOrNil(qt));
}

static _Bool ast_QualType_isInteger(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (!ast_Type_isBuiltinType(t)) return false;

   const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ast_BuiltinType_isInteger(bi);
}

static _Bool ast_QualType_isFloat(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (!ast_Type_isBuiltinType(t)) return false;

   const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ast_BuiltinType_isFloatingPoint(bi);
}

static _Bool ast_QualType_isCharPointer(const ast_QualType* qt)
{
   if (!ast_QualType_isPointer(qt)) return false;

   const ast_PointerType* pt = ast_QualType_getPointerType(qt);
   ast_QualType inner = ast_PointerType_getInner(pt);
   return ast_QualType_isChar(&inner);
}

static _Bool ast_QualType_isPointer(const ast_QualType* qt)
{
   return ast_Type_isPointerType(ast_QualType_getTypeOrNil(qt));
}

static ast_QualType ast_QualType_getPointerBaseType(const ast_QualType* qt)
{
   const ast_PointerType* pt = ast_QualType_getPointerType(qt);
   return ast_PointerType_getInner(pt);
}

static _Bool ast_QualType_isFunction(const ast_QualType* qt)
{
   return ast_Type_isFunctionType(ast_QualType_getTypeOrNil(qt));
}

static _Bool ast_QualType_isEnum(const ast_QualType* qt)
{
   return ast_Type_isEnumType(ast_QualType_getTypeOrNil(qt));
}

static _Bool ast_QualType_isVoid(const ast_QualType* qt)
{
   return ast_Type_isVoidType(ast_QualType_getTypeOrNil(qt));
}

static ast_BuiltinType* ast_QualType_getBuiltin(const ast_QualType* qt)
{
   return ((ast_BuiltinType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_BuiltinType* ast_QualType_getBuiltinTypeOrNil(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((t && (ast_Type_getKind(t) == ast_TypeKind_Builtin))) return ((ast_BuiltinType*)(t));

   return NULL;
}

static ast_StructType* ast_QualType_getStructType(const ast_QualType* qt)
{
   return ((ast_StructType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_PointerType* ast_QualType_getPointerType(const ast_QualType* qt)
{
   return ((ast_PointerType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_FunctionType* ast_QualType_getFunctionType(const ast_QualType* qt)
{
   return ((ast_FunctionType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_ArrayType* ast_QualType_getArrayType(const ast_QualType* qt)
{
   return ((ast_ArrayType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_EnumType* ast_QualType_getEnum(const ast_QualType* qt)
{
   return ((ast_EnumType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_FunctionType* ast_QualType_getFunctionTypeOrNil(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((t && (ast_Type_getKind(t) == ast_TypeKind_Function))) return ((ast_FunctionType*)(t));

   return NULL;
}

static ast_StructType* ast_QualType_getStructTypeOrNil(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((t && (ast_Type_getKind(t) == ast_TypeKind_Struct))) return ((ast_StructType*)(t));

   return NULL;
}

static ast_ArrayType* ast_QualType_getArrayTypeOrNil(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((t && (ast_Type_getKind(t) == ast_TypeKind_Array))) return ((ast_ArrayType*)(t));

   return NULL;
}

static ast_EnumType* ast_QualType_getEnumType(const ast_QualType* qt)
{
   return ((ast_EnumType*)(ast_QualType_getTypeOrNil(qt)));
}

static ast_EnumType* ast_QualType_getEnumTypeOrNil(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((ast_Type_getKind(t) == ast_TypeKind_Enum)) return ((ast_EnumType*)(t));

   return NULL;
}

static _Bool ast_QualType_isChar(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((ast_Type_getKind(t) != ast_TypeKind_Builtin)) return false;

   const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ast_BuiltinType_isChar(bi);
}

static _Bool ast_QualType_isInt8(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((ast_Type_getKind(t) != ast_TypeKind_Builtin)) return false;

   const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ast_BuiltinType_isInt8(bi);
}

static _Bool ast_QualType_isUInt8(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((ast_Type_getKind(t) != ast_TypeKind_Builtin)) return false;

   const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ast_BuiltinType_isUInt8(bi);
}

static _Bool ast_QualType_promotesToInt32(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if ((ast_Type_getKind(t) != ast_TypeKind_Builtin)) return false;

   const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
   return ((ast_BuiltinType_getKind(bi) == ast_BuiltinKind_Int32) || ast_BuiltinType_isPromotableIntegerType(bi));
}

static _Bool ast_QualType_needsCtvInit(const ast_QualType* qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(&canon);
   if (!t) {
      printf("MISSING CANONICAL\n");
      ast_QualType_dump_full(qt);
      return false;
   }
   (t) || c2_assert("ast/qualtype.c2", 359, "ast.QualType.needsCtvInit", "t");
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      return true;
   case ast_TypeKind_Pointer:
      return false;
   case ast_TypeKind_Array:
      return true;
   case ast_TypeKind_Struct:
      return true;
   case ast_TypeKind_Enum:
      return true;
   case ast_TypeKind_Function:
      return false;
   case ast_TypeKind_Alias:
      return false;
   case ast_TypeKind_Module:
      return false;
   }
   return false;
}

static const char* ast_QualType_diagName(const ast_QualType* qt)
{
   static char msgs[4][128];
   static uint32_t msg_id = 0;
   char* msg = msgs[msg_id];
   msg_id = (((msg_id + 1)) % 4);
   string_buffer_Buf* buf = string_buffer_create_static(128, false, msg);
   ast_QualType_printInner(qt, buf, true, true, true);
   string_buffer_Buf_free(buf);
   return msg;
}

static const char* ast_QualType_diagNameBare(const ast_QualType* qt)
{
   static char msgs[4][128];
   static uint32_t msg_id = 0;
   char* msg = msgs[msg_id];
   msg_id = (((msg_id + 1)) % 4);
   string_buffer_Buf* buf = string_buffer_create_static(128, false, msg);
   ast_QualType_printInner(qt, buf, true, false, true);
   string_buffer_Buf_free(buf);
   return msg;
}

static void ast_QualType_dump(const ast_QualType* qt)
{
   string_buffer_Buf* out = string_buffer_create(512, ast_useColor(), 2);
   ast_QualType_printInner(qt, out, false, true, false);
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ast_QualType_dump_full(const ast_QualType* qt)
{
   string_buffer_Buf* out = string_buffer_create(512, ast_useColor(), 1);
   ast_QualType_fullPrint(qt, out, 0);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ast_QualType_printQuoted(const ast_QualType* qt, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Type);
   ast_QualType_printInner(qt, out, true, true, true);
   string_buffer_Buf_color(out, ast_col_Type);
}

static void ast_QualType_print(const ast_QualType* qt, string_buffer_Buf* out)
{
   ast_QualType_printInner(qt, out, true, true, true);
}

static void ast_QualType_printInner(const ast_QualType* qt, string_buffer_Buf* out, _Bool printCanon, _Bool printModifiers, _Bool print_error)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t) {
      uint32_t quals = ast_QualType_getQuals(qt);
      if (ast_QualType_isPointer(qt)) {
         ast_Type_print(t, out);
         if (printModifiers) {
            if ((quals & ast_QualType_Const)) string_buffer_Buf_add(out, " const");
            if ((quals & ast_QualType_Volatile)) string_buffer_Buf_add(out, " volatile");
         }
      } else {
         if (printModifiers) {
            if (quals) string_buffer_Buf_color(out, ast_col_Type);
            if ((quals & ast_QualType_Const)) string_buffer_Buf_add(out, "const ");
            if ((quals & ast_QualType_Volatile)) string_buffer_Buf_add(out, "volatile ");
         }
         ast_Type_print(t, out);
      }
      if (printCanon) {
         ast_QualType qt2 = ast_QualType_getCanonicalType(qt);
         const ast_Type* canon = ast_QualType_getTypeOrNil(&qt2);
         if ((canon && (canon != t))) {
            string_buffer_Buf_add(out, " => ");
            ast_QualType_printInner(&qt2, out, false, true, true);
         }
      }
   } else {
      if (print_error) {
         string_buffer_Buf_color(out, ast_col_Error);
         string_buffer_Buf_add(out, "??");
      } else {
         string_buffer_Buf_add(out, "QualType(nil)");
      }
   }
}

static void ast_QualType_fullPrint(const ast_QualType* qt, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_add(out, "QualType");
   uint32_t quals = ast_QualType_getQuals(qt);
   if ((quals & ast_QualType_Const)) string_buffer_Buf_add(out, " const");
   if ((quals & ast_QualType_Volatile)) string_buffer_Buf_add(out, " volatile");
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t) {
      string_buffer_Buf_newline(out);
      ast_Type_fullPrint(t, out, (indent + 1));
   } else string_buffer_Buf_add(out, " type=nil\n");
}

static ast_StructType* ast_StructType_create(ast_context_Context* c, ast_StructTypeDecl* decl)
{
   ast_StructType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Struct);
   t->decl = decl;
   ast_Stats_addType(ast_TypeKind_Struct, 24);
   return t;
}

static ast_StructTypeDecl* ast_StructType_getDecl(const ast_StructType* t)
{
   return t->decl;
}

static ast_Type* ast_StructType_asType(ast_StructType* t)
{
   return &t->base;
}

static void ast_StructType_print(const ast_StructType* t, string_buffer_Buf* out)
{
   if (ast_StructTypeDecl_isGlobal(t->decl)) {
      string_buffer_Buf_add(out, ast_Decl_getModuleName(&t->decl->base));
      string_buffer_Buf_add1(out, '.');
   }
   const char* name = ast_Decl_getName(&t->decl->base);
   if (name) string_buffer_Buf_add(out, name);
   else string_buffer_Buf_add(out, "<anonymous>");
}

static void ast_StructType_fullPrint(const ast_StructType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "StructType [%p] %s\n", t, ast_Decl_getName(ast_StructTypeDecl_asDecl(t->decl)));
}

static const char* ast_Ref_getName(const ast_Ref* r)
{
   return ast_idx2name(r->name_idx);
}

static void ast_TypeRefHolder_init(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   r->flagBits = 0;
   r->dest = 0;
}

static uint32_t ast_TypeRefHolder_getExtraSize(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   return ast_TypeRef_getExtraSize(r);
}

static void ast_TypeRefHolder_setQualifiers(ast_TypeRefHolder* h, uint32_t qualifiers)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   if ((qualifiers & ast_QualType_Volatile)) r->flags.is_volatile = 1;
   if ((qualifiers & ast_QualType_Const)) r->flags.is_const = 1;
}

static void ast_TypeRefHolder_setConst(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   r->flags.is_const = 1;
}

static void ast_TypeRefHolder_setVolatile(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   r->flags.is_volatile = 1;
}

static void ast_TypeRefHolder_addPointer(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   ((r->flags.num_ptrs != 3)) || c2_assert("ast/type_ref.c2", 98, "ast.TypeRefHolder.addPointer", "r.flags.num_ptrs != 3");
   r->flags.num_ptrs++;
}

static _Bool ast_TypeRefHolder_isIncrArray(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   return r->flags.incr_array;
}

static void ast_TypeRefHolder_setIncrArray(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   r->flags.incr_array = 1;
}

static uint32_t ast_TypeRefHolder_getNumArrays(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   return ast_TypeRef_getNumArrays(r);
}

static void ast_TypeRefHolder_addArray(ast_TypeRefHolder* h, ast_Expr* array)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   ((r->flags.num_arrays != 3)) || c2_assert("ast/type_ref.c2", 119, "ast.TypeRefHolder.addArray", "r.flags.num_arrays != 3");
   h->arrays[r->flags.num_arrays] = array;
   r->flags.num_arrays++;
}

static void ast_TypeRefHolder_setBuiltin(ast_TypeRefHolder* h, ast_BuiltinKind kind, src_loc_SrcLoc loc)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   r->flags.builtin_kind = kind;
   r->loc = loc;
}

static void ast_TypeRefHolder_setUser(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   r->flags.is_user = 1;
   h->user.loc = loc;
   h->user.name_idx = name_idx;
   h->user.decl = NULL;
}

static void ast_TypeRefHolder_setPrefix(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx)
{
   ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   h->prefix = h->user;
   r->flags.has_prefix = 1;
   h->user.loc = loc;
   h->user.name_idx = name_idx;
   h->user.decl = NULL;
}

static void ast_TypeRefHolder_dump(const ast_TypeRefHolder* h)
{
   const ast_TypeRef* r = ((ast_TypeRef*)(&h->ref));
   string_buffer_Buf* out = string_buffer_create(128, ast_useColor(), 2);
   ast_TypeRef_print(r, out, false);
   for (uint32_t i = 0; (i < ast_TypeRef_getNumArrays(r)); i++) {
      string_buffer_Buf_add(out, "[");
      ast_Expr* size = h->arrays[i];
      if (size) ast_Expr_printLiteral(h->arrays[i], out);
      string_buffer_Buf_add(out, "]");
   }
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ast_TypeRef_init(ast_TypeRef* dest, const ast_TypeRefHolder* h)
{
   const ast_TypeRef* r = ((const ast_TypeRef*)(&h->ref));
   *dest = *r;
   if (ast_TypeRef_isUser(r)) {
      dest->refs[0] = r->refs[0];
      if (ast_TypeRef_hasPrefix(r)) {
         dest->refs[1] = r->refs[1];
      }
   }
   for (uint32_t i = 0; (i < r->flags.num_arrays); i++) {
      ast_Expr** a = ast_TypeRef_getArray2(dest, i);
      *a = h->arrays[i];
   }
}

static _Bool ast_TypeRef_matchesTemplate(const ast_TypeRef* r, uint32_t template_arg)
{
   if ((!r->flags.is_user || r->flags.has_prefix)) return false;

   return (r->refs[0].name_idx == template_arg);
}

static void ast_TypeRef_instantiate(ast_TypeRef* r, const ast_TypeRef* r1, ast_Instantiator* inst)
{
   const ast_TypeRef* r2 = inst->ref;
   if (ast_TypeRef_matchesTemplate(r1, inst->template_name)) {
      r->flagBits = r2->flagBits;
      r->dest = r2->dest;
      if (r2->flags.is_user) {
         r->refs[0].name_idx = r2->refs[0].name_idx;
         r->refs[0].loc = r1->refs[0].loc;
         r->refs[0].decl = r2->refs[0].decl;
         if (r2->flags.has_prefix) {
            r->refs[1].name_idx = r2->refs[1].name_idx;
            r->refs[1].loc = r2->refs[1].loc;
            r->refs[1].decl = r2->refs[1].decl;
         }
      }
      r->flags.is_const |= r1->flags.is_const;
      r->flags.is_volatile |= r1->flags.is_volatile;
      r->flags.num_ptrs += r1->flags.num_ptrs;
      if ((inst->used_opaque && (r->flags.num_ptrs == 0))) {
         ast_Instantiator_on_opaque(inst, r->refs[0].loc, r->refs[0].decl);
      }
   } else {
      memcpy(r, r1, (8 + ast_TypeRef_getExtraSize(r1)));
   }
}

static void ast_TypeRef_setDest(ast_TypeRef* r, uint32_t dest)
{
   (ast_TypeRef_isUser(r)) || c2_assert("ast/type_ref.c2", 213, "ast.TypeRef.setDest", "r.isUser()");
   r->dest = dest;
}

static uint32_t ast_TypeRef_getExtraSize(const ast_TypeRef* r)
{
   uint32_t numrefs = (r->flags.is_user + r->flags.has_prefix);
   uint32_t extra = (numrefs * 16);
   extra += (r->flags.num_arrays * 8);
   return extra;
}

static void* ast_TypeRef_getPointerAfter(const ast_TypeRef* r)
{
   uint8_t* ptr = ((((uint8_t*)(r)) + 8) + ast_TypeRef_getExtraSize(r));
   return ptr;
}

static _Bool ast_TypeRef_isConst(const ast_TypeRef* r)
{
   return r->flags.is_const;
}

static _Bool ast_TypeRef_isVolatile(const ast_TypeRef* r)
{
   return r->flags.is_volatile;
}

static _Bool ast_TypeRef_isUser(const ast_TypeRef* r)
{
   return r->flags.is_user;
}

static _Bool ast_TypeRef_isVoid(const ast_TypeRef* r)
{
   return ((!r->flags.is_user && (r->flags.num_ptrs == 0)) && (ast_TypeRef_getBuiltinKind(r) == ast_BuiltinKind_Void));
}

static _Bool ast_TypeRef_isConstCharPtr(const ast_TypeRef* r)
{
   return ((((r->flags.is_const && !r->flags.is_user) && (r->flags.num_ptrs == 1)) && (r->flags.num_arrays == 0)) && (ast_TypeRef_getBuiltinKind(r) == ast_BuiltinKind_Char));
}

static _Bool ast_TypeRef_isU32(const ast_TypeRef* r)
{
   return (((!r->flags.is_user && (r->flags.num_ptrs == 0)) && (r->flags.num_arrays == 0)) && (ast_TypeRef_getBuiltinKind(r) == ast_BuiltinKind_UInt32));
}

static _Bool ast_TypeRef_hasPrefix(const ast_TypeRef* r)
{
   return r->flags.has_prefix;
}

static _Bool ast_TypeRef_isIncrArray(const ast_TypeRef* r)
{
   return r->flags.incr_array;
}

static _Bool ast_TypeRef_isPointerTo(const ast_TypeRef* r, uint32_t ptr_idx)
{
   if (((r->dest != ptr_idx) || (ptr_idx == 0))) return false;

   return ((((r->flags.num_ptrs == 1) && (r->flags.num_arrays == 0)) && r->flags.is_user));
}

static ast_BuiltinKind ast_TypeRef_getBuiltinKind(const ast_TypeRef* r)
{
   return ((ast_BuiltinKind)(r->flags.builtin_kind));
}

static src_loc_SrcLoc ast_TypeRef_getLoc(const ast_TypeRef* r)
{
   if (ast_TypeRef_isUser(r)) {
      if (ast_TypeRef_hasPrefix(r)) return r->refs[1].loc;
      else return r->refs[0].loc;

   }
   return r->loc;
}

static uint32_t ast_TypeRef_getNumPointers(const ast_TypeRef* r)
{
   return r->flags.num_ptrs;
}

static const ast_Ref* ast_TypeRef_getUser(const ast_TypeRef* r)
{
   if (r->flags.is_user) return &r->refs[0];

   return NULL;
}

static const ast_Decl* ast_TypeRef_getUserDecl(const ast_TypeRef* r)
{
   if (r->flags.is_user) return r->refs[0].decl;

   return NULL;
}

static const ast_Ref* ast_TypeRef_getPrefix(const ast_TypeRef* r)
{
   if (r->flags.has_prefix) return &r->refs[1];

   return NULL;
}

static void ast_TypeRef_setPrefix(ast_TypeRef* r, ast_Decl* d)
{
   r->refs[1].decl = d;
}

static void ast_TypeRef_setUser(ast_TypeRef* r, ast_Decl* d)
{
   r->refs[0].decl = d;
}

static uint32_t ast_TypeRef_getNumArrays(const ast_TypeRef* r)
{
   return r->flags.num_arrays;
}

static ast_Expr* ast_TypeRef_getArray(const ast_TypeRef* r, uint32_t idx)
{
   const uint32_t numrefs = (r->flags.is_user + r->flags.has_prefix);
   const uint8_t* ptr = (((uint8_t*)(r->refs)) + (numrefs * 16));
   ast_Expr** arrays = ((ast_Expr**)(ptr));
   return arrays[idx];
}

static ast_Expr** ast_TypeRef_getArray2(ast_TypeRef* r, uint32_t idx)
{
   const uint32_t numrefs = (r->flags.is_user + r->flags.has_prefix);
   const uint8_t* ptr = (((uint8_t*)(r->refs)) + (numrefs * 16));
   ast_Expr** arrays = ((ast_Expr**)(ptr));
   return &arrays[idx];
}

static void ast_TypeRef_printLiteral(const ast_TypeRef* r, string_buffer_Buf* out, _Bool print_prefix, _Bool decay)
{
   if (ast_TypeRef_isConst(r)) string_buffer_Buf_add(out, "const ");
   if (ast_TypeRef_isVolatile(r)) string_buffer_Buf_add(out, "volatile ");
   if (r->flags.is_user) {
      ast_Decl* d = r->refs[0].decl;
      (d) || c2_assert("ast/type_ref.c2", 336, "ast.TypeRef.printLiteral", "d");
      if (print_prefix) {
         string_buffer_Buf_add(out, ast_Decl_getFullName(d));
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
   } else {
      string_buffer_Buf_add(out, ast_builtinType_names[r->flags.builtin_kind]);
   }
   for (uint32_t i = 0; (i < r->flags.num_ptrs); i++) string_buffer_Buf_add1(out, '*');
   if (r->flags.incr_array) string_buffer_Buf_add(out, "*");
   if (decay) {
      for (uint32_t i = 0; (i < r->flags.num_arrays); i++) {
         string_buffer_Buf_add(out, "*");
      }
   } else {
      for (uint32_t i = 0; (i < r->flags.num_arrays); i++) {
         string_buffer_Buf_add1(out, '[');
         const ast_Expr* a = ast_TypeRef_getArray(r, i);
         if (a) ast_Expr_printLiteral(a, out);
         string_buffer_Buf_add1(out, ']');
      }
   }
}

static void ast_TypeRef_printLiteral2(const ast_TypeRef* r, string_buffer_Buf* out, _Bool print_prefix, ast_ExprPrinter print_expr, void* arg)
{
   if (ast_TypeRef_isConst(r)) string_buffer_Buf_add(out, "const ");
   if (ast_TypeRef_isVolatile(r)) string_buffer_Buf_add(out, "volatile ");
   if (r->flags.is_user) {
      ast_Decl* d = r->refs[0].decl;
      (d) || c2_assert("ast/type_ref.c2", 376, "ast.TypeRef.printLiteral2", "d");
      if (print_prefix) {
         string_buffer_Buf_add(out, ast_Decl_getFullName(d));
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
   } else {
      string_buffer_Buf_add(out, ast_builtinType_names[r->flags.builtin_kind]);
   }
   for (uint32_t i = 0; (i < r->flags.num_ptrs); i++) string_buffer_Buf_add1(out, '*');
   if (r->flags.incr_array) string_buffer_Buf_add(out, "*");
   for (uint32_t i = 0; (i < r->flags.num_arrays); i++) {
      string_buffer_Buf_add1(out, '[');
      const ast_Expr* a = ast_TypeRef_getArray(r, i);
      if (a) print_expr(arg, a, out);
      string_buffer_Buf_add1(out, ']');
   }
}

static void ast_TypeRef_print(const ast_TypeRef* r, string_buffer_Buf* out, _Bool filled)
{
   string_buffer_Buf_color(out, ast_col_Error);
   if (ast_TypeRef_isConst(r)) string_buffer_Buf_add(out, "const ");
   if (ast_TypeRef_isVolatile(r)) string_buffer_Buf_add(out, "volatile ");
   if (r->flags.is_user) {
      if (r->flags.has_prefix) {
         string_buffer_Buf_add(out, ast_idx2name(r->refs[1].name_idx));
         string_buffer_Buf_add1(out, '.');
      }
      string_buffer_Buf_add(out, ast_idx2name(r->refs[0].name_idx));
   } else {
      string_buffer_Buf_add(out, ast_builtinType_names[r->flags.builtin_kind]);
   }
   for (uint32_t i = 0; (i < r->flags.num_ptrs); i++) string_buffer_Buf_add1(out, '*');
   if (r->flags.incr_array) {
      string_buffer_Buf_add(out, "[+]");
   }
   if (filled) {
      for (uint32_t i = 0; (i < r->flags.num_arrays); i++) {
         string_buffer_Buf_add1(out, '[');
         const ast_Expr* a = ast_TypeRef_getArray(r, i);
         if (a) ast_Expr_printLiteral(a, out);
         string_buffer_Buf_add1(out, ']');
      }
   }
}

static void ast_TypeRef_dump(const ast_TypeRef* r)
{
   string_buffer_Buf* out = string_buffer_create(128, ast_useColor(), 2);
   ast_TypeRef_print(r, out, true);
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ast_TypeRef_dump_full(const ast_TypeRef* r)
{
   string_buffer_Buf* out = string_buffer_create(1024, ast_useColor(), 2);
   string_buffer_Buf_add(out, "TypeRef:\n");
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_add(out, "flags:");
   if (r->flags.is_const) string_buffer_Buf_add(out, " const");
   string_buffer_Buf_print(out, " ptrs=%u", r->flags.num_ptrs);
   string_buffer_Buf_print(out, " user=%u", r->flags.is_user);
   string_buffer_Buf_print(out, " has_prefix=%u", r->flags.has_prefix);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_print(out, "dest %u\n", r->dest);
   uint32_t num_refs = 0;
   if (r->flags.is_user) num_refs++;
   if (r->flags.has_prefix) num_refs++;
   for (uint32_t i = 0; (i < num_refs); i++) {
      string_buffer_Buf_indent(out, 1);
      const ast_Ref* ref = &r->refs[i];
      string_buffer_Buf_print(out, "ref[%u] loc %u  name_idx %u  decl %p\n", i, ref->loc, ref->name_idx, ref->decl);
   }
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static const char* ast_TypeRef_diagName(const ast_TypeRef* r)
{
   static char result[128];
   string_buffer_Buf* out = string_buffer_create_static(128, false, result);
   ast_TypeRef_print(r, out, true);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
   return result;
}

static void ast_ArrayValueList_init(ast_ArrayValueList* l, uint32_t initial_size)
{
   l->count = 0;
   l->capacity = initial_size;
   l->values = NULL;
   if (initial_size) {
      l->values = malloc((l->capacity * 8));
   }
}

static void ast_ArrayValueList_free(ast_ArrayValueList* l)
{
   if (l->values) free(l->values);
}

static void ast_ArrayValueList_add(ast_ArrayValueList* l, ast_ArrayValue* v)
{
   if ((l->count >= l->capacity)) {
      l->capacity += 4;
      void* values2 = malloc((l->capacity * 8));
      void* old = l->values;
      if (old) {
         memcpy(values2, old, (l->count * 8));
         free(old);
      }
      l->values = values2;
   }
   l->values[l->count] = v;
   l->count++;
}

static uint32_t ast_ArrayValueList_getCount(const ast_ArrayValueList* l)
{
   return l->count;
}

static ast_ArrayValue** ast_ArrayValueList_get(ast_ArrayValueList* l)
{
   return l->values;
}

static ast_AST* ast_AST_create(string_pool_Pool* auxPool, uint32_t name, ast_Module* mod, _Bool is_generated)
{
   ast_AST* a = calloc(1, 208);
   a->mod = mod;
   a->auxPool = auxPool;
   a->name = name;
   a->idx = ast_addAST(a);
   a->is_generated = is_generated;
   ast_ImportDeclList_init(&a->imports);
   ast_DeclList_init(&a->types);
   ast_DeclList_init(&a->variables);
   ast_FunctionDeclList_init(&a->functions);
   ast_StaticAssertList_init(&a->static_asserts, 0);
   ast_ArrayValueList_init(&a->array_values, 0);
   return a;
}

static void ast_AST_free(ast_AST* a)
{
   ast_ImportDeclList_free(&a->imports);
   ast_DeclList_free(&a->types);
   ast_DeclList_free(&a->variables);
   ast_FunctionDeclList_free(&a->functions);
   ast_StaticAssertList_free(&a->static_asserts);
   ast_ArrayValueList_free(&a->array_values);
   if (a->attrs) attr_table_Table_free(a->attrs);
   free(a);
}

static const char* ast_AST_getFilename(const ast_AST* a)
{
   return string_pool_Pool_idx2str(a->auxPool, a->name);
}

static uint32_t ast_AST_getIdx(const ast_AST* a)
{
   return a->idx;
}

static const char* ast_AST_getName(const ast_AST* a)
{
   return ast_Module_getName(a->mod);
}

static uint32_t ast_AST_getNameIdx(const ast_AST* a)
{
   return ast_Module_getNameIdx(a->mod);
}

static src_loc_SrcLoc ast_AST_getLoc(const ast_AST* a)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   ast_Decl* d = ((ast_Decl*)(imports[0]));
   return ast_Decl_getLoc(d);
}

static void ast_AST_setPtr(ast_AST* a, void* ptr)
{
   a->ptr = ptr;
}

static void* ast_AST_getPtr(const ast_AST* a)
{
   return a->ptr;
}

static ast_Module* ast_AST_getMod(const ast_AST* a)
{
   return a->mod;
}

static void ast_AST_addImport(ast_AST* a, ast_ImportDecl* d)
{
   ast_ImportDeclList_add(&a->imports, d);
}

static ast_ImportDecl* ast_AST_findImport(const ast_AST* a, uint32_t name)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 1; (i < ast_ImportDeclList_size(&a->imports)); i++) {
      ast_ImportDecl* d = imports[i];
      if ((ast_Decl_getNameIdx(ast_ImportDecl_asDecl(d)) == name)) return d;

   }
   return NULL;
}

static _Bool ast_AST_isGenerated(const ast_AST* a)
{
   return a->is_generated;
}

static void ast_AST_addFunc(ast_AST* a, ast_FunctionDecl* d)
{
   ast_FunctionDeclList_add(&a->functions, d);
}

static void ast_AST_addTypeDecl(ast_AST* a, ast_Decl* d)
{
   ast_DeclList_add(&a->types, d);
}

static void ast_AST_addVarDecl(ast_AST* a, ast_Decl* d)
{
   ast_DeclList_add(&a->variables, d);
}

static void ast_AST_addStaticAssert(ast_AST* a, ast_StaticAssert* s)
{
   ast_StaticAssertList_add(&a->static_asserts, s);
}

static void ast_AST_addArrayValue(ast_AST* a, ast_ArrayValue* v)
{
   ast_ArrayValueList_add(&a->array_values, v);
}

static void ast_AST_visitImports(const ast_AST* a, ast_ImportVisitor visitor, void* arg)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 1; (i < ast_ImportDeclList_size(&a->imports)); i++) {
      visitor(arg, imports[i]);
   }
}

static const ast_ImportDeclList* ast_AST_getImports(const ast_AST* a)
{
   return &a->imports;
}

static void ast_AST_visitArrayValues(ast_AST* a, ast_ArrayValueVisitor visitor, void* arg)
{
   ast_ArrayValue** values = ast_ArrayValueList_get(&a->array_values);
   for (uint32_t i = 0; (i < ast_ArrayValueList_getCount(&a->array_values)); i++) {
      visitor(arg, values[i]);
   }
}

static void ast_AST_visitTypeFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg)
{
   ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; (i < ast_FunctionDeclList_size(&a->functions)); i++) {
      ast_FunctionDecl* d = functions[i];
      if (ast_FunctionDecl_hasPrefix(d)) visitor(arg, d);
   }
}

static void ast_AST_visitFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg)
{
   ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; (i < ast_FunctionDeclList_size(&a->functions)); i++) {
      ast_FunctionDecl* d = functions[i];
      visitor(arg, d);
   }
}

static void ast_AST_visitTypeDecls(const ast_AST* a, ast_TypeDeclVisitor visitor, void* arg)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->types)); i++) {
      visitor(arg, types[i]);
   }
}

static void ast_AST_visitVarDecls(const ast_AST* a, ast_VarDeclVisitor visitor, void* arg)
{
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->variables)); i++) {
      visitor(arg, ((ast_VarDecl*)(variables[i])));
   }
}

static void ast_AST_visitStaticAsserts(ast_AST* a, ast_StaticAssertVisitor visitor, void* arg)
{
   ast_StaticAssert** asserts = ast_StaticAssertList_get(&a->static_asserts);
   for (uint32_t i = 0; (i < ast_StaticAssertList_getCount(&a->static_asserts)); i++) {
      visitor(arg, asserts[i]);
   }
}

static void ast_AST_visitDecls(const ast_AST* a, ast_DeclVisitor visitor, void* arg)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 0; (i < ast_ImportDeclList_size(&a->imports)); i++) {
      visitor(arg, ((ast_Decl*)(imports[i])));
   }
   ast_AST_visitDeclsWithoutImports(a, visitor, arg);
}

static void ast_AST_visitDeclsWithoutImports(const ast_AST* a, ast_DeclVisitor visitor, void* arg)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->types)); i++) {
      visitor(arg, types[i]);
   }
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->variables)); i++) {
      visitor(arg, variables[i]);
   }
   ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; (i < ast_FunctionDeclList_size(&a->functions)); i++) {
      ast_FunctionDecl* d = functions[i];
      visitor(arg, ((ast_Decl*)(d)));
   }
}

static ast_Decl* ast_AST_findType(const ast_AST* a, uint32_t name_idx)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->types)); i++) {
      ast_Decl* d = types[i];
      if ((ast_Decl_getNameIdx(d) == name_idx)) return d;

   }
   return NULL;
}

static void ast_AST_storeAttr(ast_AST* a, ast_Decl* d, attr_AttrKind kind, const attr_Value* value)
{
   if (!a->attrs) a->attrs = attr_table_create();
   attr_table_Table_add(a->attrs, d, kind, value);
}

static const attr_Value* ast_AST_getAttr(const ast_AST* a, const ast_Decl* d, attr_AttrKind kind)
{
   if (a->attrs) return attr_table_Table_find(a->attrs, d, kind);

   return NULL;
}

static void ast_AST_print(const ast_AST* a, string_buffer_Buf* out, _Bool show_funcs)
{
   string_buffer_Buf_print(out, "---- AST %s ----\n", ast_AST_getFilename(a));
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 1; (i < ast_ImportDeclList_size(&a->imports)); i++) {
      ast_ImportDecl_print(imports[i], out, 0);
   }
   if ((ast_ImportDeclList_size(&a->imports) > 1)) string_buffer_Buf_newline(out);
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->types)); i++) {
      ast_Decl_print(types[i], out, 0);
      string_buffer_Buf_newline(out);
   }
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->variables)); i++) {
      ast_Decl_print(variables[i], out, 0);
      string_buffer_Buf_newline(out);
   }
   if (show_funcs) {
      ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
      for (uint32_t i = 0; (i < ast_FunctionDeclList_size(&a->functions)); i++) {
         ast_FunctionDecl_print(functions[i], out, 0);
         string_buffer_Buf_newline(out);
      }
   }
   for (uint32_t i = 0; (i < ast_StaticAssertList_getCount(&a->static_asserts)); i++) {
      ast_StaticAssert_print(ast_StaticAssertList_getAt(&a->static_asserts, i), out, 0);
      string_buffer_Buf_newline(out);
   }
}

static void ast_AST_setExported(ast_AST* a)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->types)); i++) {
      ast_Decl_setExportedIfPublic(types[i]);
   }
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; (i < ast_DeclList_size(&a->variables)); i++) {
      ast_Decl_setExportedIfPublic(variables[i]);
   }
   ast_Decl** functions = ((ast_Decl**)(ast_FunctionDeclList_getDecls(&a->functions)));
   for (uint32_t i = 0; (i < ast_FunctionDeclList_size(&a->functions)); i++) {
      ast_Decl_setExportedIfPublic(functions[i]);
   }
}

static void ast_DeclList_init(ast_DeclList* l)
{
   l->count = 0;
   l->capacity = 4;
   l->decls = l->stash;
}

static void ast_DeclList_free(ast_DeclList* l)
{
   if ((l->capacity > 4)) free(l->decls);
   l->count = 0;
   l->capacity = 0;
}

static void ast_DeclList_add(ast_DeclList* l, ast_Decl* d)
{
   if ((l->count >= l->capacity)) {
      if ((l->capacity == 0)) {
         l->capacity = 4;
         l->decls = l->stash;
      } else {
         uint32_t capacity2 = ((l->capacity + (l->capacity / 2)) + 2);
         void* decls2 = malloc((capacity2 * 8));
         memcpy(decls2, l->decls, (l->count * 8));
         if ((l->capacity > 4)) free(l->decls);
         l->capacity = capacity2;
         l->decls = decls2;
      }
   }
   l->decls[l->count] = d;
   l->count++;
}

static void ast_DeclList_clear(ast_DeclList* l)
{
   l->count = 0;
}

static uint32_t ast_DeclList_size(const ast_DeclList* l)
{
   return l->count;
}

static ast_Decl* ast_DeclList_get(const ast_DeclList* l, uint32_t idx)
{
   return l->decls[idx];
}

static ast_Decl** ast_DeclList_getDecls(const ast_DeclList* l)
{
   return l->decls;
}

static void ast_ExprList_init(ast_ExprList* l)
{
   l->count = 0;
   l->capacity = 4;
   l->exprs = l->stash;
}

static void ast_ExprList_free(ast_ExprList* l)
{
   if ((l->capacity > 4)) free(l->exprs);
   l->count = 0;
   l->capacity = 0;
}

static void ast_ExprList_add(ast_ExprList* l, ast_Expr* d)
{
   if ((l->count >= l->capacity)) {
      if ((l->capacity == 0)) {
         l->capacity = 4;
         l->exprs = l->stash;
      } else {
         uint32_t capacity2 = ((l->capacity + (l->capacity / 2)) + 2);
         void* exprs2 = malloc((capacity2 * 8));
         memcpy(exprs2, l->exprs, (l->count * 8));
         if ((l->capacity > 4)) free(l->exprs);
         l->capacity = capacity2;
         l->exprs = exprs2;
      }
   }
   l->exprs[l->count] = d;
   l->count++;
}

static uint32_t ast_ExprList_size(const ast_ExprList* l)
{
   return l->count;
}

static ast_Expr** ast_ExprList_getExprs(const ast_ExprList* l)
{
   return l->exprs;
}

static void ast_FunctionDeclList_init(ast_FunctionDeclList* l)
{
   memset(l, 0, 16);
}

static void ast_FunctionDeclList_free(ast_FunctionDeclList* l)
{
   if (l->decls) free(l->decls);
}

static void ast_FunctionDeclList_clear(ast_FunctionDeclList* l)
{
   l->count = 0;
}

static void ast_FunctionDeclList_add(ast_FunctionDeclList* l, ast_FunctionDecl* d)
{
   if ((l->count >= l->capacity)) {
      l->capacity = ((l->capacity == 0)) ? 4 : (l->capacity * 2);
      void* decls2 = malloc((l->capacity * 8));
      void* old = l->decls;
      if (old) {
         memcpy(decls2, old, (l->count * 8));
         free(old);
      }
      l->decls = decls2;
   }
   l->decls[l->count] = d;
   l->count++;
}

static uint32_t ast_FunctionDeclList_size(const ast_FunctionDeclList* l)
{
   return l->count;
}

static ast_FunctionDecl** ast_FunctionDeclList_getDecls(const ast_FunctionDeclList* l)
{
   return l->decls;
}

static ast_FunctionDecl* ast_FunctionDeclList_find(const ast_FunctionDeclList* l, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      ast_FunctionDecl* fd = l->decls[i];
      if ((ast_Decl_getNameIdx(ast_FunctionDecl_asDecl(fd)) == name_idx)) return fd;

   }
   return NULL;
}

static void ast_ImportDeclList_init(ast_ImportDeclList* l)
{
   memset(l, 0, 16);
}

static void ast_ImportDeclList_free(ast_ImportDeclList* l)
{
   if (l->decls) free(l->decls);
}

static void ast_ImportDeclList_add(ast_ImportDeclList* l, ast_ImportDecl* d)
{
   if ((l->count >= l->capacity)) {
      l->capacity += 4;
      void* decls2 = malloc((l->capacity * 8));
      void* old = l->decls;
      if (old) {
         memcpy(decls2, old, (l->count * 8));
         free(old);
      }
      l->decls = decls2;
   }
   l->decls[l->count] = d;
   l->count++;
}

static uint32_t ast_ImportDeclList_size(const ast_ImportDeclList* l)
{
   return l->count;
}

static ast_ImportDecl** ast_ImportDeclList_getDecls(const ast_ImportDeclList* l)
{
   return l->decls;
}

static ast_ImportDecl* ast_ImportDeclList_find(const ast_ImportDeclList* l, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      ast_ImportDecl* d = l->decls[i];
      if ((ast_ImportDecl_getImportNameIdx(d) == name_idx)) return d;

   }
   return NULL;
}

static ast_ImportDecl* ast_ImportDeclList_findAny(const ast_ImportDeclList* l, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      ast_ImportDecl* d = l->decls[i];
      if ((ast_Decl_getNameIdx(ast_ImportDecl_asDecl(d)) == name_idx)) return d;

   }
   return NULL;
}

static void ast_TemplateFunction_init(ast_TemplateFunction* f, const ast_FunctionDecl* fd)
{
   f->fd = fd;
   f->count = 0;
   f->capacity = 0;
   f->instances = NULL;
   ast_TemplateFunction_resize(f, 2);
}

static void ast_TemplateFunction_resize(ast_TemplateFunction* f, uint16_t capacity)
{
   f->capacity = capacity;
   ast_TemplateInstance* inst2 = malloc((capacity * 16));
   if (f->count) {
      memcpy(inst2, f->instances, (f->count * 16));
      free(f->instances);
   }
   f->instances = inst2;
}

static uint16_t ast_TemplateFunction_add(ast_TemplateFunction* f, ast_QualType qt, ast_FunctionDecl* instance)
{
   if ((f->count == f->capacity)) ast_TemplateFunction_resize(f, (f->capacity * 2));
   uint16_t idx = f->count;
   ast_TemplateInstance* ti = &f->instances[idx];
   f->count++;
   ti->qt = qt;
   ti->instance = instance;
   return idx;
}

static ast_FunctionDecl* ast_TemplateFunction_find(const ast_TemplateFunction* f, ast_QualType qt)
{
   for (uint32_t i = 0; (i < f->count); i++) {
      const ast_TemplateInstance* ti = &f->instances[i];
      if ((ti->qt.ptr == qt.ptr)) return ti->instance;

   }
   return NULL;
}

static ast_FunctionDecl* ast_TemplateFunction_get(const ast_TemplateFunction* f, uint32_t idx)
{
   return f->instances[idx].instance;
}

static void ast_InstanceTable_init(ast_InstanceTable* t)
{
   t->count = 0;
   t->capacity = 0;
   t->funcs = NULL;
}

static void ast_InstanceTable_free(ast_InstanceTable* t)
{
   for (uint32_t i = 0; (i < t->count); i++) {
      free(t->funcs[i].instances);
   }
   free(t->funcs);
}

static void ast_InstanceTable_resize(ast_InstanceTable* t, uint32_t capacity)
{
   t->capacity = capacity;
   ast_TemplateFunction* funcs2 = malloc((capacity * 24));
   if (t->count) {
      memcpy(funcs2, t->funcs, (t->count * 24));
      free(t->funcs);
   }
   t->funcs = funcs2;
}

static ast_TemplateFunction* ast_InstanceTable_findFunc(const ast_InstanceTable* t, const ast_FunctionDecl* fd)
{
   for (uint32_t i = 0; (i < t->count); i++) {
      ast_TemplateFunction* fi = &t->funcs[i];
      if ((fi->fd == fd)) return fi;

   }
   return NULL;
}

static ast_FunctionDecl* ast_InstanceTable_find(const ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt)
{
   const ast_TemplateFunction* fi = ast_InstanceTable_findFunc(t, fd);
   if (fi) return ast_TemplateFunction_find(fi, qt);

   return NULL;
}

static ast_FunctionDecl* ast_InstanceTable_get(const ast_InstanceTable* t, const ast_FunctionDecl* fd, uint32_t idx)
{
   const ast_TemplateFunction* fi = ast_InstanceTable_findFunc(t, fd);
   (fi) || c2_assert("ast/instance_table.c2", 120, "ast.InstanceTable.get", "fi");
   return ast_TemplateFunction_get(fi, idx);
}

static uint16_t ast_InstanceTable_add(ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance)
{
   ast_TemplateFunction* fi = ast_InstanceTable_findFunc(t, fd);
   if (!fi) {
      if ((t->count == t->capacity)) {
         if ((t->capacity == 0)) t->capacity = 2;
         ast_InstanceTable_resize(t, (t->capacity * 2));
      }
      fi = &t->funcs[t->count];
      t->count++;
      ast_TemplateFunction_init(fi, fd);
   }
   return ast_TemplateFunction_add(fi, qt, instance);
}

static void ast_Instantiator_on_opaque(ast_Instantiator* inst, src_loc_SrcLoc loc, ast_Decl* decl)
{
   inst->on_error(inst->arg, loc, decl);
}

static ast_Module* ast_Module_create(ast_context_Context* c, uint32_t name_idx, _Bool is_external, _Bool is_direct)
{
   ast_Module* m = calloc(1, 88);
   m->mt = ast_ModuleType_create(c, m);
   m->name_idx = name_idx;
   m->is_external = is_external;
   m->is_internal = false;
   m->is_direct = is_direct;
   m->is_loaded = false;
   ast_Module_resizeFiles(m, 1);
   ast_SymbolTable_init(&m->symbols, 16);
   ast_InstanceTable_init(&m->instances);
   return m;
}

static void ast_Module_free(ast_Module* m)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_free(m->files[i]);
   }
   free(m->files);
   ast_SymbolTable_free(&m->symbols);
   ast_InstanceTable_free(&m->instances);
   free(m);
}

static void ast_Module_setUsed(ast_Module* m)
{
   m->is_used = true;
}

static _Bool ast_Module_isUsed(const ast_Module* m)
{
   return m->is_used;
}

static void ast_Module_setInternal(ast_Module* m)
{
   m->is_internal = true;
}

static _Bool ast_Module_isInternal(const ast_Module* m)
{
   return m->is_internal;
}

static _Bool ast_Module_isExternal(const ast_Module* m)
{
   return m->is_external;
}

static void ast_Module_setLoaded(ast_Module* m)
{
   m->is_loaded = true;
}

static _Bool ast_Module_isLoaded(const ast_Module* m)
{
   return m->is_loaded;
}

static void ast_Module_setExported(ast_Module* m)
{
   m->is_exported = true;
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_setExported(m->files[i]);
   }
}

static _Bool ast_Module_isExported(const ast_Module* m)
{
   return m->is_exported;
}

static _Bool ast_Module_isDirect(const ast_Module* m)
{
   return m->is_direct;
}

static const ast_SymbolTable* ast_Module_getSymbols(const ast_Module* m)
{
   return &m->symbols;
}

static ast_ModuleType* ast_Module_getType(const ast_Module* m)
{
   return m->mt;
}

static const char* ast_Module_getFirstFilename(const ast_Module* m)
{
   if (m->num_files) return ast_AST_getFilename(m->files[0]);

   return NULL;
}

static void ast_Module_visitASTs(const ast_Module* m, ast_ASTVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      visitor(arg, m->files[i]);
   }
}

static void ast_Module_visitImports(const ast_Module* m, ast_ImportVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitImports(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitArrayValues(const ast_Module* m, ast_ArrayValueVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitArrayValues(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitTypeFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitTypeFunctions(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitFunctions(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitTypeDecls(const ast_Module* m, ast_TypeDeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitTypeDecls(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitVarDecls(const ast_Module* m, ast_VarDeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitVarDecls(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitStaticAsserts(const ast_Module* m, ast_StaticAssertVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitStaticAsserts(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitDecls(const ast_Module* m, ast_DeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitDecls(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitDeclsWithoutImports(const ast_Module* m, ast_DeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_visitDeclsWithoutImports(m->files[i], visitor, arg);
   }
}

static ast_Decl* ast_Module_findType(const ast_Module* m, uint32_t name_idx)
{
   ast_Decl* result = NULL;
   for (uint32_t i = 0; (i < m->num_files); i++) {
      result = ast_AST_findType(m->files[i], name_idx);
      if (result) break;

   }
   return result;
}

static const char* ast_Module_getName(const ast_Module* m)
{
   return ast_idx2name(m->name_idx);
}

static uint32_t ast_Module_getNameIdx(const ast_Module* m)
{
   return m->name_idx;
}

static void ast_Module_resizeFiles(ast_Module* m, uint32_t cap)
{
   m->max_files = cap;
   void* buf = malloc((m->max_files * 8));
   if (m->files) {
      void* old = m->files;
      memcpy(buf, old, (m->num_files * 8));
      free(old);
   }
   m->files = buf;
}

static ast_AST* ast_Module_add(ast_Module* m, string_pool_Pool* auxPool, uint32_t filename, _Bool is_generated)
{
   ast_AST* a = ast_AST_create(auxPool, filename, m, is_generated);
   if ((m->num_files == m->max_files)) ast_Module_resizeFiles(m, (m->max_files * 2));
   m->files[m->num_files] = a;
   m->num_files++;
   return a;
}

static void ast_Module_addSymbol(ast_Module* m, uint32_t name_idx, ast_Decl* d)
{
   ast_SymbolTable_add(&m->symbols, name_idx, d);
}

static ast_Decl* ast_Module_findSymbol(const ast_Module* m, uint32_t name_idx)
{
   return ast_SymbolTable_find(&m->symbols, name_idx);
}

static ast_Decl* ast_Module_findPublicSymbol(const ast_Module* m, uint32_t name_idx)
{
   return ast_SymbolTable_findPublic(&m->symbols, name_idx);
}

static ast_Decl* ast_Module_findPrivateSymbol(const ast_Module* m, uint32_t name_idx)
{
   return ast_SymbolTable_findPrivate(&m->symbols, name_idx);
}

static ast_FunctionDecl* ast_Module_findInstance(const ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt)
{
   return ast_InstanceTable_find(&m->instances, fd, qt);
}

static uint16_t ast_Module_addInstance(ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance)
{
   return ast_InstanceTable_add(&m->instances, fd, qt, instance);
}

static ast_FunctionDecl* ast_Module_getInstance(const ast_Module* m, ast_FunctionDecl* fd, uint32_t idx)
{
   return ast_InstanceTable_get(&m->instances, fd, idx);
}

static void ast_Module_print(const ast_Module* m, string_buffer_Buf* out, _Bool show_funcs)
{
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_print(out, "------ module %s (used %u, exported %u) ------\n", ast_idx2name(m->name_idx), m->is_used, m->is_exported);
   for (uint32_t i = 0; (i < m->num_files); i++) {
      ast_AST_print(m->files[i], out, show_funcs);
   }
}

static void ast_PointerPool_init(ast_PointerPool* p, ast_context_Context* c)
{
   p->count = 1;
   p->capacity = 0;
   p->slots = NULL;
   p->context = c;
   ast_PointerPool_resize(p, 64);
}

static void ast_PointerPool_clear(ast_PointerPool* p)
{
   free(p->slots);
   p->count = 1;
   p->capacity = 0;
   p->slots = NULL;
}

static void ast_PointerPool_resize(ast_PointerPool* p, uint32_t cap)
{
   p->capacity = cap;
   ast_PointerPoolSlot* slots2 = malloc((p->capacity * 32));
   if ((p->count > 1)) {
      memcpy(slots2, p->slots, (p->count * 32));
      free(p->slots);
   }
   p->slots = slots2;
}

static ast_Type* ast_PointerPool_getPointer(ast_PointerPool* p, ast_QualType qt)
{
   ast_Type* t = ast_QualType_getTypeOrNil(&qt);
   (t) || c2_assert("ast/pointer_pool.c2", 70, "ast.PointerPool.getPointer", "t");
   const uint32_t ptr_pool_idx = t->ptr_pool_idx;
   ast_PointerPoolSlot* slot = &p->slots[ptr_pool_idx];
   if ((ptr_pool_idx == 0)) {
      uint32_t slot_idx = p->count;
      if ((slot_idx == p->capacity)) ast_PointerPool_resize(p, (p->capacity * 2));
      slot = &p->slots[slot_idx];
      memset(slot, 0, 32);
      t->ptr_pool_idx = slot_idx;
      p->count++;
   }
   uint32_t quals = ast_QualType_getQuals(&qt);
   ast_Type* ptr = slot->ptrs[quals];
   if (ptr) return ptr;

   ptr = ((ast_Type*)(ast_PointerType_create(p->context, qt)));
   slot->ptrs[quals] = ptr;
   return ptr;
}

static void ast_StaticAssertList_init(ast_StaticAssertList* l, uint32_t initial_size)
{
   l->count = 0;
   l->capacity = initial_size;
   l->asserts = NULL;
   if (initial_size) {
      l->asserts = malloc((l->capacity * 8));
   }
}

static void ast_StaticAssertList_free(ast_StaticAssertList* l)
{
   if (l->asserts) free(l->asserts);
}

static void ast_StaticAssertList_add(ast_StaticAssertList* l, ast_StaticAssert* v)
{
   if ((l->count >= l->capacity)) {
      l->capacity += 4;
      void* asserts2 = malloc((l->capacity * 8));
      void* old = l->asserts;
      if (old) {
         memcpy(asserts2, old, (l->count * 8));
         free(old);
      }
      l->asserts = asserts2;
   }
   l->asserts[l->count] = v;
   l->count++;
}

static uint32_t ast_StaticAssertList_getCount(const ast_StaticAssertList* l)
{
   return l->count;
}

static ast_StaticAssert* ast_StaticAssertList_getAt(const ast_StaticAssertList* l, uint32_t idx)
{
   return l->asserts[idx];
}

static ast_StaticAssert** ast_StaticAssertList_get(ast_StaticAssertList* l)
{
   return l->asserts;
}

static void ast_Stats_reset(ast_Stats* s)
{
   memset(s, 0, 456);
}

static void ast_Stats_addType(ast_TypeKind kind, uint32_t size)
{
   ast_globals->stats.types[kind].count++;
   ast_globals->stats.types[kind].size += size;
}

static void ast_Stats_addExpr(ast_ExprKind kind, uint32_t size)
{
   ast_globals->stats.exprs[kind].count++;
   ast_globals->stats.exprs[kind].size += size;
}

static void ast_Stats_addStmt(ast_StmtKind kind, uint32_t size)
{
   ast_globals->stats.stmts[kind].count++;
   ast_globals->stats.stmts[kind].size += size;
}

static void ast_Stats_addDecl(ast_DeclKind kind, uint32_t size)
{
   ast_globals->stats.decls[kind].count++;
   ast_globals->stats.decls[kind].size += size;
}

static void ast_Stats_addArrayValue(uint32_t size)
{
   ast_globals->stats.others[0].count++;
   ast_globals->stats.others[0].size += size;
}

static void ast_Stats_addStaticAssert(uint32_t size)
{
   ast_globals->stats.others[1].count++;
   ast_globals->stats.others[1].size += size;
}

static void ast_Stats_addSwitchCase(uint32_t size)
{
   ast_globals->stats.others[2].count++;
   ast_globals->stats.others[2].size += size;
}

static void ast_Stats_dump(const ast_Stats* s)
{
   printf("---------------------------------------\n");
   printf("--- Types ---\n");
   uint32_t typesTotal = 0;
   uint32_t typesCount = 0;
   for (uint32_t i = 0; (i <= 7); i++) {
      const ast_Stat* ss = &s->types[i];
      printf("  %20s  %6u  %7u\n", ast_typeKind_names[i], ss->count, ss->size);
      typesCount += ss->count;
      typesTotal += ss->size;
   }
   printf("  %20s  %6u  %7u\n", "total", typesCount, typesTotal);
   printf("--- Expressions ---\n");
   uint32_t exprTotal = 0;
   uint32_t exprCount = 0;
   for (uint32_t i = 0; (i <= 22); i++) {
      const ast_Stat* ss = &s->exprs[i];
      printf("  %20s  %6u  %7u\n", ast_exprKind_names[i], ss->count, ss->size);
      exprCount += ss->count;
      exprTotal += ss->size;
   }
   printf("  %20s  %6u  %7u\n", "total", exprCount, exprTotal);
   printf("--- Statements ---\n");
   uint32_t stmtTotal = 0;
   uint32_t stmtCount = 0;
   for (uint32_t i = 0; (i <= 14); i++) {
      const ast_Stat* ss = &s->stmts[i];
      printf("  %20s  %6u  %7u\n", ast_stmtKind_names[i], ss->count, ss->size);
      stmtCount += ss->count;
      stmtTotal += ss->size;
   }
   printf("  %20s  %6u  %7u\n", "total", stmtCount, stmtTotal);
   printf("--- Decls ---\n");
   uint32_t declTotal = 0;
   uint32_t declCount = 0;
   for (uint32_t i = 0; (i <= 7); i++) {
      const ast_Stat* ss = &s->decls[i];
      printf("  %20s  %6u  %7u\n", ast_declKind_names[i], ss->count, ss->size);
      declCount += ss->count;
      declTotal += ss->size;
   }
   printf("  %20s  %6u  %7u\n", "total", declCount, declTotal);
   printf("--- Other ---\n");
   uint32_t otherTotal = 0;
   uint32_t otherCount = 0;
   for (uint32_t i = 0; (i < 3); i++) {
      const ast_Stat* ss = &s->others[i];
      printf("  %20s  %6u  %7u\n", ast_other_names[i], ss->count, ss->size);
      otherCount += ss->count;
      otherTotal += ss->size;
   }
   printf("  %20s  %6u  %7u\n", "total", otherCount, otherTotal);
   printf("--- Total ---\n");
   uint32_t totalCount = ((((typesCount + exprCount) + stmtCount) + declCount) + otherCount);
   uint32_t totalSize = ((((typesTotal + exprTotal) + stmtTotal) + declTotal) + otherTotal);
   printf("  %20s  %6u  %7u\n", "objects", totalCount, totalSize);
   printf("---------------------------------------\n");
}

static void ast_StringTypePool_init(ast_StringTypePool* p, ast_context_Context* c)
{
   p->count = 0;
   p->capacity = 0;
   p->slots = NULL;
   p->context = c;
   ast_StringTypePool_resize(p, 8);
}

static void ast_StringTypePool_clear(ast_StringTypePool* p)
{
   free(p->slots);
   p->count = 0;
   p->capacity = 0;
   p->slots = NULL;
}

static void ast_StringTypePool_resize(ast_StringTypePool* p, uint32_t cap)
{
   p->capacity = cap;
   ast_StringTypeSlot* slots2 = malloc((p->capacity * 16));
   if (p->count) {
      memcpy(slots2, p->slots, (p->count * 16));
      free(p->slots);
   }
   p->slots = slots2;
}

static ast_QualType ast_StringTypePool_get(ast_StringTypePool* p, uint32_t len)
{
   for (uint32_t i = 0; (i < p->count); i++) {
      ast_StringTypeSlot* s = &p->slots[i];
      if ((s->len == len)) return ast_QualType_create(s->type_);

   }
   if ((p->count == p->capacity)) ast_StringTypePool_resize(p, (p->capacity * 2));
   ast_Type* t = ((ast_Type*)(ast_ArrayType_create(p->context, ast_builtins[ast_BuiltinKind_Char], true, len)));
   uint32_t idx = p->count;
   p->slots[idx].len = len;
   p->slots[idx].type_ = t;
   p->count++;
   ast_QualType qt = ast_QualType_create(t);
   ast_Type_setCanonicalType(t, qt);
   return qt;
}

static void ast_SymbolTable_init(ast_SymbolTable* t, uint32_t initial)
{
   t->num_public = 0;
   t->num_private = 0;
   t->capacity = 0;
   ast_SymbolTable_resize(t, initial);
}

static void ast_SymbolTable_free(ast_SymbolTable* t)
{
   free(t->decls);
   free(t->symbols);
}

static uint32_t ast_SymbolTable_size(const ast_SymbolTable* t)
{
   return (t->num_public + t->num_private);
}

static ast_Decl** ast_SymbolTable_getDecls(const ast_SymbolTable* t)
{
   return t->decls;
}

static void ast_SymbolTable_resize(ast_SymbolTable* t, uint32_t capacity)
{
   uint32_t* symbols = malloc((capacity * 4));
   ast_Decl** decls = malloc((capacity * 8));
   t->capacity = capacity;
   uint32_t count = (t->num_public + t->num_private);
   if (count) {
      memcpy(symbols, t->symbols, (count * 4));
      memcpy(decls, t->decls, (count * 8));
      free(t->decls);
      free(t->symbols);
   }
   t->symbols = symbols;
   t->decls = decls;
}

static void ast_SymbolTable_add(ast_SymbolTable* t, uint32_t name_idx, ast_Decl* d)
{
   uint32_t count = (t->num_public + t->num_private);
   if ((count == t->capacity)) ast_SymbolTable_resize(t, (t->capacity * 2));
   if (ast_Decl_isPublic(d)) {
      if ((t->num_private != 0)) {
         t->symbols[count] = t->symbols[t->num_public];
         t->decls[count] = t->decls[t->num_public];
      }
      t->symbols[t->num_public] = name_idx;
      t->decls[t->num_public] = d;
      t->num_public++;
   } else {
      t->symbols[count] = name_idx;
      t->decls[count] = d;
      t->num_private++;
   }
}

static ast_Decl* ast_SymbolTable_find(const ast_SymbolTable* t, uint32_t name_idx)
{
   uint32_t count = (t->num_public + t->num_private);
   for (uint32_t i = 0; (i < count); i++) {
      if ((t->symbols[i] == name_idx)) return t->decls[i];

   }
   return NULL;
}

static ast_Decl* ast_SymbolTable_findPublic(const ast_SymbolTable* t, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < t->num_public); i++) {
      if ((t->symbols[i] == name_idx)) return t->decls[i];

   }
   return NULL;
}

static ast_Decl* ast_SymbolTable_findPrivate(const ast_SymbolTable* t, uint32_t name_idx)
{
   uint32_t count = (t->num_public + t->num_private);
   for (uint32_t i = t->num_public; (i < count); i++) {
      if ((t->symbols[i] == name_idx)) return t->decls[i];

   }
   return NULL;
}

static void ast_SymbolTable_print(const ast_SymbolTable* t, string_buffer_Buf* out)
{
   uint32_t count = (t->num_public + t->num_private);
   for (uint32_t i = 0; (i < count); i++) {
      const ast_Decl* d = t->decls[i];
      const char* col = ast_Decl_isUsed(d) ? color_Normal : color_Grey;
      string_buffer_Buf_color(out, col);
      const char* name = ast_idx2name(t->symbols[i]);
      string_buffer_Buf_print(out, "    %s", name);
      if (ast_Decl_isFunction(d)) string_buffer_Buf_add(out, "()");
      if (ast_Decl_isPublic(d)) {
         string_buffer_Buf_color(out, color_Yellow);
         string_buffer_Buf_add(out, " public");
      }
      string_buffer_Buf_newline(out);
      if (ast_Decl_isStructType(d)) {
         ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
         const ast_FunctionDecl** fds = ast_StructTypeDecl_getStructFunctions(std);
         for (uint32_t j = 0; (j < ast_StructTypeDecl_getNumStructFunctions(std)); j++) {
            ast_Decl* fd = ((ast_Decl*)(fds[j]));
            col = ast_Decl_isUsed(fd) ? color_Normal : color_Grey;
            string_buffer_Buf_color(out, col);
            string_buffer_Buf_indent(out, 6);
            string_buffer_Buf_print(out, "%s.%s()", name, ast_Decl_getName(fd));
            if (ast_Decl_isPublic(fd)) {
               string_buffer_Buf_color(out, color_Yellow);
               string_buffer_Buf_add(out, " public");
            }
            string_buffer_Buf_newline(out);
         }
      }
   }
}

static void ast_SymbolTable_dump(const ast_SymbolTable* t)
{
   string_buffer_Buf* out = string_buffer_create(4096, ast_useColor(), 2);
   uint32_t count = (t->num_public + t->num_private);
   string_buffer_Buf_add(out, "Symbols:\n");
   for (uint32_t i = 0; (i < count); i++) {
      uint32_t name_idx = t->symbols[i];
      const char* name = ast_idx2name(name_idx);
      string_buffer_Buf_print(out, "  [%2u]  %6u  %s\n", i, name_idx, name);
   }
   fputs(string_buffer_Buf_data(out), stdout);
   string_buffer_Buf_free(out);
}

static ast_Globals* ast_getGlobals(void)
{
   return ast_globals;
}

static void ast_setGlobals(ast_Globals* g)
{
   ast_globals = g;
   attr_initialize(g->attr_name_indexes);
}

static void ast_initialize(ast_context_Context* c, string_pool_Pool* astPool, uint32_t wordsize, _Bool use_color)
{
   ast_globals = malloc(816);
   ast_PointerPool_init(&ast_globals->pointers, c);
   ast_StringTypePool_init(&ast_globals->string_types, c);
   ast_globals->wordsize = wordsize;
   ast_globals->use_color = use_color;
   ast_globals->names_pool = astPool;
   ast_globals->ast_count = 1;
   ast_globals->ast_capacity = 0;
   ast_globals->ast_list = NULL;
   ast_Stats_reset(&ast_globals->stats);
   ast_builtins = malloc((((15 + 1)) * 8));
   for (uint32_t i = 0; (i < 15); i++) {
      ast_QualType_set(&ast_builtins[i], ((ast_Type*)(ast_BuiltinType_create(c, ((ast_BuiltinKind)(i))))));
   }
   ast_Type* void_ptr = ast_getPointerType(ast_builtins[ast_BuiltinKind_Void]);
   ast_QualType_set(&ast_builtins[15], void_ptr);
   ast_Type_setCanonicalType(void_ptr, ast_builtins[15]);
   memcpy(ast_globals->builtinType_sizes, ast_BuiltinType_default_sizes, 60);
   ast_globals->builtinType_sizes[ast_BuiltinKind_ISize] = wordsize;
   ast_globals->builtinType_sizes[ast_BuiltinKind_USize] = wordsize;
   memcpy(ast_globals->builtinType_width, ast_BuiltinType_default_widths, 60);
   ast_globals->builtinType_width[ast_BuiltinKind_ISize] = ((wordsize * 8) - 1);
   ast_globals->builtinType_width[ast_BuiltinKind_USize] = (wordsize * 8);
   memcpy(ast_globals->builtinType_bitfield_sizes, ast_BuiltinType_bitfield_sizes, 60);
   ast_globals->builtinType_bitfield_sizes[ast_BuiltinKind_ISize] = (wordsize * 8);
   ast_globals->builtinType_bitfield_sizes[ast_BuiltinKind_USize] = (wordsize * 8);
   for (uint32_t i = 0; (i < 15); i++) {
      ast_globals->builtinType_baseTypes[i] = ((ast_BuiltinKind)(i));
   }
   if ((wordsize == 4)) {
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_ISize] = ast_BuiltinKind_Int32;
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_USize] = ast_BuiltinKind_UInt32;
   } else {
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_ISize] = ast_BuiltinKind_Int64;
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_USize] = ast_BuiltinKind_UInt64;
   }
   attr_register(astPool, ast_globals->attr_name_indexes);
   attr_initialize(ast_globals->attr_name_indexes);
}

static void ast_deinit(_Bool print_stats)
{
   if (print_stats) ast_Stats_dump(&ast_globals->stats);
   ast_globals->names_pool = NULL;
   ast_globals->ast_count = 0;
   ast_globals->ast_capacity = 0;
   free(ast_globals->ast_list);
   ast_globals->ast_list = NULL;
   ast_PointerPool_clear(&ast_globals->pointers);
   ast_StringTypePool_clear(&ast_globals->string_types);
   free(ast_globals);
   free(ast_builtins);
}

static uint32_t ast_getWordSize(void)
{
   return ast_globals->wordsize;
}

static _Bool ast_useColor(void)
{
   return ast_globals->use_color;
}

static ast_QualType ast_getStringType(uint32_t len)
{
   return ast_StringTypePool_get(&ast_globals->string_types, len);
}

static const char* ast_idx2name(uint32_t idx)
{
   if (idx) return string_pool_Pool_idx2str(ast_globals->names_pool, idx);

   return NULL;
}

static ast_QualType ast_getVoidPtr(void)
{
   return ast_builtins[15];
}

static ast_Type* ast_getPointerType(ast_QualType inner)
{
   return ast_PointerPool_getPointer(&ast_globals->pointers, inner);
}

static uint32_t ast_addAST(ast_AST* ast_)
{
   if ((ast_globals->ast_count >= ast_globals->ast_capacity)) {
      if ((ast_globals->ast_capacity == 0)) ast_globals->ast_capacity = 16;
      else ast_globals->ast_capacity *= 2;
      void* buf = malloc((ast_globals->ast_capacity * 8));
      if (ast_globals->ast_list) {
         void* old = ast_globals->ast_list;
         memcpy(buf, old, (ast_globals->ast_count * 8));
         free(old);
      }
      ast_globals->ast_list = buf;
   }
   uint32_t idx = ast_globals->ast_count;
   ast_globals->ast_list[idx] = ast_;
   ast_globals->ast_count++;
   return idx;
}

static ast_AST* ast_idx2ast(uint32_t idx)
{
   if ((idx == 0)) return NULL;

   return ast_globals->ast_list[idx];
}

static void ast_setTypePublicUsed(ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getType(&qt);
   ast_Decl* d = NULL;
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      return;
   case ast_TypeKind_Pointer: {
      ast_PointerType* pt = ((ast_PointerType*)(t));
      ast_setTypePublicUsed(pt->inner);
      return;
   }
   case ast_TypeKind_Array: {
      ast_ArrayType* at = ((ast_ArrayType*)(t));
      ast_setTypePublicUsed(at->elem);
      return;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = ((ast_StructType*)(t));
      d = ((ast_Decl*)(st->decl));
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = ((ast_EnumType*)(t));
      d = ((ast_Decl*)(et->decl));
      break;
   }
   case ast_TypeKind_Function:
      return;
   case ast_TypeKind_Alias: {
      ast_AliasType* at = ((ast_AliasType*)(t));
      d = ((ast_Decl*)(at->decl));
      break;
   }
   case ast_TypeKind_Module:
      return;
   }
   if (d) ast_Decl_setUsedPublic(d);
}

static ast_QualType ast_getNativeType(void)
{
   ast_BuiltinKind kind = (ast_globals->wordsize == 8) ? ast_BuiltinKind_UInt64 : ast_BuiltinKind_UInt32;
   return ast_builtins[kind];
}


// --- module build_target ---
typedef struct build_target_Plugin_ build_target_Plugin;
typedef struct build_target_PluginList_ build_target_PluginList;
typedef struct build_target_File_ build_target_File;
typedef struct build_target_Target_ build_target_Target;

typedef enum {
   build_target_BackEndKind_None,
   build_target_BackEndKind_C,
   build_target_BackEndKind_QBE,
   build_target_BackEndKind_IR,
   _build_target_BackEndKind_max = 255
} __attribute__((packed)) build_target_BackEndKind;

typedef enum {
   build_target_Kind_Image,
   build_target_Kind_Executable,
   build_target_Kind_StaticLibrary,
   build_target_Kind_DynamicLibrary,
   _build_target_Kind_max = 255
} __attribute__((packed)) build_target_Kind;

struct build_target_Plugin_ {
   uint32_t name;
   uint32_t options;
   src_loc_SrcLoc loc;
};

struct build_target_PluginList_ {
   build_target_Plugin* plugins;
   uint32_t count;
   uint32_t capacity;
};

struct build_target_File_ {
   uint32_t name;
   src_loc_SrcLoc loc;
};

struct build_target_Target_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   warning_flags_Flags warnings;
   build_target_Kind kind;
   _Bool disable_asserts;
   _Bool no_libc;
   build_target_BackEndKind backend;
   _Bool backend_no_build;
   _Bool backend_fast;
   string_list_List features;
   library_list_List libs;
   string_list_List exports;
   build_target_PluginList plugins;
   build_target_File* files;
   uint32_t num_files;
   uint32_t max_files;
   build_target_File* asm_files;
   uint32_t asm_file_count;
   uint32_t asm_file_max;
};

static _Bool build_target_has_dynamic(build_target_Kind k);
static void build_target_PluginList_init(build_target_PluginList* l);
static void build_target_PluginList_free(build_target_PluginList* l);
static uint32_t build_target_PluginList_size(const build_target_PluginList* l);
static const build_target_Plugin* build_target_PluginList_get(const build_target_PluginList* l, uint32_t idx);
static void build_target_PluginList_add(build_target_PluginList* l, uint32_t name, uint32_t options, src_loc_SrcLoc loc);
static build_target_Target* build_target_create(uint32_t name_idx, src_loc_SrcLoc loc, build_target_Kind kind, string_pool_Pool* pool);
static void build_target_Target_free(build_target_Target* t);
static uint32_t build_target_Target_getNameIdx(const build_target_Target* t);
static void build_target_Target_setNameIdx(build_target_Target* t, uint32_t name_idx);
static uint32_t build_target_Target_numFiles(const build_target_Target* t);
static uint32_t build_target_Target_numAsmFiles(const build_target_Target* t);
static const string_list_List* build_target_Target_getFeatures(const build_target_Target* t);
static void build_target_Target_addFeature(build_target_Target* t, uint32_t feature);
static void build_target_Target_addPlugin(build_target_Target* t, uint32_t name, uint32_t options, src_loc_SrcLoc loc);
static const build_target_PluginList* build_target_Target_getPlugins(const build_target_Target* t);
static void build_target_Target_disableAsserts(build_target_Target* t);
static _Bool build_target_Target_hasAsserts(const build_target_Target* t);
static void build_target_Target_visitLibs(const build_target_Target* t, library_list_Visitor visitor, void* arg);
static _Bool build_target_Target_hasLib(const build_target_Target* t, uint32_t lib);
static void build_target_Target_addLib(build_target_Target* t, uint32_t lib, _Bool is_static);
static void build_target_Target_disableWarnings(build_target_Target* t);
static void build_target_Target_enableWarnings(build_target_Target* t);
static const warning_flags_Flags* build_target_Target_getWarnings(const build_target_Target* t);
static warning_flags_Flags* build_target_Target_getWarnings2(build_target_Target* t);
static void build_target_Target_addExport(build_target_Target* t, uint32_t export);
static const string_list_List* build_target_Target_getExports(const build_target_Target* t);
static build_target_Kind build_target_Target_getKind(const build_target_Target* t);
static _Bool build_target_Target_needsMain(const build_target_Target* t);
static _Bool build_target_Target_addFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc);
static const build_target_File* build_target_Target_getFile(const build_target_Target* t, uint32_t idx);
static _Bool build_target_Target_addAsmFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc);
static const build_target_File* build_target_Target_getAsmFile(const build_target_Target* t, uint32_t idx);
static void build_target_Target_setNoLibC(build_target_Target* t);
static _Bool build_target_Target_getNoLibC(const build_target_Target* t);
static build_target_BackEndKind build_target_Target_getBackEnd(const build_target_Target* t);
static _Bool build_target_Target_hasBackEnd(const build_target_Target* t);
static void build_target_Target_setBackEnd(build_target_Target* t, build_target_BackEndKind kind);
static void build_target_Target_setNoBuild(build_target_Target* t);
static _Bool build_target_Target_getNoBuild(const build_target_Target* t);
static void build_target_Target_setFastBuild(build_target_Target* t);
static _Bool build_target_Target_getFastBuild(const build_target_Target* t);

static _Bool build_target_has_dynamic(build_target_Kind k)
{
   switch (k) {
   case build_target_Kind_Image:
      return false;
   case build_target_Kind_Executable:
      return true;
   case build_target_Kind_StaticLibrary:
      return false;
   case build_target_Kind_DynamicLibrary:
      return true;
   }
   return false;
}

static void build_target_PluginList_init(build_target_PluginList* l)
{
   memset(l, 0, 16);
}

static void build_target_PluginList_free(build_target_PluginList* l)
{
   free(l->plugins);
}

static uint32_t build_target_PluginList_size(const build_target_PluginList* l)
{
   return l->count;
}

static const build_target_Plugin* build_target_PluginList_get(const build_target_PluginList* l, uint32_t idx)
{
   return &l->plugins[idx];
}

static void build_target_PluginList_add(build_target_PluginList* l, uint32_t name, uint32_t options, src_loc_SrcLoc loc)
{
   if ((l->count == l->capacity)) {
      l->capacity = l->capacity ? (l->capacity * 2) : 4;
      build_target_Plugin* plugins2 = malloc((l->capacity * 12));
      if (l->count) {
         memcpy(plugins2, l->plugins, (l->count * 12));
         free(l->plugins);
      }
      l->plugins = plugins2;
   }
   build_target_Plugin* p = &l->plugins[l->count];
   p->name = name;
   p->options = options;
   p->loc = loc;
   l->count++;
}

static build_target_Target* build_target_create(uint32_t name_idx, src_loc_SrcLoc loc, build_target_Kind kind, string_pool_Pool* pool)
{
   build_target_Target* t = calloc(1, 144);
   t->name_idx = name_idx;
   t->loc = loc;
   t->kind = kind;
   t->max_files = 8;
   string_list_List_init(&t->features, pool);
   library_list_List_init(&t->libs);
   string_list_List_init(&t->exports, pool);
   t->files = malloc((t->max_files * 8));
   t->asm_file_max = 4;
   t->asm_files = malloc((t->asm_file_max * 8));
   return t;
}

static void build_target_Target_free(build_target_Target* t)
{
   string_list_List_free(&t->exports);
   build_target_PluginList_free(&t->plugins);
   library_list_List_free(&t->libs);
   string_list_List_free(&t->features);
   free(t->files);
   free(t->asm_files);
   free(t);
}

static uint32_t build_target_Target_getNameIdx(const build_target_Target* t)
{
   return t->name_idx;
}

static void build_target_Target_setNameIdx(build_target_Target* t, uint32_t name_idx)
{
   t->name_idx = name_idx;
}

static uint32_t build_target_Target_numFiles(const build_target_Target* t)
{
   return t->num_files;
}

static uint32_t build_target_Target_numAsmFiles(const build_target_Target* t)
{
   return t->asm_file_count;
}

static const string_list_List* build_target_Target_getFeatures(const build_target_Target* t)
{
   return &t->features;
}

static void build_target_Target_addFeature(build_target_Target* t, uint32_t feature)
{
   string_list_List_add(&t->features, feature);
}

static void build_target_Target_addPlugin(build_target_Target* t, uint32_t name, uint32_t options, src_loc_SrcLoc loc)
{
   build_target_PluginList_add(&t->plugins, name, options, loc);
}

static const build_target_PluginList* build_target_Target_getPlugins(const build_target_Target* t)
{
   return &t->plugins;
}

static void build_target_Target_disableAsserts(build_target_Target* t)
{
   t->disable_asserts = true;
}

static _Bool build_target_Target_hasAsserts(const build_target_Target* t)
{
   return !t->disable_asserts;
}

static void build_target_Target_visitLibs(const build_target_Target* t, library_list_Visitor visitor, void* arg)
{
   library_list_List_visit(&t->libs, visitor, arg);
}

static _Bool build_target_Target_hasLib(const build_target_Target* t, uint32_t lib)
{
   return library_list_List_contains(&t->libs, lib);
}

static void build_target_Target_addLib(build_target_Target* t, uint32_t lib, _Bool is_static)
{
   library_list_List_add(&t->libs, lib, is_static);
}

static void build_target_Target_disableWarnings(build_target_Target* t)
{
   t->warnings.no_unused = true;
   t->warnings.no_unused_variable = true;
   t->warnings.no_unused_function = true;
   t->warnings.no_unused_parameter = true;
   t->warnings.no_unused_type = true;
   t->warnings.no_unused_module = true;
   t->warnings.no_unused_import = true;
   t->warnings.no_unused_public = true;
   t->warnings.no_unused_label = true;
   t->warnings.no_unused_enum_constant = true;
}

static void build_target_Target_enableWarnings(build_target_Target* t)
{
   t->warnings.no_unused = false;
   t->warnings.no_unused_variable = false;
   t->warnings.no_unused_function = false;
   t->warnings.no_unused_parameter = false;
   t->warnings.no_unused_type = false;
   t->warnings.no_unused_module = false;
   t->warnings.no_unused_import = false;
   t->warnings.no_unused_public = false;
   t->warnings.no_unused_label = false;
   t->warnings.no_unused_enum_constant = false;
}

static const warning_flags_Flags* build_target_Target_getWarnings(const build_target_Target* t)
{
   return &t->warnings;
}

static warning_flags_Flags* build_target_Target_getWarnings2(build_target_Target* t)
{
   return &t->warnings;
}

static void build_target_Target_addExport(build_target_Target* t, uint32_t export)
{
   string_list_List_add(&t->exports, export);
}

static const string_list_List* build_target_Target_getExports(const build_target_Target* t)
{
   return &t->exports;
}

static build_target_Kind build_target_Target_getKind(const build_target_Target* t)
{
   return t->kind;
}

static _Bool build_target_Target_needsMain(const build_target_Target* t)
{
   switch (t->kind) {
   case build_target_Kind_Image:
      fallthrough;
   case build_target_Kind_Executable:
      return true;
   case build_target_Kind_StaticLibrary:
      fallthrough;
   case build_target_Kind_DynamicLibrary:
      break;
   }
   return false;
}

static _Bool build_target_Target_addFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc)
{
   for (uint32_t i = 0; (i < t->num_files); i++) {
      if ((t->files[i].name == filename)) return false;

   }
   if ((t->num_files == t->max_files)) {
      t->max_files *= 2;
      build_target_File* files2 = malloc((t->max_files * 8));
      memcpy(files2, t->files, (t->num_files * 8));
      free(t->files);
      t->files = files2;
   }
   t->files[t->num_files].name = filename;
   t->files[t->num_files].loc = loc;
   t->num_files++;
   return true;
}

static const build_target_File* build_target_Target_getFile(const build_target_Target* t, uint32_t idx)
{
   return &t->files[idx];
}

static _Bool build_target_Target_addAsmFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc)
{
   for (uint32_t i = 0; (i < t->asm_file_count); i++) {
      if ((t->asm_files[i].name == filename)) return false;

   }
   if ((t->asm_file_count == t->asm_file_max)) {
      t->asm_file_max *= 2;
      build_target_File* files2 = malloc((t->asm_file_max * 8));
      memcpy(files2, t->files, (t->asm_file_count * 8));
      free(t->asm_files);
      t->asm_files = files2;
   }
   t->asm_files[t->asm_file_count].name = filename;
   t->asm_files[t->asm_file_count].loc = loc;
   t->asm_file_count++;
   return true;
}

static const build_target_File* build_target_Target_getAsmFile(const build_target_Target* t, uint32_t idx)
{
   return &t->asm_files[idx];
}

static void build_target_Target_setNoLibC(build_target_Target* t)
{
   t->no_libc = true;
}

static _Bool build_target_Target_getNoLibC(const build_target_Target* t)
{
   return t->no_libc;
}

static build_target_BackEndKind build_target_Target_getBackEnd(const build_target_Target* t)
{
   return t->backend;
}

static _Bool build_target_Target_hasBackEnd(const build_target_Target* t)
{
   return (t->backend != build_target_BackEndKind_None);
}

static void build_target_Target_setBackEnd(build_target_Target* t, build_target_BackEndKind kind)
{
   t->backend = kind;
}

static void build_target_Target_setNoBuild(build_target_Target* t)
{
   t->backend_no_build = true;
}

static _Bool build_target_Target_getNoBuild(const build_target_Target* t)
{
   return t->backend_no_build;
}

static void build_target_Target_setFastBuild(build_target_Target* t)
{
   t->backend_fast = true;
}

static _Bool build_target_Target_getFastBuild(const build_target_Target* t)
{
   return t->backend_fast;
}


// --- module diagnostics ---
typedef struct diagnostics_Diags_ diagnostics_Diags;

struct diagnostics_Diags_ {
   source_mgr_SourceMgr* sm;
   string_buffer_Buf* out;
   uint32_t num_errors;
   uint32_t num_warnings;
   _Bool promote_warnings;
   const utils_PathInfo* path_info;
};

typedef enum {
   diagnostics_Category_Note,
   diagnostics_Category_Warning,
   diagnostics_Category_Error,
   _diagnostics_Category_max = 255
} __attribute__((packed)) diagnostics_Category;

static const char* diagnostics_category_names[3] = { "note", "warning", "error" };

static const char* diagnostics_category_colors[3] = { color_Grey, color_Bmagenta, color_Bred };

static diagnostics_Diags* diagnostics_create(source_mgr_SourceMgr* sm, _Bool use_color, const utils_PathInfo* path_info);
static void diagnostics_Diags_free(diagnostics_Diags* diags);
static void diagnostics_Diags_clear(diagnostics_Diags* diags);
static void diagnostics_Diags_setWarningAsError(diagnostics_Diags* diags, _Bool are_errors);
__attribute__((__format__(printf, 3, 4))) 
static void diagnostics_Diags_error(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...);
static void diagnostics_Diags_error2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args);
__attribute__((__format__(printf, 3, 4))) 
static void diagnostics_Diags_note(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...);
static void diagnostics_Diags_note2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args);
__attribute__((__format__(printf, 3, 4))) 
static void diagnostics_Diags_warn(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...);
static void diagnostics_Diags_warn2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args);
__attribute__((__format__(printf, 4, 5))) 
static void diagnostics_Diags_errorRange(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...);
static void diagnostics_Diags_errorRange2(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, va_list args);
static void diagnostics_Diags_internal(diagnostics_Diags* diags, diagnostics_Category category, src_loc_SrcLoc sloc, src_loc_SrcRange range, const char* format, va_list args);
static _Bool diagnostics_Diags_isOk(const diagnostics_Diags* diags);
static _Bool diagnostics_Diags_hasErrors(const diagnostics_Diags* diags);
static uint32_t diagnostics_Diags_getNumErrors(const diagnostics_Diags* diags);
static void diagnostics_Diags_printStatus(const diagnostics_Diags* diags);

static diagnostics_Diags* diagnostics_create(source_mgr_SourceMgr* sm, _Bool use_color, const utils_PathInfo* path_info)
{
   diagnostics_Diags* diags = calloc(1, 40);
   diags->sm = sm;
   diags->out = string_buffer_create(512, use_color, 1);
   diags->path_info = path_info;
   return diags;
}

static void diagnostics_Diags_free(diagnostics_Diags* diags)
{
   string_buffer_Buf_free(diags->out);
   free(diags);
}

static void diagnostics_Diags_clear(diagnostics_Diags* diags)
{
   diags->num_errors = 0;
   diags->num_warnings = 0;
}

static void diagnostics_Diags_setWarningAsError(diagnostics_Diags* diags, _Bool are_errors)
{
   diags->promote_warnings = are_errors;
}

__attribute__((__format__(printf, 3, 4))) 
static void diagnostics_Diags_error(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_error2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args)
{
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
}

__attribute__((__format__(printf, 3, 4))) 
static void diagnostics_Diags_note(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Note, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_note2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args)
{
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Note, loc, range, format, args);
}

__attribute__((__format__(printf, 3, 4))) 
static void diagnostics_Diags_warn(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Category category = diagnostics_Category_Warning;
   if (diags->promote_warnings) category = diagnostics_Category_Error;
   diagnostics_Diags_internal(diags, category, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_warn2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args)
{
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Category category = diagnostics_Category_Warning;
   if (diags->promote_warnings) category = diagnostics_Category_Error;
   diagnostics_Diags_internal(diags, category, loc, range, format, args);
}

__attribute__((__format__(printf, 4, 5))) 
static void diagnostics_Diags_errorRange(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_errorRange2(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, va_list args)
{
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
}

static void diagnostics_Diags_internal(diagnostics_Diags* diags, diagnostics_Category category, src_loc_SrcLoc sloc, src_loc_SrcRange range, const char* format, va_list args)
{
   if ((category == diagnostics_Category_Error)) {
      diags->num_errors++;
   } else {
      diags->num_warnings++;
   }
   string_buffer_Buf* out = diags->out;
   string_buffer_Buf_clear(out);
   source_mgr_Location loc = source_mgr_SourceMgr_locate(diags->sm, sloc);
   if ((sloc && !loc.line_start)) {
      string_buffer_Buf_print(out, "<invalid location %u>: ", sloc);
      sloc = 0;
   }
   if (sloc) {
      if ((utils_PathInfo_hasSubdir(diags->path_info) && (loc.filename[0] != '/'))) {
         string_buffer_Buf_add(out, diags->path_info->root2orig);
      }
      string_buffer_Buf_print(out, "%s:%u:%u: ", loc.filename, loc.line, loc.column);
   }
   string_buffer_Buf_color(out, diagnostics_category_colors[category]);
   string_buffer_Buf_add(out, diagnostics_category_names[category]);
   string_buffer_Buf_add(out, ": ");
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_vprintf(out, format, args);
   string_buffer_Buf_newline(out);
   if (sloc) {
      const char* text = loc.line_start;
      uint32_t loc_col = loc.column;
      uint32_t range_start_col = loc_col;
      uint32_t range_end_col = (loc_col + 1);
      uint32_t end_col = (loc_col + 1);
      if ((range.start && range.end)) {
         source_mgr_Location startLoc = source_mgr_SourceMgr_locate(diags->sm, range.start);
         source_mgr_Location endLoc = source_mgr_SourceMgr_locate(diags->sm, range.end);
         if ((((loc.line == startLoc.line) && (loc.line == endLoc.line)) && (startLoc.column < endLoc.column))) {
            range_start_col = startLoc.column;
            range_end_col = endLoc.column;
            if ((end_col < range_end_col)) end_col = range_end_col;
         }
      }
      uint32_t skip = 0;
      if ((loc_col > 128)) {
         skip = (loc_col - 64);
         skip += utf8_sync(&text[skip]);
         if ((range_start_col > skip)) range_start_col -= skip;
         else range_start_col = 1;
         if ((range_end_col > skip)) range_end_col -= skip;
         else range_end_col = 1;
         loc_col -= skip;
         end_col -= skip;
         text += skip;
      }
      uint32_t len = 0;
      while (((((len < 128) && text[len]) && (text[len] != '\n')) && (text[len] != '\r'))) {
         len++;
      }
      len += utf8_sync(&text[len]);
      if ((end_col > (len + 2))) end_col = (len + 2);
      if (skip) string_buffer_Buf_add(out, "...");
      string_buffer_Buf_add2(out, text, len);
      string_buffer_Buf_newline(out);
      if (skip) string_buffer_Buf_add(out, "   ");
      for (uint32_t col = 1; (col < end_col); col++) {
         char c = ' ';
         if ((text[(col - 1)] == '\t')) c = '\t';
         if ((col == range_start_col)) string_buffer_Buf_color(out, color_Bgreen);
         if (((col >= range_start_col) && (col < range_end_col))) c = '~';
         if ((col == loc_col)) c = '^';
         string_buffer_Buf_add1(out, c);
      }
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_newline(out);
   }
   fputs(string_buffer_Buf_data(out), stderr);
}

static _Bool diagnostics_Diags_isOk(const diagnostics_Diags* diags)
{
   return (diags->num_errors == 0);
}

static _Bool diagnostics_Diags_hasErrors(const diagnostics_Diags* diags)
{
   return (diags->num_errors != 0);
}

static uint32_t diagnostics_Diags_getNumErrors(const diagnostics_Diags* diags)
{
   return diags->num_errors;
}

static void diagnostics_Diags_printStatus(const diagnostics_Diags* diags)
{
   string_buffer_Buf* out = diags->out;
   string_buffer_Buf_clear(out);
   if (diags->num_warnings) {
      string_buffer_Buf_print(out, "%u warning%s", diags->num_warnings, (diags->num_warnings > 1) ? "s" : "");
   }
   if (diags->num_errors) {
      if (diags->num_warnings) string_buffer_Buf_add(out, " and ");
      string_buffer_Buf_print(out, "%u error%s", diags->num_errors, (diags->num_errors > 1) ? "s" : "");
   }
   if (string_buffer_Buf_size(out)) {
      string_buffer_Buf_add(out, " generated.\n");
      fputs(string_buffer_Buf_data(out), stderr);
   }
}


// --- module module_list ---
typedef struct module_list_List_ module_list_List;

typedef void (*module_list_Visitor)(void* arg, ast_Module* m);

struct module_list_List_ {
   ast_Module** mods;
   uint32_t num_mods;
   uint32_t max_mods;
   _Bool owns_modules;
};

static void module_list_List_init(module_list_List* l, _Bool owns_modules, uint32_t capacity);
static void module_list_List_free(module_list_List* l);
static void module_list_List_visit(const module_list_List* l, module_list_Visitor visitor, void* arg);
static ast_Module* module_list_List_find(const module_list_List* l, uint32_t module_name);
static void module_list_List_add(module_list_List* list, ast_Module* m);
static void module_list_List_clear(module_list_List* l);
static uint32_t module_list_List_length(const module_list_List* l);
static ast_Module** module_list_List_get(const module_list_List* l);
static const ast_Module** module_list_List_getConst(const module_list_List* l);
static ast_Module* module_list_List_at(const module_list_List* l, uint32_t idx);
static _Bool module_list_List_contains(const module_list_List* l, const ast_Module* mod);
static void module_list_List_resize(module_list_List* l, uint32_t cap);

static void module_list_List_init(module_list_List* l, _Bool owns_modules, uint32_t capacity)
{
   memset(l, 0, 24);
   l->owns_modules = owns_modules;
   module_list_List_resize(l, capacity);
}

static void module_list_List_free(module_list_List* l)
{
   if (l->owns_modules) {
      for (uint32_t i = 0; (i < l->num_mods); i++) {
         ast_Module_free(l->mods[i]);
      }
   }
   free(l->mods);
}

static void module_list_List_visit(const module_list_List* l, module_list_Visitor visitor, void* arg)
{
   for (uint32_t i = 0; (i < l->num_mods); i++) {
      visitor(arg, l->mods[i]);
   }
}

static ast_Module* module_list_List_find(const module_list_List* l, uint32_t module_name)
{
   for (uint32_t i = 0; (i < l->num_mods); i++) {
      if ((ast_Module_getNameIdx(l->mods[i]) == module_name)) return l->mods[i];

   }
   return NULL;
}

static void module_list_List_add(module_list_List* list, ast_Module* m)
{
   if ((list->num_mods == list->max_mods)) module_list_List_resize(list, (list->max_mods * 2));
   list->mods[list->num_mods] = m;
   list->num_mods++;
}

static void module_list_List_clear(module_list_List* l)
{
   (!l->owns_modules) || c2_assert("common/module_list.c2", 68, "module_list.List.clear", "!l.owns_modules");
   l->num_mods = 0;
}

static uint32_t module_list_List_length(const module_list_List* l)
{
   return l->num_mods;
}

static ast_Module** module_list_List_get(const module_list_List* l)
{
   return l->mods;
}

static const ast_Module** module_list_List_getConst(const module_list_List* l)
{
   return ((const ast_Module**)(l->mods));
}

static ast_Module* module_list_List_at(const module_list_List* l, uint32_t idx)
{
   return l->mods[idx];
}

static _Bool module_list_List_contains(const module_list_List* l, const ast_Module* mod)
{
   for (uint32_t i = 0; (i < l->num_mods); i++) {
      if ((l->mods[i] == mod)) return true;

   }
   return false;
}

static void module_list_List_resize(module_list_List* l, uint32_t cap)
{
   l->max_mods = cap;
   void* buf = malloc((l->max_mods * 8));
   if (l->mods) {
      void* old = l->mods;
      memcpy(buf, old, (l->num_mods * 8));
      free(old);
   }
   l->mods = buf;
}


// --- module case_list ---
typedef struct case_list_List_ case_list_List;

#define case_list_StackSize 4
struct case_list_List_ {
   uint32_t count;
   uint32_t capacity;
   ast_SwitchCase* stack[4];
   ast_SwitchCase** heap;
};

static void case_list_List_init(case_list_List* l);
static void case_list_List_add(case_list_List* l, ast_SwitchCase* s);
static void case_list_List_free(case_list_List* l);
static uint32_t case_list_List_size(const case_list_List* l);
static ast_SwitchCase** case_list_List_getData(case_list_List* l);

static void case_list_List_init(case_list_List* l)
{
   memset(l, 0, 48);
   l->heap = l->stack;
   l->capacity = 4;
}

static void case_list_List_add(case_list_List* l, ast_SwitchCase* s)
{
   if ((l->count == l->capacity)) {
      l->capacity *= 2;
      ast_SwitchCase** heap2 = malloc((l->capacity * 8));
      memcpy(heap2, l->heap, (l->count * 8));
      if ((l->heap != l->stack)) free(l->heap);
      l->heap = heap2;
   }
   l->heap[l->count] = s;
   l->count++;
}

static void case_list_List_free(case_list_List* l)
{
   if ((l->heap != l->stack)) free(l->heap);
}

static uint32_t case_list_List_size(const case_list_List* l)
{
   return l->count;
}

static ast_SwitchCase** case_list_List_getData(case_list_List* l)
{
   return l->heap;
}


// --- module expr_list ---
typedef struct expr_list_List_ expr_list_List;

#define expr_list_StackSize 4
struct expr_list_List_ {
   uint32_t count;
   uint32_t capacity;
   ast_Expr* stack[4];
   ast_Expr** data;
};

static void expr_list_List_init(expr_list_List* l);
static void expr_list_List_add(expr_list_List* l, ast_Expr* e);
static void expr_list_List_free(expr_list_List* l);
static uint32_t expr_list_List_size(const expr_list_List* l);
static ast_Expr** expr_list_List_getData(expr_list_List* l);

static void expr_list_List_init(expr_list_List* l)
{
   memset(l, 0, 48);
   l->data = l->stack;
   l->capacity = 4;
}

static void expr_list_List_add(expr_list_List* l, ast_Expr* e)
{
   if ((l->count == l->capacity)) {
      l->capacity *= 2;
      ast_Expr** data2 = malloc((l->capacity * 8));
      memcpy(data2, l->data, (l->count * 8));
      if ((l->data != l->stack)) free(l->data);
      l->data = data2;
   }
   l->data[l->count] = e;
   l->count++;
}

static void expr_list_List_free(expr_list_List* l)
{
   if ((l->data != l->stack)) free(l->data);
}

static uint32_t expr_list_List_size(const expr_list_List* l)
{
   return l->count;
}

static ast_Expr** expr_list_List_getData(expr_list_List* l)
{
   return l->data;
}


// --- module keywords ---
typedef struct keywords_Info_ keywords_Info;

struct keywords_Info_ {
   token_Kind indexes[512];
   uint32_t max_index;
};

static void keywords_Info_init(keywords_Info* info, string_pool_Pool* pool);

static void keywords_Info_init(keywords_Info* info, string_pool_Pool* pool)
{
   uint32_t idx = 0;
   memset(info->indexes, 0, 512);
   for (token_Kind k = token_Kind_KW_bool; (k <= token_Kind_KW_while); k++) {
      const char* s = token_Kind_str(k);
      idx = string_pool_Pool_add(pool, s, strlen(s), true);
      ((idx < 512)) || c2_assert("parser/keywords.c2", 35, "keywords.Info.init", "idx < elemsof(info.indexes)");
      info->indexes[idx] = k;
   }
   info->max_index = idx;
}


// --- module stmt_list ---
typedef struct stmt_list_List_ stmt_list_List;

#define stmt_list_StackSize 4
struct stmt_list_List_ {
   uint32_t count;
   uint32_t capacity;
   ast_Stmt* stack[4];
   ast_Stmt** data;
};

static void stmt_list_List_init(stmt_list_List* l);
static void stmt_list_List_add(stmt_list_List* l, ast_Stmt* s);
static void stmt_list_List_free(stmt_list_List* l);
static uint32_t stmt_list_List_size(const stmt_list_List* l);
static ast_Stmt** stmt_list_List_getData(stmt_list_List* l);

static void stmt_list_List_init(stmt_list_List* l)
{
   memset(l, 0, 48);
   l->data = l->stack;
   l->capacity = 4;
}

static void stmt_list_List_add(stmt_list_List* l, ast_Stmt* s)
{
   if ((l->count == l->capacity)) {
      l->capacity *= 2;
      ast_Stmt** data2 = malloc((l->capacity * 8));
      memcpy(data2, l->data, (l->count * 8));
      if ((l->data != l->stack)) free(l->data);
      l->data = data2;
   }
   l->data[l->count] = s;
   l->count++;
}

static void stmt_list_List_free(stmt_list_List* l)
{
   if ((l->data != l->stack)) free(l->data);
}

static uint32_t stmt_list_List_size(const stmt_list_List* l)
{
   return l->count;
}

static ast_Stmt** stmt_list_List_getData(stmt_list_List* l)
{
   return l->data;
}


// --- module incr_array_list ---
typedef struct incr_array_list_Info_ incr_array_list_Info;
typedef struct incr_array_list_List_ incr_array_list_List;

struct incr_array_list_Info_ {
   uint32_t name;
   src_loc_SrcLoc loc;
   ast_ExprList values;
};

struct incr_array_list_List_ {
   incr_array_list_Info* entries;
   uint32_t count;
   uint32_t capacity;
};

static void incr_array_list_List_free(incr_array_list_List* v);
static void incr_array_list_List_resize(incr_array_list_List* v);
static ast_ExprList* incr_array_list_List_find(incr_array_list_List* v, uint32_t name);
static void incr_array_list_List_add(incr_array_list_List* v, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value);

static void incr_array_list_List_free(incr_array_list_List* v)
{
   for (uint32_t i = 0; (i < v->count); i++) {
      ast_ExprList_free(&v->entries[i].values);
   }
   free(v->entries);
   v->count = 0;
   v->capacity = 0;
   v->entries = NULL;
}

static void incr_array_list_List_resize(incr_array_list_List* v)
{
   v->capacity = (v->capacity == 0) ? 4 : (v->capacity * 2);
   incr_array_list_Info* entries2 = malloc((v->capacity * 56));
   if (v->entries) {
      memcpy(entries2, v->entries, (v->count * 56));
      free(v->entries);
   }
   v->entries = entries2;
}

static ast_ExprList* incr_array_list_List_find(incr_array_list_List* v, uint32_t name)
{
   for (uint32_t i = 0; (i < v->count); i++) {
      incr_array_list_Info* info = &v->entries[i];
      if ((info->name == name)) return &info->values;

   }
   return NULL;
}

static void incr_array_list_List_add(incr_array_list_List* v, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value)
{
   ast_ExprList* values = incr_array_list_List_find(v, name);
   if (!values) {
      if ((v->count == v->capacity)) incr_array_list_List_resize(v);
      incr_array_list_Info* info = &v->entries[v->count];
      info->name = name;
      info->loc = loc;
      ast_ExprList_init(&info->values);
      v->count++;
      values = &info->values;
   }
   ast_ExprList_add(values, value);
}


// --- module label_vector ---
typedef struct label_vector_Label_ label_vector_Label;
typedef struct label_vector_LabelVector_ label_vector_LabelVector;

struct label_vector_Label_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   _Bool used;
   _Bool is_label;
   ast_LabelStmt* stmt;
};

struct label_vector_LabelVector_ {
   label_vector_Label* data;
   uint32_t count;
   uint32_t capacity;
};

static void label_vector_LabelVector_init(label_vector_LabelVector* v, uint32_t capacity);
static void label_vector_LabelVector_free(label_vector_LabelVector* v);
static void label_vector_LabelVector_reset(label_vector_LabelVector* v);
static void label_vector_LabelVector_resize(label_vector_LabelVector* v);
static uint32_t label_vector_LabelVector_add(label_vector_LabelVector* v, label_vector_Label label);
static uint32_t label_vector_LabelVector_getCount(const label_vector_LabelVector* v);
static const label_vector_Label* label_vector_LabelVector_getLabels(const label_vector_LabelVector* v);
static label_vector_Label* label_vector_LabelVector_find(label_vector_LabelVector* v, uint32_t name_idx);

static void label_vector_LabelVector_init(label_vector_LabelVector* v, uint32_t capacity)
{
   v->data = NULL;
   v->count = 0;
   v->capacity = capacity;
   if (capacity) v->data = malloc((capacity * 24));
}

static void label_vector_LabelVector_free(label_vector_LabelVector* v)
{
   if (v->data) free(v->data);
   v->count = 0;
   v->capacity = 0;
   v->data = NULL;
}

static void label_vector_LabelVector_reset(label_vector_LabelVector* v)
{
   v->count = 0;
}

static void label_vector_LabelVector_resize(label_vector_LabelVector* v)
{
   v->capacity = (v->capacity == 0) ? 4 : (v->capacity * 2);
   void* data2 = malloc((v->capacity * 24));
   if (v->data) {
      memcpy(data2, v->data, (v->count * 24));
      free(v->data);
   }
   v->data = data2;
}

static uint32_t label_vector_LabelVector_add(label_vector_LabelVector* v, label_vector_Label label)
{
   if ((v->count == v->capacity)) label_vector_LabelVector_resize(v);
   uint32_t index = v->count;
   v->data[index] = label;
   v->count++;
   return index;
}

static uint32_t label_vector_LabelVector_getCount(const label_vector_LabelVector* v)
{
   return v->count;
}

static const label_vector_Label* label_vector_LabelVector_getLabels(const label_vector_LabelVector* v)
{
   return v->data;
}

static label_vector_Label* label_vector_LabelVector_find(label_vector_LabelVector* v, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < v->count); i++) {
      if ((v->data[i].name_idx == name_idx)) return &v->data[i];

   }
   return NULL;
}


// --- module scope ---
typedef struct scope_Level_ scope_Level;
typedef struct scope_Scope_ scope_Scope;

struct scope_Level_ {
   uint32_t flags;
   uint32_t first_index;
};

struct scope_Scope_ {
   const module_list_List* allmodules;
   diagnostics_Diags* diags;
   const ast_ImportDeclList* imports;
   const ast_Module* mod;
   const ast_SymbolTable* symbols;
   _Bool warn_on_unused;
   uint32_t stack_count;
   uint32_t stack_capacity;
   uint32_t* stack_symbols;
   ast_Decl** stack_decls;
   uint32_t cache_count;
   uint32_t cache_capacity;
   uint32_t* cache_symbols;
   ast_Decl** cache_decls;
   ast_ImportDecl** cache_imports;
   scope_Level levels[32];
   uint32_t lvl;
};

#define scope_Function 0x1
#define scope_Break 0x2
#define scope_Continue 0x4
#define scope_Decl 0x8
#define scope_Control 0x10
#define scope_Fallthrough 0x40
#define scope_Unreachable 0x80
static scope_Scope* scope_create(module_list_List* allmodules, diagnostics_Diags* diags, const ast_ImportDeclList* imports, ast_Module* mod, const ast_SymbolTable* symbols, _Bool warn_on_unused);
static void scope_Scope_free(scope_Scope* s);
static void scope_Scope_reset(scope_Scope* s);
static void scope_Scope_addImports(scope_Scope* s);
static void scope_Scope_enter(scope_Scope* s, uint32_t flags);
static void scope_Scope_exit(scope_Scope* s, _Bool has_error);
static ast_Decl* scope_Scope_stack_find(const scope_Scope* s, uint32_t name_idx);
static void scope_Scope_stack_add(scope_Scope* s, uint32_t name_idx, ast_Decl* d);
static void scope_Scope_stack_resize(scope_Scope* s, uint32_t capacity);
static void scope_Scope_cache_resize(scope_Scope* s, uint32_t capacity);
static void scope_Scope_setUnreachable(scope_Scope* s);
static void scope_Scope_setReachable(scope_Scope* s);
static _Bool scope_Scope_isUnreachable(const scope_Scope* s);
static _Bool scope_Scope_allowBreak(const scope_Scope* s);
static _Bool scope_Scope_allowContinue(const scope_Scope* s);
static _Bool scope_Scope_allowFallthrough(const scope_Scope* s);
static _Bool scope_Scope_inFunction(const scope_Scope* s);
static _Bool scope_Scope_add(scope_Scope* s, ast_Decl* d);
static ast_Decl* scope_Scope_find(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, _Bool usedPublic);
static _Bool scope_Scope_checkGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_ImportDecl* scope_Scope_findModule(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_Decl* scope_Scope_findSymbolInModule(scope_Scope* s, ast_Module* mod, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_Decl* scope_Scope_findType(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, _Bool usedPublic);
static ast_Decl* scope_Scope_findGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, _Bool* other_error, _Bool usedPublic, _Bool search_privates);
static void scope_Scope_dump(const scope_Scope* s);
static _Bool scope_Scope_checkAccess(scope_Scope* s, ast_Decl* d, src_loc_SrcLoc loc);

static scope_Scope* scope_create(module_list_List* allmodules, diagnostics_Diags* diags, const ast_ImportDeclList* imports, ast_Module* mod, const ast_SymbolTable* symbols, _Bool warn_on_unused)
{
   scope_Scope* s = calloc(1, 368);
   s->allmodules = allmodules;
   s->diags = diags;
   s->imports = imports;
   s->mod = mod;
   s->symbols = symbols;
   s->warn_on_unused = warn_on_unused;
   scope_Scope_stack_resize(s, 64);
   scope_Scope_cache_resize(s, 32);
   scope_Scope_addImports(s);
   return s;
}

static void scope_Scope_free(scope_Scope* s)
{
   free(s->cache_imports);
   free(s->cache_decls);
   free(s->stack_symbols);
   free(s->cache_symbols);
   free(s->stack_decls);
   free(s);
}

static void scope_Scope_reset(scope_Scope* s)
{
   s->lvl = 0;
   uint32_t first_index = ast_ImportDeclList_size(s->imports);
   s->stack_count = first_index;
}

static void scope_Scope_addImports(scope_Scope* s)
{
   uint32_t num_imports = ast_ImportDeclList_size(s->imports);
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(s->imports);
   for (uint32_t i = 0; (i < num_imports); i++) {
      ast_ImportDecl* id = imports[i];
      ast_Decl* d = ((ast_Decl*)(id));
      uint32_t name_idx = ast_ImportDecl_getImportNameIdx(id);
      ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
      if (decl) {
         diagnostics_Diags_error(s->diags, ast_ImportDecl_getLoc(id), "duplicate import name '%s'", ast_idx2name(name_idx));
         (ast_Decl_isImport(decl)) || c2_assert("analyser/scope.c2", 121, "scope.Scope.addImports", "decl.isImport()");
         ast_ImportDecl* other = ((ast_ImportDecl*)(decl));
         diagnostics_Diags_note(s->diags, ast_ImportDecl_getLoc(other), "previous definition is here");
         continue;
      }
      decl = ast_SymbolTable_find(s->symbols, name_idx);
      if (decl) {
         diagnostics_Diags_error(s->diags, ast_ImportDecl_getLoc(id), "import redefinition of '%s'", ast_idx2name(name_idx));
         diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
         continue;
      }
      scope_Scope_stack_add(s, name_idx, d);
   }
}

static void scope_Scope_enter(scope_Scope* s, uint32_t flags)
{
   if ((s->lvl == constants_MaxScopes)) {
      diagnostics_Diags_error(s->diags, 0, "max scope depth reached");
      (0) || c2_assert("analyser/scope.c2", 142, "scope.Scope.enter", "0");
      return;
   }
   scope_Level* top = &s->levels[s->lvl];
   if (s->lvl) {
      const scope_Level* parent = &s->levels[(s->lvl - 1)];
      flags |= ((parent->flags & ((scope_Break | scope_Continue))));
   }
   top->flags = flags;
   top->first_index = s->stack_count;
   s->lvl++;
}

static void scope_Scope_exit(scope_Scope* s, _Bool has_error)
{
   ((s->lvl != 0)) || c2_assert("analyser/scope.c2", 156, "scope.Scope.exit", "s.lvl != 0");
   s->lvl--;
   uint32_t first = s->levels[s->lvl].first_index;
   if ((s->warn_on_unused && !has_error)) {
      uint32_t last = s->stack_count;
      for (uint32_t i = first; (i < last); i++) {
         ast_Decl* d = s->stack_decls[i];
         if (!ast_Decl_isUsed(d)) {
            ast_VarDecl* vd = ((ast_VarDecl*)(d));
            if (ast_VarDecl_isLocal(vd)) diagnostics_Diags_warn(s->diags, ast_Decl_getLoc(d), "unused variable '%s'", ast_Decl_getName(d));
         }
      }
   }
   s->stack_count = first;
}

static ast_Decl* scope_Scope_stack_find(const scope_Scope* s, uint32_t name_idx)
{
   for (uint32_t i = 0; (i < s->stack_count); i++) {
      if ((s->stack_symbols[i] == name_idx)) return s->stack_decls[i];

   }
   return NULL;
}

static void scope_Scope_stack_add(scope_Scope* s, uint32_t name_idx, ast_Decl* d)
{
   if ((s->stack_count == s->stack_capacity)) scope_Scope_stack_resize(s, (s->stack_capacity * 2));
   s->stack_symbols[s->stack_count] = name_idx;
   s->stack_decls[s->stack_count] = d;
   s->stack_count++;
}

static void scope_Scope_stack_resize(scope_Scope* s, uint32_t capacity)
{
   uint32_t* symbols = malloc((capacity * 4));
   ast_Decl** decls = malloc((capacity * 8));
   s->stack_capacity = capacity;
   if (s->stack_count) {
      memcpy(symbols, s->stack_symbols, (s->stack_count * 4));
      memcpy(decls, s->stack_decls, (s->stack_count * 8));
      free(s->stack_decls);
      free(s->stack_symbols);
   }
   s->stack_symbols = symbols;
   s->stack_decls = decls;
}

static void scope_Scope_cache_resize(scope_Scope* s, uint32_t capacity)
{
   uint32_t* symbols = malloc((capacity * 4));
   ast_Decl** decls = malloc((capacity * 8));
   ast_ImportDecl** imports = malloc((capacity * 8));
   s->cache_capacity = capacity;
   if (s->cache_count) {
      memcpy(symbols, s->cache_symbols, (s->cache_count * 4));
      memcpy(decls, s->cache_decls, (s->cache_count * 8));
      memcpy(imports, s->cache_imports, (s->cache_count * 8));
      free(s->cache_imports);
      free(s->cache_decls);
      free(s->cache_symbols);
   }
   s->cache_symbols = symbols;
   s->cache_decls = decls;
   s->cache_imports = imports;
}

static void scope_Scope_setUnreachable(scope_Scope* s)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 223, "scope.Scope.setUnreachable", "s.lvl");
   scope_Level* top = &s->levels[(s->lvl - 1)];
   top->flags |= scope_Unreachable;
}

static void scope_Scope_setReachable(scope_Scope* s)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 229, "scope.Scope.setReachable", "s.lvl");
   scope_Level* top = &s->levels[(s->lvl - 1)];
   top->flags &= ~scope_Unreachable;
}

static _Bool scope_Scope_isUnreachable(const scope_Scope* s)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 235, "scope.Scope.isUnreachable", "s.lvl");
   const scope_Level* top = &s->levels[(s->lvl - 1)];
   return ((top->flags & scope_Unreachable));
}

static _Bool scope_Scope_allowBreak(const scope_Scope* s)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 241, "scope.Scope.allowBreak", "s.lvl");
   const scope_Level* top = &s->levels[(s->lvl - 1)];
   return ((top->flags & scope_Break));
}

static _Bool scope_Scope_allowContinue(const scope_Scope* s)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 247, "scope.Scope.allowContinue", "s.lvl");
   const scope_Level* top = &s->levels[(s->lvl - 1)];
   return ((top->flags & scope_Continue));
}

static _Bool scope_Scope_allowFallthrough(const scope_Scope* s)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 253, "scope.Scope.allowFallthrough", "s.lvl");
   const scope_Level* top = &s->levels[(s->lvl - 1)];
   return ((top->flags & scope_Fallthrough));
}

static _Bool scope_Scope_inFunction(const scope_Scope* s)
{
   const scope_Level* top = &s->levels[0];
   return ((top->flags & scope_Function));
}

static _Bool scope_Scope_add(scope_Scope* s, ast_Decl* d)
{
   (s->lvl) || c2_assert("analyser/scope.c2", 265, "scope.Scope.add", "s.lvl");
   const uint32_t name_idx = ast_Decl_getNameIdx(d);
   ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
   if (decl) {
      diagnostics_Diags_error(s->diags, ast_Decl_getLoc(d), "redefinition of '%s'", ast_Decl_getName(decl));
      diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
      return true;
   }
   _Bool other_error = false;
   decl = scope_Scope_findGlobalSymbol(s, name_idx, ast_Decl_getLoc(d), &other_error, false, false);
   if (decl) {
      diagnostics_Diags_error(s->diags, ast_Decl_getLoc(d), "redefinition of '%s'", ast_Decl_getName(decl));
      diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
      return true;
   }
   scope_Scope_stack_add(s, name_idx, d);
   return false;
}

static ast_Decl* scope_Scope_find(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, _Bool usedPublic)
{
   ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
   if (decl) {
      if (ast_Decl_isImport(decl)) {
         ast_Decl_setUsed(decl);
         if (usedPublic) ast_Decl_setUsedPublic(decl);
      }
      return decl;
   }
   _Bool other_error = false;
   decl = scope_Scope_findGlobalSymbol(s, name_idx, loc, &other_error, usedPublic, true);
   if ((!decl && !other_error)) {
      const char* name = ast_idx2name(name_idx);
      ast_ImportDecl* id = ast_ImportDeclList_findAny(s->imports, name_idx);
      if (id) {
         diagnostics_Diags_error(s->diags, loc, "module '%s' is imported with alias '%s'", ast_Decl_getName(ast_ImportDecl_asDecl(id)), ast_ImportDecl_getAliasName(id));
      } else {
         diagnostics_Diags_error(s->diags, loc, "use of undeclared identifier '%s'", name);
      }
      return NULL;
   }
   return decl;
}

static _Bool scope_Scope_checkGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc)
{
   uint32_t num_imports = ast_ImportDeclList_size(s->imports);
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(s->imports);
   ast_Decl* decl = NULL;
   for (uint32_t i = 0; (i < num_imports); i++) {
      ast_ImportDecl* id = imports[i];
      if ((name_idx == ast_ImportDecl_getImportNameIdx(id))) {
         decl = ((ast_Decl*)(id));
         break;
      }
      if (ast_ImportDecl_isLocal(id)) {
         ast_Module* dest = ast_ImportDecl_getDest(id);
         decl = ast_Module_findSymbol(dest, name_idx);
         if (decl) break;

      }
   }
   if (decl) {
      diagnostics_Diags_error(s->diags, loc, "redefinition of '%s'", ast_idx2name(name_idx));
      diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
      return false;
   }
   return true;
}

static ast_ImportDecl* scope_Scope_findModule(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc)
{
   (s) || c2_assert("analyser/scope.c2", 347, "scope.Scope.findModule", "s");
   ast_ImportDecl* d = ast_ImportDeclList_find(s->imports, name_idx);
   if (d) {
      ast_Decl_setUsed(ast_ImportDecl_asDecl(d));
      return d;
   }
   d = ast_ImportDeclList_findAny(s->imports, name_idx);
   if (d) {
      diagnostics_Diags_error(s->diags, loc, "module '%s' is imported with alias '%s'", ast_Decl_getName(ast_ImportDecl_asDecl(d)), ast_ImportDecl_getAliasName(d));
      return NULL;
   }
   ast_Module* mod = module_list_List_find(s->allmodules, name_idx);
   if (mod) {
      diagnostics_Diags_error(s->diags, loc, "module %s not imported", ast_idx2name(name_idx));
   } else {
      diagnostics_Diags_error(s->diags, loc, "unknown module: '%s'", ast_idx2name(name_idx));
   }
   return NULL;
}

static ast_Decl* scope_Scope_findSymbolInModule(scope_Scope* s, ast_Module* mod, uint32_t name_idx, src_loc_SrcLoc loc)
{
   (s) || c2_assert("analyser/scope.c2", 370, "scope.Scope.findSymbolInModule", "s");
   ast_Decl* d = ast_Module_findSymbol(mod, name_idx);
   if (!d) {
      diagnostics_Diags_error(s->diags, loc, "module '%s' has no symbol '%s'", ast_Module_getName(mod), ast_idx2name(name_idx));
      return NULL;
   }
   if ((mod != s->mod)) {
      if (!ast_Decl_isPublic(d)) {
         diagnostics_Diags_error(s->diags, loc, "symbol '%s' is not public", ast_Decl_getFullName(d));
         return NULL;
      }
      ast_Decl_setUsedPublic(d);
   }
   return d;
}

static ast_Decl* scope_Scope_findType(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, _Bool usedPublic)
{
   (s) || c2_assert("analyser/scope.c2", 389, "scope.Scope.findType", "s");
   ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
   if (decl) return decl;

   _Bool other_error = false;
   decl = scope_Scope_findGlobalSymbol(s, name_idx, loc, &other_error, usedPublic, true);
   if ((!decl && !other_error)) {
      diagnostics_Diags_error(s->diags, loc, "unknown type '%s'", ast_idx2name(name_idx));
   }
   return decl;
}

static ast_Decl* scope_Scope_findGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, _Bool* other_error, _Bool usedPublic, _Bool search_privates)
{
   for (uint32_t i = 0; (i < s->cache_count); i++) {
      if ((s->cache_symbols[i] == name_idx)) {
         ast_Decl* decl = s->cache_decls[i];
         ast_ImportDecl* used_import = s->cache_imports[i];
         _Bool external = (((ast_ImportDecl_getDest(used_import) != s->mod)) && ((((ast_Decl*)(used_import)) != decl)));
         if ((external || usedPublic)) {
            ast_Decl_setUsedPublic(decl);
            if (usedPublic) {
               ast_Decl_setUsedPublic(ast_ImportDecl_asDecl(used_import));
            }
         }
         return decl;
      }
   }
   ast_Decl* decl = NULL;
   ast_ImportDecl* used_import = NULL;
   _Bool ambiguous = false;
   uint32_t num_imports = ast_ImportDeclList_size(s->imports);
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(s->imports);
   for (uint32_t i = 0; (i < num_imports); i++) {
      ast_ImportDecl* id = imports[i];
      if (!ast_ImportDecl_isLocal(id)) continue;

      ast_Module* dest = ast_ImportDecl_getDest(id);
      ast_Decl* d;
      if ((s->mod == dest)) {
         d = ast_Module_findSymbol(dest, name_idx);
      } else {
         d = ast_Module_findPublicSymbol(dest, name_idx);
      }
      if (!d) continue;

      if (decl) {
         const char* name = ast_idx2name(name_idx);
         if (!ambiguous) {
            diagnostics_Diags_error(s->diags, loc, "symbol '%s' is ambiguous", name);
            diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "did you mean '%s'?", ast_Decl_getFullName(decl));
            diagnostics_Diags_note(s->diags, ast_Decl_getLoc(d), "did you mean '%s'?", ast_Decl_getFullName(d));
            ambiguous = true;
            *other_error = true;
         } else {
            diagnostics_Diags_note(s->diags, ast_Decl_getLoc(d), "did you mean '%s'?", ast_Decl_getFullName(d));
         }
         continue;
      } else {
         decl = d;
         used_import = id;
      }
   }
   if (ambiguous) return NULL;

   if (decl) {
      _Bool external = (((ast_ImportDecl_getDest(used_import) != s->mod)) && ((((ast_Decl*)(used_import)) != decl)));
      ast_Decl_setUsed(ast_ImportDecl_asDecl(used_import));
      if ((external || usedPublic)) {
         ast_Decl_setUsedPublic(decl);
         if (usedPublic) {
            ast_Decl_setUsedPublic(ast_ImportDecl_asDecl(used_import));
         }
      }
      if ((s->cache_count == s->cache_capacity)) {
         scope_Scope_cache_resize(s, (s->cache_capacity * 2));
      }
      s->cache_symbols[s->cache_count] = name_idx;
      s->cache_decls[s->cache_count] = decl;
      s->cache_imports[s->cache_count] = used_import;
      s->cache_count++;
   } else {
      if (search_privates) {
         for (uint32_t i = 0; (i < num_imports); i++) {
            ast_ImportDecl* id = imports[i];
            if (!ast_ImportDecl_isLocal(id)) continue;

            ast_Module* dest = ast_ImportDecl_getDest(id);
            ast_Decl* d = ast_Module_findPrivateSymbol(dest, name_idx);
            if (d) {
               diagnostics_Diags_error(s->diags, loc, "symbol '%s' is not public", ast_Decl_getFullName(d));
               *other_error = true;
               return NULL;
            }
         }
      }
   }
   return decl;
}

static void scope_Scope_dump(const scope_Scope* s)
{
   printf("Scope (lvl %u) %u\n", s->lvl, s->stack_count);
   for (uint32_t i = 0; (i < s->lvl); i++) {
      const scope_Level* l = &s->levels[i];
      printf("  [%u]  start %2u  flags 0x%02x\n", i, l->first_index, l->flags);
   }
}

static _Bool scope_Scope_checkAccess(scope_Scope* s, ast_Decl* d, src_loc_SrcLoc loc)
{
   _Bool external = ((s->mod != ast_Decl_getModule(d)));
   if (external) {
      if (ast_Decl_isPublic(d)) {
         ast_Decl_setUsedPublic(d);
      } else {
         diagnostics_Diags_error(s->diags, loc, "symbol '%s' is not public", ast_Decl_getFullName(d));
         return false;
      }
   }
   return true;
}


// --- module struct_func_list ---
typedef struct struct_func_list_Info_ struct_func_list_Info;
typedef struct struct_func_list_List_ struct_func_list_List;

struct struct_func_list_Info_ {
   ast_Decl* decl;
   ast_FunctionDeclList functions;
};

struct struct_func_list_List_ {
   struct_func_list_Info* data;
   uint32_t count;
   uint32_t capacity;
};

static void struct_func_list_List_free(struct_func_list_List* v);
static void struct_func_list_List_resize(struct_func_list_List* v);
static void struct_func_list_List_addDecl(struct_func_list_List* v, ast_Decl* decl);
static ast_Decl* struct_func_list_List_getDecl(struct_func_list_List* v, uint32_t index);
static void struct_func_list_List_addFunc(struct_func_list_List* v, uint32_t index, ast_FunctionDecl* fd);
static ast_FunctionDecl* struct_func_list_List_findFunc(struct_func_list_List* v, uint32_t index, uint32_t name_idx);

static void struct_func_list_List_free(struct_func_list_List* v)
{
   for (uint32_t i = 0; (i < v->count); i++) {
      ast_FunctionDeclList_free(&v->data[i].functions);
   }
   free(v->data);
   v->count = 0;
   v->capacity = 0;
   v->data = NULL;
}

static void struct_func_list_List_resize(struct_func_list_List* v)
{
   v->capacity = (v->capacity == 0) ? 4 : (v->capacity * 2);
   struct_func_list_Info* data2 = malloc((v->capacity * 24));
   if (v->data) {
      memcpy(data2, v->data, (v->count * 24));
      free(v->data);
   }
   v->data = data2;
}

static void struct_func_list_List_addDecl(struct_func_list_List* v, ast_Decl* decl)
{
   if ((v->count == v->capacity)) struct_func_list_List_resize(v);
   struct_func_list_Info* info = &v->data[v->count];
   info->decl = decl;
   ast_FunctionDeclList_init(&info->functions);
   v->count++;
}

static ast_Decl* struct_func_list_List_getDecl(struct_func_list_List* v, uint32_t index)
{
   return v->data[index].decl;
}

static void struct_func_list_List_addFunc(struct_func_list_List* v, uint32_t index, ast_FunctionDecl* fd)
{
   ((index < v->count)) || c2_assert("analyser/struct_func_list.c2", 70, "struct_func_list.List.addFunc", "index < v.count");
   struct_func_list_Info* info = &v->data[index];
   ast_FunctionDeclList_add(&info->functions, fd);
}

static ast_FunctionDecl* struct_func_list_List_findFunc(struct_func_list_List* v, uint32_t index, uint32_t name_idx)
{
   ((index < v->count)) || c2_assert("analyser/struct_func_list.c2", 76, "struct_func_list.List.findFunc", "index < v.count");
   struct_func_list_Info* info = &v->data[index];
   return ast_FunctionDeclList_find(&info->functions, name_idx);
}


// --- module unused_checker ---
typedef struct unused_checker_Checker_ unused_checker_Checker;

struct unused_checker_Checker_ {
   diagnostics_Diags* diags;
   const warning_flags_Flags* warnings;
};

static void unused_checker_check(diagnostics_Diags* diags, const warning_flags_Flags* warnings, ast_Module* mod);
static void unused_checker_Checker_unused_module(void* arg, ast_AST* a);
static void unused_checker_Checker_check(void* arg, ast_Decl* d);
static void unused_checker_Checker_checkEnum(unused_checker_Checker* c, ast_EnumTypeDecl* d);
static void unused_checker_Checker_checkStructMembers(unused_checker_Checker* c, ast_Decl* d);

static void unused_checker_check(diagnostics_Diags* diags, const warning_flags_Flags* warnings, ast_Module* mod)
{
   unused_checker_Checker c = { .diags = diags, .warnings = warnings };
   if (ast_Module_isUsed(mod)) {
      ast_Module_visitDecls(mod, unused_checker_Checker_check, &c);
   } else {
      ast_Module_visitASTs(mod, unused_checker_Checker_unused_module, &c);
   }
}

static void unused_checker_Checker_unused_module(void* arg, ast_AST* a)
{
   unused_checker_Checker* c = arg;
   diagnostics_Diags_warn(c->diags, ast_AST_getLoc(a), "unused module '%s'", ast_AST_getName(a));
}

static void unused_checker_Checker_check(void* arg, ast_Decl* d)
{
   unused_checker_Checker* c = arg;
   _Bool used = ast_Decl_isUsed(d);
   if (((((used && ast_Decl_isPublic(d)) && !ast_Decl_isUsedPublic(d)) && !c->warnings->no_unused_public) && !ast_Decl_hasAttrUnused(d))) {
      diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(d), "%s '%s' is not used public", ast_Decl_getKindName(d), ast_Decl_getFullName(d));
   }
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      if (c->warnings->no_unused_function) return;

      if (ast_Decl_hasAttrUnused(d)) return;

      break;
   case ast_DeclKind_Import:
      if (c->warnings->no_unused_import) return;

      break;
   case ast_DeclKind_StructType:
      if (used) {
         unused_checker_Checker_checkStructMembers(c, d);
      }
      if (c->warnings->no_unused_type) return;

      break;
   case ast_DeclKind_EnumType:
      if ((used && !c->warnings->no_unused_enum_constant)) {
         unused_checker_Checker_checkEnum(c, ((ast_EnumTypeDecl*)(d)));
      }
      break;
   case ast_DeclKind_EnumConstant:
      break;
   case ast_DeclKind_FunctionType:
      if (c->warnings->no_unused_type) return;

      break;
   case ast_DeclKind_AliasType:
      if (c->warnings->no_unused_type) return;

      break;
   case ast_DeclKind_Variable:
      if (c->warnings->no_unused_variable) return;

      break;
   }
   if (((!used && !ast_Decl_hasAttrUnused(d)) && !ast_Decl_isExported(d))) {
      diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(d), "unused %s '%s'", ast_Decl_getKindName(d), ast_Decl_getFullName(d));
      return;
   }
}

static void unused_checker_Checker_checkEnum(unused_checker_Checker* c, ast_EnumTypeDecl* d)
{
   uint32_t num_consts = ast_EnumTypeDecl_getNumConstants(d);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(d);
   for (uint32_t i = 0; (i < num_consts); i++) {
      ast_EnumConstantDecl* ecd = constants[i];
      ast_Decl* dd = ((ast_Decl*)(ecd));
      if (!ast_Decl_isUsed(dd)) {
         diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(dd), "unused %s '%s'", ast_Decl_getKindName(dd), ast_Decl_getName(dd));
      }
   }
}

static void unused_checker_Checker_checkStructMembers(unused_checker_Checker* c, ast_Decl* d)
{
   ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   for (uint32_t i = 0; (i < num_members); i++) {
      ast_Decl* member = members[i];
      if (ast_Decl_isStructType(member)) {
         unused_checker_Checker_checkStructMembers(c, member);
      } else {
         if ((!ast_Decl_isUsed(member) && !c->warnings->no_unused_variable)) {
            diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(member), "unused %s member '%s'", ast_StructTypeDecl_isStruct(std) ? "struct" : "union", ast_Decl_getName(member));
         }
      }
   }
}


// --- module ctv_analyser ---
typedef struct ctv_analyser_Limit_ ctv_analyser_Limit;

struct ctv_analyser_Limit_ {
   int64_t min_val;
   uint64_t max_val;
   const char* min_str;
   const char* max_str;
};

static const ctv_analyser_Limit ctv_analyser_Limits[9] = {
   { 0, 1, "0", "1" },
   { -128, 127, "-128", "127" },
   { 0, 255, "0", "255" },
   { -32768, 32767, "-32768", "32767" },
   { 0, 65535, "0", "65535" },
   { (-2147483647 - 1), 2147483647, "-2147483648", "2147483647" },
   { 0, 4294967295, "0", "4294967295" },
   { (-9223372036854775807lu - 1), 9223372036854775807lu, "-9223372036854775808", "9223372036854775807" },
   { 0, 18446744073709551615lu, "0", "18446744073709551615" }
};

static const ctv_analyser_Limit* ctv_analyser_getLimit(uint32_t width);
static ast_Value ctv_analyser_get_value(const ast_Expr* e);
static ast_Value ctv_analyser_get_decl_value(const ast_Decl* d);
static ast_Value ctv_analyser_get_unaryop_value(const ast_UnaryOperator* e);
static ast_Value ctv_analyser_get_binaryop_value(const ast_BinaryOperator* e);
static _Bool ctv_analyser_check(diagnostics_Diags* diags, ast_QualType qt, const ast_Expr* e);
static _Bool ctv_analyser_checkRange(diagnostics_Diags* diags, ast_QualType qt, ast_Value* value, src_loc_SrcLoc loc, const ast_Expr* e);

static const ctv_analyser_Limit* ctv_analyser_getLimit(uint32_t width)
{
   switch (width) {
   case 1:
      return &ctv_analyser_Limits[0];
   case 7:
      return &ctv_analyser_Limits[1];
   case 8:
      return &ctv_analyser_Limits[2];
   case 15:
      return &ctv_analyser_Limits[3];
   case 16:
      return &ctv_analyser_Limits[4];
   case 31:
      return &ctv_analyser_Limits[5];
   case 32:
      return &ctv_analyser_Limits[6];
   case 63:
      return &ctv_analyser_Limits[7];
   case 64:
      return &ctv_analyser_Limits[8];
   }
   (0) || c2_assert("analyser_utils/ctv_analyser.c2", 62, "ctv_analyser.getLimit", "0");
   return NULL;
}

static ast_Value ctv_analyser_get_value(const ast_Expr* e)
{
   ast_Value result = { };
   if (!ast_Expr_isCtv(e)) {
      ast_Expr_dump(e);
      (ast_Expr_isCtv(e)) || c2_assert("analyser_utils/ctv_analyser.c2", 72, "ctv_analyser.get_value", "e.isCtv()");
   }
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral: {
      const ast_IntegerLiteral* i = ((ast_IntegerLiteral*)(e));
      if (ast_IntegerLiteral_isSigned(i)) ast_Value_setSigned(&result, ((int64_t)(ast_IntegerLiteral_getValue(i))));
      else ast_Value_setUnsigned(&result, ast_IntegerLiteral_getValue(i));
      break;
   }
   case ast_ExprKind_FloatLiteral: {
      const ast_FloatLiteral* f = ((ast_FloatLiteral*)(e));
      ast_Value_setFloat(&result, ast_FloatLiteral_getValue(f));
      break;
   }
   case ast_ExprKind_BooleanLiteral: {
      const ast_BooleanLiteral* b = ((ast_BooleanLiteral*)(e));
      ast_Value_setUnsigned(&result, ast_BooleanLiteral_getValue(b));
      break;
   }
   case ast_ExprKind_CharLiteral: {
      const ast_CharLiteral* c = ((ast_CharLiteral*)(e));
      ast_Value_setUnsigned(&result, ((uint8_t)(ast_CharLiteral_getValue(c))));
      break;
   }
   case ast_ExprKind_StringLiteral:
      (0) || c2_assert("analyser_utils/ctv_analyser.c2", 96, "ctv_analyser.get_value", "0");
      break;
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      const ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      return ctv_analyser_get_decl_value(ast_IdentifierExpr_getDecl(i));
   }
   case ast_ExprKind_Type:
      fallthrough;
   case ast_ExprKind_Call:
      fallthrough;
   case ast_ExprKind_InitList:
      fallthrough;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return ctv_analyser_get_binaryop_value(((ast_BinaryOperator*)(e)));
   case ast_ExprKind_UnaryOperator:
      return ctv_analyser_get_unaryop_value(((ast_UnaryOperator*)(e)));
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = ((ast_ConditionalOperator*)(e));
      ast_Value v = ctv_analyser_get_value(ast_ConditionalOperator_getCond(c));
      return !ast_Value_isZero(&v) ? ctv_analyser_get_value(ast_ConditionalOperator_getLHS(c)) : ctv_analyser_get_value(ast_ConditionalOperator_getRHS(c));
   }
   case ast_ExprKind_Builtin: {
      const ast_BuiltinExpr* bi = ((ast_BuiltinExpr*)(e));
      result = ast_BuiltinExpr_getValue(bi);
      break;
   }
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      result = ctv_analyser_get_value(ast_ArraySubscriptExpr_getBase(a));
      ((ast_Value_isDecimal(&result) && !ast_Value_isNegative(&result))) || c2_assert("analyser_utils/ctv_analyser.c2", 128, "ctv_analyser.get_value", "result.isDecimal() && !result.isNegative()");
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      (ast_Expr_isBitOffset(index)) || c2_assert("analyser_utils/ctv_analyser.c2", 131, "ctv_analyser.get_value", "index.isBitOffset()");
      ast_BitOffsetExpr* bo = ((ast_BitOffsetExpr*)(index));
      ast_Value high = ctv_analyser_get_value(ast_BitOffsetExpr_getLHS(bo));
      ast_Value low = ctv_analyser_get_value(ast_BitOffsetExpr_getRHS(bo));
      ast_Value width = ast_Value_minus(&high, &low);
      ast_Value_incr(&width);
      result = ast_Value_right_shift(&result, &low);
      ast_Value_mask(&result, ast_Value_as_u32(&width));
      break;
   }
   case ast_ExprKind_Member: {
      const ast_MemberExpr* m = ((ast_MemberExpr*)(e));
      return ctv_analyser_get_decl_value(ast_MemberExpr_getFullDecl(m));
   }
   case ast_ExprKind_Paren: {
      const ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      return ctv_analyser_get_value(ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      (0) || c2_assert("analyser_utils/ctv_analyser.c2", 148, "ctv_analyser.get_value", "0");
      break;
   case ast_ExprKind_ExplicitCast: {
      const ast_ExplicitCastExpr* i = ((ast_ExplicitCastExpr*)(e));
      result = ctv_analyser_get_value(ast_ExplicitCastExpr_getInner(i));
      ast_QualType qt = ast_Expr_getType(e);
      qt = ast_QualType_getCanonicalType(&qt);
      if (ast_QualType_isEnum(&qt)) qt = ast_EnumType_getImplType(ast_QualType_getEnum(&qt));
      (ast_QualType_isBuiltin(&qt)) || c2_assert("analyser_utils/ctv_analyser.c2", 157, "ctv_analyser.get_value", "qt.isBuiltin()");
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&qt);
      if (ast_QualType_isFloat(&qt)) {
         if (ast_Value_isDecimal(&result)) ast_Value_setFloat(&result, ast_Value_toFloat(&result));
         if ((ast_BuiltinType_getWidth(bi) == 32)) {
            ast_Value_setFloat(&result, ((float)(ast_Value_toFloat(&result))));
         }
      } else if (ast_QualType_isBool(&qt)) {
         ast_Value_setUnsigned(&result, !ast_Value_isZero(&result));
      } else {
         if (!ast_Value_isDecimal(&result)) {
            if (ast_BuiltinType_isSigned(bi)) {
               ast_Value_setSigned(&result, ((int64_t)(ast_Value_toFloat(&result))));
            } else {
               ast_Value_setUnsigned(&result, ((uint64_t)(ast_Value_toFloat(&result))));
            }
         }
         ast_Value_truncate(&result, ast_BuiltinType_isSigned(bi), ast_BuiltinType_getWidth(bi));
      }

      break;
   }
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* i = ((ast_ImplicitCastExpr*)(e));
      return ctv_analyser_get_value(ast_ImplicitCastExpr_getInner(i));
   }
   case ast_ExprKind_Range:
      break;
   }
   return result;
}

static ast_Value ctv_analyser_get_decl_value(const ast_Decl* d)
{
   (d) || c2_assert("analyser_utils/ctv_analyser.c2", 192, "ctv_analyser.get_decl_value", "d");
   ast_Value result = { };
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_EnumConstant: {
      const ast_EnumConstantDecl* ecd = ((ast_EnumConstantDecl*)(d));
      result = ast_EnumConstantDecl_getValue(ecd);
      break;
   }
   case ast_DeclKind_Variable: {
      const ast_VarDecl* vd = ((ast_VarDecl*)(d));
      const ast_Expr* initval = ast_VarDecl_getInit(vd);
      (initval) || c2_assert("analyser_utils/ctv_analyser.c2", 202, "ctv_analyser.get_decl_value", "initval");
      return ctv_analyser_get_value(initval);
   }
   default:
      (0) || c2_assert("analyser_utils/ctv_analyser.c2", 205, "ctv_analyser.get_decl_value", "0");
      break;
   }
   return result;
}

static ast_Value ctv_analyser_get_unaryop_value(const ast_UnaryOperator* e)
{
   ast_Value result = { };
   const ast_Expr* inner = ast_UnaryOperator_getInner(e);
   ast_Value res2 = ctv_analyser_get_value(inner);
   switch (ast_UnaryOperator_getOpcode(e)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec:
      fallthrough;
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec:
      break;
   case ast_UnaryOpcode_AddrOf:
      fallthrough;
   case ast_UnaryOpcode_Deref:
      break;
   case ast_UnaryOpcode_Plus:
      result = res2;
      break;
   case ast_UnaryOpcode_Minus:
      result = ast_Value_negate(&res2);
      break;
   case ast_UnaryOpcode_Not:
      (ast_Value_isDecimal(&res2)) || c2_assert("analyser_utils/ctv_analyser.c2", 234, "ctv_analyser.get_unaryop_value", "res2.isDecimal()");
      result = ast_Value_bitnot(&res2);
      break;
   case ast_UnaryOpcode_LNot:
      (ast_Value_isDecimal(&res2)) || c2_assert("analyser_utils/ctv_analyser.c2", 238, "ctv_analyser.get_unaryop_value", "res2.isDecimal()");
      result = ast_Value_lnot(&res2);
      break;
   }
   return result;
}

static ast_Value ctv_analyser_get_binaryop_value(const ast_BinaryOperator* e)
{
   ast_Value result = { };
   ast_Value left = ctv_analyser_get_value(ast_BinaryOperator_getLHS(e));
   ast_Value right = ctv_analyser_get_value(ast_BinaryOperator_getRHS(e));
   switch (ast_BinaryOperator_getOpcode(e)) {
   case ast_BinaryOpcode_Multiply:
      result = ast_Value_multiply(&left, &right);
      break;
   case ast_BinaryOpcode_Divide:
      result = ast_Value_divide(&left, &right);
      break;
   case ast_BinaryOpcode_Remainder:
      result = ast_Value_remainder(&left, &right);
      break;
   case ast_BinaryOpcode_Add:
      result = ast_Value_add(&left, &right);
      break;
   case ast_BinaryOpcode_Subtract:
      result = ast_Value_minus(&left, &right);
      break;
   case ast_BinaryOpcode_ShiftLeft:
      result = ast_Value_left_shift(&left, &right);
      break;
   case ast_BinaryOpcode_ShiftRight:
      result = ast_Value_right_shift(&left, &right);
      break;
   case ast_BinaryOpcode_LessThan:
      ast_Value_setUnsigned(&result, ast_Value_is_less(&left, &right));
      break;
   case ast_BinaryOpcode_GreaterThan:
      ast_Value_setUnsigned(&result, ast_Value_is_greater(&left, &right));
      break;
   case ast_BinaryOpcode_LessEqual:
      ast_Value_setUnsigned(&result, ast_Value_is_less_equal(&left, &right));
      break;
   case ast_BinaryOpcode_GreaterEqual:
      ast_Value_setUnsigned(&result, ast_Value_is_greater_equal(&left, &right));
      break;
   case ast_BinaryOpcode_Equal:
      ast_Value_setUnsigned(&result, ast_Value_is_equal(&left, &right));
      break;
   case ast_BinaryOpcode_NotEqual:
      ast_Value_setUnsigned(&result, !ast_Value_is_equal(&left, &right));
      break;
   case ast_BinaryOpcode_And:
      result = ast_Value_and(&left, &right);
      break;
   case ast_BinaryOpcode_Xor:
      result = ast_Value_xor(&left, &right);
      break;
   case ast_BinaryOpcode_Or:
      result = ast_Value_or(&left, &right);
      break;
   case ast_BinaryOpcode_LAnd:
      result = ast_Value_land(&left, &right);
      break;
   case ast_BinaryOpcode_LOr:
      result = ast_Value_lor(&left, &right);
      break;
   case ast_BinaryOpcode_Assign:
      fallthrough;
   case ast_BinaryOpcode_MulAssign:
      fallthrough;
   case ast_BinaryOpcode_DivAssign:
      fallthrough;
   case ast_BinaryOpcode_RemAssign:
      fallthrough;
   case ast_BinaryOpcode_AddAssign:
      fallthrough;
   case ast_BinaryOpcode_SubAssign:
      fallthrough;
   case ast_BinaryOpcode_ShlAssign:
      fallthrough;
   case ast_BinaryOpcode_ShrAssign:
      fallthrough;
   case ast_BinaryOpcode_AndAssign:
      fallthrough;
   case ast_BinaryOpcode_XorAssign:
      fallthrough;
   case ast_BinaryOpcode_OrAssign:
      (0) || c2_assert("analyser_utils/ctv_analyser.c2", 324, "ctv_analyser.get_binaryop_value", "0");
      break;
   }
   return result;
}

static _Bool ctv_analyser_check(diagnostics_Diags* diags, ast_QualType qt, const ast_Expr* e)
{
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   if (!ast_QualType_isBuiltin(&canon)) return true;

   (ast_Expr_isCtv(e)) || c2_assert("analyser_utils/ctv_analyser.c2", 334, "ctv_analyser.check", "e.isCtv()");
   ast_Value value = ctv_analyser_get_value((e));
   return ctv_analyser_checkRange(diags, qt, &value, 0, e);
}

static _Bool ctv_analyser_checkRange(diagnostics_Diags* diags, ast_QualType qt, ast_Value* value, src_loc_SrcLoc loc, const ast_Expr* e)
{
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   if (!ast_QualType_isBuiltin(&canon)) return true;

   if ((e && ast_Expr_isTilde(e))) return true;

   ast_BuiltinType* bi = ast_QualType_getBuiltin(&canon);
   uint32_t width = ast_BuiltinType_getWidth(bi);
   if (((ast_BuiltinType_getKind(bi) == ast_BuiltinKind_Float32) || (ast_BuiltinType_getKind(bi) == ast_BuiltinKind_Float64))) return true;

   const ctv_analyser_Limit* limit = ctv_analyser_getLimit(width);
   if (!ast_Value_checkRange(value, limit->min_val, limit->max_val)) {
      if (e) {
         diagnostics_Diags_errorRange(diags, ast_Expr_getLoc(e), ast_Expr_getRange(e), "constant value %s out-of-bounds for type '%s', range [%s, %s]", ast_Value_str(value), ast_QualType_diagNameBare(&qt), limit->min_str, limit->max_str);
      } else {
         diagnostics_Diags_error(diags, loc, "constant value %s out-of-bounds for type '%s', range [%s, %s]", ast_Value_str(value), ast_QualType_diagNameBare(&qt), limit->min_str, limit->max_str);
      }
      return false;
   }
   return true;
}


// --- module printf_utils ---

typedef enum {
   printf_utils_Specifier_Other,
   printf_utils_Specifier_String,
   printf_utils_Specifier_Char,
   printf_utils_Specifier_Integer,
   printf_utils_Specifier_FloatingPoint,
   printf_utils_Specifier_Pointer,
   printf_utils_Specifier_Invalid,
   _printf_utils_Specifier_max = 255
} __attribute__((packed)) printf_utils_Specifier;

typedef _Bool (*printf_utils_FormatHandler)(void* arg, printf_utils_Specifier specifier, uint32_t offset, int32_t stars, char letter);

static const char* printf_utils_get_format(ast_Expr* format, src_loc_SrcLoc* format_loc);
static printf_utils_Specifier printf_utils_getSpecifier(const char* format, uint32_t* len, int32_t* pstars, char* c);
static _Bool printf_utils_parseFormat(const char* format, printf_utils_FormatHandler handler, void* arg);

static const char* printf_utils_get_format(ast_Expr* format, src_loc_SrcLoc* format_loc)
{
   const char* format_text = NULL;
   switch (ast_Expr_getKind(format)) {
   case ast_ExprKind_StringLiteral: {
      ast_StringLiteral* s = ((ast_StringLiteral*)(format));
      format_text = ast_StringLiteral_getText(s);
      *format_loc = (ast_Expr_getLoc(format) + 1);
      break;
   }
   case ast_ExprKind_Identifier: {
      ast_QualType qt = ast_Expr_getType(format);
      (ast_QualType_isArray(&qt)) || c2_assert("analyser_utils/printf_utils.c2", 32, "printf_utils.get_format", "qt.isArray()");
      ast_ArrayType* at = ast_QualType_getArrayType(&qt);
      qt = ast_ArrayType_getElemType(at);
      if (!ast_QualType_isConst(&qt)) return NULL;

      ast_IdentifierExpr* id = ((ast_IdentifierExpr*)(format));
      ast_Decl* decl = ast_IdentifierExpr_getDecl(id);
      (ast_Decl_isVariable(decl)) || c2_assert("analyser_utils/printf_utils.c2", 39, "printf_utils.get_format", "decl.isVariable()");
      ast_VarDecl* vd = ((ast_VarDecl*)(decl));
      ast_Expr* initExpr = ast_VarDecl_getInit(vd);
      (initExpr) || c2_assert("analyser_utils/printf_utils.c2", 42, "printf_utils.get_format", "initExpr");
      return printf_utils_get_format(initExpr, format_loc);
   }
   case ast_ExprKind_Member: {
      ast_QualType qt = ast_Expr_getType(format);
      (ast_QualType_isArray(&qt)) || c2_assert("analyser_utils/printf_utils.c2", 46, "printf_utils.get_format", "qt.isArray()");
      ast_ArrayType* at = ast_QualType_getArrayType(&qt);
      qt = ast_ArrayType_getElemType(at);
      if (!ast_QualType_isConst(&qt)) return NULL;

      ast_MemberExpr* m = ((ast_MemberExpr*)(format));
      ast_Decl* decl = ast_MemberExpr_getFullDecl(m);
      (ast_Decl_isVariable(decl)) || c2_assert("analyser_utils/printf_utils.c2", 53, "printf_utils.get_format", "decl.isVariable()");
      ast_VarDecl* vd = ((ast_VarDecl*)(decl));
      ast_Expr* initExpr = ast_VarDecl_getInit(vd);
      (initExpr) || c2_assert("analyser_utils/printf_utils.c2", 56, "printf_utils.get_format", "initExpr");
      return printf_utils_get_format(initExpr, format_loc);
   }
   default:
      (0) || c2_assert("analyser_utils/printf_utils.c2", 59, "printf_utils.get_format", "0");
      break;
   }
   return format_text;
}

static printf_utils_Specifier printf_utils_getSpecifier(const char* format, uint32_t* len, int32_t* pstars, char* c)
{
   const char* cp = format;
   printf_utils_Specifier spec = printf_utils_Specifier_Invalid;
   int32_t stars = 0;
   for (;;) {
      switch (*cp) {
      case ' ':
         fallthrough;
      case '+':
         fallthrough;
      case '-':
         fallthrough;
      case '#':
         fallthrough;
      case '\'':
         fallthrough;
      case '0':
         cp++;
         continue;
      }
      break;
   }
   if ((*cp == '*')) {
      stars++;
      cp++;
   } else {
      while (isdigit(*cp)) {
         cp++;
      }
   }
   if ((*cp == '.')) {
      cp++;
      if ((*cp == '*')) {
         stars++;
         cp++;
      } else {
         while (isdigit(*cp)) {
            cp++;
         }
      }
   }
   switch (*c = *cp) {
   case '%':
      if ((cp == format)) spec = printf_utils_Specifier_Other;
      break;
   case 'c':
      spec = printf_utils_Specifier_Char;
      break;
   case 'a':
      fallthrough;
   case 'e':
      fallthrough;
   case 'f':
      fallthrough;
   case 'g':
      fallthrough;
   case 'A':
      fallthrough;
   case 'E':
      fallthrough;
   case 'F':
      fallthrough;
   case 'G':
      spec = printf_utils_Specifier_FloatingPoint;
      break;
   case 'p':
      spec = printf_utils_Specifier_Pointer;
      break;
   case 's':
      spec = printf_utils_Specifier_String;
      break;
   case 'b':
      fallthrough;
   case 'B':
      fallthrough;
   case 'd':
      fallthrough;
   case 'o':
      fallthrough;
   case 'x':
      fallthrough;
   case 'X':
      spec = printf_utils_Specifier_Integer;
      break;
   }
   *pstars = stars;
   *len = ((uint32_t)((cp - format)));
   return spec;
}

static _Bool printf_utils_parseFormat(const char* format, printf_utils_FormatHandler handler, void* arg)
{
   const char* cp = format;
   while (*cp) {
      if ((*cp++ == '%')) {
         uint32_t len = 0;
         int32_t stars = 0;
         char c = 0;
         printf_utils_Specifier s = printf_utils_getSpecifier(cp, &len, &stars, &c);
         cp += len;
         if ((s != printf_utils_Specifier_Other)) {
            if (!handler(arg, s, ((uint32_t)((cp - format))), stars, c)) return false;

         }
         if (*cp) cp++;
      }
   }
   return true;
}


// --- module c2recipe ---
typedef struct c2recipe_Recipe_ c2recipe_Recipe;
typedef struct c2recipe_Token_ c2recipe_Token;
typedef struct c2recipe_Set_ c2recipe_Set;
typedef struct c2recipe_Parser_ c2recipe_Parser;

struct c2recipe_Recipe_ {
   string_pool_Pool* pool;
   source_mgr_SourceMgr* sm;
   build_target_Target** targets;
   uint32_t num_targets;
   uint32_t max_targets;
   build_target_PluginList plugins;
};

static c2recipe_Recipe* c2recipe_create(source_mgr_SourceMgr* sm, string_pool_Pool* pool);
static void c2recipe_Recipe_free(c2recipe_Recipe* r);
static void c2recipe_Recipe_addPlugin(c2recipe_Recipe* r, uint32_t name, uint32_t options, src_loc_SrcLoc loc);
static build_target_Target* c2recipe_Recipe_addTarget(c2recipe_Recipe* r, uint32_t name, src_loc_SrcLoc loc, build_target_Kind kind);
static _Bool c2recipe_Recipe_parse(c2recipe_Recipe* r, int32_t file_id);
static uint32_t c2recipe_Recipe_numTargets(const c2recipe_Recipe* r);
static build_target_Target* c2recipe_Recipe_getTarget(const c2recipe_Recipe* r, uint32_t idx);
static const build_target_PluginList* c2recipe_Recipe_getPlugins(const c2recipe_Recipe* r);
typedef enum {
   c2recipe_Kind_Plugin,
   c2recipe_Kind_PluginOptions,
   c2recipe_Kind_Text,
   c2recipe_Kind_Executable,
   c2recipe_Kind_Lib,
   c2recipe_Kind_Image,
   c2recipe_Kind_File,
   c2recipe_Kind_End,
   c2recipe_Kind_Warnings,
   c2recipe_Kind_Backend,
   c2recipe_Kind_DisableAsserts,
   c2recipe_Kind_NoLibc,
   c2recipe_Kind_Config,
   c2recipe_Kind_Export,
   c2recipe_Kind_Use,
   c2recipe_Kind_AsmFile,
   c2recipe_Kind_Set,
   c2recipe_Kind_SetUse,
   c2recipe_Kind_Eof,
   _c2recipe_Kind_max = 255
} __attribute__((packed)) c2recipe_Kind;

struct c2recipe_Token_ {
   src_loc_SrcLoc loc;
   c2recipe_Kind kind;
   uint32_t value;
};

struct c2recipe_Set_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   build_target_File* files;
   uint32_t num_files;
   uint32_t max_files;
   c2recipe_Set* next;
};

struct c2recipe_Parser_ {
   c2recipe_Recipe* recipe;
   string_pool_Pool* pool;
   source_mgr_SourceMgr* sm;
   string_list_List global_configs;
   const char* input_start;
   const char* cur;
   src_loc_SrcLoc loc_start;
   __jmp_buf_tag jmpbuf;
   c2recipe_Token token;
   _Bool new_line;
   _Bool targets_started;
   build_target_Target* target;
   c2recipe_Set* sets;
};

static const char* c2recipe_kind_names[19] = {
   "plugin",
   "[plugin_options]",
   "text",
   "executable",
   "lib",
   "image",
   "file",
   "end",
   "$warnings",
   "$backend",
   "$disable-asserts",
   "$nolibc",
   "$config",
   "$export",
   "$use",
   "$asm",
   "set",
   "(set)",
   "eof"
};

static void c2recipe_Token_init(c2recipe_Token* t);
static c2recipe_Set* c2recipe_Set_create(uint32_t name, src_loc_SrcLoc loc, c2recipe_Set* next);
static void c2recipe_Set_free(c2recipe_Set* s);
static _Bool c2recipe_Set_addFile(c2recipe_Set* s, uint32_t filename, src_loc_SrcLoc loc);
static void c2recipe_Parser_free(c2recipe_Parser* p);
static _Bool c2recipe_Parser_parse(c2recipe_Recipe* recipe, string_pool_Pool* pool, source_mgr_SourceMgr* sm, int32_t file_id);
static _Bool c2recipe_Parser_addGlobalFeature(c2recipe_Parser* p, uint32_t feature);
__attribute__((__format__(printf, 2, 3))) 
static void c2recipe_Parser_error(c2recipe_Parser* p, const char* format, ...);
static void c2recipe_Parser_consumeToken(c2recipe_Parser* p);
static void c2recipe_Parser_expect(c2recipe_Parser* p, c2recipe_Kind kind, const char* msg);
static _Bool c2recipe_Parser_is(const c2recipe_Parser* p, c2recipe_Kind kind);
static void c2recipe_Parser_lex(c2recipe_Parser* p, c2recipe_Token* result);
static void c2recipe_Parser_lex_plugin_options(c2recipe_Parser* p, c2recipe_Token* result);
static _Bool c2recipe_is_name(char c);
static void c2recipe_Parser_lex_set_use(c2recipe_Parser* p, c2recipe_Token* result);
static void c2recipe_Parser_lex_option(c2recipe_Parser* p, c2recipe_Token* result);
static void c2recipe_Parser_skip_comments(c2recipe_Parser* p);
static void c2recipe_Parser_parseTop(c2recipe_Parser* p);
static void c2recipe_Parser_parsePlugin(c2recipe_Parser* p, _Bool is_global);
static void c2recipe_Parser_parseWarnings(c2recipe_Parser* p);
static void c2recipe_Parser_parseExecutable(c2recipe_Parser* p);
static void c2recipe_Parser_parseImage(c2recipe_Parser* p);
static void c2recipe_Parser_parseSet(c2recipe_Parser* p);
static c2recipe_Set* c2recipe_Parser_findSet(c2recipe_Parser* p, uint32_t name_idx);
static void c2recipe_Parser_parseLibrary(c2recipe_Parser* p);
static void c2recipe_Parser_parseTarget(c2recipe_Parser* p);
static void c2recipe_Parser_parseBackend(c2recipe_Parser* p);
static void c2recipe_Parser_parseBackEndOptions(c2recipe_Parser* p);
static _Bool c2recipe_equals(const char* str, const char* expect, uint32_t len);

static c2recipe_Recipe* c2recipe_create(source_mgr_SourceMgr* sm, string_pool_Pool* pool)
{
   c2recipe_Recipe* r = calloc(1, 48);
   r->sm = sm;
   r->pool = pool;
   r->max_targets = 4;
   r->targets = calloc(r->max_targets, 8);
   build_target_PluginList_init(&r->plugins);
   return r;
}

static void c2recipe_Recipe_free(c2recipe_Recipe* r)
{
   for (uint32_t i = 0; (i < r->num_targets); i++) {
      build_target_Target_free(r->targets[i]);
   }
   free(r->targets);
   build_target_PluginList_free(&r->plugins);
   free(r);
}

static void c2recipe_Recipe_addPlugin(c2recipe_Recipe* r, uint32_t name, uint32_t options, src_loc_SrcLoc loc)
{
   build_target_PluginList_add(&r->plugins, name, options, loc);
}

static build_target_Target* c2recipe_Recipe_addTarget(c2recipe_Recipe* r, uint32_t name, src_loc_SrcLoc loc, build_target_Kind kind)
{
   if ((r->num_targets == r->max_targets)) {
      r->max_targets *= 2;
      build_target_Target** targets2 = malloc((r->max_targets * 8));
      memcpy(targets2, r->targets, (r->num_targets * 8));
      free(r->targets);
      r->targets = targets2;
   }
   build_target_Target* t = build_target_create(name, loc, kind, r->pool);
   r->targets[r->num_targets] = t;
   r->num_targets++;
   return t;
}

static _Bool c2recipe_Recipe_parse(c2recipe_Recipe* r, int32_t file_id)
{
   return c2recipe_Parser_parse(r, r->pool, r->sm, file_id);
}

static uint32_t c2recipe_Recipe_numTargets(const c2recipe_Recipe* r)
{
   return r->num_targets;
}

static build_target_Target* c2recipe_Recipe_getTarget(const c2recipe_Recipe* r, uint32_t idx)
{
   return r->targets[idx];
}

static const build_target_PluginList* c2recipe_Recipe_getPlugins(const c2recipe_Recipe* r)
{
   return &r->plugins;
}

static void c2recipe_Token_init(c2recipe_Token* t)
{
   memset(t, 0, 12);
}

static c2recipe_Set* c2recipe_Set_create(uint32_t name, src_loc_SrcLoc loc, c2recipe_Set* next)
{
   c2recipe_Set* s = calloc(1, 32);
   s->name_idx = name;
   s->loc = loc;
   s->next = next;
   s->max_files = 8;
   s->files = malloc((8 * 8));
   return s;
}

static void c2recipe_Set_free(c2recipe_Set* s)
{
   free(s->files);
   free(s);
}

static _Bool c2recipe_Set_addFile(c2recipe_Set* s, uint32_t filename, src_loc_SrcLoc loc)
{
   for (uint32_t i = 0; (i < s->num_files); i++) {
      if ((s->files[i].name == filename)) return false;

   }
   if ((s->num_files == s->max_files)) {
      s->max_files *= 2;
      build_target_File* files2 = malloc((s->max_files * 8));
      memcpy(files2, s->files, (s->num_files * 8));
      free(s->files);
      s->files = files2;
   }
   s->files[s->num_files].name = filename;
   s->files[s->num_files].loc = loc;
   s->num_files++;
   return true;
}

static void c2recipe_Parser_free(c2recipe_Parser* p)
{
   string_list_List_free(&p->global_configs);
   c2recipe_Set* s = p->sets;
   while (s) {
      c2recipe_Set* next = s->next;
      c2recipe_Set_free(s);
      s = next;
   }
}

static _Bool c2recipe_Parser_parse(c2recipe_Recipe* recipe, string_pool_Pool* pool, source_mgr_SourceMgr* sm, int32_t file_id)
{
   const char* data = source_mgr_SourceMgr_get_content(sm, file_id);
   c2recipe_Parser p = { };
   p.recipe = recipe;
   p.pool = pool;
   p.sm = sm;
   string_list_List_init(&p.global_configs, pool);
   p.input_start = data;
   p.cur = data;
   p.loc_start = source_mgr_SourceMgr_get_offset(sm, file_id);
   p.new_line = true;
   c2recipe_Token_init(&p.token);
   int32_t res = setjmp(&p.jmpbuf);
   if ((res == 0)) {
      c2recipe_Parser_consumeToken(&p);
      c2recipe_Parser_parseTop(&p);
   }
   c2recipe_Parser_free(&p);
   return (res == 0);
}

static _Bool c2recipe_Parser_addGlobalFeature(c2recipe_Parser* p, uint32_t feature)
{
   if (string_list_List_contains_idx(&p->global_configs, feature)) return false;

   string_list_List_add(&p->global_configs, feature);
   return true;
}

__attribute__((__format__(printf, 2, 3))) 
static void c2recipe_Parser_error(c2recipe_Parser* p, const char* format, ...)
{
   char msg[128];
   va_list args;
   va_start(args, format);
   vsnprintf(msg, (128 - 1), format, args);
   va_end(args);
   if (color_useColor()) {
      fprintf(stderr, "%s: %serror:%s %s\n", source_mgr_SourceMgr_loc2str(p->sm, p->token.loc), color_Red, color_Normal, msg);
   } else {
      fprintf(stderr, "%s: error: %s\n", source_mgr_SourceMgr_loc2str(p->sm, p->token.loc), msg);
   }
   longjmp(&p->jmpbuf, 1);
}

static void c2recipe_Parser_consumeToken(c2recipe_Parser* p)
{
   c2recipe_Parser_lex(p, &p->token);
}

static void c2recipe_Parser_expect(c2recipe_Parser* p, c2recipe_Kind kind, const char* msg)
{
   if ((p->token.kind != kind)) c2recipe_Parser_error(p, "%s", msg);
}

static _Bool c2recipe_Parser_is(const c2recipe_Parser* p, c2recipe_Kind kind)
{
   return (p->token.kind == kind);
}

static void c2recipe_Parser_lex(c2recipe_Parser* p, c2recipe_Token* result)
{
   while (1) {
      switch (*p->cur) {
      case 0:
         p->cur--;
         result->loc = (p->loc_start + ((src_loc_SrcLoc)((p->cur - p->input_start))));
         result->kind = c2recipe_Kind_Eof;
         return;
      case ' ':
         fallthrough;
      case '\t':
         fallthrough;
      case '\r':
         p->cur++;
         break;
      case '\n':
         p->cur++;
         p->new_line = true;
         break;
      case '#':
         c2recipe_Parser_skip_comments(p);
         break;
      case '[':
         c2recipe_Parser_lex_plugin_options(p, result);
         p->new_line = false;
         return;
      case '$':
         c2recipe_Parser_lex_option(p, result);
         p->new_line = false;
         return;
      case '(':
         c2recipe_Parser_lex_set_use(p, result);
         p->new_line = false;
         return;
      case '/': {
         const char* start = p->cur;
         while ((*p->cur && !isspace(*p->cur))) p->cur++;
         result->kind = p->new_line ? c2recipe_Kind_File : c2recipe_Kind_Text;
         if ((*p->cur == 0)) result->kind = c2recipe_Kind_Eof;
         p->new_line = false;
         uint32_t len = ((uint32_t)((p->cur - start)));
         result->value = string_pool_Pool_add(p->pool, start, len, true);
         return;
      }
      default:
         if (isalnum(*p->cur)) {
            result->loc = (p->loc_start + ((src_loc_SrcLoc)((p->cur - p->input_start))));
            if (c2recipe_equals(p->cur, "plugin ", 7)) {
               result->kind = c2recipe_Kind_Plugin;
               p->cur += 7;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "executable ", 11)) {
               result->kind = c2recipe_Kind_Executable;
               p->cur += 11;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "lib ", 4)) {
               result->kind = c2recipe_Kind_Lib;
               p->cur += 4;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "end", 3)) {
               result->kind = c2recipe_Kind_End;
               p->cur += 3;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "image ", 6)) {
               result->kind = c2recipe_Kind_Image;
               p->cur += 6;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "config ", 7)) {
               result->kind = c2recipe_Kind_Config;
               p->cur += 7;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "set ", 4)) {
               result->kind = c2recipe_Kind_Set;
               p->cur += 4;
               p->new_line = false;
               return;
            }
            const char* start = p->cur;
            while ((*p->cur && !isspace(*p->cur))) p->cur++;
            result->kind = p->new_line ? c2recipe_Kind_File : c2recipe_Kind_Text;
            p->new_line = false;
            uint32_t len = ((uint32_t)((p->cur - start)));
            result->value = string_pool_Pool_add(p->pool, start, len, true);
            return;
         }
         result->loc = (p->loc_start + ((src_loc_SrcLoc)((p->cur - p->input_start))));
         c2recipe_Parser_error(p, "unexpected input '%c'", *p->cur);
         return;
      }
   }
}

static void c2recipe_Parser_lex_plugin_options(c2recipe_Parser* p, c2recipe_Token* result)
{
   p->cur++;
   const char* start = p->cur;
   while (1) {
      if ((*p->cur == 0)) {
         return;
      }
      if ((*p->cur == ']')) {
         uint32_t len = ((uint32_t)((p->cur - start)));
         result->loc = (p->loc_start + ((src_loc_SrcLoc)((start - p->input_start))));
         result->kind = c2recipe_Kind_PluginOptions;
         result->value = string_pool_Pool_add(p->pool, start, len, true);
         p->cur++;
         return;
      }
      p->cur++;
   }
}

static _Bool c2recipe_is_name(char c)
{
   if (((c >= 'a') && (c <= 'z'))) return true;

   if (((c >= 'A') && (c <= 'Z'))) return true;

   if (((c >= '0') && (c <= '9'))) return true;

   if ((c == '_')) return true;

   return false;
}

static void c2recipe_Parser_lex_set_use(c2recipe_Parser* p, c2recipe_Token* result)
{
   p->cur++;
   result->loc = (p->loc_start + ((src_loc_SrcLoc)((p->cur - p->input_start))));
   const char* start = p->cur;
   while (c2recipe_is_name(*p->cur)) p->cur++;
   result->kind = c2recipe_Kind_SetUse;
   uint32_t len = ((uint32_t)((p->cur - start)));
   if ((len == 0)) c2recipe_Parser_error(p, "expected set name");
   result->value = string_pool_Pool_add(p->pool, start, len, true);
   if ((*p->cur != ')')) {
      result->loc = (p->loc_start + ((src_loc_SrcLoc)((p->cur - p->input_start))));
      c2recipe_Parser_error(p, "expected ')'");
   }
   p->cur++;
}

static void c2recipe_Parser_lex_option(c2recipe_Parser* p, c2recipe_Token* result)
{
   p->cur++;
   result->loc = (p->loc_start + ((src_loc_SrcLoc)((p->cur - p->input_start))));
   const char* end = p->cur;
   while ((*end && !isspace(*end))) end++;
   uint32_t len = ((uint32_t)((end - p->cur)));
   if ((len >= 20)) c2recipe_Parser_error(p, "unknown option");
   char option[24];
   memcpy(option, p->cur, len);
   option[len] = 0;
   switch (c2_strswitch(option, "\010warnings" "\007backend" "\017disable-asserts" "\006nolibc" "\006config" "\006export" "\006plugin" "\003use" "\003asm")) {
   case 2: // "warnings"
      result->kind = c2recipe_Kind_Warnings;
      break;
   case 3: // "backend"
      result->kind = c2recipe_Kind_Backend;
      break;
   case 4: // "disable-asserts"
      result->kind = c2recipe_Kind_DisableAsserts;
      break;
   case 5: // "nolibc"
      result->kind = c2recipe_Kind_NoLibc;
      break;
   case 6: // "config"
      result->kind = c2recipe_Kind_Config;
      break;
   case 7: // "export"
      result->kind = c2recipe_Kind_Export;
      break;
   case 8: // "plugin"
      result->kind = c2recipe_Kind_Plugin;
      break;
   case 9: // "use"
      result->kind = c2recipe_Kind_Use;
      break;
   case 10: // "asm"
      result->kind = c2recipe_Kind_AsmFile;
      break;
   default:
      c2recipe_Parser_error(p, "unknown option '%s'", option);
      break;
   }
   p->cur += strlen(option);
}

static void c2recipe_Parser_skip_comments(c2recipe_Parser* p)
{
   while (*p->cur) {
      if ((*p->cur == '\n')) return;

      p->cur++;
   }
}

static void c2recipe_Parser_parseTop(c2recipe_Parser* p)
{
   while (1) {
      switch (p->token.kind) {
      case c2recipe_Kind_Plugin:
         c2recipe_Parser_parsePlugin(p, true);
         break;
      case c2recipe_Kind_PluginOptions:
         break;
      case c2recipe_Kind_Text:
         break;
      case c2recipe_Kind_Executable:
         c2recipe_Parser_parseExecutable(p);
         break;
      case c2recipe_Kind_Lib:
         c2recipe_Parser_parseLibrary(p);
         break;
      case c2recipe_Kind_Image:
         c2recipe_Parser_parseImage(p);
         break;
      case c2recipe_Kind_File:
         c2recipe_Parser_error(p, "syntax error");
         break;
      case c2recipe_Kind_End:
         break;
      case c2recipe_Kind_Warnings:
         fallthrough;
      case c2recipe_Kind_Backend:
         fallthrough;
      case c2recipe_Kind_DisableAsserts:
         fallthrough;
      case c2recipe_Kind_NoLibc:
         c2recipe_Parser_error(p, "must be inside target");
         break;
      case c2recipe_Kind_Config:
         if (p->targets_started) c2recipe_Parser_error(p, "global configs must come before targets");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect config");
         if (!c2recipe_Parser_addGlobalFeature(p, p->token.value)) {
            c2recipe_Parser_error(p, "duplicate config '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_Export:
         fallthrough;
      case c2recipe_Kind_Use:
         fallthrough;
      case c2recipe_Kind_AsmFile:
         c2recipe_Parser_error(p, "must be inside target");
         break;
      case c2recipe_Kind_Set:
         c2recipe_Parser_parseSet(p);
         break;
      case c2recipe_Kind_SetUse:
         c2recipe_Parser_error(p, "syntax error");
         break;
      case c2recipe_Kind_Eof:
         return;
      }
   }
}

static void c2recipe_Parser_parsePlugin(c2recipe_Parser* p, _Bool is_global)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect plugin name");
   uint32_t name = p->token.value;
   src_loc_SrcLoc loc = p->token.loc;
   c2recipe_Parser_consumeToken(p);
   uint32_t options = 0;
   if ((p->token.kind == c2recipe_Kind_PluginOptions)) {
      options = p->token.value;
      c2recipe_Parser_consumeToken(p);
   }
   if (is_global) {
      c2recipe_Recipe_addPlugin(p->recipe, name, options, loc);
   } else {
      build_target_Target_addPlugin(p->target, name, options, loc);
   }
}

static void c2recipe_Parser_parseWarnings(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect options");
   warning_flags_Flags* warnings = build_target_Target_getWarnings2(p->target);
   while (c2recipe_Parser_is(p, c2recipe_Kind_Text)) {
      const char* option = string_pool_Pool_idx2str(p->pool, p->token.value);
      switch (c2_strswitch(option, "\011no-unused" "\022no-unused-variable" "\022no-unused-function" "\023no-unused-parameter" "\016no-unused-type" "\020no-unused-module" "\020no-unused-import" "\020no-unused-public" "\017no-unused-label" "\027no-unused-enum-constant" "\020promote-to-error")) {
      case 2: // "no-unused"
         warnings->no_unused = true;
         warnings->no_unused_variable = true;
         warnings->no_unused_function = true;
         warnings->no_unused_parameter = true;
         warnings->no_unused_type = true;
         warnings->no_unused_module = true;
         warnings->no_unused_import = true;
         warnings->no_unused_public = true;
         warnings->no_unused_label = true;
         warnings->no_unused_enum_constant = true;
         break;
      case 3: // "no-unused-variable"
         warnings->no_unused_variable = true;
         break;
      case 4: // "no-unused-function"
         warnings->no_unused_function = true;
         break;
      case 5: // "no-unused-parameter"
         warnings->no_unused_parameter = true;
         break;
      case 6: // "no-unused-type"
         warnings->no_unused_type = true;
         break;
      case 7: // "no-unused-module"
         warnings->no_unused_module = true;
         break;
      case 8: // "no-unused-import"
         warnings->no_unused_import = true;
         break;
      case 9: // "no-unused-public"
         warnings->no_unused_public = true;
         break;
      case 10: // "no-unused-label"
         warnings->no_unused_label = true;
         break;
      case 11: // "no-unused-enum-constant"
         warnings->no_unused_enum_constant = true;
         break;
      case 12: // "promote-to-error"
         warnings->are_errors = true;
         break;
      default:
         c2recipe_Parser_error(p, "unknown warning '%s'", option);
         break;
      }
      c2recipe_Parser_consumeToken(p);
   }
}

static void c2recipe_Parser_parseExecutable(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect target name");
   p->target = c2recipe_Recipe_addTarget(p->recipe, p->token.value, p->token.loc, build_target_Kind_Executable);
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_parseTarget(p);
}

static void c2recipe_Parser_parseImage(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect image name");
   p->target = c2recipe_Recipe_addTarget(p->recipe, p->token.value, p->token.loc, build_target_Kind_Image);
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_parseTarget(p);
}

static void c2recipe_Parser_parseSet(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect set name");
   c2recipe_Set* old = c2recipe_Parser_findSet(p, p->token.value);
   if (old) {
      c2recipe_Parser_error(p, "duplicate set '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
   }
   p->sets = c2recipe_Set_create(p->token.value, p->token.loc, p->sets);
   c2recipe_Parser_consumeToken(p);
   while (1) {
      switch (p->token.kind) {
      case c2recipe_Kind_File:
         if (!c2recipe_Set_addFile(p->sets, p->token.value, p->token.loc)) {
            c2recipe_Parser_error(p, "duplicate file '%s' in set '%s'", string_pool_Pool_idx2str(p->pool, p->token.value), string_pool_Pool_idx2str(p->pool, p->sets->name_idx));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_End:
         c2recipe_Parser_consumeToken(p);
         return;
      default:
         c2recipe_Parser_error(p, "syntax error");
         break;
      }
   }
}

static c2recipe_Set* c2recipe_Parser_findSet(c2recipe_Parser* p, uint32_t name_idx)
{
   c2recipe_Set* s = p->sets;
   while (s) {
      if ((s->name_idx == name_idx)) return s;

      s = s->next;
   }
   return NULL;
}

static void c2recipe_Parser_parseLibrary(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect target name");
   uint32_t name = p->token.value;
   src_loc_SrcLoc loc = p->token.loc;
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect lib type");
   uint32_t kind_name = p->token.value;
   build_target_Kind kind = build_target_Kind_StaticLibrary;
   switch (c2_strswitch(string_pool_Pool_idx2str(p->pool, kind_name), "\006static" "\007dynamic")) {
   case 2: // "static"
      kind = build_target_Kind_StaticLibrary;
      break;
   case 3: // "dynamic"
      kind = build_target_Kind_DynamicLibrary;
      break;
   default:
      c2recipe_Parser_error(p, "invalid library type (allowed: dynamic|static)");
      break;
   }
   c2recipe_Parser_consumeToken(p);
   p->target = c2recipe_Recipe_addTarget(p->recipe, name, loc, kind);
   c2recipe_Parser_parseTarget(p);
}

static void c2recipe_Parser_parseTarget(c2recipe_Parser* p)
{
   p->targets_started = true;
   _Bool files_started = false;
   for (uint32_t i = 0; (i < string_list_List_length(&p->global_configs)); i++) {
      build_target_Target_addFeature(p->target, string_list_List_get_idx(&p->global_configs, i));
   }
   while (1) {
      switch (p->token.kind) {
      case c2recipe_Kind_Plugin:
         c2recipe_Parser_parsePlugin(p, false);
         break;
      case c2recipe_Kind_PluginOptions:
         fallthrough;
      case c2recipe_Kind_Text:
         fallthrough;
      case c2recipe_Kind_Executable:
         fallthrough;
      case c2recipe_Kind_Lib:
         fallthrough;
      case c2recipe_Kind_Image:
         c2recipe_Parser_error(p, "syntax error");
         break;
      case c2recipe_Kind_File:
         files_started = true;
         if (!build_target_Target_addFile(p->target, p->token.value, p->token.loc)) {
            c2recipe_Parser_error(p, "duplicate file '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_End:
         c2recipe_Parser_consumeToken(p);
         p->target = NULL;
         return;
      case c2recipe_Kind_Warnings:
         if (files_started) c2recipe_Parser_error(p, "$warnings must come before files");
         c2recipe_Parser_parseWarnings(p);
         break;
      case c2recipe_Kind_Backend:
         if (files_started) c2recipe_Parser_error(p, "$backend must come before files");
         c2recipe_Parser_parseBackend(p);
         break;
      case c2recipe_Kind_DisableAsserts:
         if (files_started) c2recipe_Parser_error(p, "$disable-asserts must come before files");
         c2recipe_Parser_consumeToken(p);
         build_target_Target_disableAsserts(p->target);
         break;
      case c2recipe_Kind_NoLibc:
         if (files_started) c2recipe_Parser_error(p, "$nolibc must come before files");
         c2recipe_Parser_consumeToken(p);
         build_target_Target_setNoLibC(p->target);
         break;
      case c2recipe_Kind_Config:
         if (files_started) c2recipe_Parser_error(p, "$config must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect config");
         build_target_Target_addFeature(p->target, p->token.value);
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_Export:
         if (files_started) c2recipe_Parser_error(p, "$export must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect export");
         while ((p->token.kind == c2recipe_Kind_Text)) {
            build_target_Target_addExport(p->target, p->token.value);
            c2recipe_Parser_consumeToken(p);
         }
         break;
      case c2recipe_Kind_Use: {
         if (files_started) c2recipe_Parser_error(p, "$use must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect library name");
         uint32_t libname = p->token.value;
         if (build_target_Target_hasLib(p->target, libname)) {
            c2recipe_Parser_error(p, "duplicate use of %s", string_pool_Pool_idx2str(p->pool, libname));
         }
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect library type");
         _Bool is_static = false;
         const char* libtype = string_pool_Pool_idx2str(p->pool, p->token.value);
         switch (c2_strswitch(libtype, "\006static" "\007dynamic")) {
         case 2: // "static"
            is_static = true;
            break;
         case 3: // "dynamic"
            break;
         default:
            c2recipe_Parser_error(p, "unknown library kind '%s'", libtype);
            break;
         }
         build_target_Target_addLib(p->target, libname, is_static);
         c2recipe_Parser_consumeToken(p);
         while ((p->token.kind == c2recipe_Kind_Text)) c2recipe_Parser_consumeToken(p);
         break;
      }
      case c2recipe_Kind_AsmFile:
         if (files_started) c2recipe_Parser_error(p, "$asm must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect filename");
         if (!build_target_Target_addAsmFile(p->target, p->token.value, p->token.loc)) {
            c2recipe_Parser_error(p, "duplicate asm file '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_Set:
         c2recipe_Parser_error(p, "cannot define a set here");
         break;
      case c2recipe_Kind_SetUse: {
         c2recipe_Set* s = c2recipe_Parser_findSet(p, p->token.value);
         if (!s) c2recipe_Parser_error(p, "unknown set '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         c2recipe_Parser_consumeToken(p);
         files_started = true;
         for (uint32_t i = 0; (i < s->num_files); i++) {
            const build_target_File* f = &s->files[i];
            if (!build_target_Target_addFile(p->target, f->name, f->loc)) {
               c2recipe_Parser_error(p, "duplicate file '%s' from set '%s'", string_pool_Pool_idx2str(p->pool, f->name), string_pool_Pool_idx2str(p->pool, s->name_idx));
            }
         }
         break;
      }
      case c2recipe_Kind_Eof:
         c2recipe_Parser_error(p, "un-terminated target");
         return;
      }
   }
}

static void c2recipe_Parser_parseBackend(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect backend type");
   const char* backend_kind = string_pool_Pool_idx2str(p->pool, p->token.value);
   c2recipe_Parser_consumeToken(p);
   if (build_target_Target_hasBackEnd(p->target)) c2recipe_Parser_error(p, "duplicate backend");
   switch (c2_strswitch(backend_kind, "\001c" "\002ir" "\003qbe")) {
   case 2: // "c"
      build_target_Target_setBackEnd(p->target, build_target_BackEndKind_C);
      break;
   case 3: // "ir"
      build_target_Target_setBackEnd(p->target, build_target_BackEndKind_IR);
      break;
   case 4: // "qbe"
      build_target_Target_setBackEnd(p->target, build_target_BackEndKind_QBE);
      break;
   default:
      c2recipe_Parser_error(p, "unknown backend type (supported: c,ir,qbe)");
      break;
   }
   c2recipe_Parser_parseBackEndOptions(p);
}

static void c2recipe_Parser_parseBackEndOptions(c2recipe_Parser* p)
{
   while ((p->token.kind == c2recipe_Kind_Text)) {
      const char* option = string_pool_Pool_idx2str(p->pool, p->token.value);
      switch (c2_strswitch(option, "\010no-build" "\004fast")) {
      case 2: // "no-build"
         build_target_Target_setNoBuild(p->target);
         break;
      case 3: // "fast"
         build_target_Target_setFastBuild(p->target);
         break;
      default:
         c2recipe_Parser_error(p, "invalid backend option '%s'", option);
         break;
      }
      c2recipe_Parser_consumeToken(p);
   }
}

static _Bool c2recipe_equals(const char* str, const char* expect, uint32_t len)
{
   for (uint32_t i = 0; (i < len); i++) {
      if ((str[i] != expect[i])) return false;

   }
   return true;
}


// --- module ast_visitor ---
typedef struct ast_visitor_Visitor_ ast_visitor_Visitor;

typedef void (*ast_visitor_OnRef)(void* arg, const ast_Ref* ref);

struct ast_visitor_Visitor_ {
   void* arg;
   ast_visitor_OnRef on_ref;
};

static ast_visitor_Visitor* ast_visitor_create(void* arg, ast_visitor_OnRef on_ref);
static void ast_visitor_Visitor_free(ast_visitor_Visitor* v);
static void ast_visitor_Visitor_handleAssert(ast_visitor_Visitor* v, ast_StaticAssert* a);
static void ast_visitor_Visitor_handle(ast_visitor_Visitor* v, ast_Decl* d);
static void ast_visitor_Visitor_handleFunction(ast_visitor_Visitor* v, ast_FunctionDecl* d);
static void ast_visitor_Visitor_handleVarDecl(ast_visitor_Visitor* v, ast_VarDecl* d);
static void ast_visitor_Visitor_handleTypeRef(ast_visitor_Visitor* v, const ast_TypeRef* r);
static void ast_visitor_Visitor_handleStmt(ast_visitor_Visitor* v, ast_Stmt* s);
static void ast_visitor_Visitor_handleCompoundStmt(ast_visitor_Visitor* v, ast_CompoundStmt* s);
static void ast_visitor_Visitor_handleExpr(ast_visitor_Visitor* v, ast_Expr* e);
static void ast_visitor_Visitor_handleCallExpr(ast_visitor_Visitor* v, ast_CallExpr* c);
static void ast_visitor_Visitor_handleMemberExpr(ast_visitor_Visitor* v, ast_MemberExpr* m);
static void ast_visitor_Visitor_handleBuiltinExpr(ast_visitor_Visitor* v, ast_BuiltinExpr* b);

static ast_visitor_Visitor* ast_visitor_create(void* arg, ast_visitor_OnRef on_ref)
{
   ast_visitor_Visitor* v = calloc(1, 16);
   v->arg = arg;
   v->on_ref = on_ref;
   return v;
}

static void ast_visitor_Visitor_free(ast_visitor_Visitor* v)
{
   free(v);
}

static void ast_visitor_Visitor_handleAssert(ast_visitor_Visitor* v, ast_StaticAssert* a)
{
   ast_visitor_Visitor_handleExpr(v, ast_StaticAssert_getLhs(a));
   ast_visitor_Visitor_handleExpr(v, ast_StaticAssert_getRhs(a));
}

static void ast_visitor_Visitor_handle(ast_visitor_Visitor* v, ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      ast_visitor_Visitor_handleFunction(v, ((ast_FunctionDecl*)(d)));
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType: {
      ast_StructTypeDecl* s = ((ast_StructTypeDecl*)(d));
      uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
      ast_Decl** members = ast_StructTypeDecl_getMembers(s);
      for (uint32_t i = 0; (i < num_members); i++) {
         ast_visitor_Visitor_handle(v, members[i]);
      }
      break;
   }
   case ast_DeclKind_EnumType:
      break;
   case ast_DeclKind_EnumConstant: {
      const ast_EnumConstantDecl* ecd = ((ast_EnumConstantDecl*)(d));
      ast_Expr* init_expr = ast_EnumConstantDecl_getInit(ecd);
      if (init_expr) ast_visitor_Visitor_handleExpr(v, init_expr);
      break;
   }
   case ast_DeclKind_FunctionType: {
      ast_FunctionTypeDecl* ftd = ((ast_FunctionTypeDecl*)(d));
      ast_visitor_Visitor_handleFunction(v, ast_FunctionTypeDecl_getDecl(ftd));
      break;
   }
   case ast_DeclKind_AliasType: {
      ast_AliasTypeDecl* atd = ((ast_AliasTypeDecl*)(d));
      ast_visitor_Visitor_handleTypeRef(v, ast_AliasTypeDecl_getTypeRef(atd));
      break;
   }
   case ast_DeclKind_Variable:
      ast_visitor_Visitor_handleVarDecl(v, ((ast_VarDecl*)(d)));
      break;
   }
}

static void ast_visitor_Visitor_handleFunction(ast_visitor_Visitor* v, ast_FunctionDecl* d)
{
   if (ast_FunctionDecl_isTemplate(d)) return;

   ast_visitor_Visitor_handleTypeRef(v, ast_FunctionDecl_getReturnTypeRef(d));
   ast_Ref* prefix = ast_FunctionDecl_getPrefix(d);
   if (prefix) v->on_ref(v->arg, prefix);
   uint32_t num_params = ast_FunctionDecl_getNumParams(d);
   ast_VarDecl** args = ast_FunctionDecl_getParams(d);
   for (uint32_t i = 0; (i < num_params); i++) ast_visitor_Visitor_handleVarDecl(v, args[i]);
   ast_CompoundStmt* body = ast_FunctionDecl_getBody(d);
   if (body) {
      ast_visitor_Visitor_handleCompoundStmt(v, body);
   }
}

static void ast_visitor_Visitor_handleVarDecl(ast_visitor_Visitor* v, ast_VarDecl* d)
{
   ast_visitor_Visitor_handleTypeRef(v, ast_VarDecl_getTypeRef(d));
   ast_Expr* init_expr = ast_VarDecl_getInit(d);
   if (init_expr) ast_visitor_Visitor_handleExpr(v, init_expr);
}

static void ast_visitor_Visitor_handleTypeRef(ast_visitor_Visitor* v, const ast_TypeRef* r)
{
   if (ast_TypeRef_isUser(r)) {
      const ast_Ref* prefix = ast_TypeRef_getPrefix(r);
      if (prefix) v->on_ref(v->arg, prefix);
      const ast_Ref* user = ast_TypeRef_getUser(r);
      v->on_ref(v->arg, user);
   }
   uint32_t num_arrays = ast_TypeRef_getNumArrays(r);
   for (uint32_t i = 0; (i < num_arrays); i++) {
      ast_Expr* e = ast_TypeRef_getArray(r, i);
      if (e) ast_visitor_Visitor_handleExpr(v, e);
   }
}

static void ast_visitor_Visitor_handleStmt(ast_visitor_Visitor* v, ast_Stmt* s)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      ast_ReturnStmt* r = ((ast_ReturnStmt*)(s));
      ast_Expr* e = ast_ReturnStmt_getValue(r);
      if (e) ast_visitor_Visitor_handleExpr(v, e);
      break;
   }
   case ast_StmtKind_Expr:
      ast_visitor_Visitor_handleExpr(v, ((ast_Expr*)(s)));
      break;
   case ast_StmtKind_If: {
      ast_IfStmt* i = ((ast_IfStmt*)(s));
      ast_visitor_Visitor_handleStmt(v, ast_IfStmt_getCond(i));
      ast_visitor_Visitor_handleStmt(v, ast_IfStmt_getThen(i));
      ast_Stmt* e = ast_IfStmt_getElse(i);
      if (e) ast_visitor_Visitor_handleStmt(v, e);
      break;
   }
   case ast_StmtKind_While: {
      ast_WhileStmt* w = ((ast_WhileStmt*)(s));
      ast_visitor_Visitor_handleStmt(v, ast_WhileStmt_getCond(w));
      ast_visitor_Visitor_handleStmt(v, ast_WhileStmt_getBody(w));
      break;
   }
   case ast_StmtKind_For: {
      ast_ForStmt* f = ((ast_ForStmt*)(s));
      ast_Stmt* in = ast_ForStmt_getInit(f);
      if (in) ast_visitor_Visitor_handleStmt(v, in);
      ast_Expr* cond = ast_ForStmt_getCond(f);
      if (cond) ast_visitor_Visitor_handleExpr(v, cond);
      ast_Expr* cont = ast_ForStmt_getCont(f);
      if (cont) ast_visitor_Visitor_handleExpr(v, cont);
      ast_Stmt* body = ast_ForStmt_getBody(f);
      if (body) ast_visitor_Visitor_handleStmt(v, body);
      break;
   }
   case ast_StmtKind_Switch: {
      ast_SwitchStmt* sw = ((ast_SwitchStmt*)(s));
      ast_visitor_Visitor_handleExpr(v, ast_SwitchStmt_getCond(sw));
      const uint32_t numcases = ast_SwitchStmt_getNumCases(sw);
      ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
      for (uint32_t i = 0; (i < numcases); i++) {
         ast_SwitchCase* c = cases[i];
         uint32_t numconds = ast_SwitchCase_getNumConds(c);
         for (uint32_t j = 0; (j < numconds); j++) ast_visitor_Visitor_handleExpr(v, ast_SwitchCase_getCond(c, j));
         uint32_t numstmts = ast_SwitchCase_getNumStmts(c);
         for (uint32_t j = 0; (j < numstmts); j++) ast_visitor_Visitor_handleStmt(v, ast_SwitchCase_getStmt(c, j));
      }
      break;
   }
   case ast_StmtKind_Break:
      break;
   case ast_StmtKind_Continue:
      break;
   case ast_StmtKind_Fallthrough:
      break;
   case ast_StmtKind_Label: {
      ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      if (stmt) ast_visitor_Visitor_handleStmt(v, stmt);
      break;
   }
   case ast_StmtKind_Goto:
      break;
   case ast_StmtKind_Compound:
      ast_visitor_Visitor_handleCompoundStmt(v, ((ast_CompoundStmt*)(s)));
      break;
   case ast_StmtKind_Decl: {
      ast_DeclStmt* d = ((ast_DeclStmt*)(s));
      ast_visitor_Visitor_handleVarDecl(v, ast_DeclStmt_getDecl(d));
      break;
   }
   case ast_StmtKind_Asm: {
      ast_AsmStmt* a = ((ast_AsmStmt*)(s));
      uint32_t num_exprs = ast_AsmStmt_getNumExprs(a);
      ast_Expr** exprs = ast_AsmStmt_getExprs(a);
      for (uint32_t i = 0; (i < num_exprs); i++) {
         ast_visitor_Visitor_handleExpr(v, exprs[i]);
      }
      break;
   }
   case ast_StmtKind_Assert: {
      ast_AssertStmt* a = ((ast_AssertStmt*)(s));
      ast_visitor_Visitor_handleExpr(v, ast_AssertStmt_getInner(a));
      break;
   }
   }
}

static void ast_visitor_Visitor_handleCompoundStmt(ast_visitor_Visitor* v, ast_CompoundStmt* s)
{
   uint32_t count = ast_CompoundStmt_getCount(s);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(s);
   for (uint32_t i = 0; (i < count); i++) ast_visitor_Visitor_handleStmt(v, stmts[i]);
}

static void ast_visitor_Visitor_handleExpr(ast_visitor_Visitor* v, ast_Expr* e)
{
   (e) || c2_assert("generator/ast_visitor_expr.c2", 21, "ast_visitor.Visitor.handleExpr", "e");
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      return;
   case ast_ExprKind_FloatLiteral:
      return;
   case ast_ExprKind_BooleanLiteral:
      return;
   case ast_ExprKind_CharLiteral:
      return;
   case ast_ExprKind_StringLiteral:
      return;
   case ast_ExprKind_Nil:
      return;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      ast_Ref ref = ast_IdentifierExpr_getRef(i);
      v->on_ref(v->arg, &ref);
      break;
   }
   case ast_ExprKind_Type: {
      ast_TypeExpr* t = ((ast_TypeExpr*)(e));
      ast_visitor_Visitor_handleTypeRef(v, ast_TypeExpr_getTypeRef(t));
      break;
   }
   case ast_ExprKind_Call:
      ast_visitor_Visitor_handleCallExpr(v, ((ast_CallExpr*)(e)));
      break;
   case ast_ExprKind_InitList: {
      ast_InitListExpr* ili = ((ast_InitListExpr*)(e));
      uint32_t count = ast_InitListExpr_getNumValues(ili);
      ast_Expr** exprs = ast_InitListExpr_getValues(ili);
      for (uint32_t i = 0; (i < count); i++) ast_visitor_Visitor_handleExpr(v, exprs[i]);
      break;
   }
   case ast_ExprKind_FieldDesignatedInit: {
      ast_FieldDesignatedInitExpr* f = ((ast_FieldDesignatedInitExpr*)(e));
      ast_Ref ref = { .loc = ast_Expr_getLoc(e), .name_idx = ast_FieldDesignatedInitExpr_getField(f), .decl = ast_FieldDesignatedInitExpr_getDecl(f) };
      v->on_ref(v->arg, &ref);
      ast_visitor_Visitor_handleExpr(v, ast_FieldDesignatedInitExpr_getInit(f));
      break;
   }
   case ast_ExprKind_ArrayDesignatedInit: {
      ast_ArrayDesignatedInitExpr* a = ((ast_ArrayDesignatedInitExpr*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_ArrayDesignatedInitExpr_getDesignator(a));
      ast_visitor_Visitor_handleExpr(v, ast_ArrayDesignatedInitExpr_getInit(a));
      break;
   }
   case ast_ExprKind_BinaryOperator: {
      ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_BinaryOperator_getLHS(b));
      ast_visitor_Visitor_handleExpr(v, ast_BinaryOperator_getRHS(b));
      break;
   }
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* u = ((ast_UnaryOperator*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_UnaryOperator_getInner(u));
      break;
   }
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = ((ast_ConditionalOperator*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_ConditionalOperator_getCond(c));
      ast_visitor_Visitor_handleExpr(v, ast_ConditionalOperator_getLHS(c));
      ast_visitor_Visitor_handleExpr(v, ast_ConditionalOperator_getRHS(c));
      break;
   }
   case ast_ExprKind_Builtin:
      ast_visitor_Visitor_handleBuiltinExpr(v, ((ast_BuiltinExpr*)(e)));
      break;
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_ArraySubscriptExpr_getBase(a));
      ast_visitor_Visitor_handleExpr(v, ast_ArraySubscriptExpr_getIndex(a));
      break;
   }
   case ast_ExprKind_Member:
      ast_visitor_Visitor_handleMemberExpr(v, ((ast_MemberExpr*)(e)));
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_ParenExpr_getInner(p));
      break;
   }
   case ast_ExprKind_BitOffset: {
      ast_BitOffsetExpr* bi = ((ast_BitOffsetExpr*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_BitOffsetExpr_getLHS(bi));
      ast_visitor_Visitor_handleExpr(v, ast_BitOffsetExpr_getRHS(bi));
      break;
   }
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* ec = ((ast_ExplicitCastExpr*)(e));
      ast_visitor_Visitor_handleTypeRef(v, ast_ExplicitCastExpr_getTypeRef(ec));
      ast_visitor_Visitor_handleExpr(v, ast_ExplicitCastExpr_getInner(ec));
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_ImplicitCastExpr_getInner(ic));
      break;
   }
   case ast_ExprKind_Range: {
      ast_RangeExpr* b = ((ast_RangeExpr*)(e));
      ast_visitor_Visitor_handleExpr(v, ast_RangeExpr_getLHS(b));
      ast_visitor_Visitor_handleExpr(v, ast_RangeExpr_getRHS(b));
      break;
   }
   }
}

static void ast_visitor_Visitor_handleCallExpr(ast_visitor_Visitor* v, ast_CallExpr* c)
{
   ast_visitor_Visitor_handleExpr(v, ast_CallExpr_getFunc(c));
   uint32_t num_args = ast_CallExpr_getNumArgs(c);
   ast_Expr** args = ast_CallExpr_getArgs(c);
   for (uint32_t i = 0; (i < num_args); i++) ast_visitor_Visitor_handleExpr(v, args[i]);
}

static void ast_visitor_Visitor_handleMemberExpr(ast_visitor_Visitor* v, ast_MemberExpr* m)
{
   if (ast_MemberExpr_hasExpr(m)) ast_visitor_Visitor_handleExpr(v, ast_MemberExpr_getExprBase(m));
   for (uint32_t i = 0; (i < ast_MemberExpr_getNumRefs(m)); i++) {
      ast_Ref ref = ast_MemberExpr_getRef(m, i);
      v->on_ref(v->arg, &ref);
   }
}

static void ast_visitor_Visitor_handleBuiltinExpr(ast_visitor_Visitor* v, ast_BuiltinExpr* b)
{
   ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getInner(b));
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof:
      break;
   case ast_BuiltinExprKind_Elemsof:
      break;
   case ast_BuiltinExprKind_EnumMin:
      break;
   case ast_BuiltinExprKind_EnumMax:
      break;
   case ast_BuiltinExprKind_OffsetOf:
      ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getOffsetOfMember(b));
      break;
   case ast_BuiltinExprKind_ToContainer:
      ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getToContainerMember(b));
      ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getToContainerPointer(b));
      break;
   }
}


// --- module c2i_generator ---
typedef struct c2i_generator_Generator_ c2i_generator_Generator;

struct c2i_generator_Generator_ {
   string_buffer_Buf* out;
   string_list_List imports;
   ast_Module* mod;
   _Bool in_body;
};

static void c2i_generator_generate(const char* output_dir, ast_Module* mod);
static void c2i_generator_Generator_write(c2i_generator_Generator* gen, const char* output_dir);
static void c2i_generator_on_import(void* arg, ast_ImportDecl* i);
static void c2i_generator_on_decl(void* arg, ast_Decl* d);
static void c2i_generator_Generator_emitDecl(c2i_generator_Generator* gen, ast_Decl* d);
static void c2i_generator_Generator_emitVarDecl(c2i_generator_Generator* gen, const ast_Decl* d, uint32_t indent);
static void c2i_generator_Generator_emitTypeRef(c2i_generator_Generator* gen, const ast_TypeRef* ref);
static void c2i_generator_print_expr(void* arg, const ast_Expr* e, string_buffer_Buf* out);
static void c2i_generator_Generator_emitEnumType(c2i_generator_Generator* gen, const ast_Decl* d);
static void c2i_generator_Generator_emitFunctionDecl(c2i_generator_Generator* gen, const ast_Decl* d, _Bool as_type);
static void c2i_generator_Generator_emitFunctionTypeDecl(c2i_generator_Generator* gen, const ast_Decl* d);
static void c2i_generator_Generator_emitAliasTypeDecl(c2i_generator_Generator* gen, const ast_Decl* d);
static void c2i_generator_Generator_emitStructTypeDecl(c2i_generator_Generator* gen, const ast_Decl* d, uint32_t indent);
static void c2i_generator_Generator_emitMember(c2i_generator_Generator* gen, const ast_Expr* e);
static void c2i_generator_Generator_emitExpr(c2i_generator_Generator* gen, const ast_Expr* e);
static void c2i_generator_Generator_emitBuiltin(c2i_generator_Generator* gen, const ast_Expr* e);
static void c2i_generator_Generator_emitCall(c2i_generator_Generator* gen, const ast_Expr* e);
static void c2i_generator_Generator_emitStmt(c2i_generator_Generator* gen, ast_Stmt* s, uint32_t indent, _Bool newline);
static void c2i_generator_Generator_emitSwitchStmt(c2i_generator_Generator* gen, ast_Stmt* s, uint32_t indent);

static void c2i_generator_generate(const char* output_dir, ast_Module* mod)
{
   c2i_generator_Generator gen = { .out = string_buffer_create((256 * 1024), false, 3), .mod = mod, .in_body = false };
   string_list_List_init(&gen.imports, NULL);
   string_buffer_Buf_print(gen.out, "module %s;\n\n", ast_Module_getName(mod));
   ast_Module_visitImports(mod, c2i_generator_on_import, &gen);
   if (string_list_List_length(&gen.imports)) string_buffer_Buf_newline(gen.out);
   ast_Module_visitDecls(mod, c2i_generator_on_decl, &gen);
   c2i_generator_Generator_write(&gen, output_dir);
   string_buffer_Buf_free(gen.out);
   string_list_List_free(&gen.imports);
}

static void c2i_generator_Generator_write(c2i_generator_Generator* gen, const char* output_dir)
{
   char fullname[512];
   snprintf(fullname, 512, "%s/%s.c2i", output_dir, ast_Module_getName(gen->mod));
   file_utils_Writer writer;
   _Bool ok = file_utils_Writer_write(&writer, fullname, string_buffer_Buf_udata(gen->out), string_buffer_Buf_size(gen->out));
   if (!ok) {
      console_error("cannot write to %s: %s", fullname, file_utils_Writer_getError(&writer));
   }
}

static void c2i_generator_on_import(void* arg, ast_ImportDecl* i)
{
   c2i_generator_Generator* gen = arg;
   ast_Decl* d = ((ast_Decl*)(i));
   if (!ast_Decl_isUsedPublic(d)) return;

   uint32_t name_idx = ast_Decl_getNameIdx(d);
   if (string_list_List_contains_idx(&gen->imports, name_idx)) return;

   string_list_List_add(&gen->imports, name_idx);
   string_buffer_Buf_print(gen->out, "import %s;\n", ast_Decl_getName(d));
}

static void c2i_generator_on_decl(void* arg, ast_Decl* d)
{
   c2i_generator_Generator* gen = arg;
   if (!ast_Decl_isPublic(d)) return;

   if (ast_Decl_isImport(d)) return;

   c2i_generator_Generator_emitDecl(gen, d);
}

static void c2i_generator_Generator_emitDecl(c2i_generator_Generator* gen, ast_Decl* d)
{
   string_buffer_Buf* out = gen->out;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      c2i_generator_Generator_emitFunctionDecl(gen, d, false);
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      c2i_generator_Generator_emitStructTypeDecl(gen, d, 0);
      break;
   case ast_DeclKind_EnumType:
      c2i_generator_Generator_emitEnumType(gen, d);
      break;
   case ast_DeclKind_EnumConstant:
      (0) || c2_assert("generator/c/c2i_generator_decl.c2", 37, "c2i_generator.Generator.emitDecl", "0");
      break;
   case ast_DeclKind_FunctionType:
      c2i_generator_Generator_emitFunctionTypeDecl(gen, d);
      break;
   case ast_DeclKind_AliasType:
      c2i_generator_Generator_emitAliasTypeDecl(gen, d);
      break;
   case ast_DeclKind_Variable:
      c2i_generator_Generator_emitVarDecl(gen, d, 0);
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   string_buffer_Buf_newline(out);
}

static void c2i_generator_Generator_emitVarDecl(c2i_generator_Generator* gen, const ast_Decl* d, uint32_t indent)
{
   string_buffer_Buf* out = gen->out;
   ast_VarDecl* v = ((ast_VarDecl*)(d));
   string_buffer_Buf_indent(out, indent);
   c2i_generator_Generator_emitTypeRef(gen, ast_VarDecl_getTypeRef(v));
   string_buffer_Buf_space(out);
   if (ast_Decl_getName(d)) string_buffer_Buf_add(out, ast_Decl_getName(d));
   ast_QualType qt = ast_Decl_getType(d);
   if ((ast_QualType_isConst(&qt) && ast_VarDecl_getInit(v))) {
      ast_Expr* initExpr = ast_VarDecl_getInit(v);
      string_buffer_Buf_add(out, " = ");
      c2i_generator_Generator_emitExpr(gen, initExpr);
   }
   if (ast_VarDecl_hasAutoAttr(v)) {
      if (ast_VarDecl_hasAttrAutoFile(v)) string_buffer_Buf_add(out, " @(auto_file)");
      if (ast_VarDecl_hasAttrAutoLine(v)) string_buffer_Buf_add(out, " @(auto_line)");
   }
}

static void c2i_generator_Generator_emitTypeRef(c2i_generator_Generator* gen, const ast_TypeRef* ref)
{
   const ast_Decl* d = ast_TypeRef_getUserDecl(ref);
   _Bool is_external = false;
   if (d) is_external = ((ast_Decl_getModule(d) != gen->mod));
   if (gen->in_body) {
      ast_TypeRef_printLiteral2(ref, gen->out, is_external, c2i_generator_print_expr, gen);
   } else {
      ast_TypeRef_printLiteral(ref, gen->out, is_external, true);
   }
}

static void c2i_generator_print_expr(void* arg, const ast_Expr* e, string_buffer_Buf* out)
{
   c2i_generator_Generator* gen = arg;
   c2i_generator_Generator_emitExpr(gen, e);
}

static void c2i_generator_Generator_emitEnumType(c2i_generator_Generator* gen, const ast_Decl* d)
{
   string_buffer_Buf* out = gen->out;
   ast_EnumTypeDecl* etd = ((ast_EnumTypeDecl*)(d));
   string_buffer_Buf_print(out, "type %s enum ", ast_Decl_getName(d));
   ast_QualType implType = ast_EnumTypeDecl_getImplType(etd);
   ast_QualType_print(&implType, out);
   string_buffer_Buf_add(out, " {\n");
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
   for (uint32_t i = 0; (i < ast_EnumTypeDecl_getNumConstants(etd)); i++) {
      ast_EnumConstantDecl* ecd = constants[i];
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_add(out, ast_Decl_getName(ast_EnumConstantDecl_asDecl(ecd)));
      ast_Expr* initExpr = ast_EnumConstantDecl_getInit(ecd);
      if (initExpr) {
         string_buffer_Buf_add(out, " = ");
         c2i_generator_Generator_emitExpr(gen, initExpr);
      }
      string_buffer_Buf_add(out, ",\n");
   }
   string_buffer_Buf_add(out, "}\n");
}

static void c2i_generator_Generator_emitFunctionDecl(c2i_generator_Generator* gen, const ast_Decl* d, _Bool as_type)
{
   string_buffer_Buf* out = gen->out;
   ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
   if (!as_type) string_buffer_Buf_add(out, "fn ");
   c2i_generator_Generator_emitTypeRef(gen, ast_FunctionDecl_getReturnTypeRef(fd));
   if (!as_type) {
      string_buffer_Buf_space(out);
      const char* prefix = ast_FunctionDecl_getPrefixName(fd);
      if (prefix) {
         string_buffer_Buf_add(out, prefix);
         string_buffer_Buf_add1(out, '.');
      }
      string_buffer_Buf_add(out, ast_Decl_getName(d));
   }
   string_buffer_Buf_lparen(out);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   for (uint32_t i = 0; (i < num_params); i++) {
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      c2i_generator_Generator_emitVarDecl(gen, ((ast_Decl*)(params[i])), 0);
   }
   if (ast_FunctionDecl_isVariadic(fd)) {
      if (num_params) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_add(out, "...");
   }
   string_buffer_Buf_add1(out, ')');
   if (ast_FunctionDecl_isInline(fd)) {
      string_buffer_Buf_space(out);
      gen->in_body = true;
      c2i_generator_Generator_emitStmt(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))), 0, true);
      gen->in_body = false;
      string_buffer_Buf_newline(out);
   } else {
      string_buffer_Buf_add(out, ";\n");
   }
}

static void c2i_generator_Generator_emitFunctionTypeDecl(c2i_generator_Generator* gen, const ast_Decl* d)
{
   string_buffer_Buf* out = gen->out;
   const ast_FunctionTypeDecl* ftd = ((ast_FunctionTypeDecl*)(d));
   string_buffer_Buf_print(out, "type %s fn ", ast_Decl_getName(d));
   c2i_generator_Generator_emitFunctionDecl(gen, ((ast_Decl*)(ast_FunctionTypeDecl_getDecl(ftd))), true);
}

static void c2i_generator_Generator_emitAliasTypeDecl(c2i_generator_Generator* gen, const ast_Decl* d)
{
   string_buffer_Buf* out = gen->out;
   ast_AliasTypeDecl* a = ((ast_AliasTypeDecl*)(d));
   string_buffer_Buf_print(out, "type %s ", ast_Decl_getName(d));
   c2i_generator_Generator_emitTypeRef(gen, ast_AliasTypeDecl_getTypeRef(a));
   string_buffer_Buf_add(out, ";\n");
}

static void c2i_generator_Generator_emitStructTypeDecl(c2i_generator_Generator* gen, const ast_Decl* d, uint32_t indent)
{
   string_buffer_Buf* out = gen->out;
   ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
   string_buffer_Buf_indent(out, indent);
   if ((indent == 0)) {
      string_buffer_Buf_add(out, "type ");
      string_buffer_Buf_add(out, ast_Decl_getName(d));
      if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, " struct");
      else string_buffer_Buf_add(out, " union");
   } else {
      if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct");
      else string_buffer_Buf_add(out, "union");
      if (ast_Decl_getNameIdx(d)) string_buffer_Buf_print(out, " %s", ast_Decl_getName(d));
   }
   if (ast_StructTypeDecl_isOpaque(std)) {
      string_buffer_Buf_add(out, " @(opaque) {}\n");
   } else {
      string_buffer_Buf_add(out, " {\n");
      ast_Decl** members = ast_StructTypeDecl_getMembers(std);
      for (uint32_t i = 0; (i < ast_StructTypeDecl_getNumMembers(std)); i++) {
         const ast_Decl* m = members[i];
         if (ast_Decl_isStructType(m)) {
            c2i_generator_Generator_emitStructTypeDecl(gen, m, (indent + 1));
         } else {
            (ast_Decl_isVariable(m)) || c2_assert("generator/c/c2i_generator_decl.c2", 199, "c2i_generator.Generator.emitStructTypeDecl", "m.isVariable()");
            c2i_generator_Generator_emitVarDecl(gen, m, (indent + 1));
            string_buffer_Buf_add(out, ";\n");
         }
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   }
}

static void c2i_generator_Generator_emitMember(c2i_generator_Generator* gen, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_MemberExpr* m = ((ast_MemberExpr*)(e));
   const ast_Expr* base = ast_MemberExpr_getExprBase(m);
   if (base) {
      c2i_generator_Generator_emitExpr(gen, base);
   }
   for (uint32_t i = 0; (i < ast_MemberExpr_getNumRefs(m)); i++) {
      if (((i != 0) || base)) string_buffer_Buf_add1(out, '.');
      ast_Ref r = ast_MemberExpr_getRef(m, i);
      if (((i == 0) && (ast_Decl_getModule(r.decl) != gen->mod))) {
         string_buffer_Buf_add(out, ast_Decl_getFullName(r.decl));
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(r.decl));
      }
   }
}

static void c2i_generator_Generator_emitExpr(c2i_generator_Generator* gen, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      ast_IntegerLiteral_printLiteral(((ast_IntegerLiteral*)(e)), out);
      return;
   case ast_ExprKind_FloatLiteral:
      ast_FloatLiteral_printLiteral(((ast_FloatLiteral*)(e)), out);
      return;
   case ast_ExprKind_BooleanLiteral:
      ast_BooleanLiteral_printLiteral(((ast_BooleanLiteral*)(e)), out);
      return;
   case ast_ExprKind_CharLiteral:
      ast_CharLiteral_printLiteral(((ast_CharLiteral*)(e)), out);
      return;
   case ast_ExprKind_StringLiteral:
      ast_StringLiteral_printLiteral(((ast_StringLiteral*)(e)), out);
      return;
   case ast_ExprKind_Nil:
      string_buffer_Buf_add(out, "nil");
      return;
   case ast_ExprKind_Identifier: {
      const ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      ast_Decl* d = ast_IdentifierExpr_getDecl(i);
      if ((ast_Decl_getModule(d) != gen->mod)) {
         string_buffer_Buf_add(out, ast_Decl_getFullName(d));
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
      return;
   }
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      c2i_generator_Generator_emitCall(gen, e);
      return;
   case ast_ExprKind_InitList:
      break;
   case ast_ExprKind_FieldDesignatedInit:
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator: {
      const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
      c2i_generator_Generator_emitExpr(gen, ast_BinaryOperator_getLHS(b));
      string_buffer_Buf_print(out, " %s ", ast_BinaryOperator_getOpcodeStr(b));
      c2i_generator_Generator_emitExpr(gen, ast_BinaryOperator_getRHS(b));
      return;
   }
   case ast_ExprKind_UnaryOperator: {
      const ast_UnaryOperator* u = ((ast_UnaryOperator*)(e));
      if (ast_UnaryOperator_isBefore(u)) {
         string_buffer_Buf_add(out, ast_UnaryOperator_getOpcodeStr(u));
         c2i_generator_Generator_emitExpr(gen, ast_UnaryOperator_getInner(u));
      } else {
         c2i_generator_Generator_emitExpr(gen, ast_UnaryOperator_getInner(u));
         string_buffer_Buf_add(out, ast_UnaryOperator_getOpcodeStr(u));
      }
      return;
   }
   case ast_ExprKind_ConditionalOperator:
      break;
   case ast_ExprKind_Builtin:
      c2i_generator_Generator_emitBuiltin(gen, e);
      return;
   case ast_ExprKind_ArraySubscript: {
      const ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      const ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      if (ast_Expr_isBitOffset(index)) {
         (0) || c2_assert("generator/c/c2i_generator_expr.c2", 88, "c2i_generator.Generator.emitExpr", "0");
      } else {
         c2i_generator_Generator_emitExpr(gen, ast_ArraySubscriptExpr_getBase(a));
         string_buffer_Buf_add1(out, '[');
         c2i_generator_Generator_emitExpr(gen, index);
         string_buffer_Buf_add1(out, ']');
      }
      return;
   }
   case ast_ExprKind_Member:
      c2i_generator_Generator_emitMember(gen, e);
      return;
   case ast_ExprKind_Paren: {
      const ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      string_buffer_Buf_lparen(out);
      c2i_generator_Generator_emitExpr(gen, ast_ParenExpr_getInner(p));
      string_buffer_Buf_rparen(out);
      return;
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast:
      break;
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* c = ((ast_ImplicitCastExpr*)(e));
      c2i_generator_Generator_emitExpr(gen, ast_ImplicitCastExpr_getInner(c));
      return;
   }
   case ast_ExprKind_Range: {
      const ast_RangeExpr* b = ((ast_RangeExpr*)(e));
      c2i_generator_Generator_emitExpr(gen, ast_RangeExpr_getLHS(b));
      string_buffer_Buf_print(out, " ... ");
      c2i_generator_Generator_emitExpr(gen, ast_RangeExpr_getRHS(b));
      return;
   }
   }
   ast_Expr_dump(e);
   (0) || c2_assert("generator/c/c2i_generator_expr.c2", 122, "c2i_generator.Generator.emitExpr", "0");
}

static void c2i_generator_Generator_emitBuiltin(c2i_generator_Generator* gen, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_BuiltinExpr* b = ((ast_BuiltinExpr*)(e));
   ast_Value v = ast_BuiltinExpr_getValue(b);
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof:
      string_buffer_Buf_add(out, "sizeof(");
      c2i_generator_Generator_emitExpr(gen, ast_BuiltinExpr_getInner(b));
      string_buffer_Buf_rparen(out);
      break;
   case ast_BuiltinExprKind_Elemsof:
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      return;
   case ast_BuiltinExprKind_EnumMin:
      break;
   case ast_BuiltinExprKind_EnumMax:
      break;
   case ast_BuiltinExprKind_OffsetOf:
      break;
   case ast_BuiltinExprKind_ToContainer:
      break;
   }
   ast_Expr_dump(e);
   (0) || c2_assert("generator/c/c2i_generator_expr.c2", 153, "c2i_generator.Generator.emitBuiltin", "0");
}

static void c2i_generator_Generator_emitCall(c2i_generator_Generator* gen, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   ast_CallExpr* call = ((ast_CallExpr*)(e));
   (!ast_CallExpr_isTemplateCall(call)) || c2_assert("generator/c/c2i_generator_expr.c2", 166, "c2i_generator.Generator.emitCall", "!call.isTemplateCall()");
   ast_Expr* func = ast_CallExpr_getFunc(call);
   ((ast_Expr_getKind(func) == ast_ExprKind_ImplicitCast)) || c2_assert("generator/c/c2i_generator_expr.c2", 169, "c2i_generator.Generator.emitCall", "func.getKind() == ExprKind.ImplicitCast");
   ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(func));
   func = ast_ImplicitCastExpr_getInner(ic);
   c2i_generator_Generator_emitExpr(gen, func);
   string_buffer_Buf_lparen(out);
   uint32_t num_args = ast_CallExpr_getNumArgs(call);
   ast_Expr** args = ast_CallExpr_getArgs(call);
   for (uint32_t i = 0; (i < num_args); i++) {
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      c2i_generator_Generator_emitExpr(gen, args[i]);
   }
   string_buffer_Buf_rparen(out);
}

static void c2i_generator_Generator_emitStmt(c2i_generator_Generator* gen, ast_Stmt* s, uint32_t indent, _Bool newline)
{
   string_buffer_Buf* out = gen->out;
   if (newline) {
      if ((ast_Stmt_getKind(s) == ast_StmtKind_Label)) string_buffer_Buf_indent(out, (indent - 1));
      else string_buffer_Buf_indent(out, indent);
   }
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      string_buffer_Buf_add(out, "return");
      ast_ReturnStmt* r = ((ast_ReturnStmt*)(s));
      ast_Expr* val = ast_ReturnStmt_getValue(r);
      if (val) {
         string_buffer_Buf_space(out);
         c2i_generator_Generator_emitExpr(gen, val);
      }
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Expr:
      c2i_generator_Generator_emitExpr(gen, ((ast_Expr*)(s)));
      if (newline) string_buffer_Buf_add(out, ";\n");
      break;
   case ast_StmtKind_If: {
      ast_IfStmt* i = ((ast_IfStmt*)(s));
      ast_Stmt* cond = ast_IfStmt_getCond(i);
      _Bool is_decl = ast_Stmt_isDecl(cond);
      if (is_decl) {
         c2i_generator_Generator_emitStmt(gen, cond, 0, true);
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "if (");
         ast_DeclStmt* ds = ((ast_DeclStmt*)(cond));
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
      } else {
         string_buffer_Buf_add(out, "if (");
         c2i_generator_Generator_emitStmt(gen, cond, 0, false);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* thenStmt = ast_IfStmt_getThen(i);
      c2i_generator_Generator_emitStmt(gen, thenStmt, indent, false);
      if (!ast_Stmt_isCompound(thenStmt)) {
         if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
      }
      ast_Stmt* elseStmt = ast_IfStmt_getElse(i);
      if (elseStmt) {
         if (ast_Stmt_isCompound(thenStmt)) {
            string_buffer_Buf_space(out);
         } else {
            if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_newline(out);
            string_buffer_Buf_indent(out, indent);
         }
         string_buffer_Buf_add(out, "else ");
         c2i_generator_Generator_emitStmt(gen, elseStmt, indent, false);
         if (!ast_Stmt_isCompound(elseStmt)) {
            if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
         }
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_While: {
      ast_WhileStmt* w = ((ast_WhileStmt*)(s));
      ast_Stmt* cond = ast_WhileStmt_getCond(w);
      _Bool is_decl = ast_Stmt_isDecl(cond);
      if (is_decl) {
         c2i_generator_Generator_emitStmt(gen, cond, 0, true);
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "while (");
         ast_DeclStmt* ds = ((ast_DeclStmt*)(cond));
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
      } else {
         string_buffer_Buf_add(out, "while (");
         c2i_generator_Generator_emitStmt(gen, cond, 0, false);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* body = ast_WhileStmt_getBody(w);
      c2i_generator_Generator_emitStmt(gen, body, indent, false);
      if (!ast_Stmt_isCompound(body)) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_For: {
      ast_ForStmt* f = ((ast_ForStmt*)(s));
      string_buffer_Buf_add(out, "for (");
      ast_Stmt* initStmt = ast_ForStmt_getInit(f);
      if (initStmt) {
         c2i_generator_Generator_emitStmt(gen, initStmt, 0, false);
      }
      string_buffer_Buf_add1(out, ';');
      if (ast_ForStmt_getCond(f)) {
         string_buffer_Buf_space(out);
         c2i_generator_Generator_emitExpr(gen, ast_ForStmt_getCond(f));
      }
      string_buffer_Buf_add1(out, ';');
      ast_Expr* cont = ast_ForStmt_getCont(f);
      if (cont) {
         string_buffer_Buf_space(out);
         c2i_generator_Generator_emitExpr(gen, cont);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* body = ast_ForStmt_getBody(f);
      c2i_generator_Generator_emitStmt(gen, body, indent, false);
      if (!ast_Stmt_isCompound(body)) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_Switch:
      c2i_generator_Generator_emitSwitchStmt(gen, s, indent);
      break;
   case ast_StmtKind_Break:
      string_buffer_Buf_add(out, "break;\n");
      break;
   case ast_StmtKind_Continue:
      string_buffer_Buf_add(out, "continue;\n");
      break;
   case ast_StmtKind_Fallthrough:
      string_buffer_Buf_add(out, "fallthrough;\n");
      break;
   case ast_StmtKind_Label: {
      ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      string_buffer_Buf_add(out, ast_LabelStmt_getName(ls));
      string_buffer_Buf_add1(out, ':');
      if ((!stmt || ast_Stmt_isDecl(stmt))) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      if (stmt) {
         c2i_generator_Generator_emitStmt(gen, stmt, indent, true);
      }
      break;
   }
   case ast_StmtKind_Goto: {
      ast_GotoStmt* g = ((ast_GotoStmt*)(s));
      string_buffer_Buf_add(out, "goto ");
      string_buffer_Buf_add(out, ast_GotoStmt_getName(g));
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      string_buffer_Buf_add(out, "{\n");
      uint32_t count = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; (i < count); i++) {
         c2i_generator_Generator_emitStmt(gen, stmts[i], (indent + 1), true);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add1(out, '}');
      if (newline) string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_Decl: {
      ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      ast_Decl* d = ((ast_Decl*)(vd));
      c2i_generator_Generator_emitTypeRef(gen, ast_VarDecl_getTypeRef(vd));
      string_buffer_Buf_space(out);
      string_buffer_Buf_add(out, ast_Decl_getName(d));
      const ast_Expr* ie = ast_VarDecl_getInit(vd);
      if (ie) {
         string_buffer_Buf_add(out, " = ");
         c2i_generator_Generator_emitExpr(gen, ie);
      }
      if (newline) string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Asm:
      break;
   case ast_StmtKind_Assert:
      break;
   }
}

static void c2i_generator_Generator_emitSwitchStmt(c2i_generator_Generator* gen, ast_Stmt* s, uint32_t indent)
{
}


// --- module dep_finder ---
typedef struct dep_finder_Finder_ dep_finder_Finder;

typedef void (*dep_finder_OnDecl)(void* arg, ast_Decl* d);

struct dep_finder_Finder_ {
   ast_Module* mod;
   void* arg;
   dep_finder_OnDecl on_decl;
   ast_Decl* current;
};

static void dep_finder_Finder_init(dep_finder_Finder* f, ast_Module* mod, void* arg, dep_finder_OnDecl on_decl);
static void dep_finder_Finder_check(dep_finder_Finder* s, ast_Decl* d);
static void dep_finder_Finder_handleFunction(dep_finder_Finder* s, ast_FunctionDecl* d);
static void dep_finder_Finder_handleStruct(dep_finder_Finder* s, ast_StructTypeDecl* d);
static void dep_finder_Finder_handleEnumType(dep_finder_Finder* s, ast_EnumTypeDecl* etd);
static void dep_finder_Finder_handleTypeRef(dep_finder_Finder* f, ast_TypeRef* r);
static void dep_finder_Finder_handleVarDecl(dep_finder_Finder* s, ast_VarDecl* d);
static void dep_finder_Finder_handleExpr(dep_finder_Finder* s, ast_Expr* e);
static void dep_finder_Finder_handleInitList(dep_finder_Finder* s, ast_InitListExpr* ile);
static void dep_finder_Finder_handleMemberExpr(dep_finder_Finder* s, ast_MemberExpr* m);
static void dep_finder_Finder_onDep(dep_finder_Finder* s, const ast_Decl* d, _Bool full);

static void dep_finder_Finder_init(dep_finder_Finder* f, ast_Module* mod, void* arg, dep_finder_OnDecl on_decl)
{
   f->mod = mod;
   f->arg = arg;
   f->on_decl = on_decl;
   f->current = NULL;
}

static void dep_finder_Finder_check(dep_finder_Finder* s, ast_Decl* d)
{
   s->current = d;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      dep_finder_Finder_handleFunction(s, ((ast_FunctionDecl*)(d)));
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      dep_finder_Finder_handleStruct(s, ((ast_StructTypeDecl*)(d)));
      break;
   case ast_DeclKind_EnumType:
      dep_finder_Finder_handleEnumType(s, ((ast_EnumTypeDecl*)(d)));
      break;
   case ast_DeclKind_EnumConstant:
      ast_Decl_dump(d);
      (0) || c2_assert("generator/c/dep_finder.c2", 52, "dep_finder.Finder.check", "0");
      break;
   case ast_DeclKind_FunctionType: {
      ast_FunctionTypeDecl* ftd = ((ast_FunctionTypeDecl*)(d));
      dep_finder_Finder_handleFunction(s, ast_FunctionTypeDecl_getDecl(ftd));
      break;
   }
   case ast_DeclKind_AliasType: {
      ast_AliasTypeDecl* at = ((ast_AliasTypeDecl*)(d));
      dep_finder_Finder_handleTypeRef(s, ast_AliasTypeDecl_getTypeRef(at));
      break;
   }
   case ast_DeclKind_Variable:
      dep_finder_Finder_handleVarDecl(s, ((ast_VarDecl*)(d)));
      break;
   }
}

static void dep_finder_Finder_handleFunction(dep_finder_Finder* s, ast_FunctionDecl* d)
{
   if (ast_FunctionDecl_isTemplate(d)) return;

   dep_finder_Finder_handleTypeRef(s, ast_FunctionDecl_getReturnTypeRef(d));
   uint32_t num_params = ast_FunctionDecl_getNumParams(d);
   ast_VarDecl** args = ast_FunctionDecl_getParams(d);
   for (uint32_t i = 0; (i < num_params); i++) dep_finder_Finder_handleVarDecl(s, args[i]);
}

static void dep_finder_Finder_handleStruct(dep_finder_Finder* s, ast_StructTypeDecl* d)
{
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(d);
   ast_Decl** members = ast_StructTypeDecl_getMembers(d);
   for (uint32_t i = 0; (i < num_members); i++) {
      ast_Decl* m = members[i];
      if (ast_Decl_isStructType(m)) {
         dep_finder_Finder_handleStruct(s, ((ast_StructTypeDecl*)(m)));
      } else {
         (ast_Decl_isVariable(m)) || c2_assert("generator/c/dep_finder.c2", 103, "dep_finder.Finder.handleStruct", "m.isVariable()");
         dep_finder_Finder_handleVarDecl(s, ((ast_VarDecl*)(m)));
      }
   }
}

static void dep_finder_Finder_handleEnumType(dep_finder_Finder* s, ast_EnumTypeDecl* etd)
{
   uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(etd);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
   for (uint32_t i = 0; (i < num_constants); i++) {
      ast_EnumConstantDecl* c = constants[i];
      ast_Expr* initExpr = ast_EnumConstantDecl_getInit(c);
      if (initExpr) dep_finder_Finder_handleExpr(s, initExpr);
   }
}

static void dep_finder_Finder_handleTypeRef(dep_finder_Finder* f, ast_TypeRef* r)
{
   const ast_Decl* refDecl = ast_TypeRef_getUserDecl(r);
   if (refDecl) {
      if ((ast_TypeRef_getNumPointers(r) && ast_Decl_isStructType(refDecl))) {
      } else {
         dep_finder_Finder_onDep(f, refDecl, (ast_TypeRef_getNumPointers(r) == 0));
      }
   }
   uint32_t num_arrays = ast_TypeRef_getNumArrays(r);
   for (uint32_t i = 0; (i < num_arrays); i++) {
      ast_Expr* e = ast_TypeRef_getArray(r, i);
      if (e) dep_finder_Finder_handleExpr(f, e);
   }
}

static void dep_finder_Finder_handleVarDecl(dep_finder_Finder* s, ast_VarDecl* d)
{
   dep_finder_Finder_handleTypeRef(s, ast_VarDecl_getTypeRef(d));
   ast_Expr* init_expr = ast_VarDecl_getInit(d);
   if (init_expr) dep_finder_Finder_handleExpr(s, init_expr);
}

static void dep_finder_Finder_handleExpr(dep_finder_Finder* s, ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      break;
   case ast_ExprKind_FloatLiteral:
      break;
   case ast_ExprKind_BooleanLiteral:
      break;
   case ast_ExprKind_CharLiteral:
      break;
   case ast_ExprKind_StringLiteral:
      break;
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      ast_Decl* d = ast_IdentifierExpr_getDecl(i);
      dep_finder_Finder_onDep(s, d, true);
      break;
   }
   case ast_ExprKind_Type: {
      ast_TypeExpr* t = ((ast_TypeExpr*)(e));
      dep_finder_Finder_handleTypeRef(s, ast_TypeExpr_getTypeRef(t));
      break;
   }
   case ast_ExprKind_Call:
      break;
   case ast_ExprKind_InitList:
      dep_finder_Finder_handleInitList(s, ((ast_InitListExpr*)(e)));
      break;
   case ast_ExprKind_FieldDesignatedInit: {
      ast_FieldDesignatedInitExpr* i = ((ast_FieldDesignatedInitExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_FieldDesignatedInitExpr_getInit(i));
      break;
   }
   case ast_ExprKind_ArrayDesignatedInit: {
      ast_ArrayDesignatedInitExpr* a = ((ast_ArrayDesignatedInitExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_ArrayDesignatedInitExpr_getDesignator(a));
      dep_finder_Finder_handleExpr(s, ast_ArrayDesignatedInitExpr_getInit(a));
      break;
   }
   case ast_ExprKind_BinaryOperator: {
      ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
      dep_finder_Finder_handleExpr(s, ast_BinaryOperator_getLHS(b));
      dep_finder_Finder_handleExpr(s, ast_BinaryOperator_getRHS(b));
      break;
   }
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* u = ((ast_UnaryOperator*)(e));
      dep_finder_Finder_handleExpr(s, ast_UnaryOperator_getInner(u));
      break;
   }
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = ((ast_ConditionalOperator*)(e));
      dep_finder_Finder_handleExpr(s, ast_ConditionalOperator_getCond(c));
      dep_finder_Finder_handleExpr(s, ast_ConditionalOperator_getLHS(c));
      dep_finder_Finder_handleExpr(s, ast_ConditionalOperator_getRHS(c));
      break;
   }
   case ast_ExprKind_Builtin: {
      ast_BuiltinExpr* b = ((ast_BuiltinExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_BuiltinExpr_getInner(b));
      break;
   }
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_ArraySubscriptExpr_getBase(a));
      dep_finder_Finder_handleExpr(s, ast_ArraySubscriptExpr_getIndex(a));
      break;
   }
   case ast_ExprKind_Member:
      dep_finder_Finder_handleMemberExpr(s, ((ast_MemberExpr*)(e)));
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_ParenExpr_getInner(p));
      break;
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* c = ((ast_ExplicitCastExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_ExplicitCastExpr_getInner(c));
      dep_finder_Finder_handleTypeRef(s, ast_ExplicitCastExpr_getTypeRef(c));
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* c = ((ast_ImplicitCastExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_ImplicitCastExpr_getInner(c));
      break;
   }
   case ast_ExprKind_Range: {
      ast_RangeExpr* b = ((ast_RangeExpr*)(e));
      dep_finder_Finder_handleExpr(s, ast_RangeExpr_getLHS(b));
      dep_finder_Finder_handleExpr(s, ast_RangeExpr_getRHS(b));
      break;
   }
   }
}

static void dep_finder_Finder_handleInitList(dep_finder_Finder* s, ast_InitListExpr* ile)
{
   uint32_t count = ast_InitListExpr_getNumValues(ile);
   ast_Expr** exprs = ast_InitListExpr_getValues(ile);
   for (uint32_t i = 0; (i < count); i++) {
      dep_finder_Finder_handleExpr(s, exprs[i]);
   }
}

static void dep_finder_Finder_handleMemberExpr(dep_finder_Finder* s, ast_MemberExpr* m)
{
   ast_Decl* d = ast_MemberExpr_getFullDecl(m);
   if (ast_Decl_isEnumConstant(d)) {
      d = ast_MemberExpr_getPrevLastDecl(m);
      (ast_Decl_isEnum(d)) || c2_assert("generator/c/dep_finder.c2", 245, "dep_finder.Finder.handleMemberExpr", "d.isEnum()");
   }
   dep_finder_Finder_onDep(s, d, true);
}

static void dep_finder_Finder_onDep(dep_finder_Finder* s, const ast_Decl* d, _Bool full)
{
   if ((ast_Decl_getModule(d) != s->mod)) return;

   if (ast_Decl_isGenerated(d)) return;

   if ((d == s->current)) return;

   s->on_decl(s->arg, ((ast_Decl*)(d)));
}


// --- module qbe ---
typedef struct qbe_Var_ qbe_Var;

struct qbe_Var_ {
   const ast_VarDecl* vd;
   uint32_t slot;
   uint32_t width;
   uint32_t align;
   uint32_t size;
};



// --- module qbe_locals ---
typedef struct qbe_locals_Locals_ qbe_locals_Locals;

struct qbe_locals_Locals_ {
   qbe_Var* vars;
   uint32_t count;
   uint32_t capacity;
   uint32_t index;
};

static void qbe_locals_Locals_init(qbe_locals_Locals* l);
static void qbe_locals_Locals_free(qbe_locals_Locals* l);
static void qbe_locals_Locals_clear(qbe_locals_Locals* l);
static void qbe_locals_Locals_resize(qbe_locals_Locals* l, uint32_t capacity);
static void qbe_locals_Locals_skipSlots(qbe_locals_Locals* l, uint32_t amount);
static uint32_t qbe_locals_Locals_add(qbe_locals_Locals* l, ast_VarDecl* vd, uint32_t width, uint32_t align, uint32_t size);
static uint32_t qbe_locals_Locals_get(qbe_locals_Locals* l);
static qbe_Var* qbe_locals_Locals_find(const qbe_locals_Locals* l, const ast_VarDecl* vd);
static void qbe_locals_Locals_dump(const qbe_locals_Locals* l);

static void qbe_locals_Locals_init(qbe_locals_Locals* l)
{
   qbe_locals_Locals_clear(l);
   qbe_locals_Locals_resize(l, 32);
}

static void qbe_locals_Locals_free(qbe_locals_Locals* l)
{
   free(l->vars);
}

static void qbe_locals_Locals_clear(qbe_locals_Locals* l)
{
   l->count = 0;
   l->index = 1;
}

static void qbe_locals_Locals_resize(qbe_locals_Locals* l, uint32_t capacity)
{
   l->capacity = capacity;
   qbe_Var* vars2 = malloc((capacity * 24));
   if (l->count) {
      memcpy(vars2, l->vars, (l->count * 24));
      free(l->vars);
   }
   l->vars = vars2;
}

static void qbe_locals_Locals_skipSlots(qbe_locals_Locals* l, uint32_t amount)
{
   l->index += amount;
}

static uint32_t qbe_locals_Locals_add(qbe_locals_Locals* l, ast_VarDecl* vd, uint32_t width, uint32_t align, uint32_t size)
{
   if ((l->count == l->capacity)) qbe_locals_Locals_resize(l, (l->capacity * 2));
   qbe_Var* var = &l->vars[l->count];
   l->count++;
   uint32_t slot = l->index;
   l->index++;
   var->vd = vd;
   var->slot = slot;
   var->width = width;
   var->align = align;
   var->size = size;
   return slot;
}

static uint32_t qbe_locals_Locals_get(qbe_locals_Locals* l)
{
   return l->index++;
}

static qbe_Var* qbe_locals_Locals_find(const qbe_locals_Locals* l, const ast_VarDecl* vd)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      qbe_Var* v = &l->vars[i];
      if ((v->vd == vd)) return v;

   }
   return NULL;
}

static void qbe_locals_Locals_dump(const qbe_locals_Locals* l)
{
   printf("Locals %u/%u last %u\n", l->count, l->capacity, l->index);
   for (uint32_t i = 0; (i < l->count); i++) {
      const qbe_Var* v = &l->vars[i];
      printf("  [%2u] slot %u  s %u a %u  %s\n", i, v->slot, v->size, v->align, ast_VarDecl_getName(v->vd));
   }
}


// --- module array_init_sorter ---
typedef struct array_init_sorter_InitEntry_ array_init_sorter_InitEntry;
typedef struct array_init_sorter_Sorter_ array_init_sorter_Sorter;

struct array_init_sorter_InitEntry_ {
   uint32_t index;
   const ast_Expr* expr;
};

struct array_init_sorter_Sorter_ {
   array_init_sorter_InitEntry* entries;
   uint32_t index;
   uint32_t count;
   uint32_t array_size;
   uint32_t elem_size;
};

typedef void (*array_init_sorter_OnZeroFn)(void* arg, uint32_t size);

typedef void (*array_init_sorter_OnExprFn)(void* arg, const ast_Expr* e, uint32_t elem_size);

static array_init_sorter_Sorter array_init_sorter_create(uint32_t allocate, uint32_t array_size, uint32_t elem_size);
static void array_init_sorter_Sorter_free(array_init_sorter_Sorter* s);
static void array_init_sorter_Sorter_addAt(array_init_sorter_Sorter* s, uint32_t index, const ast_Expr* e);
static void array_init_sorter_Sorter_add(array_init_sorter_Sorter* s, const ast_Expr* e);
static void array_init_sorter_Sorter_iterate(const array_init_sorter_Sorter* s, array_init_sorter_OnExprFn on_expr, array_init_sorter_OnZeroFn on_zero, void* arg);

static array_init_sorter_Sorter array_init_sorter_create(uint32_t allocate, uint32_t array_size, uint32_t elem_size)
{
   ((array_size != 0)) || c2_assert("generator/ir/array_init_sorter.c2", 36, "array_init_sorter.create", "array_size != 0");
   array_init_sorter_Sorter s = { };
   s.array_size = array_size;
   s.elem_size = elem_size;
   s.entries = malloc((allocate * 16));
   return s;
}

static void array_init_sorter_Sorter_free(array_init_sorter_Sorter* s)
{
   free(s->entries);
}

static void array_init_sorter_Sorter_addAt(array_init_sorter_Sorter* s, uint32_t index, const ast_Expr* e)
{
   array_init_sorter_InitEntry entry = { .index = index, .expr = e };
   if ((s->count == 0)) {
      s->entries[0] = entry;
      s->count = 1;
      s->index = (index + 1);
      return;
   }
   uint32_t idx = s->count;
   while (idx) {
      array_init_sorter_InitEntry* ie = &s->entries[(idx - 1)];
      if ((index > ie->index)) break;

      s->entries[idx] = *ie;
      idx--;
   }
   s->entries[idx] = entry;
   s->count++;
   s->index = (index + 1);
}

static void array_init_sorter_Sorter_add(array_init_sorter_Sorter* s, const ast_Expr* e)
{
   array_init_sorter_Sorter_addAt(s, s->index, e);
}

static void array_init_sorter_Sorter_iterate(const array_init_sorter_Sorter* s, array_init_sorter_OnExprFn on_expr, array_init_sorter_OnZeroFn on_zero, void* arg)
{
   uint32_t last = 0;
   for (uint32_t i = 0; (i < s->count); i++) {
      const array_init_sorter_InitEntry* ie = &s->entries[i];
      if ((ie->index > (last + 1))) {
         on_zero(arg, ((((ie->index - last) - 1)) * s->elem_size));
      }
      last = ie->index;
      on_expr(arg, ie->expr, s->elem_size);
   }
   if (((last + 1) < s->array_size)) {
      on_zero(arg, ((((s->array_size - last) - 1)) * s->elem_size));
   }
}


// --- module ir ---
typedef struct ir_Block_ ir_Block;
typedef struct ir_BlockList_ ir_BlockList;
typedef struct ir_Case_ ir_Case;
typedef struct ir_CaseList_ ir_CaseList;
typedef struct ir_Constant_ ir_Constant;
typedef struct ir_ConstantList_ ir_ConstantList;
typedef struct ir_Context_ ir_Context;
typedef struct ir_FunctionInfo_ ir_FunctionInfo;
typedef struct ir_InitValue_ ir_InitValue;
typedef struct ir_InitValueList_ ir_InitValueList;
typedef struct ir_ReadSlotAccess_ ir_ReadSlotAccess;
typedef struct ir_WriteSlotAccess_ ir_WriteSlotAccess;
typedef struct ir_BlockIndex_ ir_BlockIndex;
typedef struct ir_SlotCollector_ ir_SlotCollector;
typedef struct ir_RevIndex_ ir_RevIndex;
typedef struct ir_RevList_ ir_RevList;
typedef struct ir_Symbol_ ir_Symbol;
typedef struct ir_SymbolList_ ir_SymbolList;
typedef struct ir_InstrBits_ ir_InstrBits;
typedef struct ir_Instr_ ir_Instr;
typedef struct ir_InstrList_ ir_InstrList;
typedef struct ir_PhiClause_ ir_PhiClause;
typedef struct ir_PhiList_ ir_PhiList;
typedef struct ir_PhiCache_ ir_PhiCache;
typedef struct ir_PrintHelper_ ir_PrintHelper;
typedef struct ir_Ref_ ir_Ref;
typedef struct ir_RefList_ ir_RefList;
typedef struct ir_Index_ ir_Index;

typedef enum {
   ir_BlockKind_Unspecified,
   ir_BlockKind_FnStart,
   ir_BlockKind_WhileCond,
   ir_BlockKind_WhileBody,
   ir_BlockKind_WhileJoin,
   ir_BlockKind_ForCond,
   ir_BlockKind_ForBody,
   ir_BlockKind_ForCont,
   ir_BlockKind_ForJoin,
   ir_BlockKind_IfTrue,
   ir_BlockKind_IfFalse,
   ir_BlockKind_IfJoin,
   ir_BlockKind_AndTrue,
   ir_BlockKind_LogicJoin,
   ir_BlockKind_OrFalse,
   ir_BlockKind_CondTrue,
   ir_BlockKind_CondFalse,
   ir_BlockKind_CondJoin,
   ir_BlockKind_Label,
   ir_BlockKind_SwitchCase,
   ir_BlockKind_SwitchJoin,
   ir_BlockKind_SwitchDefault,
   _ir_BlockKind_max = 255
} __attribute__((packed)) ir_BlockKind;

typedef uint32_t ir_BlockId;

struct ir_Index_ {
   uint32_t start;
   uint32_t count;
};

struct ir_Block_ {
   ir_BlockKind kind : 8;
   uint32_t used : 1;
   uint32_t checked : 1;
   uint32_t end_with_switch : 1;
   uint32_t phi_source : 1;
   uint32_t end_block : 1;
   ir_BlockId dests[2];
   ir_Index instr;
};

static const char* ir_BlockKind_str(ir_BlockKind k);
static void ir_Block_init(ir_Block* b, ir_BlockKind kind);
static ir_BlockKind ir_Block_getKind(const ir_Block* b);
static const char* ir_Block_getKindName(const ir_Block* b);
static void ir_Block_setInstructions(ir_Block* b, uint32_t start, uint32_t count);
static ir_Index ir_Block_getInstructions(const ir_Block* b);
static void ir_Block_setDest(ir_Block* b, ir_BlockId dest1, ir_BlockId dest2);
struct ir_BlockList_ {
   uint32_t count;
   uint32_t capacity;
   ir_Block* blocks;
};

static void ir_BlockList_init(ir_BlockList* l, uint32_t initial_size);
static void ir_BlockList_free(ir_BlockList* l);
static void ir_BlockList_resize(ir_BlockList* l, uint32_t cap);
static ir_BlockId ir_BlockList_add(ir_BlockList* l, ir_BlockKind kind);
static ir_BlockId ir_BlockList_copy(ir_BlockList* l, const ir_Block* b2);
static void ir_BlockList_clear(ir_BlockList* l);
static uint32_t ir_BlockList_getCount(const ir_BlockList* l);
static uint32_t ir_BlockList_getUsedCount(const ir_BlockList* l);
static ir_Block* ir_BlockList_get(const ir_BlockList* l, ir_BlockId idx);
typedef uint32_t ir_CaseId;

struct ir_Case_ {
   uint32_t value;
   ir_BlockId block;
};

struct ir_CaseList_ {
   uint32_t count;
   uint32_t capacity;
   ir_Case* cases;
};

static void ir_CaseList_init(ir_CaseList* l);
static void ir_CaseList_free(ir_CaseList* l);
static void ir_CaseList_resize(ir_CaseList* l, uint32_t extra, _Bool copy);
static ir_CaseId ir_CaseList_reserve(ir_CaseList* l, uint32_t count);
static void ir_CaseList_set(ir_CaseList* l, ir_CaseId id, uint32_t value, ir_BlockId block);
static void ir_CaseList_clear(ir_CaseList* l);
static uint32_t ir_CaseList_getCount(const ir_CaseList* l);
static ir_Case* ir_CaseList_get(const ir_CaseList* l, ir_CaseId idx);
static void ir_CaseList_copy(ir_CaseList* l, const ir_CaseList* l2);
struct ir_Constant_ {
   union {
      int64_t ivalue;
      uint64_t uvalue;
      float svalue;
      double dvalue;
   };
};

struct ir_ConstantList_ {
   uint32_t count;
   uint32_t capacity;
   ir_Constant* constants;
};

static void ir_ConstantList_init(ir_ConstantList* l, uint32_t initial_size);
static void ir_ConstantList_free(ir_ConstantList* l);
static uint32_t ir_ConstantList_add(ir_ConstantList* l, const ir_Constant* c);
static uint32_t ir_ConstantList_getCount(const ir_ConstantList* l);
static ir_Constant* ir_ConstantList_get(const ir_ConstantList* l, uint32_t idx);
struct ir_SymbolList_ {
   uint32_t count;
   uint32_t capacity;
   ir_Symbol* symbols;
};

struct ir_InitValueList_ {
   uint32_t count;
   uint32_t capacity;
   ir_InitValue* values;
};

typedef uint32_t ir_SymbolId;

struct ir_SlotCollector_ {
   uint32_t read_idx;
   uint32_t write_idx;
   uint32_t num_writes;
   uint32_t num_blocks;
   ir_ReadSlotAccess* reads;
   ir_WriteSlotAccess* writes;
   ir_WriteSlotAccess* writes2;
   ir_BlockIndex* indexes;
   ir_FunctionInfo* info;
};

struct ir_RevList_ {
   uint8_t* nodes;
   uint32_t capacity;
   uint32_t count;
   uint32_t block_capacity;
   uint32_t block_count;
   ir_RevIndex* indexes;
};

struct ir_Context_ {
   string_pool_Pool* pool;
   ir_ConstantList constants;
   ir_SymbolList symbols;
   ir_InitValueList init_values;
   _Bool in_block;
   uint32_t slot_idx;
   uint32_t num_scopes;
   ir_SymbolId cur_func;
   ir_SymbolId cur_global;
   ir_BlockId cur_block;
   uint32_t blk_start_instr;
   _Bool block_terminated;
   index_list_List block_order;
   lookup_table_Table conversion;
   ir_FunctionInfo* tmp_info;
   ir_SlotCollector collector;
   ir_RevList revlist;
   instr_inserter_InstrInserter inserter;
   bit_array_BitArray active_blocks;
};

typedef enum {
   ir_InstrKind_None,
   ir_InstrKind_Add,
   ir_InstrKind_Sub,
   ir_InstrKind_Div,
   ir_InstrKind_Rem,
   ir_InstrKind_Mul,
   ir_InstrKind_IDiv,
   ir_InstrKind_And,
   ir_InstrKind_Or,
   ir_InstrKind_Xor,
   ir_InstrKind_Shr,
   ir_InstrKind_Shl,
   ir_InstrKind_CmpNe,
   ir_InstrKind_CmpEq,
   ir_InstrKind_CmpLt,
   ir_InstrKind_CmpGt,
   ir_InstrKind_CmpLe,
   ir_InstrKind_CmpGe,
   ir_InstrKind_Load1,
   ir_InstrKind_Load2,
   ir_InstrKind_Load4,
   ir_InstrKind_Load8,
   ir_InstrKind_Store1,
   ir_InstrKind_Store2,
   ir_InstrKind_Store4,
   ir_InstrKind_Store8,
   ir_InstrKind_Alloc1,
   ir_InstrKind_Alloc2,
   ir_InstrKind_Alloc4,
   ir_InstrKind_Alloc8,
   ir_InstrKind_Jmp,
   ir_InstrKind_JmpIf,
   ir_InstrKind_Ret,
   ir_InstrKind_Halt,
   ir_InstrKind_Call,
   ir_InstrKind_Switch,
   ir_InstrKind_Phi,
   ir_InstrKind_Copy,
   ir_InstrKind_Comment,
   _ir_InstrKind_max = 255
} __attribute__((packed)) ir_InstrKind;

typedef enum {
   ir_Type_None,
   ir_Type_I8,
   ir_Type_I16,
   ir_Type_I32,
   ir_Type_I64,
   ir_Type_U8,
   ir_Type_U16,
   ir_Type_U32,
   ir_Type_U64,
   ir_Type_F32,
   ir_Type_F64,
   _ir_Type_max = 255
} __attribute__((packed)) ir_Type;

static const ir_InstrKind ir_Type2Store[11] = {
   [ir_Type_I8] = ir_InstrKind_Store1,
   [ir_Type_I16] = ir_InstrKind_Store2,
   [ir_Type_I32] = ir_InstrKind_Store4,
   [ir_Type_I64] = ir_InstrKind_Store8,
   [ir_Type_U8] = ir_InstrKind_Store1,
   [ir_Type_U16] = ir_InstrKind_Store2,
   [ir_Type_U32] = ir_InstrKind_Store4,
   [ir_Type_U64] = ir_InstrKind_Store8,
   [ir_Type_F32] = ir_InstrKind_Store4,
   [ir_Type_F64] = ir_InstrKind_Store8
};

static ir_Context* ir_create(void);
static void ir_Context_free(ir_Context* c);
static ir_SymbolId ir_Context_addStringLiteral(ir_Context* c, const char* name, const char* text, uint32_t size);
static ir_SymbolId ir_Context_addGlobalVar(ir_Context* c, const char* name, uint32_t align, _Bool is_external);
static ir_SymbolId ir_Context_addFunction(ir_Context* c, const char* name, _Bool is_external);
static void ir_Context_startFunc(ir_Context* c, ir_SymbolId id);
static void ir_Context_endFunc(ir_Context* c);
static void ir_Context_startGlobal(ir_Context* c, ir_SymbolId id);
static void ir_Context_endGlobal(ir_Context* c);
static void ir_Context_addInitZero(ir_Context* c, uint32_t size);
static void ir_Context_addInitValueU8(ir_Context* c, uint32_t value);
static void ir_Context_addInitValueU16(ir_Context* c, uint32_t value);
static void ir_Context_addInitValueU32(ir_Context* c, uint32_t value);
static void ir_Context_addInitValueU64(ir_Context* c, uint64_t value);
static void ir_Context_addInitSymbol(ir_Context* c, ir_SymbolId id);
static void ir_Context_addInitString(ir_Context* c, const char* text, uint32_t size);
static void ir_Context_setFunctionReturnType(ir_Context* c, ir_Type t);
static void ir_Context_addFuncArg(ir_Context* c, ir_Type t);
static uint32_t ir_Context_addCallArgs(ir_Context* c, const ir_RefList* refs);
static ir_BlockId ir_Context_createBlock(ir_Context* c, ir_BlockKind kind);
static _Bool ir_Context_isBlockTerminated(const ir_Context* c);
static void ir_Context_startBlock(ir_Context* c, ir_BlockId id);
static void ir_Context_endBlock(ir_Context* c);
static ir_BlockId ir_Context_getCurBlock(const ir_Context* c);
static void ir_Context_addJmpInstr(ir_Context* c, ir_BlockId dest);
struct ir_Ref_ {
   uint32_t kind : 4;
   uint32_t value : 28;
};

static void ir_Context_addJmpIfInstr(ir_Context* c, ir_Ref cond, ir_BlockId dest1, ir_BlockId dest2);
static void ir_Context_addRet0Instr(ir_Context* c);
static void ir_Context_addRet1Instr(ir_Context* c, ir_Ref ref);
static ir_Ref ir_Context_addLoadInstr(ir_Context* c, ir_Type t, ir_Ref src);
static void ir_Context_addStoreInstr(ir_Context* c, ir_Type t, ir_Ref src, ir_Ref dest);
static ir_Ref ir_Context_addBinaryInstr(ir_Context* c, ir_InstrKind k, ir_Ref left, ir_Ref right);
static ir_Ref ir_Context_addCallInstr(ir_Context* c, ir_Ref name, ir_Ref args, _Bool has_result, _Bool noreturn);
static ir_Ref ir_Context_addPhi2Instr(ir_Context* c, ir_BlockId b1, ir_Ref r1, ir_BlockId b2, ir_Ref r2);
static ir_Ref ir_Context_addStackSlot(ir_Context* c, uint32_t align, ir_Ref size);
static ir_Ref ir_Context_addIntegerConstant(ir_Context* c, int64_t size);
static void ir_Context_addComment(ir_Context* c, const char* text);
static ir_Ref ir_Context_addComment2(ir_Context* c, const char* text, ir_FunctionInfo* info);
static ir_CaseId ir_Context_addSwitchInstr(ir_Context* c, ir_Ref cond, uint32_t num_cases);
static void ir_Context_setCase(ir_Context* c, ir_CaseId case_id, uint32_t value, ir_BlockId blk_id);
static void ir_Context_finalizeFunction(ir_Context* c, ir_SymbolId id);
static _Bool ir_empty_block(const ir_Block* b, const ir_InstrList* instructions);
static ir_BlockId ir_Context_checkDest(ir_Context* c, ir_BlockId id);
struct ir_InstrList_ {
   uint32_t count;
   uint32_t capacity;
   ir_Instr* instrs;
};

struct ir_RefList_ {
   uint32_t count;
   uint32_t capacity;
   ir_Ref* refs;
};

struct ir_PhiList_ {
   uint32_t count;
   uint32_t capacity;
   ir_PhiClause* clauses;
};

struct ir_FunctionInfo_ {
   ir_BlockList blocks;
   ir_InstrList instructions;
   ir_CaseList cases;
   ir_RefList refs;
   ir_PhiList phis;
   uint16_t num_slots;
   uint8_t num_args;
   uint8_t args[13];
};

static ir_FunctionInfo* ir_FunctionInfo_create(uint32_t num_blks, uint32_t num_instr, uint32_t num_refs);
static void ir_FunctionInfo_free(ir_FunctionInfo* fi);
static void ir_FunctionInfo_clear(ir_FunctionInfo* fi);
static uint32_t ir_FunctionInfo_getUsedBlkCount(const ir_FunctionInfo* fi);
static void ir_FunctionInfo_setReturnType(ir_FunctionInfo* fi, ir_Type t);
static void ir_FunctionInfo_addArg(ir_FunctionInfo* fi, ir_Type t);
static ir_Type ir_FunctionInfo_getReturnType(const ir_FunctionInfo* fi);
static ir_Type ir_FunctionInfo_getArg(const ir_FunctionInfo* fi, uint32_t idx);
static void ir_Context_generate_graphviz(ir_Context* c, ir_FunctionInfo* fi, const char* name);
typedef enum {
   ir_InitValueKind_None,
   ir_InitValueKind_Byte,
   ir_InitValueKind_Short,
   ir_InitValueKind_Word,
   ir_InitValueKind_Word2,
   ir_InitValueKind_Long,
   ir_InitValueKind_Long2,
   ir_InitValueKind_Symbol,
   ir_InitValueKind_Text,
   ir_InitValueKind_Zero,
   _ir_InitValueKind_max = 255
} __attribute__((packed)) ir_InitValueKind;

struct ir_InitValue_ {
   uint32_t kind : 4;
   uint32_t value : 28;
};

static const char* ir_InitValueKind_str(ir_InitValueKind k);
static void ir_InitValue_init(ir_InitValue* r, ir_InitValueKind kind, uint32_t value);
static const char* ir_InitValue_getKindName(const ir_InitValue* r);
static ir_InitValueKind ir_InitValue_getKind(const ir_InitValue* r);
static void ir_InitValueList_init(ir_InitValueList* l, uint32_t initial_size);
static void ir_InitValueList_free(ir_InitValueList* l);
static void ir_InitValueList_resize(ir_InitValueList* l, uint32_t cap);
static ir_InitValue* ir_InitValueList_add(ir_InitValueList* l);
static uint32_t ir_InitValueList_getCount(const ir_InitValueList* l);
static ir_InitValue* ir_InitValueList_get(const ir_InitValueList* l, uint32_t idx);
struct ir_ReadSlotAccess_ {
   uint16_t done : 1;
   uint16_t slot : 15;
   uint16_t instr_idx;
};

struct ir_WriteSlotAccess_ {
   uint16_t slot;
   ir_Ref ref;
};

struct ir_BlockIndex_ {
   uint16_t rd_start;
   uint16_t rd_count;
   uint16_t wr_start;
   uint16_t wr_count;
};

#define ir_SlotMax 1024
static ir_BlockIndex* ir_SlotCollector_getBlock(const ir_SlotCollector* c, ir_BlockId blk_id);
static void ir_SlotCollector_create(ir_SlotCollector* c);
static void ir_SlotCollector_free(ir_SlotCollector* c);
static void ir_SlotCollector_fill(ir_SlotCollector* c, ir_FunctionInfo* info);
static ir_ReadSlotAccess* ir_SlotCollector_findRead(const ir_SlotCollector* c, ir_BlockId blk_id, uint16_t slot);
static const ir_WriteSlotAccess* ir_SlotCollector_findWrite(const ir_SlotCollector* c, ir_BlockId blk_id, uint16_t slot);
static void ir_SlotCollector_checkBlock(ir_SlotCollector* c, ir_BlockId blk_id);
static void ir_SlotCollector_insertWrite(ir_SlotCollector* c, ir_BlockId blk_id, uint16_t slot, ir_Ref ref);
static void ir_SlotCollector_defragWrites(ir_SlotCollector* c);
static void ir_SlotCollector_dump(const ir_SlotCollector* c);
struct ir_RevIndex_ {
   uint16_t start;
   uint16_t count;
};

static ir_Ref ir_Context_addPhiInstr(ir_Context* c, ir_FunctionInfo* fi, const ir_PhiCache* cache);
static _Bool ir_block_has_dest(const ir_Block* b, const ir_CaseList* cases, uint32_t dest);
static void ir_RevList_create(ir_RevList* r, uint32_t num_blocks);
static void ir_RevList_build(ir_RevList* r, ir_FunctionInfo* info);
static void ir_RevList_dump(const ir_RevList* r);
static void ir_RevList_free(ir_RevList* r);
static ir_RevIndex ir_RevList_getBlockIndex(const ir_RevList* r, ir_BlockId blk_id);
static uint8_t ir_RevList_getRev(const ir_RevList* r, uint32_t idx);
static void ir_Context_create_ssa(ir_Context* c, ir_FunctionInfo* fi, const char* name);
static ir_Ref ir_Context_checkPredBlock(ir_Context* c, ir_BlockId blk_id, uint16_t slot, uint32_t indent, ir_FunctionInfo* fi);
static void ir_Context_fixup_function(ir_Context* c, ir_FunctionInfo* fi);
struct ir_Symbol_ {
   uint32_t name;
   uint32_t is_external : 1;
   uint32_t is_function : 1;
   uint32_t align : 8;
   uint32_t size : 22;
   union {
      struct {
         ir_FunctionInfo* info;
      } f;
      struct {
         uint32_t init_value_idx;
         uint32_t init_value_count;
      } g;
   };
};

static void ir_SymbolList_init(ir_SymbolList* l, uint32_t initial_size);
static void ir_SymbolList_free(ir_SymbolList* l);
static void ir_SymbolList_resize(ir_SymbolList* l, uint32_t cap);
static ir_SymbolId ir_SymbolList_add(ir_SymbolList* l, uint32_t name, _Bool is_function, uint32_t align, _Bool is_external);
static uint32_t ir_SymbolList_getCount(const ir_SymbolList* l);
static ir_Symbol* ir_SymbolList_get(const ir_SymbolList* l, ir_SymbolId idx);
struct ir_InstrBits_ {
   ir_InstrKind kind : 8;
   uint32_t type_ : 4;
   uint32_t has_result : 1;
};

struct ir_Instr_ {
   union {
      ir_InstrBits instrBits;
      uint32_t bits;
   };
   union {
      ir_Ref args[2];
      ir_Index phi_clauses;
   };
};

static void ir_Instr_init0(ir_Instr* i, ir_InstrKind k);
static void ir_Instr_initPhi(ir_Instr* i, uint32_t clause_start, uint32_t num_clauses);
static void ir_Instr_init1(ir_Instr* i, ir_InstrKind k, ir_Ref ref1);
static void ir_Instr_init1b(ir_Instr* i, ir_InstrKind k, ir_Ref ref1);
static void ir_Instr_init2(ir_Instr* i, ir_InstrKind k, ir_Ref ref1, ir_Ref ref2);
static void ir_Instr_init2b(ir_Instr* i, ir_InstrKind k, ir_Ref ref1, ir_Ref ref2);
static void ir_Instr_copy(ir_Instr* i, const ir_Instr* i2);
static ir_InstrKind ir_Instr_getKind(const ir_Instr* i);
static _Bool ir_Instr_hasResult(const ir_Instr* i);
static const char* ir_Instr_getKindName(const ir_Instr* i);
static _Bool ir_Instr_isPseudo(const ir_Instr* i);
static _Bool ir_Instr_isLoad(const ir_Instr* i);
static _Bool ir_Instr_isLoadOrStore(const ir_Instr* i);
static _Bool ir_Instr_isPhi(const ir_Instr* i);
static _Bool ir_Instr_isComment(const ir_Instr* i);
static const char* ir_InstrKind_str(ir_InstrKind k);
static void ir_InstrList_init(ir_InstrList* l, uint32_t initial_size);
static void ir_InstrList_free(ir_InstrList* l);
static ir_Instr* ir_InstrList_add(ir_InstrList* l);
static void ir_InstrList_clear(ir_InstrList* l);
static uint32_t ir_InstrList_getCount(const ir_InstrList* l);
static ir_Instr* ir_InstrList_get(const ir_InstrList* l, uint32_t idx);
static void ir_InstrList_swap(ir_InstrList* l, ir_InstrList* other);
struct ir_PhiClause_ {
   ir_BlockId src;
   ir_Ref ref;
};

struct ir_PhiCache_ {
   uint32_t count;
   uint32_t capacity;
   ir_PhiClause* clauses;
   ir_PhiClause stash[2];
};

static void ir_PhiList_init(ir_PhiList* l);
static void ir_PhiList_free(ir_PhiList* l);
static void ir_PhiList_resize(ir_PhiList* l, uint32_t extra);
static void ir_PhiList_add(ir_PhiList* l, ir_BlockId src, ir_Ref ref);
static uint32_t ir_PhiList_addCache(ir_PhiList* l, const ir_PhiCache* cache);
static void ir_PhiList_clear(ir_PhiList* l);
static uint32_t ir_PhiList_getCount(const ir_PhiList* l);
static ir_PhiClause* ir_PhiList_get(const ir_PhiList* l, uint32_t idx);
static void ir_PhiList_copy(ir_PhiList* l, const ir_PhiList* l2);
static void ir_PhiCache_init(ir_PhiCache* c);
static void ir_PhiCache_free(ir_PhiCache* c);
static uint32_t ir_PhiCache_getCount(const ir_PhiCache* c);
static void ir_PhiCache_clear(ir_PhiCache* c);
static _Bool ir_PhiCache_contains(const ir_PhiCache* c, ir_Ref ref);
static void ir_PhiCache_add(ir_PhiCache* c, ir_BlockId blk_id, ir_Ref ref);
static const ir_PhiClause* ir_PhiCache_getClauses(const ir_PhiCache* c);
struct ir_PrintHelper_ {
   const ir_Context* c;
   const ir_BlockList* blocks;
   string_buffer_Buf* out;
   uint32_t* temp_ids;
   uint32_t temp_count;
   const ir_Block* cur_block;
   const ir_FunctionInfo* cur_info;
   uint32_t blk_instr_start;
   uint32_t blk_instr_count;
};

static const char* ir_col_Instr = color_Normal;

static const char* ir_col_PseudoInstr = color_Bred;

static const char* ir_col_Decl = color_Magenta;

static const char* ir_col_Name = color_White;

static const char* ir_col_Block = color_Cyan;

static const char* ir_col_Symbol = color_Bblue;

static const char* ir_col_Attr = color_Bmagenta;

static const char* ir_col_Unknown = color_Yellow;

static const char* ir_col_Value = color_Magenta;

static const char* ir_col_Data = color_Bcyan;

static const char* ir_col_Slot = color_Bcyan;

static const char* ir_col_Temp = color_Bgreen;

static const char* ir_col_Type = color_Green;

static const char* ir_col_Comment = color_Grey;

static const char* ir_col_Fixup = color_Bred;

#define ir_MaxTemps 4096
static void ir_PrintHelper_init(ir_PrintHelper* ph, const ir_Context* c);
static void ir_PrintHelper_free(ir_PrintHelper* ph);
static void ir_PrintHelper_print(const ir_PrintHelper* ph);
static void ir_PrintHelper_resetTemps(ir_PrintHelper* ph, uint32_t num_args, uint32_t num_instr);
static uint32_t ir_PrintHelper_addTemp(ir_PrintHelper* ph, uint32_t local_instr_idx);
static uint32_t ir_PrintHelper_findTemp(ir_PrintHelper* ph, uint32_t instr_idx);
static void ir_PrintHelper_collect_temps(ir_PrintHelper* ph);
static void ir_PrintHelper_print_func(ir_PrintHelper* ph, const ir_Symbol* s, const ir_FunctionInfo* info);
static void ir_Context_print_function(const ir_Context* c, ir_SymbolId id, const ir_FunctionInfo* info);
static void ir_Context_print(const ir_Context* c);
static void ir_PrintHelper_printInitValue(ir_PrintHelper* ph, const ir_InitValue* v, string_buffer_Buf* out);
static void ir_PrintHelper_printInstr(ir_PrintHelper* ph, const ir_Instr* blk_instrs, uint32_t blk_instr_idx, uint32_t gbl_idx);
static void ir_PrintHelper_printRef(ir_PrintHelper* ph, ir_Ref r, _Bool print_type);
static void ir_Context_dump_function(const ir_Context* c, const ir_FunctionInfo* info, const char* name);
static void ir_dump_function_info(string_buffer_Buf* out, const ir_FunctionInfo* info);
static void ir_Context_dump(const ir_Context* c);
static void ir_Context_report(const ir_Context* c);
typedef enum {
   ir_RefKind_None,
   ir_RefKind_Slot,
   ir_RefKind_Temp,
   ir_RefKind_Param,
   ir_RefKind_JmpDest,
   ir_RefKind_RefList,
   ir_RefKind_Symbol,
   ir_RefKind_Value,
   ir_RefKind_Integer,
   ir_RefKind_Float,
   ir_RefKind_Double,
   ir_RefKind_Text,
   _ir_RefKind_max = 255
} __attribute__((packed)) ir_RefKind;

static void ir_Ref_init(ir_Ref* r, ir_RefKind kind, uint32_t value);
static _Bool ir_Ref_equals(const ir_Ref* r1, ir_Ref r2);
static ir_RefKind ir_Ref_getKind(const ir_Ref* r);
static _Bool ir_Ref_isValid(const ir_Ref* r);
static _Bool ir_Ref_isTemp(const ir_Ref* r);
static _Bool ir_Ref_isSlot(const ir_Ref* r);
static _Bool ir_Ref_isRefList(const ir_Ref* r);
static const char* ir_Ref_getKindName(const ir_Ref* r);
static void ir_RefList_init(ir_RefList* l, uint32_t initial_size);
static void ir_RefList_free(ir_RefList* l);
static void ir_RefList_resize(ir_RefList* l, uint32_t cap);
static void ir_RefList_add(ir_RefList* l, ir_Ref ref);
static uint32_t ir_RefList_addList(ir_RefList* l, const ir_RefList* l2);
static void ir_RefList_copy(ir_RefList* l, const ir_RefList* l2);
static void ir_RefList_clear(ir_RefList* l);
static uint32_t ir_RefList_getCount(const ir_RefList* l);
static ir_Ref* ir_RefList_get(const ir_RefList* l, uint32_t idx);
static const char* ir_Type_str(ir_Type t);

static const char* ir_BlockKind_str(ir_BlockKind k)
{
   switch (k) {
   case ir_BlockKind_Unspecified:
      return "";
   case ir_BlockKind_FnStart:
      return "start";
   case ir_BlockKind_WhileCond:
      return "while_cond";
   case ir_BlockKind_WhileBody:
      return "while_body";
   case ir_BlockKind_WhileJoin:
      return "while_join";
   case ir_BlockKind_ForCond:
      return "for_cond";
   case ir_BlockKind_ForBody:
      return "for_body";
   case ir_BlockKind_ForCont:
      return "for_cont";
   case ir_BlockKind_ForJoin:
      return "for_join";
   case ir_BlockKind_IfTrue:
      return "if_true";
   case ir_BlockKind_IfFalse:
      return "if_false";
   case ir_BlockKind_IfJoin:
      return "if_join";
   case ir_BlockKind_AndTrue:
      return "and_true";
   case ir_BlockKind_LogicJoin:
      return "logic_join";
   case ir_BlockKind_OrFalse:
      return "or_false";
   case ir_BlockKind_CondTrue:
      return "cond_true";
   case ir_BlockKind_CondFalse:
      return "cond_false";
   case ir_BlockKind_CondJoin:
      return "cond_join";
   case ir_BlockKind_Label:
      return "label";
   case ir_BlockKind_SwitchCase:
      return "switch_case";
   case ir_BlockKind_SwitchJoin:
      return "switch_join";
   case ir_BlockKind_SwitchDefault:
      return "switch_default";
   }
   return "";
}

static void ir_Block_init(ir_Block* b, ir_BlockKind kind)
{
   memset(b, 0, 20);
   b->kind = kind;
}

static ir_BlockKind ir_Block_getKind(const ir_Block* b)
{
   return b->kind;
}

static const char* ir_Block_getKindName(const ir_Block* b)
{
   ir_BlockKind k = ir_Block_getKind(b);
   return ir_BlockKind_str(k);
}

static void ir_Block_setInstructions(ir_Block* b, uint32_t start, uint32_t count)
{
   b->instr.start = start;
   b->instr.count = count;
}

static ir_Index ir_Block_getInstructions(const ir_Block* b)
{
   return b->instr;
}

static void ir_Block_setDest(ir_Block* b, ir_BlockId dest1, ir_BlockId dest2)
{
   b->dests[0] = dest1;
   b->dests[1] = dest2;
}

static void ir_BlockList_init(ir_BlockList* l, uint32_t initial_size)
{
   memset(l, 0, 16);
   ir_BlockList_resize(l, initial_size);
}

static void ir_BlockList_free(ir_BlockList* l)
{
   if (l->blocks) free(((void*)(l->blocks)));
}

static void ir_BlockList_resize(ir_BlockList* l, uint32_t cap)
{
   l->capacity = cap;
   ir_Block* blocks2 = calloc(l->capacity, 20);
   if ((l->count > 1)) {
      memcpy(blocks2, l->blocks, (l->count * 20));
      free(l->blocks);
   }
   l->blocks = blocks2;
}

static ir_BlockId ir_BlockList_add(ir_BlockList* l, ir_BlockKind kind)
{
   if ((l->count == l->capacity)) ir_BlockList_resize(l, (l->capacity * 2));
   ir_BlockId idx = l->count;
   ir_Block* b = &l->blocks[idx];
   ir_Block_init(b, kind);
   l->count++;
   return idx;
}

static ir_BlockId ir_BlockList_copy(ir_BlockList* l, const ir_Block* b2)
{
   if ((l->count == l->capacity)) ir_BlockList_resize(l, (l->capacity * 2));
   ir_BlockId idx = l->count;
   ir_Block* b = &l->blocks[idx];
   memcpy(b, b2, 20);
   l->count++;
   return idx;
}

static void ir_BlockList_clear(ir_BlockList* l)
{
   l->count = 0;
}

static uint32_t ir_BlockList_getCount(const ir_BlockList* l)
{
   return l->count;
}

static uint32_t ir_BlockList_getUsedCount(const ir_BlockList* l)
{
   uint32_t used = 0;
   ir_Block* blks = &l->blocks[0];
   for (uint32_t i = 0; (i < l->count); i++) {
      if (blks[i].used) used++;
   }
   return used;
}

static ir_Block* ir_BlockList_get(const ir_BlockList* l, ir_BlockId idx)
{
   return &l->blocks[idx];
}

static void ir_CaseList_init(ir_CaseList* l)
{
   l->count = 0;
   l->capacity = 0;
   l->cases = NULL;
}

static void ir_CaseList_free(ir_CaseList* l)
{
   if (l->cases) free(((void*)(l->cases)));
}

static void ir_CaseList_resize(ir_CaseList* l, uint32_t extra, _Bool copy)
{
   l->capacity += extra;
   ir_Case* cases2 = calloc(l->capacity, 8);
   if (((l->count != 0) && copy)) memcpy(cases2, l->cases, (l->count * 8));
   if (l->cases) free(l->cases);
   l->cases = cases2;
}

static ir_CaseId ir_CaseList_reserve(ir_CaseList* l, uint32_t count)
{
   uint32_t avail = (l->capacity - l->count);
   if ((count > avail)) ir_CaseList_resize(l, (count - avail), true);
   ir_CaseId idx = l->count;
   l->count += count;
   return idx;
}

static void ir_CaseList_set(ir_CaseList* l, ir_CaseId id, uint32_t value, ir_BlockId block)
{
   ir_Case* c = &l->cases[id];
   c->value = value;
   c->block = block;
}

static void ir_CaseList_clear(ir_CaseList* l)
{
   l->count = 0;
}

static uint32_t ir_CaseList_getCount(const ir_CaseList* l)
{
   return l->count;
}

static ir_Case* ir_CaseList_get(const ir_CaseList* l, ir_CaseId idx)
{
   return &l->cases[idx];
}

static void ir_CaseList_copy(ir_CaseList* l, const ir_CaseList* l2)
{
   if ((l->capacity < l2->count)) ir_CaseList_resize(l, (l2->count - l->capacity), false);
   l->count = l2->count;
   memcpy(l->cases, l2->cases, (l2->count * 8));
}

static void ir_ConstantList_init(ir_ConstantList* l, uint32_t initial_size)
{
   memset(l, 0, 16);
   if (initial_size) {
      l->capacity = initial_size;
      l->constants = malloc((l->capacity * 8));
   }
}

static void ir_ConstantList_free(ir_ConstantList* l)
{
   if (l->constants) free(((void*)(l->constants)));
}

static uint32_t ir_ConstantList_add(ir_ConstantList* l, const ir_Constant* c)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      if ((l->constants[i].ivalue == c->ivalue)) return i;

   }
   if ((l->count >= l->capacity)) {
      l->capacity *= 2;
      void* constants2 = malloc((l->capacity * 8));
      void* old = ((void*)(l->constants));
      if (old) {
         memcpy(constants2, old, (l->count * 8));
         free(old);
      }
      l->constants = constants2;
   }
   l->constants[l->count] = *c;
   return l->count++;
}

static uint32_t ir_ConstantList_getCount(const ir_ConstantList* l)
{
   return l->count;
}

static ir_Constant* ir_ConstantList_get(const ir_ConstantList* l, uint32_t idx)
{
   return &l->constants[idx];
}

static ir_Context* ir_create(void)
{
   ir_Context* c = calloc(1, 272);
   c->pool = string_pool_create((2 * 1024), 256);
   ir_ConstantList_init(&c->constants, 128);
   ir_SymbolList_init(&c->symbols, 128);
   ir_InitValueList_init(&c->init_values, 128);
   index_list_List_init(&c->block_order, 64);
   lookup_table_Table_init(&c->conversion, 64);
   c->tmp_info = ir_FunctionInfo_create(32, 64, 32);
   ir_SlotCollector_create(&c->collector);
   ir_RevList_create(&c->revlist, 256);
   instr_inserter_InstrInserter_create(&c->inserter);
   return c;
}

static void ir_Context_free(ir_Context* c)
{
   instr_inserter_InstrInserter_free(&c->inserter);
   ir_RevList_free(&c->revlist);
   ir_SlotCollector_free(&c->collector);
   for (uint32_t i = 1; (i < ir_SymbolList_getCount(&c->symbols)); i++) {
      const ir_Symbol* s = ir_SymbolList_get(&c->symbols, i);
      if ((s->is_function && s->f.info)) {
         ir_FunctionInfo_free(s->f.info);
      }
   }
   ir_FunctionInfo_free(c->tmp_info);
   lookup_table_Table_free(&c->conversion);
   index_list_List_free(&c->block_order);
   ir_InitValueList_free(&c->init_values);
   ir_SymbolList_free(&c->symbols);
   ir_ConstantList_free(&c->constants);
   string_pool_Pool_free(c->pool);
   free(c);
}

static ir_SymbolId ir_Context_addStringLiteral(ir_Context* c, const char* name, const char* text, uint32_t size)
{
   ir_SymbolId id = ir_Context_addGlobalVar(c, name, 1, false);
   uint32_t text_idx = string_pool_Pool_addStr(c->pool, text, false);
   ir_Symbol* s = ir_SymbolList_get(&c->symbols, id);
   s->g.init_value_idx = ir_InitValueList_getCount(&c->init_values);
   s->g.init_value_count = 1;
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   ir_InitValue_init(v, ir_InitValueKind_Text, text_idx);
   return id;
}

static ir_SymbolId ir_Context_addGlobalVar(ir_Context* c, const char* name, uint32_t align, _Bool is_external)
{
   uint32_t name_idx = string_pool_Pool_addStr(c->pool, name, false);
   ir_SymbolId id = ir_SymbolList_add(&c->symbols, name_idx, false, align, is_external);
   return id;
}

static ir_SymbolId ir_Context_addFunction(ir_Context* c, const char* name, _Bool is_external)
{
   uint32_t name_idx = string_pool_Pool_addStr(c->pool, name, false);
   ir_SymbolId id = ir_SymbolList_add(&c->symbols, name_idx, true, 4, is_external);
   return id;
}

static void ir_Context_startFunc(ir_Context* c, ir_SymbolId id)
{
   ((c->cur_func == 0)) || c2_assert("ir/context.c2", 135, "ir.Context.startFunc", "c.cur_func == 0");
   c->cur_func = id;
   c->num_scopes = 0;
   c->slot_idx = 0;
}

static void ir_Context_endFunc(ir_Context* c)
{
   ((c->num_scopes == 0)) || c2_assert("ir/context.c2", 145, "ir.Context.endFunc", "c.num_scopes == 0");
   (c->cur_func) || c2_assert("ir/context.c2", 146, "ir.Context.endFunc", "c.cur_func");
   ir_Context_finalizeFunction(c, c->cur_func);
   c->cur_func = 0;
}

static void ir_Context_startGlobal(ir_Context* c, ir_SymbolId id)
{
   ((c->cur_global == 0)) || c2_assert("ir/context.c2", 157, "ir.Context.startGlobal", "c.cur_global == 0");
   c->cur_global = id;
   ir_Symbol* s = ir_SymbolList_get(&c->symbols, c->cur_global);
   s->g.init_value_idx = ir_InitValueList_getCount(&c->init_values);
}

static void ir_Context_endGlobal(ir_Context* c)
{
   (c->cur_global) || c2_assert("ir/context.c2", 167, "ir.Context.endGlobal", "c.cur_global");
   ir_Symbol* s = ir_SymbolList_get(&c->symbols, c->cur_global);
   s->g.init_value_count = (ir_InitValueList_getCount(&c->init_values) - s->g.init_value_idx);
   c->cur_global = 0;
}

static void ir_Context_addInitZero(ir_Context* c, uint32_t size)
{
   ((size < 0xfffffff)) || c2_assert("ir/context.c2", 177, "ir.Context.addInitZero", "size < 0xfffffff");
   (c->cur_global) || c2_assert("ir/context.c2", 178, "ir.Context.addInitZero", "c.cur_global");
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   ir_InitValue_init(v, ir_InitValueKind_Zero, size);
}

static void ir_Context_addInitValueU8(ir_Context* c, uint32_t value)
{
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   ir_InitValue_init(v, ir_InitValueKind_Byte, value);
}

static void ir_Context_addInitValueU16(ir_Context* c, uint32_t value)
{
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   ir_InitValue_init(v, ir_InitValueKind_Short, value);
}

static void ir_Context_addInitValueU32(ir_Context* c, uint32_t value)
{
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   if ((value < 0xfffffff)) {
      ir_InitValue_init(v, ir_InitValueKind_Word, value);
   } else {
      ir_Constant constant = { .uvalue = value };
      uint32_t idx = ir_ConstantList_add(&c->constants, &constant);
      ir_InitValue_init(v, ir_InitValueKind_Word2, idx);
   }
}

static void ir_Context_addInitValueU64(ir_Context* c, uint64_t value)
{
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   if ((value < 0xfffffff)) {
      ir_InitValue_init(v, ir_InitValueKind_Long, ((uint32_t)(value)));
   } else {
      ir_Constant constant = { .uvalue = value };
      uint32_t idx = ir_ConstantList_add(&c->constants, &constant);
      ir_InitValue_init(v, ir_InitValueKind_Long2, idx);
   }
}

static void ir_Context_addInitSymbol(ir_Context* c, ir_SymbolId id)
{
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   ir_InitValue_init(v, ir_InitValueKind_Symbol, id);
}

static void ir_Context_addInitString(ir_Context* c, const char* text, uint32_t size)
{
   ir_InitValue* v = ir_InitValueList_add(&c->init_values);
   uint32_t text_idx = string_pool_Pool_add(c->pool, text, size, false);
   ir_InitValue_init(v, ir_InitValueKind_Text, text_idx);
}

static void ir_Context_setFunctionReturnType(ir_Context* c, ir_Type t)
{
   ir_FunctionInfo_setReturnType(c->tmp_info, t);
}

static void ir_Context_addFuncArg(ir_Context* c, ir_Type t)
{
   ir_FunctionInfo_addArg(c->tmp_info, t);
}

static uint32_t ir_Context_addCallArgs(ir_Context* c, const ir_RefList* refs)
{
   return ir_RefList_addList(&c->tmp_info->refs, refs);
}

static ir_BlockId ir_Context_createBlock(ir_Context* c, ir_BlockKind kind)
{
   ir_BlockId id = ir_BlockList_add(&c->tmp_info->blocks, kind);
   return id;
}

static _Bool ir_Context_isBlockTerminated(const ir_Context* c)
{
   return c->block_terminated;
}

static void ir_Context_startBlock(ir_Context* c, ir_BlockId id)
{
   (!c->in_block) || c2_assert("ir/context.c2", 257, "ir.Context.startBlock", "!c.in_block");
   c->in_block = true;
   index_list_List_add(&c->block_order, id);
   c->cur_block = id;
   c->block_terminated = false;
   c->blk_start_instr = ir_InstrList_getCount(&c->tmp_info->instructions);
}

static void ir_Context_endBlock(ir_Context* c)
{
   if (!c->block_terminated) {
      ir_Context_addJmpInstr(c, (c->cur_block + 1));
   }
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
   ir_Block_setInstructions(b, c->blk_start_instr, (ir_InstrList_getCount(&c->tmp_info->instructions) - c->blk_start_instr));
   c->cur_block = 0;
   c->in_block = false;
}

static ir_BlockId ir_Context_getCurBlock(const ir_Context* c)
{
   return c->cur_block;
}

static void ir_Context_addJmpInstr(ir_Context* c, ir_BlockId dest)
{
   (c->in_block) || c2_assert("ir/context.c2", 284, "ir.Context.addJmpInstr", "c.in_block");
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
   ir_Block_setDest(b, dest, 0);
   ir_Ref ref; ir_Ref_init(&ref, ir_RefKind_JmpDest, 0);
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init1(i, ir_InstrKind_Jmp, ref);
   c->block_terminated = true;
}

static void ir_Context_addJmpIfInstr(ir_Context* c, ir_Ref cond, ir_BlockId dest1, ir_BlockId dest2)
{
   (c->in_block) || c2_assert("ir/context.c2", 298, "ir.Context.addJmpIfInstr", "c.in_block");
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
   ir_Block_setDest(b, dest1, dest2);
   ir_Ref ref; ir_Ref_init(&ref, ir_RefKind_JmpDest, 0);
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init2(i, ir_InstrKind_JmpIf, cond, ref);
   c->block_terminated = true;
}

static void ir_Context_addRet0Instr(ir_Context* c)
{
   (c->in_block) || c2_assert("ir/context.c2", 316, "ir.Context.addRet0Instr", "c.in_block");
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init0(i, ir_InstrKind_Ret);
   c->block_terminated = true;
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
   b->end_block = 1;
}

static void ir_Context_addRet1Instr(ir_Context* c, ir_Ref ref)
{
   (c->in_block) || c2_assert("ir/context.c2", 328, "ir.Context.addRet1Instr", "c.in_block");
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init1(i, ir_InstrKind_Ret, ref);
   c->block_terminated = true;
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
   b->end_block = 1;
}

static ir_Ref ir_Context_addLoadInstr(ir_Context* c, ir_Type t, ir_Ref src)
{
   (c->in_block) || c2_assert("ir/context.c2", 340, "ir.Context.addLoadInstr", "c.in_block");
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Temp, ir_InstrList_getCount(&c->tmp_info->instructions));
   ir_InstrKind k;
   switch (t) {
   case ir_Type_None:
      (0) || c2_assert("ir/context.c2", 347, "ir.Context.addLoadInstr", "0");
      return out;
   case ir_Type_I8:
      k = ir_InstrKind_Load1;
      break;
   case ir_Type_I16:
      k = ir_InstrKind_Load2;
      break;
   case ir_Type_I32:
      k = ir_InstrKind_Load4;
      break;
   case ir_Type_I64:
      k = ir_InstrKind_Load8;
      break;
   case ir_Type_U8:
      k = ir_InstrKind_Load1;
      break;
   case ir_Type_U16:
      k = ir_InstrKind_Load2;
      break;
   case ir_Type_U32:
      k = ir_InstrKind_Load4;
      break;
   case ir_Type_U64:
      k = ir_InstrKind_Load8;
      break;
   case ir_Type_F32:
      k = ir_InstrKind_Load4;
      break;
   case ir_Type_F64:
      k = ir_InstrKind_Load8;
      break;
   }
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init1b(i, k, src);
   return out;
}

static void ir_Context_addStoreInstr(ir_Context* c, ir_Type t, ir_Ref src, ir_Ref dest)
{
   (c->in_block) || c2_assert("ir/context.c2", 404, "ir.Context.addStoreInstr", "c.in_block");
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ((t != ir_Type_None)) || c2_assert("ir/context.c2", 406, "ir.Context.addStoreInstr", "t != Type.None");
   ir_InstrKind k = ir_Type2Store[t];
   ir_Instr_init2(i, k, src, dest);
}

static ir_Ref ir_Context_addBinaryInstr(ir_Context* c, ir_InstrKind k, ir_Ref left, ir_Ref right)
{
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Temp, ir_InstrList_getCount(&c->tmp_info->instructions));
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init2b(i, k, left, right);
   return out;
}

static ir_Ref ir_Context_addCallInstr(ir_Context* c, ir_Ref name, ir_Ref args, _Bool has_result, _Bool noreturn)
{
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Temp, ir_InstrList_getCount(&c->tmp_info->instructions));
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   if (has_result) {
      ir_Instr_init2b(i, ir_InstrKind_Call, name, args);
   } else {
      ir_Instr_init2(i, ir_InstrKind_Call, name, args);
   }
   if (noreturn) {
      ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
      b->end_block = 1;
      c->block_terminated = true;
   }
   return out;
}

static ir_Ref ir_Context_addPhi2Instr(ir_Context* c, ir_BlockId b1, ir_Ref r1, ir_BlockId b2, ir_Ref r2)
{
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Temp, ir_InstrList_getCount(&c->tmp_info->instructions));
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_initPhi(i, ir_PhiList_getCount(&c->tmp_info->phis), 2);
   ir_Block* blk = ir_BlockList_get(&c->tmp_info->blocks, b1);
   blk->phi_source = 1;
   blk = ir_BlockList_get(&c->tmp_info->blocks, b2);
   blk->phi_source = 1;
   ir_PhiList_add(&c->tmp_info->phis, b1, r1);
   ir_PhiList_add(&c->tmp_info->phis, b2, r2);
   return out;
}

static ir_Ref ir_Context_addStackSlot(ir_Context* c, uint32_t align, ir_Ref size)
{
   uint32_t idx = c->slot_idx;
   c->slot_idx++;
   ((c->slot_idx < 65536)) || c2_assert("ir/context.c2", 469, "ir.Context.addStackSlot", "c.slot_idx < 65536");
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Slot, idx);
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_InstrKind kind;
   switch (align) {
   case 1:
      kind = ir_InstrKind_Alloc1;
      break;
   case 2:
      kind = ir_InstrKind_Alloc2;
      break;
   case 4:
      kind = ir_InstrKind_Alloc4;
      break;
   case 8:
      kind = ir_InstrKind_Alloc8;
      break;
   default:
      kind = ir_InstrKind_Alloc8;
      break;
   }
   ir_Instr_init1b(i, kind, size);
   return out;
}

static ir_Ref ir_Context_addIntegerConstant(ir_Context* c, int64_t size)
{
   const int32_t min_27bits = (-0x3ffffff - 1);
   const int32_t max_27_bits = 0x3ffffff;
   ir_Ref ref;
   if (((size >= min_27bits) && (size <= max_27_bits))) {
      ir_Ref_init(&ref, ir_RefKind_Value, ((uint32_t)(size)));
   } else {
      ir_Constant constant = { .ivalue = size };
      uint32_t idx = ir_ConstantList_add(&c->constants, &constant);
      ir_Ref_init(&ref, ir_RefKind_Integer, idx);
   }
   return ref;
}

static void ir_Context_addComment(ir_Context* c, const char* text)
{
   ir_Context_addComment2(c, text, c->tmp_info);
}

static ir_Ref ir_Context_addComment2(ir_Context* c, const char* text, ir_FunctionInfo* info)
{
   uint32_t idx = string_pool_Pool_addStr(c->pool, text, false);
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Temp, ir_InstrList_getCount(&info->instructions));
   ir_Instr* i = ir_InstrList_add(&info->instructions);
   ir_Ref ref; ir_Ref_init(&ref, ir_RefKind_Text, idx);
   ir_Instr_init1(i, ir_InstrKind_Comment, ref);
   return out;
}

static ir_CaseId ir_Context_addSwitchInstr(ir_Context* c, ir_Ref cond, uint32_t num_cases)
{
   ir_CaseId case_id = ir_CaseList_reserve(&c->tmp_info->cases, num_cases);
   (c->in_block) || c2_assert("ir/context.c2", 535, "ir.Context.addSwitchInstr", "c.in_block");
   ir_Instr* i = ir_InstrList_add(&c->tmp_info->instructions);
   ir_Instr_init1(i, ir_InstrKind_Switch, cond);
   c->block_terminated = true;
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, c->cur_block);
   b->end_with_switch = 1;
   ir_Block_setDest(b, case_id, num_cases);
   return case_id;
}

static void ir_Context_setCase(ir_Context* c, ir_CaseId case_id, uint32_t value, ir_BlockId blk_id)
{
   ir_CaseList_set(&c->tmp_info->cases, case_id, value, blk_id);
}

static void ir_Context_finalizeFunction(ir_Context* c, ir_SymbolId id)
{
   ir_Symbol* s = ir_SymbolList_get(&c->symbols, id);
   uint32_t num_blocks = ir_BlockList_getCount(&c->tmp_info->blocks);
   c->tmp_info->num_slots = ((uint16_t)(c->slot_idx));
   const char* name = string_pool_Pool_idx2str(c->pool, s->name);
   ir_Context_checkDest(c, 0);
   uint32_t num_used_blocks = ir_FunctionInfo_getUsedBlkCount(c->tmp_info);
   ir_FunctionInfo* fi2 = ir_FunctionInfo_create(num_used_blocks, 32, ir_RefList_getCount(&c->tmp_info->refs));
   fi2->num_slots = c->tmp_info->num_slots;
   const uint32_t* order = index_list_List_getFrom(&c->block_order, 0);
   ((num_blocks == index_list_List_getCount(&c->block_order))) || c2_assert("ir/context.c2", 580, "ir.Context.finalizeFunction", "num_blocks == c.block_order.getCount()");
   uint32_t blk_count = 0;
   lookup_table_Table_clear(&c->conversion, num_blocks);
   for (uint32_t i = 0; (i < num_blocks); i++) {
      ir_BlockId bid = order[i];
      const ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, bid);
      if (!b->used) continue;

      ir_BlockList_copy(&fi2->blocks, b);
      lookup_table_Table_set(&c->conversion, bid, blk_count);
      blk_count++;
   }
   ir_Block* new_blks = ir_BlockList_get(&fi2->blocks, 0);
   ((lookup_table_Table_get(&c->conversion, 0) == 0)) || c2_assert("ir/context.c2", 601, "ir.Context.finalizeFunction", "c.conversion.get(0) == 0");
   for (uint32_t i = 0; (i < blk_count); i++) {
      ir_Block* b = &new_blks[i];
      if (b->end_with_switch) {
         ir_CaseId case_id = b->dests[0];
         uint32_t num_cases = b->dests[1];
         for (uint32_t j = 0; (j < num_cases); j++) {
            ir_Case* cs = ir_CaseList_get(&c->tmp_info->cases, (case_id + j));
            cs->block = lookup_table_Table_get(&c->conversion, cs->block);
         }
      } else {
         b->dests[0] = lookup_table_Table_get(&c->conversion, b->dests[0]);
         b->dests[1] = lookup_table_Table_get(&c->conversion, b->dests[1]);
      }
   }
   for (uint32_t i = 0; (i < ir_PhiList_getCount(&c->tmp_info->phis)); i++) {
      ir_PhiClause* pc = ir_PhiList_get(&c->tmp_info->phis, i);
      pc->src = lookup_table_Table_get(&c->conversion, pc->src);
   }
   ir_RefList_copy(&fi2->refs, &c->tmp_info->refs);
   ir_CaseList_copy(&fi2->cases, &c->tmp_info->cases);
   ir_PhiList_copy(&fi2->phis, &c->tmp_info->phis);
   fi2->num_args = c->tmp_info->num_args;
   memcpy(fi2->args, c->tmp_info->args, 13);
   const ir_Instr* i_old = ir_InstrList_get(&c->tmp_info->instructions, 0);
   lookup_table_Table_clear(&c->conversion, ir_InstrList_getCount(&c->tmp_info->instructions));
   uint32_t i_index = 0;
   for (uint32_t i = 0; (i < blk_count); i++) {
      ir_Block* b = &new_blks[i];
      uint32_t i_start = b->instr.start;
      uint32_t i_count = b->instr.count;
      uint32_t new_start = i_index;
      for (uint32_t j = i_start; (j < (i_start + i_count)); j++) {
         ir_Instr* is = ir_InstrList_add(&fi2->instructions);
         ir_Instr_copy(is, &i_old[j]);
         lookup_table_Table_set(&c->conversion, j, i_index);
         ir_Ref* r = &is->args[0];
         if (ir_Ref_isTemp(r)) r->value = lookup_table_Table_get(&c->conversion, r->value);
         r = &is->args[1];
         if (ir_Ref_isTemp(r)) r->value = lookup_table_Table_get(&c->conversion, r->value);
         else if (ir_Ref_isRefList(r)) {
            ir_Ref* refs = ir_RefList_get(&fi2->refs, r->value);
            uint32_t idx = 0;
            while (1) {
               ir_Ref* r2 = &refs[idx];
               if (ir_Ref_isTemp(r2)) r2->value = lookup_table_Table_get(&c->conversion, r2->value);
               if (!ir_Ref_isValid(r2)) break;

               idx++;
            }
         }

         i_index++;
      }
      b->instr.start = new_start;
   }
   for (uint32_t i = 0; (i < ir_PhiList_getCount(&fi2->phis)); i++) {
      ir_PhiClause* pc = ir_PhiList_get(&fi2->phis, i);
      if (ir_Ref_isTemp(&pc->ref)) pc->ref.value = lookup_table_Table_get(&c->conversion, pc->ref.value);
   }
   s->f.info = fi2;
   ir_FunctionInfo_clear(c->tmp_info);
   index_list_List_clear(&c->block_order);
   ir_Context_create_ssa(c, fi2, name);
   if (instr_inserter_InstrInserter_needsFixup(&c->inserter)) ir_Context_fixup_function(c, fi2);
}

static _Bool ir_empty_block(const ir_Block* b, const ir_InstrList* instructions)
{
   if ((b->instr.count == 1)) return true;

   if ((b->instr.count == 2)) {
      ir_Instr* instr = ir_InstrList_get(instructions, b->instr.start);
      if ((ir_Instr_getKind(instr) == ir_InstrKind_Comment)) return true;

      instr = ir_InstrList_get(instructions, (b->instr.start + 1));
      if ((ir_Instr_getKind(instr) == ir_InstrKind_Comment)) return true;

   }
   return false;
}

static ir_BlockId ir_Context_checkDest(ir_Context* c, ir_BlockId id)
{
   ir_Block* b = ir_BlockList_get(&c->tmp_info->blocks, id);
   if (b->checked) {
      if (b->used) return id;

      (!b->end_with_switch) || c2_assert("ir/context.c2", 709, "ir.Context.checkDest", "!b.end_with_switch");
      return b->dests[0];
   }
   b->checked = true;
   if (b->end_with_switch) {
      b->used = true;
      ir_CaseId case_id = b->dests[0];
      uint32_t num_cases = b->dests[1];
      for (uint32_t i = 0; (i < num_cases); i++) {
         ir_Case* cs = ir_CaseList_get(&c->tmp_info->cases, (case_id + i));
         ir_BlockId new_blk = ir_Context_checkDest(c, cs->block);
         if ((cs->block != new_blk)) cs->block = new_blk;
      }
      return id;
   }
   if (((b->dests[0] == 0) && (b->dests[1] == 0))) {
      b->used = true;
      return id;
   }
   if (((!b->phi_source && (id != 0)) && ir_empty_block(b, &c->tmp_info->instructions))) {
      ir_BlockId new_blk = ir_Context_checkDest(c, b->dests[0]);
      if ((new_blk == id)) {
         b->used = true;
         b->dests[0] = id;
      } else {
         b->used = false;
         b->dests[0] = new_blk;
      }
      return new_blk;
   }
   b->used = true;
   if (b->dests[0]) {
      b->dests[0] = ir_Context_checkDest(c, b->dests[0]);
   }
   if (b->dests[1]) {
      b->dests[1] = ir_Context_checkDest(c, b->dests[1]);
   }
   if ((b->dests[0] == b->dests[1])) {
      ir_Instr* last = ir_InstrList_get(&c->tmp_info->instructions, ((b->instr.start + b->instr.count) - 1));
      ir_Ref ref; ir_Ref_init(&ref, ir_RefKind_JmpDest, id);
      ir_Instr_init1(last, ir_InstrKind_Jmp, ref);
      b->dests[1] = 0;
   }
   return id;
}

static ir_FunctionInfo* ir_FunctionInfo_create(uint32_t num_blks, uint32_t num_instr, uint32_t num_refs)
{
   ir_FunctionInfo* fi = malloc(96);
   ir_BlockList_init(&fi->blocks, num_blks);
   ir_InstrList_init(&fi->instructions, num_instr);
   ir_CaseList_init(&fi->cases);
   ir_RefList_init(&fi->refs, num_refs);
   ir_PhiList_init(&fi->phis);
   fi->num_args = 0;
   return fi;
}

static void ir_FunctionInfo_free(ir_FunctionInfo* fi)
{
   ir_PhiList_free(&fi->phis);
   ir_RefList_free(&fi->refs);
   ir_CaseList_free(&fi->cases);
   ir_InstrList_free(&fi->instructions);
   ir_BlockList_free(&fi->blocks);
   free(fi);
}

static void ir_FunctionInfo_clear(ir_FunctionInfo* fi)
{
   ir_BlockList_clear(&fi->blocks);
   ir_CaseList_clear(&fi->cases);
   ir_InstrList_clear(&fi->instructions);
   ir_RefList_clear(&fi->refs);
   ir_PhiList_clear(&fi->phis);
}

static uint32_t ir_FunctionInfo_getUsedBlkCount(const ir_FunctionInfo* fi)
{
   return ir_BlockList_getUsedCount(&fi->blocks);
}

static void ir_FunctionInfo_setReturnType(ir_FunctionInfo* fi, ir_Type t)
{
   fi->args[0] = t;
   fi->num_args = 1;
}

static void ir_FunctionInfo_addArg(ir_FunctionInfo* fi, ir_Type t)
{
   uint8_t* ptr = &fi->args[(fi->num_args / 2)];
   if ((fi->num_args % 2)) {
      *ptr |= ((t << 4));
   } else {
      *ptr = t;
   }
   fi->num_args++;
}

static ir_Type ir_FunctionInfo_getReturnType(const ir_FunctionInfo* fi)
{
   if ((fi->num_args == 0)) return ir_Type_None;

   return ((ir_Type)((fi->args[0] & 0xf)));
}

static ir_Type ir_FunctionInfo_getArg(const ir_FunctionInfo* fi, uint32_t idx)
{
   uint8_t value = fi->args[(idx / 2)];
   if ((idx % 2)) {
      value >>= 4;
   } else {
      value &= 0xf;
   }
   return ((ir_Type)(value));
}

static void ir_Context_generate_graphviz(ir_Context* c, ir_FunctionInfo* fi, const char* name)
{
   string_buffer_Buf* out = string_buffer_create((16 * 1024), false, 2);
   string_buffer_Buf_add(out, "-------------\n");
   string_buffer_Buf_add(out, "dot\ndigraph G {\nnode [shape=circle, style=filled]\n");
   uint32_t num_blocks = ir_BlockList_getCount(&fi->blocks);
   for (uint32_t i = 0; (i < num_blocks); i++) {
      string_buffer_Buf_print(out, "%u[label=\"%u\"];\n", i, i);
   }
   for (uint32_t i = 0; (i < num_blocks); i++) {
      ir_Block* b = ir_BlockList_get(&fi->blocks, i);
      for (uint32_t j = 1; (j < num_blocks); j++) {
         if (ir_block_has_dest(b, &fi->cases, j)) {
            string_buffer_Buf_print(out, "%u->%u;\n", i, j);
         }
      }
   }
   string_buffer_Buf_add(out, "}\n");
   string_buffer_Buf_add(out, "-------------\n");
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static const char* ir_InitValueKind_str(ir_InitValueKind k)
{
   switch (k) {
   case ir_InitValueKind_None:
      return "none";
   case ir_InitValueKind_Byte:
      return "byte";
   case ir_InitValueKind_Short:
      return "short";
   case ir_InitValueKind_Word:
      fallthrough;
   case ir_InitValueKind_Word2:
      return "word";
   case ir_InitValueKind_Long:
      fallthrough;
   case ir_InitValueKind_Long2:
      return "long";
   case ir_InitValueKind_Symbol:
      return "symbol";
   case ir_InitValueKind_Text:
      return "text";
   case ir_InitValueKind_Zero:
      return "zero";
   }
   return "?";
}

static void ir_InitValue_init(ir_InitValue* r, ir_InitValueKind kind, uint32_t value)
{
   r->kind = kind;
   r->value = value;
}

static const char* ir_InitValue_getKindName(const ir_InitValue* r)
{
   ir_InitValueKind k = ir_InitValue_getKind(r);
   return ir_InitValueKind_str(k);
}

static ir_InitValueKind ir_InitValue_getKind(const ir_InitValue* r)
{
   return ((ir_InitValueKind)(r->kind));
}

static void ir_InitValueList_init(ir_InitValueList* l, uint32_t initial_size)
{
   memset(l, 0, 16);
   if (initial_size) ir_InitValueList_resize(l, initial_size);
}

static void ir_InitValueList_free(ir_InitValueList* l)
{
   if (l->values) free(((void*)(l->values)));
}

static void ir_InitValueList_resize(ir_InitValueList* l, uint32_t cap)
{
   l->capacity = cap;
   ir_InitValue* values2 = malloc((l->capacity * 4));
   if ((l->count != 0)) memcpy(values2, l->values, (l->count * 4));
   if (l->values) free(l->values);
   l->values = values2;
}

static ir_InitValue* ir_InitValueList_add(ir_InitValueList* l)
{
   if ((l->count == l->capacity)) ir_InitValueList_resize(l, l->capacity ? (l->capacity * 2) : 4);
   ir_InitValue* v = &l->values[l->count];
   l->count++;
   return v;
}

static uint32_t ir_InitValueList_getCount(const ir_InitValueList* l)
{
   return l->count;
}

static ir_InitValue* ir_InitValueList_get(const ir_InitValueList* l, uint32_t idx)
{
   return &l->values[idx];
}

static ir_BlockIndex* ir_SlotCollector_getBlock(const ir_SlotCollector* c, ir_BlockId blk_id)
{
   return &c->indexes[blk_id];
}

static void ir_SlotCollector_create(ir_SlotCollector* c)
{
   memset(c, 0, 56);
   c->reads = malloc((ir_SlotMax * 4));
   c->writes = malloc((ir_SlotMax * 8));
   c->writes2 = malloc((ir_SlotMax * 8));
   c->indexes = malloc((256 * 8));
}

static void ir_SlotCollector_free(ir_SlotCollector* c)
{
   free(c->indexes);
   free(c->writes2);
   free(c->writes);
   free(c->reads);
}

static void ir_SlotCollector_fill(ir_SlotCollector* c, ir_FunctionInfo* info)
{
   c->read_idx = 0;
   c->write_idx = 0;
   c->num_writes = 0;
   c->num_blocks = ir_BlockList_getCount(&info->blocks);
   c->info = info;
   for (uint32_t i = 0; (i < c->num_blocks); i++) {
      ir_SlotCollector_checkBlock(c, i);
   }
}

static ir_ReadSlotAccess* ir_SlotCollector_findRead(const ir_SlotCollector* c, ir_BlockId blk_id, uint16_t slot)
{
   const ir_BlockIndex* bi = &c->indexes[blk_id];
   uint32_t slot_start = bi->rd_start;
   uint32_t slot_end = (bi->rd_start + bi->rd_count);
   for (uint32_t i = slot_start; (i < slot_end); i++) {
      ir_ReadSlotAccess* ra = &c->reads[i];
      if ((ra->slot == slot)) return ra;

   }
   return NULL;
}

static const ir_WriteSlotAccess* ir_SlotCollector_findWrite(const ir_SlotCollector* c, ir_BlockId blk_id, uint16_t slot)
{
   const ir_BlockIndex* bi = &c->indexes[blk_id];
   uint32_t slot_start = bi->wr_start;
   uint32_t slot_end = (bi->wr_start + bi->wr_count);
   for (uint32_t i = slot_start; (i < slot_end); i++) {
      const ir_WriteSlotAccess* wa = &c->writes[i];
      if ((wa->slot == slot)) {
         return wa;
      }
   }
   return NULL;
}

static void ir_SlotCollector_checkBlock(ir_SlotCollector* c, ir_BlockId blk_id)
{
   ir_Block* b = ir_BlockList_get(&c->info->blocks, blk_id);
   ir_BlockIndex* bi = &c->indexes[blk_id];
   bi->rd_start = ((uint16_t)(c->read_idx));
   bi->wr_start = ((uint16_t)(c->write_idx));
   ir_Instr* ii = ir_InstrList_get(&c->info->instructions, b->instr.start);
   for (uint32_t i = 0; (i < b->instr.count); i++) {
      ir_Instr* cur = &ii[i];
      if (!ir_Instr_isLoadOrStore(cur)) continue;

      uint16_t idx = ((uint16_t)((b->instr.start + i)));
      _Bool found = false;
      if (ir_Instr_isLoad(cur)) {
         if (!ir_Ref_isSlot(&cur->args[0])) continue;

         cur->instrBits.kind = ir_InstrKind_Copy;
         uint16_t slot = ((uint16_t)(cur->args[0].value));
         for (uint32_t j = bi->wr_start; (j < c->write_idx); j++) {
            if ((c->writes[j].slot == slot)) {
               found = true;
               break;
            }
         }
         if (found) continue;

         for (uint32_t j = bi->rd_start; (j < c->read_idx); j++) {
            if ((c->reads[j].slot == slot)) {
               found = true;
               break;
            }
         }
         if (found) continue;

         ((c->read_idx < ir_SlotMax)) || c2_assert("ir/slot_collector.c2", 159, "ir.SlotCollector.checkBlock", "c.read_idx < SlotMax");
         ir_ReadSlotAccess* ra = &c->reads[c->read_idx++];
         ra->done = 0;
         ra->slot = slot;
         ra->instr_idx = idx;
      } else {
         if (!ir_Ref_isSlot(&cur->args[1])) continue;

         cur->instrBits.kind = ir_InstrKind_Copy;
         uint16_t slot = ((uint16_t)(cur->args[1].value));
         ir_WriteSlotAccess* wa = NULL;
         for (uint32_t j = bi->wr_start; (j < c->write_idx); j++) {
            if ((c->writes[j].slot == slot)) {
               wa = &c->writes[j];
               break;
            }
         }
         if (!wa) {
            ((c->write_idx < ir_SlotMax)) || c2_assert("ir/slot_collector.c2", 181, "ir.SlotCollector.checkBlock", "c.write_idx < SlotMax");
            wa = &c->writes[c->write_idx++];
            c->num_writes++;
         }
         wa->slot = slot;
         wa->ref = cur->args[0];
      }
   }
   bi->rd_count = (((uint16_t)(c->read_idx)) - bi->rd_start);
   bi->wr_count = (((uint16_t)(c->write_idx)) - bi->wr_start);
}

static void ir_SlotCollector_insertWrite(ir_SlotCollector* c, ir_BlockId blk_id, uint16_t slot, ir_Ref ref)
{
   ir_BlockIndex* bi = &c->indexes[blk_id];
   ((((c->write_idx + bi->wr_count) + 1) < ir_SlotMax)) || c2_assert("ir/slot_collector.c2", 198, "ir.SlotCollector.insertWrite", "c.write_idx + bi.wr_count + 1 < SlotMax");
   if (bi->wr_count) {
      memcpy(&c->writes[c->write_idx], &c->writes[bi->wr_start], (bi->wr_count * 8));
   }
   bi->wr_start = ((uint16_t)(c->write_idx));
   c->write_idx += bi->wr_count;
   ir_WriteSlotAccess* wa = &c->writes[c->write_idx++];
   c->num_writes++;
   bi->wr_count++;
   wa->slot = slot;
   wa->ref = ref;
   if ((c->write_idx > (c->num_writes + 200))) ir_SlotCollector_defragWrites(c);
}

static void ir_SlotCollector_defragWrites(ir_SlotCollector* c)
{
   uint16_t out_idx = 0;
   for (uint32_t i = 0; (i < c->num_blocks); i++) {
      ir_BlockIndex* bi = &c->indexes[i];
      if ((bi->wr_count == 0)) continue;

      memcpy(&c->writes2[out_idx], &c->writes[bi->wr_start], (bi->wr_count * 8));
      bi->wr_start = out_idx;
      out_idx += bi->wr_count;
   }
   ir_WriteSlotAccess* tmp = c->writes;
   c->writes = c->writes2;
   c->writes2 = tmp;
   c->write_idx = out_idx;
}

static void ir_SlotCollector_dump(const ir_SlotCollector* c)
{
   printf("Access: [%u reads, %u writes, %u blocks]\n", c->read_idx, c->write_idx, c->num_blocks);
   for (uint32_t i = 0; (i < c->num_blocks); i++) {
      const ir_BlockIndex* bi = &c->indexes[i];
      printf("  B%u  [%2u %2u | %2u %2u]  ", i, bi->rd_start, bi->rd_count, bi->wr_start, bi->wr_count);
      printf("R");
      if (bi->rd_count) {
         uint32_t start = bi->rd_start;
         uint32_t end = (bi->rd_start + bi->rd_count);
         for (uint32_t j = start; (j < end); j++) {
            const ir_ReadSlotAccess* ra = &c->reads[j];
            printf(" %u", ra->slot);
         }
      }
      printf(" | W");
      if (bi->wr_count) {
         uint32_t start = bi->wr_start;
         uint32_t end = (bi->wr_start + bi->wr_count);
         for (uint32_t j = start; (j < end); j++) {
            const ir_WriteSlotAccess* wa = &c->writes[j];
            printf(" %u", wa->slot);
         }
      }
      printf("\n");
   }
}

static ir_Ref ir_Context_addPhiInstr(ir_Context* c, ir_FunctionInfo* fi, const ir_PhiCache* cache)
{
   ir_Ref out; ir_Ref_init(&out, ir_RefKind_Temp, ir_InstrList_getCount(&fi->instructions));
   uint32_t phi_start = ir_PhiList_addCache(&fi->phis, cache);
   ir_Instr* ii = ir_InstrList_add(&fi->instructions);
   ir_Instr_initPhi(ii, phi_start, ir_PhiCache_getCount(cache));
   const ir_PhiClause* clauses = ir_PhiCache_getClauses(cache);
   for (uint32_t i = 0; (i < ir_PhiCache_getCount(cache)); i++) {
      ir_BlockId blk_id = clauses[i].src;
      ir_Block* b = ir_BlockList_get(&fi->blocks, blk_id);
      b->phi_source = 1;
   }
   return out;
}

static _Bool ir_block_has_dest(const ir_Block* b, const ir_CaseList* cases, uint32_t dest)
{
   if (b->end_with_switch) {
      ir_CaseId case_id = b->dests[0];
      uint32_t num_cases = b->dests[1];
      for (uint32_t j = 0; (j < num_cases); j++) {
         ir_Case* cs = ir_CaseList_get(cases, (case_id + j));
         if ((cs->block == dest)) return true;

      }
   } else {
      if ((b->dests[0] == dest)) return true;

      if ((b->dests[1] == dest)) return true;

   }
   return false;
}

static void ir_RevList_create(ir_RevList* r, uint32_t num_blocks)
{
   memset(r, 0, 32);
   r->capacity = 1024;
   r->block_capacity = num_blocks;
   r->nodes = malloc((r->capacity * 1));
   r->indexes = malloc((num_blocks * 4));
}

static void ir_RevList_build(ir_RevList* r, ir_FunctionInfo* info)
{
   r->count = 0;
   uint32_t num_blocks = ir_BlockList_getCount(&info->blocks);
   if ((num_blocks > r->block_capacity)) {
      (0) || c2_assert("ir/ssa.c2", 87, "ir.RevList.build", "0");
   }
   r->block_count = ir_BlockList_getCount(&info->blocks);
   r->indexes[0].start = 0;
   r->indexes[0].count = 0;
   for (uint32_t i = 1; (i < num_blocks); i++) {
      uint32_t dest = i;
      uint32_t start = r->count;
      for (uint32_t j = 0; (j < num_blocks); j++) {
         ir_Block* b = ir_BlockList_get(&info->blocks, j);
         if (ir_block_has_dest(b, &info->cases, dest)) {
            ((r->count < r->capacity)) || c2_assert("ir/ssa.c2", 101, "ir.RevList.build", "r.count < r.capacity");
            r->nodes[r->count++] = ((uint8_t)(j));
         }
      }
      uint32_t count = (r->count - start);
      r->indexes[i].count = ((uint16_t)(count));
      if (count) {
         r->indexes[i].start = ((uint16_t)(start));
      } else {
         r->indexes[i].start = 0;
      }
   }
}

static void ir_RevList_dump(const ir_RevList* r)
{
   printf("Revlist [%u blocks]\n", r->block_count);
   for (uint32_t i = 0; (i < r->block_count); i++) {
      printf("  B%u  [", i);
      uint32_t start = r->indexes[i].start;
      uint32_t count = r->indexes[i].count;
      for (uint32_t j = 0; (j < count); j++) {
         printf(" %u", r->nodes[(start + j)]);
      }
      printf(" ]\n");
   }
}

static void ir_RevList_free(ir_RevList* r)
{
   free(r->nodes);
   free(r->indexes);
}

static ir_RevIndex ir_RevList_getBlockIndex(const ir_RevList* r, ir_BlockId blk_id)
{
   return r->indexes[blk_id];
}

static uint8_t ir_RevList_getRev(const ir_RevList* r, uint32_t idx)
{
   return r->nodes[idx];
}

static void ir_Context_create_ssa(ir_Context* c, ir_FunctionInfo* fi, const char* name)
{
   const uint32_t num_blocks = ir_BlockList_getCount(&fi->blocks);
   instr_inserter_InstrInserter_clear(&c->inserter);
   ir_SlotCollector_fill(&c->collector, fi);
   ir_RevList_build(&c->revlist, fi);
   bit_array_BitArray_reset(&c->active_blocks, num_blocks);
   if ((num_blocks == 1)) return;

   uint32_t indent = 1;
   ir_PhiCache results; ir_PhiCache_init(&results);
   for (uint32_t i = 0; (i < num_blocks); i++) {
      uint32_t blk_id = i;
      bit_array_BitArray_set(&c->active_blocks, i);
      const ir_BlockIndex* bi = ir_SlotCollector_getBlock(&c->collector, blk_id);
      for (uint32_t j = bi->rd_start; (j < (bi->rd_start + bi->rd_count)); j++) {
         ir_ReadSlotAccess* ra = &c->collector.reads[j];
         if (ra->done) continue;

         uint16_t slot = ra->slot;
         ir_PhiCache_clear(&results);
         ir_RevIndex revs = ir_RevList_getBlockIndex(&c->revlist, blk_id);
         for (uint32_t r = revs.start; (r < (revs.start + revs.count)); r++) {
            uint32_t rev_blk = ir_RevList_getRev(&c->revlist, r);
            if (!bit_array_BitArray_get(&c->active_blocks, rev_blk)) {
               ir_Ref ref = ir_Context_checkPredBlock(c, rev_blk, slot, (indent + 1), fi);
               if (ir_Ref_isValid(&ref)) {
                  ir_PhiCache_add(&results, rev_blk, ref);
               }
            }
         }
         if (ir_PhiCache_getCount(&results)) {
            ir_Ref ref;
            if ((ir_PhiCache_getCount(&results) > 1)) {
               ir_Ref phi_ref = ir_Context_addPhiInstr(c, fi, &results);
               ir_Block* b = ir_BlockList_get(&fi->blocks, blk_id);
               uint32_t loc = b->instr.start;
               if (ir_Instr_isComment(ir_InstrList_get(&fi->instructions, loc))) loc++;
               instr_inserter_InstrInserter_add(&c->inserter, loc, phi_ref.value);
               char tmp[8];
               sprintf(tmp, "s%u", slot);
               ir_Ref com_ref = ir_Context_addComment2(c, tmp, fi);
               instr_inserter_InstrInserter_add(&c->inserter, loc, com_ref.value);
               ir_SlotCollector_insertWrite(&c->collector, blk_id, slot, phi_ref);
               ref = phi_ref;
            } else {
               ref = results.stash[0].ref;
            }
            const ir_WriteSlotAccess* wr = ir_SlotCollector_findWrite(&c->collector, blk_id, slot);
            if (!wr) {
               (ir_Ref_isValid(&ref)) || c2_assert("ir/ssa.c2", 233, "ir.Context.create_ssa", "ref.isValid()");
               ir_SlotCollector_insertWrite(&c->collector, blk_id, slot, ref);
            }
         }
         ra->done = 1;
      }
      bit_array_BitArray_clear(&c->active_blocks, i);
   }
   ir_PhiCache_free(&results);
}

static ir_Ref ir_Context_checkPredBlock(ir_Context* c, ir_BlockId blk_id, uint16_t slot, uint32_t indent, ir_FunctionInfo* fi)
{
   ir_Ref ref = { };
   bit_array_BitArray_set(&c->active_blocks, blk_id);
   const ir_WriteSlotAccess* wr = ir_SlotCollector_findWrite(&c->collector, blk_id, slot);
   if (wr) {
      bit_array_BitArray_clear(&c->active_blocks, blk_id);
      return wr->ref;
   }
   ir_RevIndex revs = ir_RevList_getBlockIndex(&c->revlist, blk_id);
   uint32_t rev_end = (revs.start + revs.count);
   ir_PhiCache results; ir_PhiCache_init(&results);
   for (uint32_t j = revs.start; (j < rev_end); j++) {
      uint32_t rev_blk = ir_RevList_getRev(&c->revlist, j);
      if (!bit_array_BitArray_get(&c->active_blocks, rev_blk)) {
         ir_Ref ref2 = ir_Context_checkPredBlock(c, rev_blk, slot, (indent + 1), fi);
         if (ir_Ref_isValid(&ref2)) {
            ir_PhiCache_add(&results, rev_blk, ref2);
         }
      }
   }
   if ((ir_PhiCache_getCount(&results) != 0)) {
      ir_ReadSlotAccess* my_read = ir_SlotCollector_findRead(&c->collector, blk_id, slot);
      if (my_read) {
         my_read->done = 1;
      }
      if ((ir_PhiCache_getCount(&results) != 0)) {
         if ((ir_PhiCache_getCount(&results) > 1)) {
            ref = ir_Context_addPhiInstr(c, fi, &results);
            ir_Block* b = ir_BlockList_get(&fi->blocks, blk_id);
            uint32_t loc = b->instr.start;
            if (ir_Instr_isComment(ir_InstrList_get(&fi->instructions, loc))) loc++;
            instr_inserter_InstrInserter_add(&c->inserter, loc, ref.value);
            char tmp[8];
            sprintf(tmp, "s%u", slot);
            ir_Ref com_ref = ir_Context_addComment2(c, tmp, fi);
            instr_inserter_InstrInserter_add(&c->inserter, loc, com_ref.value);
            if (my_read) {
            }
         } else {
            ref = results.stash[0].ref;
         }
         (ir_Ref_isValid(&ref)) || c2_assert("ir/ssa.c2", 316, "ir.Context.checkPredBlock", "ref.isValid()");
         ir_SlotCollector_insertWrite(&c->collector, blk_id, slot, ref);
         if (my_read) {
         }
      }
   }
   ir_PhiCache_free(&results);
   bit_array_BitArray_clear(&c->active_blocks, blk_id);
   return ref;
}

static void ir_Context_fixup_function(ir_Context* c, ir_FunctionInfo* fi)
{
   uint32_t old_icount = ir_InstrList_getCount(&fi->instructions);
   ir_InstrList i_new; ir_InstrList_init(&i_new, old_icount);
   lookup_table_Table_clear(&c->conversion, old_icount);
   instr_inserter_InstrInserter_start(&c->inserter);
   const ir_Instr* i_old = ir_InstrList_get(&fi->instructions, 0);
   uint32_t blk_count = ir_BlockList_getCount(&fi->blocks);
   uint32_t new_index = 0;
   for (uint32_t i = 0; (i < blk_count); i++) {
      ir_Block* b = ir_BlockList_get(&fi->blocks, i);
      uint32_t i_start = b->instr.start;
      uint32_t i_count = b->instr.count;
      uint32_t new_start = new_index;
      uint32_t new_count = i_count;
      for (uint32_t j = i_start; (j < (i_start + i_count)); j++) {
         {
            uint32_t instr_idx;
            while ((instr_idx = instr_inserter_InstrInserter_insert(&c->inserter, j))) {
               ir_Instr* is = ir_InstrList_add(&i_new);
               ir_Instr_copy(is, &i_old[instr_idx]);
               lookup_table_Table_set(&c->conversion, instr_idx, new_index);
               new_index++;
               new_count++;
            }
         }
         ir_Instr* is = ir_InstrList_add(&i_new);
         ir_Instr_copy(is, &i_old[j]);
         lookup_table_Table_set(&c->conversion, j, new_index);
         if (ir_Instr_isPhi(is)) {
         } else {
            ir_Ref* r = &is->args[0];
            if (ir_Ref_isTemp(r)) r->value = lookup_table_Table_get(&c->conversion, r->value);
            r = &is->args[1];
            if (ir_Ref_isTemp(r)) r->value = lookup_table_Table_get(&c->conversion, r->value);
            else if (ir_Ref_isRefList(r)) {
               ir_Ref* refs = ir_RefList_get(&fi->refs, r->value);
               uint32_t idx = 0;
               while (1) {
                  ir_Ref* r2 = &refs[idx];
                  if (ir_Ref_isTemp(r2)) r2->value = lookup_table_Table_get(&c->conversion, r2->value);
                  if (!ir_Ref_isValid(r2)) break;

                  idx++;
               }
            }

         }
         new_index++;
      }
      b->instr.start = new_start;
      b->instr.count = new_count;
   }
   for (uint32_t i = 0; (i < ir_PhiList_getCount(&fi->phis)); i++) {
      ir_PhiClause* pc = ir_PhiList_get(&fi->phis, i);
      if (ir_Ref_isTemp(&pc->ref)) pc->ref.value = lookup_table_Table_get(&c->conversion, pc->ref.value);
   }
   ir_InstrList_swap(&i_new, &fi->instructions);
   ir_InstrList_free(&i_new);
   instr_inserter_InstrInserter_clear(&c->inserter);
}

static void ir_SymbolList_init(ir_SymbolList* l, uint32_t initial_size)
{
   memset(l, 0, 16);
   l->count = 1;
   ir_SymbolList_resize(l, initial_size);
}

static void ir_SymbolList_free(ir_SymbolList* l)
{
   if (l->symbols) free(((void*)(l->symbols)));
}

static void ir_SymbolList_resize(ir_SymbolList* l, uint32_t cap)
{
   l->capacity = cap;
   ir_Symbol* symbols2 = calloc(l->capacity, 16);
   if ((l->count > 1)) memcpy(symbols2, l->symbols, (l->count * 16));
   if (l->symbols) free(l->symbols);
   l->symbols = symbols2;
}

static ir_SymbolId ir_SymbolList_add(ir_SymbolList* l, uint32_t name, _Bool is_function, uint32_t align, _Bool is_external)
{
   if ((l->count == l->capacity)) ir_SymbolList_resize(l, (l->capacity * 2));
   ir_SymbolId idx = l->count;
   ir_Symbol* s = &l->symbols[idx];
   memset(s, 0, 16);
   s->name = name;
   s->align = align;
   s->is_external = is_external;
   s->is_function = is_function;
   if (is_function) {
      s->f.info = NULL;
   } else {
      s->g.init_value_count = 0;
      s->g.init_value_idx = 0;
   }
   l->count++;
   return idx;
}

static uint32_t ir_SymbolList_getCount(const ir_SymbolList* l)
{
   return l->count;
}

static ir_Symbol* ir_SymbolList_get(const ir_SymbolList* l, ir_SymbolId idx)
{
   return &l->symbols[idx];
}

static void ir_Instr_init0(ir_Instr* i, ir_InstrKind k)
{
   memset(i, 0, 12);
   i->instrBits.kind = k;
}

static void ir_Instr_initPhi(ir_Instr* i, uint32_t clause_start, uint32_t num_clauses)
{
   i->bits = 0;
   i->instrBits.kind = ir_InstrKind_Phi;
   i->instrBits.has_result = true;
   i->phi_clauses.start = clause_start;
   i->phi_clauses.count = num_clauses;
}

static void ir_Instr_init1(ir_Instr* i, ir_InstrKind k, ir_Ref ref1)
{
   memset(i, 0, 12);
   i->instrBits.kind = k;
   i->args[0] = ref1;
}

static void ir_Instr_init1b(ir_Instr* i, ir_InstrKind k, ir_Ref ref1)
{
   memset(i, 0, 12);
   i->instrBits.kind = k;
   i->instrBits.has_result = true;
   i->args[0] = ref1;
}

static void ir_Instr_init2(ir_Instr* i, ir_InstrKind k, ir_Ref ref1, ir_Ref ref2)
{
   memset(i, 0, 12);
   i->instrBits.kind = k;
   i->args[0] = ref1;
   i->args[1] = ref2;
}

static void ir_Instr_init2b(ir_Instr* i, ir_InstrKind k, ir_Ref ref1, ir_Ref ref2)
{
   i->bits = 0;
   i->instrBits.kind = k;
   i->instrBits.has_result = true;
   i->args[0] = ref1;
   i->args[1] = ref2;
}

static void ir_Instr_copy(ir_Instr* i, const ir_Instr* i2)
{
   memcpy(i, i2, 12);
}

static ir_InstrKind ir_Instr_getKind(const ir_Instr* i)
{
   return i->instrBits.kind;
}

static _Bool ir_Instr_hasResult(const ir_Instr* i)
{
   return i->instrBits.has_result;
}

static const char* ir_Instr_getKindName(const ir_Instr* i)
{
   ir_InstrKind k = ir_Instr_getKind(i);
   return ir_InstrKind_str(k);
}

static _Bool ir_Instr_isPseudo(const ir_Instr* i)
{
   ir_InstrKind k = ir_Instr_getKind(i);
   return (k >= ir_InstrKind_Switch);
}

static _Bool ir_Instr_isLoad(const ir_Instr* i)
{
   ir_InstrKind k = ir_Instr_getKind(i);
   return ((k >= ir_InstrKind_Load1) && (k <= ir_InstrKind_Load8));
}

static _Bool ir_Instr_isLoadOrStore(const ir_Instr* i)
{
   ir_InstrKind k = ir_Instr_getKind(i);
   return ((k >= ir_InstrKind_Load1) && (k <= ir_InstrKind_Store8));
}

static _Bool ir_Instr_isPhi(const ir_Instr* i)
{
   ir_InstrKind k = ir_Instr_getKind(i);
   return (k == ir_InstrKind_Phi);
}

static _Bool ir_Instr_isComment(const ir_Instr* i)
{
   ir_InstrKind k = ir_Instr_getKind(i);
   return (k == ir_InstrKind_Comment);
}

static const char* ir_InstrKind_str(ir_InstrKind k)
{
   switch (k) {
   case ir_InstrKind_None:
      return "none";
   case ir_InstrKind_Add:
      return "add";
   case ir_InstrKind_Sub:
      return "sub";
   case ir_InstrKind_Div:
      return "div";
   case ir_InstrKind_Rem:
      return "rem";
   case ir_InstrKind_Mul:
      return "mul";
   case ir_InstrKind_IDiv:
      return "idiv";
   case ir_InstrKind_And:
      return "and";
   case ir_InstrKind_Or:
      return "or";
   case ir_InstrKind_Xor:
      return "xor";
   case ir_InstrKind_Shl:
      return "shl";
   case ir_InstrKind_Shr:
      return "shr";
   case ir_InstrKind_CmpNe:
      return "icmp ne";
   case ir_InstrKind_CmpEq:
      return "icmp eq";
   case ir_InstrKind_CmpLt:
      return "icmp lt";
   case ir_InstrKind_CmpGt:
      return "icmp gt";
   case ir_InstrKind_CmpLe:
      return "icmp le";
   case ir_InstrKind_CmpGe:
      return "icmp ge";
   case ir_InstrKind_Load1:
      return "load1";
   case ir_InstrKind_Load2:
      return "load2";
   case ir_InstrKind_Load4:
      return "load4";
   case ir_InstrKind_Load8:
      return "load8";
   case ir_InstrKind_Store1:
      return "store1";
   case ir_InstrKind_Store2:
      return "store2";
   case ir_InstrKind_Store4:
      return "store4";
   case ir_InstrKind_Store8:
      return "store8";
   case ir_InstrKind_Alloc1:
      return "alloc1";
   case ir_InstrKind_Alloc2:
      return "alloc2";
   case ir_InstrKind_Alloc4:
      return "alloc4";
   case ir_InstrKind_Alloc8:
      return "alloc8";
   case ir_InstrKind_Jmp:
      return "jmp";
   case ir_InstrKind_JmpIf:
      return "jmp_if";
   case ir_InstrKind_Ret:
      return "ret";
   case ir_InstrKind_Halt:
      return "halt";
   case ir_InstrKind_Call:
      return "call";
   case ir_InstrKind_Switch:
      return "switch";
   case ir_InstrKind_Phi:
      return "phi";
   case ir_InstrKind_Copy:
      return "copy";
   case ir_InstrKind_Comment:
      return "comment";
   }
   return "";
}

static void ir_InstrList_init(ir_InstrList* l, uint32_t initial_size)
{
   memset(l, 0, 16);
   if (initial_size) {
      l->capacity = initial_size;
      l->instrs = malloc((l->capacity * 12));
   }
}

static void ir_InstrList_free(ir_InstrList* l)
{
   if (l->instrs) free(((void*)(l->instrs)));
}

static ir_Instr* ir_InstrList_add(ir_InstrList* l)
{
   if ((l->count >= l->capacity)) {
      if ((l->capacity == 0)) l->capacity = 8;
      else l->capacity *= 2;
      ir_Instr* instrs2 = malloc((l->capacity * 12));
      if (l->count) memcpy(instrs2, l->instrs, (l->count * 12));
      if (l->instrs) free(l->instrs);
      l->instrs = instrs2;
   }
   return &l->instrs[l->count++];
}

static void ir_InstrList_clear(ir_InstrList* l)
{
   l->count = 0;
}

static uint32_t ir_InstrList_getCount(const ir_InstrList* l)
{
   return l->count;
}

static ir_Instr* ir_InstrList_get(const ir_InstrList* l, uint32_t idx)
{
   ((idx < l->count)) || c2_assert("ir/instr_list.c2", 61, "ir.InstrList.get", "idx < l.count");
   return &l->instrs[idx];
}

static void ir_InstrList_swap(ir_InstrList* l, ir_InstrList* other)
{
   ir_InstrList tmp = *other;
   *other = *l;
   *l = tmp;
}

static void ir_PhiList_init(ir_PhiList* l)
{
   l->count = 0;
   l->capacity = 0;
   l->clauses = NULL;
}

static void ir_PhiList_free(ir_PhiList* l)
{
   if (l->clauses) free(((void*)(l->clauses)));
}

static void ir_PhiList_resize(ir_PhiList* l, uint32_t extra)
{
   l->capacity += extra;
   ir_PhiClause* clauses2 = calloc(l->capacity, 8);
   if ((l->count != 0)) memcpy(clauses2, l->clauses, (l->count * 8));
   if (l->clauses) free(l->clauses);
   l->clauses = clauses2;
}

static void ir_PhiList_add(ir_PhiList* l, ir_BlockId src, ir_Ref ref)
{
   if ((l->count == l->capacity)) ir_PhiList_resize(l, 2);
   ir_PhiClause* c = &l->clauses[l->count++];
   c->src = src;
   c->ref = ref;
}

static uint32_t ir_PhiList_addCache(ir_PhiList* l, const ir_PhiCache* cache)
{
   uint32_t extra = ir_PhiCache_getCount(cache);
   if (((l->count + extra) >= l->capacity)) ir_PhiList_resize(l, extra);
   uint32_t start = l->count;
   const ir_PhiClause* src = ir_PhiCache_getClauses(cache);
   memcpy(&l->clauses[l->count], src, (extra * 8));
   l->count += extra;
   return start;
}

static void ir_PhiList_clear(ir_PhiList* l)
{
   l->count = 0;
}

static uint32_t ir_PhiList_getCount(const ir_PhiList* l)
{
   return l->count;
}

static ir_PhiClause* ir_PhiList_get(const ir_PhiList* l, uint32_t idx)
{
   return &l->clauses[idx];
}

static void ir_PhiList_copy(ir_PhiList* l, const ir_PhiList* l2)
{
   if ((l->capacity < l2->count)) ir_PhiList_resize(l, (l2->count - l->capacity));
   l->count = l2->count;
   memcpy(l->clauses, l2->clauses, (l2->count * 8));
}

static void ir_PhiCache_init(ir_PhiCache* c)
{
   c->count = 0;
   c->capacity = 0;
}

static void ir_PhiCache_free(ir_PhiCache* c)
{
   if ((c->capacity > 2)) free(c->clauses);
}

static uint32_t ir_PhiCache_getCount(const ir_PhiCache* c)
{
   return c->count;
}

static void ir_PhiCache_clear(ir_PhiCache* c)
{
   c->count = 0;
}

static _Bool ir_PhiCache_contains(const ir_PhiCache* c, ir_Ref ref)
{
   const ir_PhiClause* clauses = ir_PhiCache_getClauses(c);
   for (uint32_t i = 0; (i < c->count); i++) {
      if (ir_Ref_equals(&clauses[i].ref, ref)) return true;

   }
   return false;
}

static void ir_PhiCache_add(ir_PhiCache* c, ir_BlockId blk_id, ir_Ref ref)
{
   if (ir_PhiCache_contains(c, ref)) return;

   ir_PhiClause* clause;
   if ((c->count >= c->capacity)) {
      if ((c->capacity == 0)) {
         c->capacity = 2;
         clause = c->stash;
      } else {
         uint32_t cap2 = ((c->capacity + (c->capacity / 2)) + 2);
         ir_PhiClause* clauses2 = malloc((cap2 * 8));
         memcpy(clauses2, ir_PhiCache_getClauses(c), (c->count * 8));
         if ((c->capacity > 2)) free(c->clauses);
         c->capacity = cap2;
         c->clauses = clauses2;
         clause = &c->clauses[c->count];
      }
   } else {
      if ((c->count > 2)) clause = &c->clauses[c->count];
      else clause = &c->stash[c->count];
   }
   c->count++;
   clause->src = blk_id;
   clause->ref = ref;
}

static const ir_PhiClause* ir_PhiCache_getClauses(const ir_PhiCache* c)
{
   if ((c->count <= 2)) return c->stash;

   return c->clauses;
}

static void ir_PrintHelper_init(ir_PrintHelper* ph, const ir_Context* c)
{
   ph->out = string_buffer_create((16 * 1024), color_useColor(), 2);
   ph->blocks = NULL;
   ph->c = c;
   ph->temp_ids = calloc(ir_MaxTemps, 4);
   ph->temp_count = 0;
   ph->cur_block = NULL;
   ph->cur_info = NULL;
}

static void ir_PrintHelper_free(ir_PrintHelper* ph)
{
   string_buffer_Buf_free(ph->out);
   free(ph->temp_ids);
}

static void ir_PrintHelper_print(const ir_PrintHelper* ph)
{
   string_buffer_Buf_color(ph->out, color_Normal);
   puts(string_buffer_Buf_data(ph->out));
}

static void ir_PrintHelper_resetTemps(ir_PrintHelper* ph, uint32_t num_args, uint32_t num_instr)
{
   ph->temp_count = num_args;
   ((num_instr < ir_MaxTemps)) || c2_assert("ir/print.c2", 83, "ir.PrintHelper.resetTemps", "num_instr < MaxTemps");
   memset(ph->temp_ids, 0, (num_instr * 4));
}

static uint32_t ir_PrintHelper_addTemp(ir_PrintHelper* ph, uint32_t local_instr_idx)
{
   uint32_t temp_nr = ph->temp_count;
   ((local_instr_idx < ir_MaxTemps)) || c2_assert("ir/print.c2", 89, "ir.PrintHelper.addTemp", "local_instr_idx < MaxTemps");
   ((ph->temp_ids[local_instr_idx] == 0)) || c2_assert("ir/print.c2", 90, "ir.PrintHelper.addTemp", "ph.temp_ids[local_instr_idx] == 0");
   ph->temp_ids[local_instr_idx] = temp_nr;
   ph->temp_count++;
   return temp_nr;
}

static uint32_t ir_PrintHelper_findTemp(ir_PrintHelper* ph, uint32_t instr_idx)
{
   ((instr_idx < ir_MaxTemps)) || c2_assert("ir/print.c2", 97, "ir.PrintHelper.findTemp", "instr_idx < MaxTemps");
   return ph->temp_ids[instr_idx];
}

static void ir_PrintHelper_collect_temps(ir_PrintHelper* ph)
{
   const ir_Instr* instr = ir_InstrList_get(&ph->cur_info->instructions, 0);
   for (uint32_t i = 0; (i < ir_InstrList_getCount(&ph->cur_info->instructions)); i++) {
      const ir_Instr* ii = &instr[i];
      if (ir_Instr_hasResult(ii)) ir_PrintHelper_addTemp(ph, i);
   }
}

static void ir_PrintHelper_print_func(ir_PrintHelper* ph, const ir_Symbol* s, const ir_FunctionInfo* info)
{
   const ir_Context* c = ph->c;
   if (!info) return;

   ph->blocks = &info->blocks;
   ph->cur_info = info;
   string_buffer_Buf* out = ph->out;
   uint8_t num_args = info->num_args;
   ir_PrintHelper_resetTemps(ph, num_args, ir_InstrList_getCount(&info->instructions));
   if (s->is_external) {
      string_buffer_Buf_color(out, ir_col_Attr);
      string_buffer_Buf_add(out, "external ");
   }
   string_buffer_Buf_color(out, ir_col_Attr);
   string_buffer_Buf_add(out, "fn");
   ir_Type rt = ir_FunctionInfo_getReturnType(info);
   if ((rt != ir_Type_None)) {
      string_buffer_Buf_space(out);
      string_buffer_Buf_color(out, ir_col_Type);
      string_buffer_Buf_add(out, ir_Type_str(rt));
      string_buffer_Buf_color(out, color_Normal);
   }
   string_buffer_Buf_color(out, ir_col_Symbol);
   string_buffer_Buf_print(out, " %s(", string_pool_Pool_idx2str(c->pool, s->name));
   for (uint32_t i = 1; (i < num_args); i++) {
      if ((i != 1)) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_color(out, ir_col_Type);
      ir_Type t = ir_FunctionInfo_getArg(info, i);
      string_buffer_Buf_add(out, ir_Type_str(t));
      string_buffer_Buf_space(out);
      string_buffer_Buf_color(out, ir_col_Temp);
      string_buffer_Buf_print(out, "%%%u", i);
      string_buffer_Buf_color(out, color_Normal);
   }
   string_buffer_Buf_add(out, ") {");
   string_buffer_Buf_add(out, "  ");
   string_buffer_Buf_color(out, ir_col_Comment);
   string_buffer_Buf_print(out, "# %u blocks, %u instr, %u slots", ir_BlockList_getCount(&info->blocks), ir_InstrList_getCount(&info->instructions), info->num_slots);
   string_buffer_Buf_newline(out);
   uint32_t num_blks = ir_BlockList_getCount(&info->blocks);
   ir_PrintHelper_collect_temps(ph);
   const ir_Block* blks = ir_BlockList_get(ph->blocks, 0);
   uint32_t last = 0;
   for (uint32_t i = 0; (i < num_blks); i++) {
      ph->cur_block = &blks[i];
      const ir_Block* b = ph->cur_block;
      string_buffer_Buf_color(out, color_Yellow);
      string_buffer_Buf_print(out, "%s.%u:", ir_Block_getKindName(b), i);
      if (!b->used) {
         string_buffer_Buf_color(out, color_Grey);
         string_buffer_Buf_add(out, " unused");
      }
      ir_Index i_idx = ir_Block_getInstructions(b);
      string_buffer_Buf_newline(out);
      ph->blk_instr_start = i_idx.start;
      ph->blk_instr_count = i_idx.count;
      const ir_Instr* instrs = ir_InstrList_get(&info->instructions, i_idx.start);
      for (uint32_t j = 0; (j < i_idx.count); j++) {
         ir_PrintHelper_printInstr(ph, instrs, j, (i_idx.start + j));
      }
      last = (i_idx.start + i_idx.count);
      ph->cur_block = NULL;
   }
   uint32_t instr_count = ir_InstrList_getCount(&info->instructions);
   if ((last != instr_count)) {
      string_buffer_Buf_color(out, ir_col_Fixup);
      string_buffer_Buf_print(out, "Inserted (%u)\n", (instr_count - last));
      const ir_Instr* instrs = ir_InstrList_get(&info->instructions, 0);
      while ((last != instr_count)) {
         ir_PrintHelper_printInstr(ph, instrs, last, last);
         last++;
      }
   }
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_add(out, "}\n\n");
}

static void ir_Context_print_function(const ir_Context* c, ir_SymbolId id, const ir_FunctionInfo* info)
{
   ir_PrintHelper ph; ir_PrintHelper_init(&ph, c);
   ir_PrintHelper_print_func(&ph, ir_SymbolList_get(&c->symbols, id), info);
   ir_PrintHelper_print(&ph);
   ir_PrintHelper_free(&ph);
}

static void ir_Context_print(const ir_Context* c)
{
   ir_PrintHelper ph; ir_PrintHelper_init(&ph, c);
   string_buffer_Buf* out = ph.out;
   _Bool prev_is_var = false;
   for (uint32_t i = 1; (i < ir_SymbolList_getCount(&c->symbols)); i++) {
      const ir_Symbol* s = ir_SymbolList_get(&c->symbols, i);
      if (s->is_function) {
         if (prev_is_var) string_buffer_Buf_newline(out);
         ir_PrintHelper_print_func(&ph, s, s->f.info);
      } else {
         if (s->is_external) {
            string_buffer_Buf_color(out, ir_col_Attr);
            string_buffer_Buf_add(out, "external ");
         }
         string_buffer_Buf_color(out, ir_col_Symbol);
         string_buffer_Buf_print(out, "%s", string_pool_Pool_idx2str(c->pool, s->name));
         string_buffer_Buf_space(out);
         string_buffer_Buf_color(out, ir_col_Value);
         string_buffer_Buf_print(out, "align %u ", s->align);
         const ir_InitValue* v = ir_InitValueList_get(&c->init_values, s->g.init_value_idx);
         if ((s->g.init_value_count == 1)) {
            ir_PrintHelper_printInitValue(&ph, v, out);
         } else {
            string_buffer_Buf_color(out, ir_col_Data);
            string_buffer_Buf_add(out, "[ ");
            for (uint32_t j = 0; (j < s->g.init_value_count); j++) {
               if ((j != 0)) string_buffer_Buf_add(out, ", ");
               ir_PrintHelper_printInitValue(&ph, &v[j], out);
            }
            string_buffer_Buf_color(out, ir_col_Data);
            string_buffer_Buf_add(out, " ]");
         }
         string_buffer_Buf_newline(out);
      }
      prev_is_var = !s->is_function;
   }
   ir_PrintHelper_print(&ph);
   ir_PrintHelper_free(&ph);
}

static void ir_PrintHelper_printInitValue(ir_PrintHelper* ph, const ir_InitValue* v, string_buffer_Buf* out)
{
   switch (ir_InitValue_getKind(v)) {
   case ir_InitValueKind_None:
      break;
   case ir_InitValueKind_Byte:
      string_buffer_Buf_color(out, ir_col_Data);
      string_buffer_Buf_print(out, "b %u", v->value);
      break;
   case ir_InitValueKind_Short:
      string_buffer_Buf_color(out, ir_col_Data);
      string_buffer_Buf_print(out, "s %u", v->value);
      break;
   case ir_InitValueKind_Word:
      string_buffer_Buf_color(out, ir_col_Data);
      string_buffer_Buf_print(out, "w %u", v->value);
      break;
   case ir_InitValueKind_Word2: {
      string_buffer_Buf_color(out, ir_col_Data);
      const ir_Constant* con = ir_ConstantList_get(&ph->c->constants, v->value);
      string_buffer_Buf_print(out, "w %lu", con->uvalue);
      break;
   }
   case ir_InitValueKind_Long:
      string_buffer_Buf_color(out, ir_col_Data);
      string_buffer_Buf_print(out, "l %u", v->value);
      break;
   case ir_InitValueKind_Long2: {
      const ir_Constant* con = ir_ConstantList_get(&ph->c->constants, v->value);
      string_buffer_Buf_print(out, "l %lu", con->uvalue);
      break;
   }
   case ir_InitValueKind_Symbol: {
      const ir_Symbol* g = ir_SymbolList_get(&ph->c->symbols, v->value);
      string_buffer_Buf_color(out, ir_col_Symbol);
      string_buffer_Buf_print(out, "@%s", string_pool_Pool_idx2str(ph->c->pool, g->name));
      break;
   }
   case ir_InitValueKind_Text: {
      string_buffer_Buf_color(out, ir_col_Data);
      const char* text = string_pool_Pool_idx2str(ph->c->pool, v->value);
      string_buffer_Buf_add1(out, '"');
      string_buffer_Buf_encodeBytes(out, text, (((uint32_t)(strlen(text))) + 1), '"');
      string_buffer_Buf_add1(out, '"');
      break;
   }
   case ir_InitValueKind_Zero:
      string_buffer_Buf_color(out, ir_col_Data);
      string_buffer_Buf_print(out, "z %u", v->value);
      break;
   }
}

static void ir_PrintHelper_printInstr(ir_PrintHelper* ph, const ir_Instr* blk_instrs, uint32_t blk_instr_idx, uint32_t gbl_idx)
{
   const ir_Instr* i = &blk_instrs[blk_instr_idx];
   string_buffer_Buf* out = ph->out;
   ir_InstrKind k = ir_Instr_getKind(i);
   if ((ir_Instr_getKind(i) == ir_InstrKind_Comment)) {
      string_buffer_Buf_resetToLastNewline(out);
      string_buffer_Buf_add(out, "   ");
      string_buffer_Buf_color(out, ir_col_Comment);
      string_buffer_Buf_add(out, "# ");
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(ph->c->pool, i->args[0].value));
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_newline(out);
      return;
   }
   string_buffer_Buf_color(out, ir_col_Comment);
   string_buffer_Buf_print(out, "%-3u", gbl_idx);
   string_buffer_Buf_indent(out, 2);
   if (ir_Instr_hasResult(i)) {
      string_buffer_Buf_color(out, ir_col_Temp);
      uint32_t temp_nr = ir_PrintHelper_findTemp(ph, (ph->blk_instr_start + blk_instr_idx));
      string_buffer_Buf_print(out, "%%%u", temp_nr);
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_add(out, " = ");
   }
   if (ir_Instr_isPseudo(i)) {
      string_buffer_Buf_color(out, ir_col_PseudoInstr);
   } else {
      string_buffer_Buf_color(out, ir_col_Instr);
   }
   string_buffer_Buf_add(out, ir_Instr_getKindName(i));
   switch (ir_Instr_getKind(i)) {
   case ir_InstrKind_Call:
      string_buffer_Buf_space(out);
      ir_PrintHelper_printRef(ph, i->args[0], false);
      string_buffer_Buf_add(out, " (");
      if ((i->args[1].kind != ir_RefKind_None)) {
         ir_PrintHelper_printRef(ph, i->args[1], false);
      }
      string_buffer_Buf_add1(out, ')');
      break;
   case ir_InstrKind_Switch: {
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_space(out);
      ir_PrintHelper_printRef(ph, i->args[0], false);
      string_buffer_Buf_add(out, " [\n");
      ir_CaseId case_id = ph->cur_block->dests[0];
      uint32_t num_cases = ph->cur_block->dests[1];
      for (uint32_t j = 0; (j < num_cases); j++) {
         ir_Case* cc = ir_CaseList_get(&ph->cur_info->cases, (case_id + j));
         string_buffer_Buf_indent(out, 3);
         string_buffer_Buf_color(out, ir_col_Value);
         string_buffer_Buf_print(out, "%u", cc->value);
         string_buffer_Buf_space(out);
         string_buffer_Buf_color(out, ir_col_Block);
         ir_Block* dest = ir_BlockList_get(ph->blocks, cc->block);
         string_buffer_Buf_print(out, "@%s.%u", ir_Block_getKindName(dest), cc->block);
         string_buffer_Buf_color(out, color_Normal);
         string_buffer_Buf_newline(out);
      }
      string_buffer_Buf_indent(out, 2);
      string_buffer_Buf_add1(out, ']');
      break;
   }
   case ir_InstrKind_Phi: {
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_add(out, " [ ");
      const ir_PhiClause* clauses = ir_PhiList_get(&ph->cur_info->phis, i->phi_clauses.start);
      for (uint32_t j = 0; (j < i->phi_clauses.count); j++) {
         if ((j != 0)) string_buffer_Buf_add(out, ", ");
         uint32_t blk_id = clauses[j].src;
         ir_Block* src = ir_BlockList_get(ph->blocks, blk_id);
         string_buffer_Buf_color(out, ir_col_Block);
         string_buffer_Buf_print(out, "@%s.%u", ir_Block_getKindName(src), blk_id);
         string_buffer_Buf_color(out, color_Normal);
         string_buffer_Buf_add(out, ": ");
         ir_PrintHelper_printRef(ph, clauses[j].ref, false);
      }
      string_buffer_Buf_add(out, " ]");
      break;
   }
   default:
      for (uint32_t r = 0; (r < 2); r++) {
         if (ir_Ref_isValid(&i->args[r])) {
            if ((r > 0)) string_buffer_Buf_add1(out, ',');
            string_buffer_Buf_space(out);
            ir_PrintHelper_printRef(ph, i->args[r], false);
         }
      }
      break;
   }
   string_buffer_Buf_newline(out);
}

static void ir_PrintHelper_printRef(ir_PrintHelper* ph, ir_Ref r, _Bool print_type)
{
   string_buffer_Buf* out = ph->out;
   switch (ir_Ref_getKind(&r)) {
   case ir_RefKind_None:
      string_buffer_Buf_add(out, "(none)");
      break;
   case ir_RefKind_Slot:
      string_buffer_Buf_color(out, ir_col_Slot);
      string_buffer_Buf_print(out, "s%u", r.value);
      break;
   case ir_RefKind_Temp:
      string_buffer_Buf_color(out, ir_col_Temp);
      string_buffer_Buf_print(out, "%%%u", ir_PrintHelper_findTemp(ph, r.value));
      break;
   case ir_RefKind_Param:
      string_buffer_Buf_color(out, ir_col_Temp);
      string_buffer_Buf_print(out, "%%%u", r.value);
      break;
   case ir_RefKind_JmpDest: {
      const ir_Block* b = ph->cur_block;
      string_buffer_Buf_color(out, ir_col_Block);
      (b->dests[0]) || c2_assert("ir/print.c2", 456, "ir.PrintHelper.printRef", "b.dests[0]");
      ir_Block* dest = ir_BlockList_get(ph->blocks, b->dests[0]);
      string_buffer_Buf_print(out, "@%s.%u", ir_Block_getKindName(dest), b->dests[0]);
      if (b->dests[1]) {
         string_buffer_Buf_add(out, ", ");
         dest = ir_BlockList_get(ph->blocks, b->dests[1]);
         string_buffer_Buf_print(out, "@%s.%u", ir_Block_getKindName(dest), b->dests[1]);
      }
      break;
   }
   case ir_RefKind_RefList: {
      const ir_Ref* refs = ir_RefList_get(&ph->cur_info->refs, r.value);
      uint32_t i = 0;
      while ((refs[i].kind != ir_RefKind_None)) {
         if ((i != 0)) string_buffer_Buf_add(out, ", ");
         ir_PrintHelper_printRef(ph, refs[i], false);
         i++;
      }
      break;
   }
   case ir_RefKind_Symbol: {
      const ir_Symbol* g = ir_SymbolList_get(&ph->c->symbols, r.value);
      string_buffer_Buf_color(out, ir_col_Symbol);
      string_buffer_Buf_print(out, "@%s", string_pool_Pool_idx2str(ph->c->pool, g->name));
      break;
   }
   case ir_RefKind_Value:
      string_buffer_Buf_color(out, ir_col_Value);
      string_buffer_Buf_print(out, "%u", r.value);
      break;
   case ir_RefKind_Integer: {
      string_buffer_Buf_color(out, ir_col_Value);
      const ir_Constant* con = ir_ConstantList_get(&ph->c->constants, r.value);
      string_buffer_Buf_print(out, "%ld", con->ivalue);
      break;
   }
   case ir_RefKind_Float:
      break;
   case ir_RefKind_Double:
      break;
   case ir_RefKind_Text:
      string_buffer_Buf_color(out, ir_col_Block);
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(ph->c->pool, r.value));
      break;
   }
   string_buffer_Buf_color(out, color_Normal);
}

static void ir_Context_dump_function(const ir_Context* c, const ir_FunctionInfo* info, const char* name)
{
   string_buffer_Buf* out = string_buffer_create((16 * 1024), false, 1);
   string_buffer_Buf_print(out, "function %s:\n", name);
   ir_dump_function_info(out, info);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ir_dump_function_info(string_buffer_Buf* out, const ir_FunctionInfo* info)
{
   string_buffer_Buf_add(out, "  blocks:\n");
   for (uint32_t j = 0; (j < ir_BlockList_getCount(&info->blocks)); j++) {
      const ir_Block* b = ir_BlockList_get(&info->blocks, j);
      ir_Index b_idx = ir_Block_getInstructions(b);
      string_buffer_Buf_print(out, "    [%3u] %14s  D %u|%u  I %u-%u", j, ir_Block_getKindName(b), b->dests[0], b->dests[1], b_idx.start, ((b_idx.start + b_idx.count) - 1));
      if (b->used) string_buffer_Buf_add(out, " unused");
      if (b->end_with_switch) string_buffer_Buf_add(out, " switch");
      if (b->end_block) string_buffer_Buf_add(out, " end");
      if (b->phi_source) string_buffer_Buf_add(out, " phi-src");
      string_buffer_Buf_newline(out);
   }
   string_buffer_Buf_print(out, "  instructions: %u\n", ir_InstrList_getCount(&info->instructions));
   const ir_Instr* instr = ir_InstrList_get(&info->instructions, 0);
   for (uint32_t i = 0; (i < ir_InstrList_getCount(&info->instructions)); i++) {
      const ir_Instr* r = &instr[i];
      string_buffer_Buf_print(out, "    [%3u] %7s", i, ir_Instr_getKindName(r));
      if (ir_Instr_isPhi(r)) {
         string_buffer_Buf_print(out, "  clauses: start %u  count %u", r->phi_clauses.start, r->phi_clauses.count);
      } else {
         string_buffer_Buf_print(out, "  %8s %3u  ", ir_Ref_getKindName(&r->args[0]), r->args[0].value);
         string_buffer_Buf_print(out, "  %8s %3u", ir_Ref_getKindName(&r->args[01]), r->args[1].value);
      }
      string_buffer_Buf_newline(out);
   }
   uint32_t num_refs = ir_RefList_getCount(&info->refs);
   if (num_refs) {
      string_buffer_Buf_print(out, " refs: (%u)\n", ir_RefList_getCount(&info->refs));
      const ir_Ref* refs = ir_RefList_get(&info->refs, 0);
      for (uint32_t i = 0; (i < ir_RefList_getCount(&info->refs)); i++) {
         ir_Ref r = refs[i];
         string_buffer_Buf_print(out, "    [%2u] %8s  %u\n", i, ir_Ref_getKindName(&r), r.value);
      }
   }
   uint32_t num_cases = ir_CaseList_getCount(&info->cases);
   if (num_cases) {
      string_buffer_Buf_print(out, " cases: (%u)\n", num_cases);
      const ir_Case* cases = ir_CaseList_get(&info->cases, 0);
      for (uint32_t i = 0; (i < num_cases); i++) {
         const ir_Case* c = &cases[i];
         string_buffer_Buf_print(out, "    [%2u] %u   blk %u\n", i, c->value, c->block);
      }
   }
   uint32_t num_clauses = ir_PhiList_getCount(&info->phis);
   if (num_clauses) {
      string_buffer_Buf_print(out, " phi clauses: (%u)\n", num_clauses);
      for (uint32_t i = 0; (i < num_clauses); i++) {
         ir_PhiClause* pc = ir_PhiList_get(&info->phis, i);
         string_buffer_Buf_print(out, "    [%2u] ref %8s %u   blk %u\n", i, ir_Ref_getKindName(&pc->ref), pc->ref.value, pc->src);
      }
   }
   string_buffer_Buf_newline(out);
}

static void ir_Context_dump(const ir_Context* c)
{
   string_buffer_Buf* out = string_buffer_create((16 * 1024), false, 1);
   string_buffer_Buf_print(out, "symbols: (%u)\n", ir_SymbolList_getCount(&c->symbols));
   for (uint32_t i = 1; (i < ir_SymbolList_getCount(&c->symbols)); i++) {
      const ir_Symbol* s = ir_SymbolList_get(&c->symbols, i);
      string_buffer_Buf_print(out, "  [%2u] %s", i, string_pool_Pool_idx2str(c->pool, s->name));
      if (s->is_function) {
         if (s->f.info) ir_dump_function_info(out, s->f.info);
      } else {
         uint32_t init_value_idx;
         uint32_t init_value_count;
         string_buffer_Buf_print(out, "  init_value %u-%u", s->g.init_value_idx, ((s->g.init_value_idx + s->g.init_value_count) - 1));
      }
      string_buffer_Buf_newline(out);
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_print(out, "constants: (%u)\n", ir_ConstantList_getCount(&c->constants));
   for (uint32_t i = 0; (i < ir_ConstantList_getCount(&c->constants)); i++) {
      const ir_Constant* con = ir_ConstantList_get(&c->constants, i);
      string_buffer_Buf_print(out, "  [%2u] %ld\n", i, con->ivalue);
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_print(out, "init values: (%u)\n", ir_InitValueList_getCount(&c->init_values));
   for (uint32_t i = 0; (i < ir_InitValueList_getCount(&c->init_values)); i++) {
      const ir_InitValue* v = ir_InitValueList_get(&c->init_values, i);
      string_buffer_Buf_print(out, "  [%2u] %6s  %u\n", i, ir_InitValue_getKindName(v), v->value);
   }
   string_buffer_Buf_newline(out);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ir_Context_report(const ir_Context* c)
{
   string_buffer_Buf* out = string_buffer_create(256, false, 1);
   uint32_t total_blocks = 0;
   uint32_t total_instr = 0;
   uint32_t total_refs = 0;
   uint32_t total_functions = 0;
   uint32_t total_globals = 0;
   for (uint32_t i = 1; (i < ir_SymbolList_getCount(&c->symbols)); i++) {
      const ir_Symbol* s = ir_SymbolList_get(&c->symbols, i);
      if (s->is_function) {
         total_functions++;
         if (s->f.info) {
            total_blocks += ir_BlockList_getCount(&s->f.info->blocks);
            total_instr += ir_InstrList_getCount(&s->f.info->instructions);
            total_refs += ir_RefList_getCount(&s->f.info->refs);
         } else {
            string_buffer_Buf_print(out, "NO INFO: %s\n", string_pool_Pool_idx2str(c->pool, s->name));
         }
      } else {
         total_globals++;
      }
   }
   string_buffer_Buf_print(out, "IR: %u symbols (%u globals, %u funcs), %u refs, %u const, %u blocks, %u instr, %u values\n", c->symbols.count, total_globals, total_functions, total_refs, c->constants.count, total_blocks, total_instr, ir_InitValueList_getCount(&c->init_values));
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void ir_Ref_init(ir_Ref* r, ir_RefKind kind, uint32_t value)
{
   r->kind = kind;
   r->value = value;
}

static _Bool ir_Ref_equals(const ir_Ref* r1, ir_Ref r2)
{
   if ((r1->value != r2.value)) return false;

   return (r1->kind == r2.kind);
}

static ir_RefKind ir_Ref_getKind(const ir_Ref* r)
{
   return ((ir_RefKind)(r->kind));
}

static _Bool ir_Ref_isValid(const ir_Ref* r)
{
   return (r->kind != ir_RefKind_None);
}

static _Bool ir_Ref_isTemp(const ir_Ref* r)
{
   return (r->kind == ir_RefKind_Temp);
}

static _Bool ir_Ref_isSlot(const ir_Ref* r)
{
   return (r->kind == ir_RefKind_Slot);
}

static _Bool ir_Ref_isRefList(const ir_Ref* r)
{
   return (r->kind == ir_RefKind_RefList);
}

static const char* ir_Ref_getKindName(const ir_Ref* r)
{
   switch (ir_Ref_getKind(r)) {
   case ir_RefKind_None:
      return "none";
   case ir_RefKind_Slot:
      return "slot";
   case ir_RefKind_Temp:
      return "temp";
   case ir_RefKind_Param:
      return "param";
   case ir_RefKind_JmpDest:
      return "jmp_dest";
   case ir_RefKind_RefList:
      return "ref_list";
   case ir_RefKind_Symbol:
      return "symbol";
   case ir_RefKind_Value:
      return "value";
   case ir_RefKind_Integer:
      return "integer";
   case ir_RefKind_Float:
      return "float";
   case ir_RefKind_Double:
      return "double";
   case ir_RefKind_Text:
      return "text";
   }
   return "?";
}

static void ir_RefList_init(ir_RefList* l, uint32_t initial_size)
{
   memset(l, 0, 16);
   if (initial_size) ir_RefList_resize(l, initial_size);
}

static void ir_RefList_free(ir_RefList* l)
{
   if (l->refs) free(((void*)(l->refs)));
}

static void ir_RefList_resize(ir_RefList* l, uint32_t cap)
{
   l->capacity = cap;
   ir_Ref* refs2 = calloc(l->capacity, 4);
   if ((l->count != 0)) memcpy(refs2, l->refs, (l->count * 4));
   if (l->refs) free(l->refs);
   l->refs = refs2;
}

static void ir_RefList_add(ir_RefList* l, ir_Ref ref)
{
   if ((l->count == l->capacity)) ir_RefList_resize(l, l->capacity ? (l->capacity * 2) : 4);
   l->refs[l->count] = ref;
   l->count++;
}

static uint32_t ir_RefList_addList(ir_RefList* l, const ir_RefList* l2)
{
   uint32_t start = l->count;
   if ((l->capacity < (l->count + l2->count))) ir_RefList_resize(l, (l->count + l2->count));
   memcpy(&l->refs[l->count], l2->refs, (l2->count * 4));
   l->count += l2->count;
   return start;
}

static void ir_RefList_copy(ir_RefList* l, const ir_RefList* l2)
{
   if ((l->capacity < l2->count)) ir_RefList_resize(l, l2->count);
   l->count = l2->count;
   memcpy(l->refs, l2->refs, (l2->count * 4));
}

static void ir_RefList_clear(ir_RefList* l)
{
   l->count = 0;
}

static uint32_t ir_RefList_getCount(const ir_RefList* l)
{
   return l->count;
}

static ir_Ref* ir_RefList_get(const ir_RefList* l, uint32_t idx)
{
   return &l->refs[idx];
}

static const char* ir_Type_str(ir_Type t)
{
   switch (t) {
   case ir_Type_None:
      return "none";
   case ir_Type_I8:
      return "i8";
   case ir_Type_I16:
      return "i16";
   case ir_Type_I32:
      return "i32";
   case ir_Type_I64:
      return "i64";
   case ir_Type_U8:
      return "u8";
   case ir_Type_U16:
      return "u16";
   case ir_Type_U32:
      return "u32";
   case ir_Type_U64:
      return "u64";
   case ir_Type_F32:
      return "f32";
   case ir_Type_F64:
      return "f64";
   }
   return "";
}


// --- module attr_handler ---
typedef struct attr_handler_Entry_ attr_handler_Entry;
typedef struct attr_handler_Handler_ attr_handler_Handler;

struct attr_handler_Entry_ {
   uint32_t name;
   ast_AttrHandlerFn func;
   void* arg;
};

struct attr_handler_Handler_ {
   diagnostics_Diags* diags;
   attr_handler_Entry* entries;
   uint32_t count;
   uint32_t capacity;
};

static attr_handler_Handler* attr_handler_create(diagnostics_Diags* diags);
static void attr_handler_Handler_free(attr_handler_Handler* h);
static _Bool attr_handler_Handler_register(attr_handler_Handler* h, uint32_t name, ast_AttrHandlerFn func, void* arg);
static _Bool attr_handler_Handler_handle(attr_handler_Handler* h, ast_Decl* d, const attr_Attr* a);

static attr_handler_Handler* attr_handler_create(diagnostics_Diags* diags)
{
   attr_handler_Handler* h = calloc(1, 24);
   h->diags = diags;
   return h;
}

static void attr_handler_Handler_free(attr_handler_Handler* h)
{
   if (h->entries) free(h->entries);
   free(h);
}

static _Bool attr_handler_Handler_register(attr_handler_Handler* h, uint32_t name, ast_AttrHandlerFn func, void* arg)
{
   if ((h->count == h->capacity)) {
      h->capacity += 2;
      attr_handler_Entry* entries2 = malloc((h->capacity * 24));
      if (h->count) {
         memcpy(entries2, h->entries, (h->count * 24));
         free(h->entries);
      }
      h->entries = entries2;
   }
   attr_handler_Entry* e = &h->entries[h->count];
   e->name = name;
   e->func = func;
   e->arg = arg;
   h->count++;
   return true;
}

static _Bool attr_handler_Handler_handle(attr_handler_Handler* h, ast_Decl* d, const attr_Attr* a)
{
   for (uint32_t i = 0; (i < h->count); i++) {
      attr_handler_Entry* e = &h->entries[i];
      if ((e->name == a->name)) return e->func(e->arg, d, a);

   }
   diagnostics_Diags_error(h->diags, a->loc, "unknown attribute '%s'", ast_idx2name(a->name));
   return false;
}


// --- module component ---
typedef struct component_Component_ component_Component;
typedef struct component_List_ component_List;

typedef enum {
   component_Kind_Internal,
   component_Kind_Image,
   component_Kind_Executable,
   component_Kind_StaticLibrary,
   component_Kind_DynamicLibrary,
   component_Kind_ExternalStatic,
   component_Kind_ExternalDynamic,
   _component_Kind_max = 255
} __attribute__((packed)) component_Kind;

struct component_Component_ {
   uint32_t name_idx;
   uint32_t dirname_idx;
   uint32_t linkname;
   component_Kind kind;
   _Bool is_direct;
   _Bool available_static;
   _Bool available_dynamic;
   ast_context_Context* context;
   string_pool_Pool* auxPool;
   module_list_List* allmodules;
   module_list_List mods;
   string_list_List deps;
};

struct component_List_ {
   component_Component** components;
   uint32_t count;
   uint32_t capacity;
};

static const char* component_kind_names[7] = {
   "internal",
   "image",
   "executable",
   "static library",
   "dynamic library",
   "external static library",
   "external dynamic library"
};

static component_Component* component_create(ast_context_Context* context, string_pool_Pool* auxPool, module_list_List* allmodules, uint32_t name_idx, component_Kind kind, _Bool is_direct);
static void component_Component_free(component_Component* c);
static const char* component_Component_getName(const component_Component* c);
static uint32_t component_Component_getNameIdx(const component_Component* c);
static void component_Component_setPath(component_Component* c, uint32_t dirname);
static const char* component_Component_getPath(const component_Component* c);
static void component_Component_setLinkName(component_Component* c, const char* name);
static const char* component_Component_getLinkName(const component_Component* c);
static _Bool component_Component_isExternal(const component_Component* c);
static _Bool component_Component_isInternal(const component_Component* c);
static void component_Component_setKind(component_Component* c, _Bool is_static, _Bool is_dynamic);
static _Bool component_Component_isStaticLib(const component_Component* c);
static _Bool component_Component_isAvailableStatic(const component_Component* c);
static _Bool component_Component_isAvailableDynamic(const component_Component* c);
static void component_Component_visitModules(const component_Component* c, module_list_Visitor visitor, void* arg);
static module_list_List* component_Component_getModules(component_Component* c);
static ast_Module* component_Component_getOrAddModule(component_Component* c, uint32_t name_idx);
static ast_Module* component_Component_createModule(component_Component* c, uint32_t name_idx);
static _Bool component_Component_hasModule(const component_Component* c, const ast_Module* mod);
static void component_Component_print(const component_Component* c, _Bool show_funcs);
static void component_Component_printModules(const component_Component* c);
static void component_Component_printSymbols(const component_Component* c, _Bool print_external);
static void component_Component_addDep(component_Component* c, const char* dep);
static string_list_List* component_Component_getDeps(component_Component* c);
static void component_List_init(component_List* l);
static void component_List_free(component_List* l);
static void component_List_resize(component_List* l, uint32_t capacity);
static void component_List_add(component_List* l, component_Component* c);
static uint32_t component_List_size(const component_List* l);
static component_Component* component_List_get(component_List* l, uint32_t idx);
static component_Component** component_List_get_all(component_List* l);
static component_Component* component_List_getLast(component_List* l);
static _Bool component_Component_isLibrary(const component_Component* c);
static component_Kind component_Component_getKind(const component_Component* c);

static component_Component* component_create(ast_context_Context* context, string_pool_Pool* auxPool, module_list_List* allmodules, uint32_t name_idx, component_Kind kind, _Bool is_direct)
{
   component_Component* c = calloc(1, 88);
   c->name_idx = name_idx;
   c->kind = kind;
   c->is_direct = is_direct;
   c->context = context;
   c->auxPool = auxPool;
   c->allmodules = allmodules;
   module_list_List_init(&c->mods, true, 4);
   string_list_List_init(&c->deps, auxPool);
   return c;
}

static void component_Component_free(component_Component* c)
{
   module_list_List_free(&c->mods);
   string_list_List_free(&c->deps);
   free(c);
}

static const char* component_Component_getName(const component_Component* c)
{
   return string_pool_Pool_idx2str(c->auxPool, c->name_idx);
}

static uint32_t component_Component_getNameIdx(const component_Component* c)
{
   return c->name_idx;
}

static void component_Component_setPath(component_Component* c, uint32_t dirname)
{
   c->dirname_idx = dirname;
}

static const char* component_Component_getPath(const component_Component* c)
{
   return string_pool_Pool_idx2str(c->auxPool, c->dirname_idx);
}

static void component_Component_setLinkName(component_Component* c, const char* name)
{
   c->linkname = string_pool_Pool_addStr(c->auxPool, name, false);
}

static const char* component_Component_getLinkName(const component_Component* c)
{
   if (c->linkname) return string_pool_Pool_idx2str(c->auxPool, c->linkname);

   return NULL;
}

static _Bool component_Component_isExternal(const component_Component* c)
{
   return (c->kind >= component_Kind_ExternalStatic);
}

static _Bool component_Component_isInternal(const component_Component* c)
{
   return (c->kind == component_Kind_Internal);
}

static void component_Component_setKind(component_Component* c, _Bool is_static, _Bool is_dynamic)
{
   c->available_static = is_static;
   c->available_dynamic = is_dynamic;
}

static _Bool component_Component_isStaticLib(const component_Component* c)
{
   return ((c->kind == component_Kind_StaticLibrary) || (c->kind == component_Kind_ExternalStatic));
}

static _Bool component_Component_isAvailableStatic(const component_Component* c)
{
   return c->available_static;
}

static _Bool component_Component_isAvailableDynamic(const component_Component* c)
{
   return c->available_dynamic;
}

static void component_Component_visitModules(const component_Component* c, module_list_Visitor visitor, void* arg)
{
   module_list_List_visit(&c->mods, visitor, arg);
}

static module_list_List* component_Component_getModules(component_Component* c)
{
   return &c->mods;
}

static ast_Module* component_Component_getOrAddModule(component_Component* c, uint32_t name_idx)
{
   ast_Module* m = module_list_List_find(&c->mods, name_idx);
   if (m) return m;

   return component_Component_createModule(c, name_idx);
}

static ast_Module* component_Component_createModule(component_Component* c, uint32_t name_idx)
{
   ast_Module* m = module_list_List_find(c->allmodules, name_idx);
   if (m) return NULL;

   m = ast_Module_create(c->context, name_idx, component_Component_isExternal(c), c->is_direct);
   module_list_List_add(&c->mods, m);
   module_list_List_add(c->allmodules, m);
   return m;
}

static _Bool component_Component_hasModule(const component_Component* c, const ast_Module* mod)
{
   return module_list_List_contains(&c->mods, mod);
}

static void component_Component_print(const component_Component* c, _Bool show_funcs)
{
   string_buffer_Buf* out = string_buffer_create((128 * 1024), color_useColor(), 1);
   const ast_Module** mods = module_list_List_getConst(&c->mods);
   for (uint32_t i = 0; (i < module_list_List_length(&c->mods)); i++) {
      ast_Module_print(mods[i], out, show_funcs);
   }
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void component_Component_printModules(const component_Component* c)
{
   string_buffer_Buf* out = string_buffer_create(4096, color_useColor(), 1);
   string_buffer_Buf_print(out, "--- %s [%s]", component_Component_getName(c), component_kind_names[c->kind]);
   if (!c->is_direct) string_buffer_Buf_add(out, " (indirect)");
   string_buffer_Buf_add(out, " ---\n");
   const ast_Module** mods = module_list_List_getConst(&c->mods);
   for (uint32_t i = 0; (i < module_list_List_length(&c->mods)); i++) {
      const ast_Module* m = mods[i];
      const char* col = ast_Module_isUsed(m) ? color_Normal : color_Grey;
      string_buffer_Buf_color(out, col);
      string_buffer_Buf_print(out, "   %s\n", ast_Module_getName(m));
   }
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void component_Component_printSymbols(const component_Component* c, _Bool print_external)
{
   if ((component_Component_isExternal(c) != print_external)) return;

   string_buffer_Buf* out = string_buffer_create(4096, color_useColor(), 1);
   string_buffer_Buf_print(out, "--- %s [%s] ---\n", component_Component_getName(c), component_kind_names[c->kind]);
   const ast_Module** mods = module_list_List_getConst(&c->mods);
   for (uint32_t i = 0; (i < module_list_List_length(&c->mods)); i++) {
      string_buffer_Buf_color(out, color_Cyan);
      string_buffer_Buf_print(out, "  %s\n", ast_Module_getName(mods[i]));
      const ast_SymbolTable* table = ast_Module_getSymbols(mods[i]);
      ast_SymbolTable_print(table, out);
   }
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void component_Component_addDep(component_Component* c, const char* dep)
{
   uint32_t dep_idx = string_pool_Pool_addStr(c->auxPool, dep, true);
   string_list_List_add(&c->deps, dep_idx);
}

static string_list_List* component_Component_getDeps(component_Component* c)
{
   return &c->deps;
}

static void component_List_init(component_List* l)
{
   l->components = NULL;
   l->count = 0;
   component_List_resize(l, 4);
}

static void component_List_free(component_List* l)
{
   for (uint32_t i = 0; (i < l->count); i++) {
      component_Component_free(l->components[i]);
   }
   free(l->components);
}

static void component_List_resize(component_List* l, uint32_t capacity)
{
   l->capacity = capacity;
   component_Component** comps2 = malloc((l->capacity * 8));
   if (l->count) {
      memcpy(comps2, l->components, (l->count * 8));
      free(l->components);
   }
   l->components = comps2;
}

static void component_List_add(component_List* l, component_Component* c)
{
   if ((l->count == l->capacity)) component_List_resize(l, (l->capacity * 2));
   l->components[l->count] = c;
   l->count++;
}

static uint32_t component_List_size(const component_List* l)
{
   return l->count;
}

static component_Component* component_List_get(component_List* l, uint32_t idx)
{
   return l->components[idx];
}

static component_Component** component_List_get_all(component_List* l)
{
   return l->components;
}

static component_Component* component_List_getLast(component_List* l)
{
   if ((l->count == 0)) return NULL;

   return l->components[(l->count - 1)];
}

static _Bool component_Component_isLibrary(const component_Component* c)
{
   return ((c->kind == component_Kind_StaticLibrary) || (c->kind == component_Kind_DynamicLibrary));
}

static component_Kind component_Component_getKind(const component_Component* c)
{
   return c->kind;
}


// --- module component_sorter ---

static uint32_t component_sorter_find_idx(component_Component** comps, uint32_t count, uint32_t name);
static void component_sorter_sort(component_Component** orig, uint32_t count, diagnostics_Diags* diags);

static uint32_t component_sorter_find_idx(component_Component** comps, uint32_t count, uint32_t name)
{
   for (uint32_t i = 0; (i < count); i++) {
      if ((component_Component_getNameIdx(comps[i]) == name)) return i;

   }
   (0) || c2_assert("common/component_sorter.c2", 30, "component_sorter.find_idx", "0");
   return 0;
}

static void component_sorter_sort(component_Component** orig, uint32_t count, diagnostics_Diags* diags)
{
   if ((count <= 1)) return;

   dsm_sorter_Sorter dsm; dsm_sorter_Sorter_init(&dsm, count);
   for (uint32_t i = 0; (i < count); i++) {
      component_Component* c = orig[i];
      const string_list_List* deps = component_Component_getDeps(c);
      for (uint32_t j = 0; (j < string_list_List_length(deps)); j++) {
         uint32_t dest_name = string_list_List_get_idx(deps, j);
         uint32_t dest_idx = component_sorter_find_idx(orig, count, dest_name);
         dsm_sorter_Sorter_add_dep(&dsm, i, dest_idx);
      }
   }
   const uint8_t* sorted = dsm_sorter_Sorter_sort(&dsm);
   if (!sorted) {
      diagnostics_Diags_error(diags, 0, "circular dependency between libraries");
      exit(-1);
   }
   component_Component** copy = malloc((count * 8));
   memcpy(copy, orig, (count * 8));
   for (uint32_t i = 0; (i < count); i++) orig[i] = copy[sorted[i]];
   free(copy);
   dsm_sorter_Sorter_free(&dsm);
}


// --- module manifest_writer ---

static const char* manifest_writer_getKindStr(const component_Component* c);
static void manifest_writer_on_module(void* arg, ast_Module* m);
static void manifest_writer_write(const char* dir, component_Component* c, const char* filename);

static const char* manifest_writer_getKindStr(const component_Component* c)
{
   switch (component_Component_getKind(c)) {
   case component_Kind_Internal:
      fallthrough;
   case component_Kind_Image:
      (0) || c2_assert("common/manifest_writer.c2", 33, "manifest_writer.getKindStr", "0");
      break;
   case component_Kind_Executable:
      (0) || c2_assert("common/manifest_writer.c2", 36, "manifest_writer.getKindStr", "0");
      break;
   case component_Kind_StaticLibrary:
      return "static";
   case component_Kind_DynamicLibrary:
      return "dynamic";
   case component_Kind_ExternalStatic:
      fallthrough;
   case component_Kind_ExternalDynamic:
      (0) || c2_assert("common/manifest_writer.c2", 42, "manifest_writer.getKindStr", "0");
      break;
   }
   return "";
}

static void manifest_writer_on_module(void* arg, ast_Module* m)
{
   if (!ast_Module_isExported(m)) return;

   string_buffer_Buf* out = arg;
   string_buffer_Buf_print(out, "    - %s\n", ast_Module_getName(m));
}

static void manifest_writer_write(const char* dir, component_Component* c, const char* filename)
{
   string_buffer_Buf* out = string_buffer_create(4096, false, 2);
   string_buffer_Buf_print(out, "# Generated by C2C\n\ninfo:\n    language: C2\n    type: library\n    linkname: %s\n    kinds:\n        - %s\n\n", component_Component_getName(c), manifest_writer_getKindStr(c));
   const string_list_List* deps = component_Component_getDeps(c);
   for (uint32_t i = 0; (i < string_list_List_length(deps)); i++) {
      string_buffer_Buf_print(out, "dependencies:\n    %s: dynamic\n", string_list_List_get(deps, i));
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_add(out, "modules:\n");
   component_Component_visitModules(c, manifest_writer_on_module, out);
   char fullname[512];
   snprintf(fullname, 512, "%s/%s", dir, filename);
   file_utils_Writer writer;
   if (!file_utils_Writer_write(&writer, fullname, string_buffer_Buf_data(out), string_buffer_Buf_size(out))) {
      console_error("cannot write to %s: %s", fullname, file_utils_Writer_getError(&writer));
      exit(EXIT_FAILURE);
   }
   string_buffer_Buf_free(out);
}


// --- module ast_builder ---
typedef struct ast_builder_Builder_ ast_builder_Builder;

struct ast_builder_Builder_ {
   ast_context_Context* context;
   diagnostics_Diags* diags;
   string_pool_Pool* auxPool;
   component_Component* comp;
   ast_Module* mod;
   ast_AST* ast;
   uint32_t ast_idx;
   uint32_t c2_name;
   uint32_t main_name;
   _Bool is_interface;
   attr_Attr attrs[8];
   uint32_t num_attrs;
   attr_handler_Handler* attr_handler;
};

static ast_builder_Builder* ast_builder_create(ast_context_Context* context, diagnostics_Diags* diags, string_pool_Pool* auxPool, uint32_t c2_name, uint32_t main_name, attr_handler_Handler* attr_handler_);
static void ast_builder_Builder_free(ast_builder_Builder* b);
static void ast_builder_Builder_setComponent(ast_builder_Builder* b, component_Component* comp);
static void ast_builder_Builder_actOnModule(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t filename, _Bool is_generated);
static void ast_builder_Builder_actOnImport(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, _Bool islocal);
static ast_Decl* ast_builder_Builder_actOnAliasType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref);
static ast_Decl* ast_builder_Builder_actOnFunctionTypeDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* rtype, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic);
static ast_StructTypeDecl* ast_builder_Builder_actOnStructType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, _Bool is_struct, _Bool is_global, ast_Decl** members, uint32_t num_members);
static ast_VarDecl* ast_builder_Builder_actOnStructMember(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref, ast_Expr* bitfield);
static ast_Decl* ast_builder_Builder_actOnGlobalVarDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue);
static ast_VarDecl* ast_builder_Builder_actOnFunctionParam(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref);
static ast_Stmt* ast_builder_Builder_actOnVarDeclStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, const ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue, _Bool has_local, _Bool has_init_call);
static _Bool ast_builder_Builder_hasAttr(const ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_storeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnArrayValue(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Expr* initValue);
static _Bool ast_builder_Builder_checkAttr(ast_builder_Builder* b, const attr_Attr* a);
static void ast_builder_Builder_actOnFunctionAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnStructAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static _Bool ast_builder_Builder_actOnTypeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnVarAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnParamAttr(ast_builder_Builder* b, ast_VarDecl* d, uint32_t name, src_loc_SrcLoc loc);
static void ast_builder_Builder_actOnAttr(ast_builder_Builder* b, attr_Attr* a);
static void ast_builder_Builder_clearAttributes(ast_builder_Builder* b);
static void ast_builder_Builder_applyAttribute(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_applyAttributes(ast_builder_Builder* b, ast_Decl* d);
static ast_QualType ast_builder_Builder_actOnBuiltinType(ast_builder_Builder* _arg0, ast_BuiltinKind kind);
static ast_QualType ast_builder_Builder_actOnPointerType(ast_builder_Builder* _arg0, ast_QualType inner);
static ast_QualType ast_builder_Builder_actOnArrayType(ast_builder_Builder* b, ast_QualType elem, _Bool has_size, uint32_t size);
static ast_QualType ast_builder_Builder_actOnIncrementalArrayType(ast_builder_Builder* b, ast_QualType elem);
static ast_FunctionDecl* ast_builder_Builder_actOnFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic);
static ast_FunctionDecl* ast_builder_Builder_actOnTemplateFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic);
static void ast_builder_Builder_actOnFunctionBody(ast_builder_Builder* _arg0, ast_FunctionDecl* f, ast_CompoundStmt* body);
static ast_EnumConstantDecl* ast_builder_Builder_actOnEnumConstant(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, ast_Expr* init_expr);
static ast_Decl* ast_builder_Builder_actOnEnumType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, _Bool is_incr, ast_QualType implType, ast_EnumConstantDecl** constants, uint32_t num_constants);
static ast_Stmt* ast_builder_Builder_actOnAsmStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, _Bool is_basic, _Bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* asm_string);
static ast_CompoundStmt* ast_builder_Builder_actOnCompoundStmt(ast_builder_Builder* b, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count);
static ast_Stmt* ast_builder_Builder_actOnReturnStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* ret);
static ast_Stmt* ast_builder_Builder_actOnIfStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt);
static ast_Stmt* ast_builder_Builder_actOnWhileStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then);
static ast_Stmt* ast_builder_Builder_actOnForStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* incr, ast_Stmt* body);
static ast_Stmt* ast_builder_Builder_actOnSwitchStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* cond, ast_SwitchCase** cases, uint32_t num_cases, _Bool has_default);
static ast_SwitchCase* ast_builder_Builder_actOnCase(ast_builder_Builder* b, src_loc_SrcLoc loc, _Bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts);
static ast_Stmt* ast_builder_Builder_actOnAssertStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* inner);
static ast_Stmt* ast_builder_Builder_actOnBreakStmt(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Stmt* ast_builder_Builder_actOnContinueStmt(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Stmt* ast_builder_Builder_actOnFallthroughStmt(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Stmt* ast_builder_Builder_actOnLabelStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt);
static ast_Stmt* ast_builder_Builder_actOnGotoStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc);
static ast_IdentifierExpr* ast_builder_Builder_actOnIdentifier(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t name);
static ast_Expr* ast_builder_Builder_actOnIntegerLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint64_t value, number_radix_Radix radix);
static ast_Expr* ast_builder_Builder_actOnFloatLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, double value, number_radix_Radix radix);
static ast_Expr* ast_builder_Builder_actOnCharLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint8_t value, number_radix_Radix radix);
static ast_Expr* ast_builder_Builder_actOnStringLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len);
static ast_Expr* ast_builder_Builder_actOnNilExpr(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Expr* ast_builder_Builder_actOnParenExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner);
static ast_Expr* ast_builder_Builder_actOnUnaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_UnaryOpcode opcode, ast_Expr* inner);
static ast_Expr* ast_builder_Builder_actOnBinaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_BinaryOpcode opcode, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnConditionalOperator(ast_builder_Builder* b, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnBooleanConstant(ast_builder_Builder* b, src_loc_SrcLoc loc, _Bool value);
static ast_Expr* ast_builder_Builder_actOnBuiltinExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind);
static ast_Expr* ast_builder_Builder_actOnOffsetOfExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member);
static ast_Expr* ast_builder_Builder_actOnToContainerExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member, ast_Expr* pointer);
static ast_Expr* ast_builder_Builder_actOnTypeExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref);
static ast_Expr* ast_builder_Builder_actOnBitOffsetExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnArraySubscriptExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* base, ast_Expr* idx);
static ast_Expr* ast_builder_Builder_actOnCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args);
static ast_Expr* ast_builder_Builder_actOnTemplateCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, const ast_TypeRefHolder* ref);
static ast_Expr* ast_builder_Builder_actOnExplicitCast(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, _Bool c_style);
static ast_Expr* ast_builder_Builder_actOnMemberExpr(ast_builder_Builder* b, ast_Expr* base, const ast_Ref* refs, uint32_t refcount);
static ast_Expr* ast_builder_Builder_actOnRange(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnInitList(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values);
static ast_Expr* ast_builder_Builder_actOnFieldDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue);
static ast_Expr* ast_builder_Builder_actOnArrayDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue);
static void ast_builder_Builder_actOnStaticAssert(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static void ast_builder_Builder_insertImplicitCast(ast_builder_Builder* b, ast_ImplicitCastKind kind, ast_Expr** e_ptr, ast_QualType qt);
static void ast_builder_Builder_addSymbol(ast_builder_Builder* b, uint32_t name_idx, ast_Decl* d);

static ast_builder_Builder* ast_builder_create(ast_context_Context* context, diagnostics_Diags* diags, string_pool_Pool* auxPool, uint32_t c2_name, uint32_t main_name, attr_handler_Handler* attr_handler_)
{
   ast_builder_Builder* b = calloc(1, 240);
   b->context = context;
   b->diags = diags;
   b->auxPool = auxPool;
   b->c2_name = c2_name;
   b->main_name = main_name;
   b->attr_handler = attr_handler_;
   return b;
}

static void ast_builder_Builder_free(ast_builder_Builder* b)
{
   free(b);
}

static void ast_builder_Builder_setComponent(ast_builder_Builder* b, component_Component* comp)
{
   b->comp = comp;
   b->mod = NULL;
   b->is_interface = component_Component_isExternal(comp);
}

static void ast_builder_Builder_actOnModule(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t filename, _Bool is_generated)
{
   (b->comp) || c2_assert("parser/ast_builder.c2", 89, "ast_builder.Builder.actOnModule", "b.comp");
   if ((mod_name == b->c2_name)) {
      diagnostics_Diags_error(b->diags, mod_loc, "module name 'c2' is reserved");
      exit(-1);
   }
   if ((mod_name == b->main_name)) {
      diagnostics_Diags_error(b->diags, mod_loc, "module name 'main' is reserved");
      exit(-1);
   }
   b->mod = component_Component_getOrAddModule(b->comp, mod_name);
   if (!b->mod) {
      diagnostics_Diags_error(b->diags, mod_loc, "module '%s' is already defined in another component", ast_idx2name(mod_name));
      exit(-1);
   }
   b->ast = ast_Module_add(b->mod, b->auxPool, filename, is_generated);
   b->ast_idx = ast_AST_getIdx(b->ast);
   ast_ImportDecl* i = ast_ImportDecl_create(b->context, mod_name, mod_loc, 0, 0, b->ast_idx, true);
   ast_Decl* d = ((ast_Decl*)(i));
   ast_Decl_setUsed(d);
   ast_Decl_setChecked(d);
   ast_ImportDecl_setDest(i, b->mod);
   ast_Decl_setType(d, ast_QualType_create(((ast_Type*)(ast_Module_getType(b->mod)))));
   ast_AST_addImport(b->ast, i);
}

static void ast_builder_Builder_actOnImport(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, _Bool islocal)
{
   if ((ast_AST_getNameIdx(b->ast) == mod_name)) {
      diagnostics_Diags_error(b->diags, mod_loc, "cannot import own module '%s'", ast_idx2name(mod_name));
      return;
   }
   ast_ImportDecl* old = ast_AST_findImport(b->ast, mod_name);
   if (old) {
      diagnostics_Diags_error(b->diags, mod_loc, "duplicate import of module '%s'", ast_idx2name(mod_name));
      diagnostics_Diags_note(b->diags, ast_Decl_getLoc(ast_ImportDecl_asDecl(old)), "previous import is here");
      return;
   }
   if (alias_name) {
      if ((alias_name == mod_name)) {
         diagnostics_Diags_error(b->diags, alias_loc, "alias name is same as module name");
         return;
      }
   }
   ast_ImportDecl* d = ast_ImportDecl_create(b->context, mod_name, mod_loc, alias_name, alias_loc, b->ast_idx, islocal);
   ast_AST_addImport(b->ast, d);
}

static ast_Decl* ast_builder_Builder_actOnAliasType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref)
{
   is_public |= b->is_interface;
   ast_AliasTypeDecl* d = ast_AliasTypeDecl_create(b->context, name, loc, is_public, b->ast_idx, ref);
   ast_AST_addTypeDecl(b->ast, ast_AliasTypeDecl_asDecl(d));
   ast_Decl* dd = ((ast_Decl*)(d));
   if (b->is_interface) ast_Decl_setExternal(dd);
   ast_builder_Builder_addSymbol(b, name, dd);
   return dd;
}

static ast_Decl* ast_builder_Builder_actOnFunctionTypeDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* rtype, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic)
{
   is_public |= b->is_interface;
   ast_FunctionDecl* fd = ast_FunctionDecl_create(b->context, name, loc, is_public, b->ast_idx, rtype, NULL, params, num_params, is_variadic, true);
   ast_FunctionTypeDecl* d = ast_FunctionTypeDecl_create(b->context, fd);
   ast_AST_addTypeDecl(b->ast, ast_FunctionTypeDecl_asDecl(d));
   ast_Decl* dd = ((ast_Decl*)(d));
   if (b->is_interface) {
      ast_Decl_setExternal(dd);
      ast_Decl_setExternal(ast_FunctionDecl_asDecl(fd));
   }
   ast_builder_Builder_addSymbol(b, name, dd);
   return dd;
}

static ast_StructTypeDecl* ast_builder_Builder_actOnStructType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, _Bool is_struct, _Bool is_global, ast_Decl** members, uint32_t num_members)
{
   is_public |= b->is_interface;
   ast_StructTypeDecl* d = ast_StructTypeDecl_create(b->context, name, loc, is_public, b->ast_idx, is_struct, is_global, members, num_members);
   if (is_global) {
      ast_AST_addTypeDecl(b->ast, ast_StructTypeDecl_asDecl(d));
      ast_builder_Builder_addSymbol(b, name, ast_StructTypeDecl_asDecl(d));
   }
   if (b->is_interface) ast_Decl_setExternal(ast_StructTypeDecl_asDecl(d));
   return d;
}

static ast_VarDecl* ast_builder_Builder_actOnStructMember(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref, ast_Expr* bitfield)
{
   is_public |= b->is_interface;
   return ast_VarDecl_createStructMember(b->context, name, loc, is_public, ref, b->ast_idx, bitfield);
}

static ast_Decl* ast_builder_Builder_actOnGlobalVarDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue)
{
   is_public |= b->is_interface;
   ast_VarDecl* vd = ast_VarDecl_create(b->context, ast_VarDeclKind_GlobalVar, name, loc, is_public, ref, b->ast_idx, assignLoc, initValue);
   ast_Decl* d = ast_VarDecl_asDecl(vd);
   ast_AST_addVarDecl(b->ast, d);
   ast_builder_Builder_addSymbol(b, name, d);
   if (b->is_interface) ast_Decl_setExternal(d);
   return d;
}

static ast_VarDecl* ast_builder_Builder_actOnFunctionParam(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* ref)
{
   is_public |= b->is_interface;
   return ast_VarDecl_create(b->context, ast_VarDeclKind_FunctionParam, name, loc, is_public, ref, b->ast_idx, 0, NULL);
}

static ast_Stmt* ast_builder_Builder_actOnVarDeclStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, const ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue, _Bool has_local, _Bool has_init_call)
{
   ast_VarDecl* d = ast_VarDecl_create(b->context, ast_VarDeclKind_LocalVar, name, loc, false, ref, b->ast_idx, assignLoc, initValue);
   ast_VarDecl_setLocal(d, has_local);
   ast_VarDecl_setInitCall(d, has_init_call);
   return ((ast_Stmt*)(ast_DeclStmt_create(b->context, d)));
}

static _Bool ast_builder_Builder_hasAttr(const ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   return false;
}

static void ast_builder_Builder_storeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_Decl_setHasAttr(d);
   if (ast_builder_Builder_hasAttr(b, d, a)) {
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is already applied", attr_kind2name(a->kind));
      return;
   }
   ast_AST_storeAttr(b->ast, d, a->kind, &a->value);
}

static void ast_builder_Builder_actOnArrayValue(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Expr* initValue)
{
   ast_ArrayValue* avd = ast_ArrayValue_create(b->context, name, loc, initValue);
   ast_AST_addArrayValue(b->ast, avd);
}

static _Bool ast_builder_Builder_checkAttr(ast_builder_Builder* b, const attr_Attr* a)
{
   switch (a->kind) {
   case attr_AttrKind_CName:
      fallthrough;
   case attr_AttrKind_CDef:
      if (!b->is_interface) {
         diagnostics_Diags_error(b->diags, a->loc, "attribute 'cname' can only be used in interface files");
         return false;
      }
      break;
   default:
      break;
   }
   return true;
}

static void ast_builder_Builder_actOnFunctionAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Unused:
      if (ast_Decl_hasAttrUnused(d)) {
         diagnostics_Diags_error(b->diags, a->loc, "attribute 'unused' is already applied");
      }
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_UnusedParams:
      ast_FunctionDecl_setAttrUnusedParams(fd);
      break;
   case attr_AttrKind_Section:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_NoReturn:
      ast_FunctionDecl_setAttrNoReturn(fd);
      break;
   case attr_AttrKind_Inline:
      ast_FunctionDecl_setAttrInline(fd);
      break;
   case attr_AttrKind_Weak:
      if (!ast_Decl_isPublic(d)) diagnostics_Diags_error(b->diags, a->loc, "weak declarations must be public");
      ast_FunctionDecl_setAttrWeak(fd);
      break;
   case attr_AttrKind_CName:
      fallthrough;
   case attr_AttrKind_CDef:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Constructor:
      ast_FunctionDecl_setAttrConstructor(fd);
      break;
   case attr_AttrKind_Destructor:
      ast_FunctionDecl_setAttrDestructor(fd);
      break;
   case attr_AttrKind_Pure:
      ast_FunctionDecl_setAttrPure(fd);
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to functions", attr_kind2name(a->kind));
      break;
   }
}

static void ast_builder_Builder_actOnStructAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Packed:
      ast_StructTypeDecl_setPacked(std);
      break;
   case attr_AttrKind_Unused:
      if (ast_Decl_hasAttrUnused(d)) {
         diagnostics_Diags_error(b->diags, a->loc, "attribute 'unused' is already applied");
      }
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_Section:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' cannot be applied to type declarations", attr_kind2name(a->kind));
      break;
   case attr_AttrKind_Aligned:
      ast_StructTypeDecl_setAttrAlignment(std, a->value.number);
      break;
   case attr_AttrKind_Opaque:
      if (!ast_Decl_isPublic(d)) {
         diagnostics_Diags_error(b->diags, a->loc, "opaque declaration must be public");
      }
      ast_StructTypeDecl_setOpaque(std);
      break;
   case attr_AttrKind_CName:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_NoTypeDef:
      if (b->is_interface) {
         ast_StructTypeDecl_setAttrNoTypeDef(std);
      } else {
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be used in interfaces", attr_kind2name(a->kind));
      }
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to structs", attr_kind2name(a->kind));
      break;
   }
}

static _Bool ast_builder_Builder_actOnTypeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Packed:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be applied to struct/union types", attr_kind2name(a->kind));
      return false;
   case attr_AttrKind_Unused:
      if (ast_Decl_hasAttrUnused(d)) {
         diagnostics_Diags_error(b->diags, a->loc, "attribute 'unused' is already applied");
      }
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_Opaque:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be applied to struct/union types", attr_kind2name(a->kind));
      return false;
   case attr_AttrKind_CName:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to Enum/Alias types", attr_kind2name(a->kind));
      return false;
   }
   return true;
}

static void ast_builder_Builder_actOnVarAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_VarDecl* vd = ((ast_VarDecl*)(d));
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Unused:
      if (ast_Decl_hasAttrUnused(d)) {
         diagnostics_Diags_error(b->diags, a->loc, "attribute 'unused' is already applied");
      }
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_Section:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Aligned:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Weak:
      if (!ast_Decl_isPublic(d)) diagnostics_Diags_error(b->diags, a->loc, "weak declarations must be public");
      ast_VarDecl_setAttrWeak(vd);
      break;
   case attr_AttrKind_CName:
      fallthrough;
   case attr_AttrKind_CDef:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to variables", attr_kind2name(a->kind));
      break;
   }
}

static void ast_builder_Builder_actOnParamAttr(ast_builder_Builder* b, ast_VarDecl* d, uint32_t name, src_loc_SrcLoc loc)
{
   attr_AttrKind kind = attr_find(name);
   switch (kind) {
   case attr_AttrKind_Unknown:
      diagnostics_Diags_error(b->diags, loc, "unknown attribute '%s'", ast_idx2name(name));
      break;
   case attr_AttrKind_PrintfFormat:
      ast_VarDecl_setPrintfFormat(d);
      break;
   case attr_AttrKind_AutoFile:
      ast_VarDecl_setAttrAutoFile(d);
      break;
   case attr_AttrKind_AutoLine:
      ast_VarDecl_setAttrAutoLine(d);
      break;
   default:
      diagnostics_Diags_error(b->diags, loc, "attribute '%s' cannot be applied to function parameters", ast_idx2name(name));
      break;
   }
}

static void ast_builder_Builder_actOnAttr(ast_builder_Builder* b, attr_Attr* a)
{
   a->kind = attr_find(a->name);
   if (!ast_builder_Builder_checkAttr(b, a)) return;

   if ((a->kind != attr_AttrKind_Unknown)) {
      attr_AttrReq req = attr_check(a);
      switch (req) {
      case attr_AttrReq_NoArg:
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' has no argument", attr_kind2name(a->kind));
         return;
      case attr_AttrReq_Arg:
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' needs an argument", attr_kind2name(a->kind));
         return;
      case attr_AttrReq_Number:
         diagnostics_Diags_error(b->diags, a->value.loc, "attribute '%s' needs a number argument", attr_kind2name(a->kind));
         return;
      case attr_AttrReq_String:
         diagnostics_Diags_error(b->diags, a->value.loc, "attribute '%s' needs a string argument", attr_kind2name(a->kind));
         return;
      case attr_AttrReq_Power2:
         diagnostics_Diags_error(b->diags, a->value.loc, "requested alignment is not a power of 2");
         return;
      case attr_AttrReq_Ok:
         break;
      }
   }
   if ((b->num_attrs == 8)) {
      diagnostics_Diags_error(b->diags, a->loc, "too many attributes");
      return;
   }
   memcpy(&b->attrs[b->num_attrs], a, 20);
   b->num_attrs++;
}

static void ast_builder_Builder_clearAttributes(ast_builder_Builder* b)
{
   b->num_attrs = 0;
}

static void ast_builder_Builder_applyAttribute(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_DeclKind dk = ast_Decl_getKind(d);
   switch (dk) {
   case ast_DeclKind_Function:
      ast_builder_Builder_actOnFunctionAttr(b, d, a);
      break;
   case ast_DeclKind_StructType:
      ast_builder_Builder_actOnStructAttr(b, d, a);
      break;
   case ast_DeclKind_EnumType:
      ast_builder_Builder_actOnTypeAttr(b, d, a);
      break;
   case ast_DeclKind_FunctionType: {
      if (!ast_builder_Builder_actOnTypeAttr(b, d, a)) return;

      ast_FunctionTypeDecl* ftd = ((ast_FunctionTypeDecl*)(d));
      if ((a->kind == attr_AttrKind_PrintfFormat)) {
         ast_builder_Builder_applyAttribute(b, ((ast_Decl*)(ast_FunctionTypeDecl_getDecl(ftd))), a);
      } else {
         ast_builder_Builder_applyAttribute(b, ((ast_Decl*)(ast_FunctionTypeDecl_getDecl(ftd))), a);
      }
      break;
   }
   case ast_DeclKind_AliasType:
      ast_builder_Builder_actOnTypeAttr(b, d, a);
      break;
   case ast_DeclKind_Variable:
      ast_builder_Builder_actOnVarAttr(b, d, a);
      break;
   default:
      (0) || c2_assert("parser/ast_builder.c2", 614, "ast_builder.Builder.applyAttribute", "0");
      return;
   }
}

static void ast_builder_Builder_applyAttributes(ast_builder_Builder* b, ast_Decl* d)
{
   (d) || c2_assert("parser/ast_builder.c2", 620, "ast_builder.Builder.applyAttributes", "d");
   for (uint32_t i = 0; (i < b->num_attrs); i++) {
      const attr_Attr* a = &b->attrs[i];
      if ((a->kind == attr_AttrKind_Unknown)) {
         attr_handler_Handler_handle(b->attr_handler, d, a);
      } else {
         ast_builder_Builder_applyAttribute(b, d, a);
      }
   }
   b->num_attrs = 0;
}

static ast_QualType ast_builder_Builder_actOnBuiltinType(ast_builder_Builder* _arg0, ast_BuiltinKind kind)
{
   return ast_builtins[kind];
}

static ast_QualType ast_builder_Builder_actOnPointerType(ast_builder_Builder* _arg0, ast_QualType inner)
{
   ast_QualType ptr = ast_QualType_create(ast_getPointerType(inner));
   ast_QualType canon = ast_QualType_getCanonicalType(&inner);
   if ((ast_QualType_getTypeOrNil(&inner) == ast_QualType_getTypeOrNil(&canon))) {
      canon = ptr;
   } else {
      canon = ast_QualType_create(ast_getPointerType(canon));
      ast_QualType_setCanonicalType(&canon, canon);
   }
   ast_QualType_setCanonicalType(&ptr, canon);
   return ptr;
}

static ast_QualType ast_builder_Builder_actOnArrayType(ast_builder_Builder* b, ast_QualType elem, _Bool has_size, uint32_t size)
{
   ast_ArrayType* t = ast_ArrayType_create(b->context, elem, has_size, size);
   ast_QualType a = ast_QualType_create(((ast_Type*)(t)));
   ast_QualType canon = ast_QualType_getCanonicalType(&elem);
   if ((ast_QualType_getTypeOrNil(&elem) == ast_QualType_getTypeOrNil(&canon))) {
      canon = a;
   } else {
      ast_ArrayType* t2 = ast_ArrayType_create(b->context, canon, has_size, size);
      canon = ast_QualType_create(((ast_Type*)(t2)));
   }
   ast_QualType_setCanonicalType(&a, canon);
   return a;
}

static ast_QualType ast_builder_Builder_actOnIncrementalArrayType(ast_builder_Builder* b, ast_QualType elem)
{
   ast_ArrayType* t = ast_ArrayType_createIncremental(b->context, elem);
   ast_QualType a = ast_QualType_create(((ast_Type*)(t)));
   ast_QualType canon = ast_QualType_getCanonicalType(&elem);
   if ((ast_QualType_getTypeOrNil(&elem) == ast_QualType_getTypeOrNil(&canon))) {
      canon = a;
   } else {
      ast_ArrayType* t2 = ast_ArrayType_createIncremental(b->context, canon);
      canon = ast_QualType_create(((ast_Type*)(t2)));
   }
   ast_QualType_setCanonicalType(&a, canon);
   return a;
}

static ast_FunctionDecl* ast_builder_Builder_actOnFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic)
{
   is_public |= b->is_interface;
   ast_FunctionDecl* f = ast_FunctionDecl_create(b->context, name, loc, is_public, b->ast_idx, rtype, prefix, params, num_params, is_variadic, false);
   ast_AST_addFunc(b->ast, f);
   if (!prefix) ast_builder_Builder_addSymbol(b, name, ast_FunctionDecl_asDecl(f));
   if (b->is_interface) ast_Decl_setExternal(ast_FunctionDecl_asDecl(f));
   return f;
}

static ast_FunctionDecl* ast_builder_Builder_actOnTemplateFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, _Bool is_variadic)
{
   if (b->is_interface) diagnostics_Diags_error(b->diags, loc, "template functions are not allow in interfaces");
   is_public |= b->is_interface;
   ast_FunctionDecl* f = ast_FunctionDecl_createTemplate(b->context, name, loc, is_public, b->ast_idx, rtype, template_name, template_loc, params, num_params, is_variadic);
   ast_AST_addFunc(b->ast, f);
   ast_builder_Builder_addSymbol(b, name, ast_FunctionDecl_asDecl(f));
   if (b->is_interface) ast_Decl_setExternal(ast_FunctionDecl_asDecl(f));
   return f;
}

static void ast_builder_Builder_actOnFunctionBody(ast_builder_Builder* _arg0, ast_FunctionDecl* f, ast_CompoundStmt* body)
{
   ast_FunctionDecl_setBody(f, body);
}

static ast_EnumConstantDecl* ast_builder_Builder_actOnEnumConstant(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, ast_Expr* init_expr)
{
   return ast_EnumConstantDecl_create(b->context, name, loc, is_public, b->ast_idx, init_expr);
}

static ast_Decl* ast_builder_Builder_actOnEnumType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, _Bool is_public, _Bool is_incr, ast_QualType implType, ast_EnumConstantDecl** constants, uint32_t num_constants)
{
   is_public |= b->is_interface;
   ast_EnumTypeDecl* d = ast_EnumTypeDecl_create(b->context, name, loc, is_public, b->ast_idx, implType, is_incr, constants, num_constants);
   ast_AST_addTypeDecl(b->ast, ast_EnumTypeDecl_asDecl(d));
   ast_builder_Builder_addSymbol(b, name, ast_EnumTypeDecl_asDecl(d));
   return ((ast_Decl*)(d));
}

static ast_Stmt* ast_builder_Builder_actOnAsmStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, _Bool is_basic, _Bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* asm_string)
{
   return ((ast_Stmt*)(ast_AsmStmt_create(b->context, loc, is_basic, is_volatile, num_outputs, num_inputs, names, constraints, exprs, clobbers, asm_string)));
}

static ast_CompoundStmt* ast_builder_Builder_actOnCompoundStmt(ast_builder_Builder* b, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count)
{
   return ast_CompoundStmt_create(b->context, endLoc, stmts, count);
}

static ast_Stmt* ast_builder_Builder_actOnReturnStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* ret)
{
   return ((ast_Stmt*)(ast_ReturnStmt_create(b->context, loc, ret)));
}

static ast_Stmt* ast_builder_Builder_actOnIfStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt)
{
   return ((ast_Stmt*)(ast_IfStmt_create(b->context, loc, cond, then, else_stmt)));
}

static ast_Stmt* ast_builder_Builder_actOnWhileStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then)
{
   return ((ast_Stmt*)(ast_WhileStmt_create(b->context, loc, cond, then)));
}

static ast_Stmt* ast_builder_Builder_actOnForStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* incr, ast_Stmt* body)
{
   return ((ast_Stmt*)(ast_ForStmt_create(b->context, loc, init, cond, incr, body)));
}

static ast_Stmt* ast_builder_Builder_actOnSwitchStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* cond, ast_SwitchCase** cases, uint32_t num_cases, _Bool has_default)
{
   return ((ast_Stmt*)(ast_SwitchStmt_create(b->context, loc, cond, cases, num_cases, has_default)));
}

static ast_SwitchCase* ast_builder_Builder_actOnCase(ast_builder_Builder* b, src_loc_SrcLoc loc, _Bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts)
{
   return ast_SwitchCase_create(b->context, loc, is_default, conds, num_conds, stmts, num_stmts);
}

static ast_Stmt* ast_builder_Builder_actOnAssertStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* inner)
{
   return ((ast_Stmt*)(ast_AssertStmt_create(b->context, loc, inner)));
}

static ast_Stmt* ast_builder_Builder_actOnBreakStmt(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return ((ast_Stmt*)(ast_BreakStmt_create(b->context, loc)));
}

static ast_Stmt* ast_builder_Builder_actOnContinueStmt(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return ((ast_Stmt*)(ast_ContinueStmt_create(b->context, loc)));
}

static ast_Stmt* ast_builder_Builder_actOnFallthroughStmt(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return ((ast_Stmt*)(ast_FallthroughStmt_create(b->context, loc)));
}

static ast_Stmt* ast_builder_Builder_actOnLabelStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt)
{
   return ((ast_Stmt*)(ast_LabelStmt_create(b->context, name, loc, stmt)));
}

static ast_Stmt* ast_builder_Builder_actOnGotoStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc)
{
   return ((ast_Stmt*)(ast_GotoStmt_create(b->context, name, loc)));
}

static ast_IdentifierExpr* ast_builder_Builder_actOnIdentifier(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t name)
{
   return ast_IdentifierExpr_create(b->context, loc, name);
}

static ast_Expr* ast_builder_Builder_actOnIntegerLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint64_t value, number_radix_Radix radix)
{
   return ((ast_Expr*)(ast_IntegerLiteral_create(b->context, loc, src_len, value, radix)));
}

static ast_Expr* ast_builder_Builder_actOnFloatLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, double value, number_radix_Radix radix)
{
   return ((ast_Expr*)(ast_FloatLiteral_create(b->context, loc, src_len, value, radix)));
}

static ast_Expr* ast_builder_Builder_actOnCharLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint8_t value, number_radix_Radix radix)
{
   return ((ast_Expr*)(ast_CharLiteral_create(b->context, loc, src_len, value, radix)));
}

static ast_Expr* ast_builder_Builder_actOnStringLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len)
{
   return ((ast_Expr*)(ast_StringLiteral_create(b->context, loc, src_len, value, len)));
}

static ast_Expr* ast_builder_Builder_actOnNilExpr(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return ((ast_Expr*)(ast_NilExpr_create(b->context, loc)));
}

static ast_Expr* ast_builder_Builder_actOnParenExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner)
{
   return ((ast_Expr*)(ast_ParenExpr_create(b->context, loc, src_len, inner)));
}

static ast_Expr* ast_builder_Builder_actOnUnaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_UnaryOpcode opcode, ast_Expr* inner)
{
   return ((ast_Expr*)(ast_UnaryOperator_create(b->context, loc, opcode, inner)));
}

static ast_Expr* ast_builder_Builder_actOnBinaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_BinaryOpcode opcode, ast_Expr* lhs, ast_Expr* rhs)
{
   return ((ast_Expr*)(ast_BinaryOperator_create(b->context, loc, opcode, lhs, rhs)));
}

static ast_Expr* ast_builder_Builder_actOnConditionalOperator(ast_builder_Builder* b, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs)
{
   return ((ast_Expr*)(ast_ConditionalOperator_create(b->context, questionLoc, colonLoc, cond, lhs, rhs)));
}

static ast_Expr* ast_builder_Builder_actOnBooleanConstant(ast_builder_Builder* b, src_loc_SrcLoc loc, _Bool value)
{
   return ((ast_Expr*)(ast_BooleanLiteral_create(b->context, loc, value)));
}

static ast_Expr* ast_builder_Builder_actOnBuiltinExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind)
{
   return ((ast_Expr*)(ast_BuiltinExpr_create(b->context, loc, src_len, inner, kind)));
}

static ast_Expr* ast_builder_Builder_actOnOffsetOfExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member)
{
   return ((ast_Expr*)(ast_BuiltinExpr_createOffsetOf(b->context, loc, src_len, structExpr, member)));
}

static ast_Expr* ast_builder_Builder_actOnToContainerExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member, ast_Expr* pointer)
{
   return ((ast_Expr*)(ast_BuiltinExpr_createToContainer(b->context, loc, src_len, structExpr, member, pointer)));
}

static ast_Expr* ast_builder_Builder_actOnTypeExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref)
{
   return ((ast_Expr*)(ast_TypeExpr_create(b->context, loc, src_len, ref)));
}

static ast_Expr* ast_builder_Builder_actOnBitOffsetExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   return ((ast_Expr*)(ast_BitOffsetExpr_create(b->context, loc, lhs, rhs)));
}

static ast_Expr* ast_builder_Builder_actOnArraySubscriptExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* base, ast_Expr* idx)
{
   return ((ast_Expr*)(ast_ArraySubscriptExpr_create(b->context, loc, src_len, base, idx)));
}

static ast_Expr* ast_builder_Builder_actOnCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args)
{
   return ((ast_Expr*)(ast_CallExpr_create(b->context, loc, endLoc, func, args, num_args)));
}

static ast_Expr* ast_builder_Builder_actOnTemplateCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, const ast_TypeRefHolder* ref)
{
   return ((ast_Expr*)(ast_CallExpr_createTemplate(b->context, loc, endLoc, func, args, num_args, b->ast_idx, ref)));
}

static ast_Expr* ast_builder_Builder_actOnExplicitCast(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, _Bool c_style)
{
   return ((ast_Expr*)(ast_ExplicitCastExpr_create(b->context, loc, src_len, ref, inner, c_style)));
}

static ast_Expr* ast_builder_Builder_actOnMemberExpr(ast_builder_Builder* b, ast_Expr* base, const ast_Ref* refs, uint32_t refcount)
{
   return ((ast_Expr*)(ast_MemberExpr_create(b->context, base, refs, refcount)));
}

static ast_Expr* ast_builder_Builder_actOnRange(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   return ((ast_Expr*)(ast_RangeExpr_create(b->context, loc, lhs, rhs)));
}

static ast_Expr* ast_builder_Builder_actOnInitList(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values)
{
   return ((ast_Expr*)(ast_InitListExpr_create(b->context, loc, endLoc, values, num_values)));
}

static ast_Expr* ast_builder_Builder_actOnFieldDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue)
{
   return ((ast_Expr*)(ast_FieldDesignatedInitExpr_create(b->context, loc, field, initValue)));
}

static ast_Expr* ast_builder_Builder_actOnArrayDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue)
{
   return ((ast_Expr*)(ast_ArrayDesignatedInitExpr_create(b->context, loc, designator, initValue)));
}

static void ast_builder_Builder_actOnStaticAssert(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_StaticAssert* d = ast_StaticAssert_create(b->context, b->ast_idx, loc, lhs, rhs);
   ast_AST_addStaticAssert(b->ast, d);
}

static void ast_builder_Builder_insertImplicitCast(ast_builder_Builder* b, ast_ImplicitCastKind kind, ast_Expr** e_ptr, ast_QualType qt)
{
   ast_Expr* inner = *e_ptr;
   ast_Expr* ic = ((ast_Expr*)(ast_ImplicitCastExpr_create(b->context, ast_Expr_getLoc(inner), kind, inner)));
   ast_Expr_setType(ic, qt);
   *e_ptr = ic;
}

static void ast_builder_Builder_addSymbol(ast_builder_Builder* b, uint32_t name_idx, ast_Decl* d)
{
   ast_Decl* old = ast_Module_findSymbol(b->mod, name_idx);
   if (old) {
      diagnostics_Diags_error(b->diags, ast_Decl_getLoc(d), "redefinition of '%s'", ast_idx2name(name_idx));
      diagnostics_Diags_note(b->diags, ast_Decl_getLoc(old), "previous definition is here");
   } else {
      ast_Module_addSymbol(b->mod, name_idx, d);
   }
}


// --- module c2_tokenizer ---
typedef struct c2_tokenizer_Feature_ c2_tokenizer_Feature;
typedef struct c2_tokenizer_Tokenizer_ c2_tokenizer_Tokenizer;
typedef struct c2_tokenizer_Operand_ c2_tokenizer_Operand;

typedef enum {
   c2_tokenizer_Action_INVALID = 0,
   c2_tokenizer_Action_TABSPACE,
   c2_tokenizer_Action_IDENT,
   c2_tokenizer_Action_DIGIT,
   c2_tokenizer_Action_LPAREN,
   c2_tokenizer_Action_RPAREN,
   c2_tokenizer_Action_LSQUARE,
   c2_tokenizer_Action_RSQUARE,
   c2_tokenizer_Action_NEWLINE,
   c2_tokenizer_Action_EXCLAIM,
   c2_tokenizer_Action_BQUOTE,
   c2_tokenizer_Action_DQUOTE,
   c2_tokenizer_Action_SQUOTE,
   c2_tokenizer_Action_POUND,
   c2_tokenizer_Action_STAR,
   c2_tokenizer_Action_PLUS,
   c2_tokenizer_Action_MINUS,
   c2_tokenizer_Action_COMMA,
   c2_tokenizer_Action_DOT,
   c2_tokenizer_Action_PERCENT,
   c2_tokenizer_Action_SLASH,
   c2_tokenizer_Action_COLON,
   c2_tokenizer_Action_SEMI_COLON,
   c2_tokenizer_Action_LESS,
   c2_tokenizer_Action_EQUAL,
   c2_tokenizer_Action_GREATER,
   c2_tokenizer_Action_QUESTION,
   c2_tokenizer_Action_AT,
   c2_tokenizer_Action_AMP,
   c2_tokenizer_Action_CARET,
   c2_tokenizer_Action_LBRACE,
   c2_tokenizer_Action_RBRACE,
   c2_tokenizer_Action_PIPE,
   c2_tokenizer_Action_TILDE,
   c2_tokenizer_Action_CR,
   c2_tokenizer_Action_EOF,
   _c2_tokenizer_Action_max = 255
} __attribute__((packed)) c2_tokenizer_Action;

struct c2_tokenizer_Feature_ {
   src_loc_SrcLoc loc;
   token_Kind kind;
   uint8_t skipping;
   _Bool is_else;
};

typedef void (*c2_tokenizer_HandlerFn)(void* arg, src_loc_SrcLoc loc);

#define c2_tokenizer_MaxLookahead 64
struct c2_tokenizer_Tokenizer_ {
   const char* cur;
   src_loc_SrcLoc loc_start;
   const char* input_start;
   const keywords_Info* kwinfo;
   token_Token next[64];
   uint32_t next_count;
   uint32_t next_head;
   const char* line_start;
   string_pool_Pool* pool;
   string_buffer_Buf* buf;
   c2_tokenizer_HandlerFn on_error;
   c2_tokenizer_HandlerFn on_warning;
   void* fn_arg;
   c2_tokenizer_Feature feature_stack[7];
   uint32_t feature_count;
   const string_list_List* features;
   _Bool raw_mode;
   _Bool stop_at_eol;
   char error_msg[256];
};

struct c2_tokenizer_Operand_ {
   int64_t val;
   token_Kind op;
   uint8_t prec;
};

static const c2_tokenizer_Action c2_tokenizer_Char_lookup[256] = {
   [0] = c2_tokenizer_Action_EOF,
   ['\t'] = c2_tokenizer_Action_TABSPACE,
   ['\n'] = c2_tokenizer_Action_NEWLINE,
   ['\r'] = c2_tokenizer_Action_CR,
   [' '] = c2_tokenizer_Action_TABSPACE,
   ['!'] = c2_tokenizer_Action_EXCLAIM,
   ['"'] = c2_tokenizer_Action_DQUOTE,
   ['#'] = c2_tokenizer_Action_POUND,
   ['%'] = c2_tokenizer_Action_PERCENT,
   ['&'] = c2_tokenizer_Action_AMP,
   ['\''] = c2_tokenizer_Action_SQUOTE,
   ['('] = c2_tokenizer_Action_LPAREN,
   [')'] = c2_tokenizer_Action_RPAREN,
   ['*'] = c2_tokenizer_Action_STAR,
   ['+'] = c2_tokenizer_Action_PLUS,
   [','] = c2_tokenizer_Action_COMMA,
   ['-'] = c2_tokenizer_Action_MINUS,
   ['.'] = c2_tokenizer_Action_DOT,
   ['/'] = c2_tokenizer_Action_SLASH,
   ['0'] = c2_tokenizer_Action_DIGIT,
   ['1'] = c2_tokenizer_Action_DIGIT,
   ['2'] = c2_tokenizer_Action_DIGIT,
   ['3'] = c2_tokenizer_Action_DIGIT,
   ['4'] = c2_tokenizer_Action_DIGIT,
   ['5'] = c2_tokenizer_Action_DIGIT,
   ['6'] = c2_tokenizer_Action_DIGIT,
   ['7'] = c2_tokenizer_Action_DIGIT,
   ['8'] = c2_tokenizer_Action_DIGIT,
   ['9'] = c2_tokenizer_Action_DIGIT,
   [':'] = c2_tokenizer_Action_COLON,
   [';'] = c2_tokenizer_Action_SEMI_COLON,
   ['<'] = c2_tokenizer_Action_LESS,
   ['='] = c2_tokenizer_Action_EQUAL,
   ['>'] = c2_tokenizer_Action_GREATER,
   ['?'] = c2_tokenizer_Action_QUESTION,
   ['@'] = c2_tokenizer_Action_AT,
   ['A'] = c2_tokenizer_Action_IDENT,
   ['B'] = c2_tokenizer_Action_IDENT,
   ['C'] = c2_tokenizer_Action_IDENT,
   ['D'] = c2_tokenizer_Action_IDENT,
   ['E'] = c2_tokenizer_Action_IDENT,
   ['F'] = c2_tokenizer_Action_IDENT,
   ['G'] = c2_tokenizer_Action_IDENT,
   ['H'] = c2_tokenizer_Action_IDENT,
   ['I'] = c2_tokenizer_Action_IDENT,
   ['J'] = c2_tokenizer_Action_IDENT,
   ['K'] = c2_tokenizer_Action_IDENT,
   ['L'] = c2_tokenizer_Action_IDENT,
   ['M'] = c2_tokenizer_Action_IDENT,
   ['N'] = c2_tokenizer_Action_IDENT,
   ['O'] = c2_tokenizer_Action_IDENT,
   ['P'] = c2_tokenizer_Action_IDENT,
   ['Q'] = c2_tokenizer_Action_IDENT,
   ['R'] = c2_tokenizer_Action_IDENT,
   ['S'] = c2_tokenizer_Action_IDENT,
   ['T'] = c2_tokenizer_Action_IDENT,
   ['U'] = c2_tokenizer_Action_IDENT,
   ['V'] = c2_tokenizer_Action_IDENT,
   ['W'] = c2_tokenizer_Action_IDENT,
   ['X'] = c2_tokenizer_Action_IDENT,
   ['Y'] = c2_tokenizer_Action_IDENT,
   ['Z'] = c2_tokenizer_Action_IDENT,
   ['['] = c2_tokenizer_Action_LSQUARE,
   ['\\'] = c2_tokenizer_Action_INVALID,
   [']'] = c2_tokenizer_Action_RSQUARE,
   ['^'] = c2_tokenizer_Action_CARET,
   ['_'] = c2_tokenizer_Action_IDENT,
   ['`'] = c2_tokenizer_Action_BQUOTE,
   ['a'] = c2_tokenizer_Action_IDENT,
   ['b'] = c2_tokenizer_Action_IDENT,
   ['c'] = c2_tokenizer_Action_IDENT,
   ['d'] = c2_tokenizer_Action_IDENT,
   ['e'] = c2_tokenizer_Action_IDENT,
   ['f'] = c2_tokenizer_Action_IDENT,
   ['g'] = c2_tokenizer_Action_IDENT,
   ['h'] = c2_tokenizer_Action_IDENT,
   ['i'] = c2_tokenizer_Action_IDENT,
   ['j'] = c2_tokenizer_Action_IDENT,
   ['k'] = c2_tokenizer_Action_IDENT,
   ['l'] = c2_tokenizer_Action_IDENT,
   ['m'] = c2_tokenizer_Action_IDENT,
   ['n'] = c2_tokenizer_Action_IDENT,
   ['o'] = c2_tokenizer_Action_IDENT,
   ['p'] = c2_tokenizer_Action_IDENT,
   ['q'] = c2_tokenizer_Action_IDENT,
   ['r'] = c2_tokenizer_Action_IDENT,
   ['s'] = c2_tokenizer_Action_IDENT,
   ['t'] = c2_tokenizer_Action_IDENT,
   ['u'] = c2_tokenizer_Action_IDENT,
   ['v'] = c2_tokenizer_Action_IDENT,
   ['w'] = c2_tokenizer_Action_IDENT,
   ['x'] = c2_tokenizer_Action_IDENT,
   ['y'] = c2_tokenizer_Action_IDENT,
   ['z'] = c2_tokenizer_Action_IDENT,
   ['{'] = c2_tokenizer_Action_LBRACE,
   ['|'] = c2_tokenizer_Action_PIPE,
   ['}'] = c2_tokenizer_Action_RBRACE,
   ['~'] = c2_tokenizer_Action_TILDE
};

static const uint8_t c2_tokenizer_Identifier_char[256] = {
   ['0'] = 1,
   ['1'] = 1,
   ['2'] = 1,
   ['3'] = 1,
   ['4'] = 1,
   ['5'] = 1,
   ['6'] = 1,
   ['7'] = 1,
   ['8'] = 1,
   ['9'] = 1,
   ['A'] = 1,
   ['B'] = 1,
   ['C'] = 1,
   ['D'] = 1,
   ['E'] = 1,
   ['F'] = 1,
   ['G'] = 1,
   ['H'] = 1,
   ['I'] = 1,
   ['J'] = 1,
   ['K'] = 1,
   ['L'] = 1,
   ['M'] = 1,
   ['N'] = 1,
   ['O'] = 1,
   ['P'] = 1,
   ['Q'] = 1,
   ['R'] = 1,
   ['S'] = 1,
   ['T'] = 1,
   ['U'] = 1,
   ['V'] = 1,
   ['W'] = 1,
   ['X'] = 1,
   ['Y'] = 1,
   ['Z'] = 1,
   ['_'] = 1,
   ['a'] = 1,
   ['b'] = 1,
   ['c'] = 1,
   ['d'] = 1,
   ['e'] = 1,
   ['f'] = 1,
   ['g'] = 1,
   ['h'] = 1,
   ['i'] = 1,
   ['j'] = 1,
   ['k'] = 1,
   ['l'] = 1,
   ['m'] = 1,
   ['n'] = 1,
   ['o'] = 1,
   ['p'] = 1,
   ['q'] = 1,
   ['r'] = 1,
   ['s'] = 1,
   ['t'] = 1,
   ['u'] = 1,
   ['v'] = 1,
   ['w'] = 1,
   ['x'] = 1,
   ['y'] = 1,
   ['z'] = 1
};

#define c2_tokenizer_MAX_LEVEL 16
static void c2_tokenizer_Tokenizer_init(c2_tokenizer_Tokenizer* t, string_pool_Pool* pool, string_buffer_Buf* buf, const char* input, src_loc_SrcLoc loc_start, const keywords_Info* kwinfo, const string_list_List* features, c2_tokenizer_HandlerFn on_error, c2_tokenizer_HandlerFn on_warning, void* fn_arg, _Bool raw_mode);
static void c2_tokenizer_Tokenizer_lex(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_internal(c2_tokenizer_Tokenizer* t, token_Token* result);
static token_Kind c2_tokenizer_Tokenizer_lookahead(c2_tokenizer_Tokenizer* t, uint32_t n, token_Token* tok);
__attribute__((__format__(printf, 3, 4))) 
static void c2_tokenizer_Tokenizer_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* format, ...);
__attribute__((__format__(printf, 4, 5))) 
static void c2_tokenizer_Tokenizer_num_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* format, ...);
static void c2_tokenizer_Tokenizer_lex_identifier(c2_tokenizer_Tokenizer* t, token_Token* result);
static uint8_t c2_tokenizer_hex2val(char c);
static _Bool c2_tokenizer_is_octal(char c);
static _Bool c2_tokenizer_is_binary(char c);
static void c2_tokenizer_Tokenizer_lex_number_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* qual);
static void c2_tokenizer_Tokenizer_lex_number(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_floating_point(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start);
static void c2_tokenizer_Tokenizer_lex_floating_point_hex(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start);
static uint32_t c2_tokenizer_Tokenizer_lex_escaped_char(c2_tokenizer_Tokenizer* t, token_Token* result, const char* stype);
static void c2_tokenizer_Tokenizer_lex_char_literal(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_raw_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_Tokenizer_lex_line_comment(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_Tokenizer_lex_block_comment(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_compare_word(const char* cur, const char* expect);
static _Bool c2_tokenizer_Tokenizer_lex_feature_cmd(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_Tokenizer_at_bol(c2_tokenizer_Tokenizer* t);
static _Bool c2_tokenizer_Tokenizer_parse_error_warn(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind);
static _Bool c2_tokenizer_Tokenizer_is_enabled(const c2_tokenizer_Tokenizer* t);
static token_Kind c2_tokenizer_Tokenizer_lex_preproc(c2_tokenizer_Tokenizer* t, token_Token* result);
static int64_t c2_tokenizer_Tokenizer_parse_ppexpr(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_Tokenizer_handle_if(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind);
static _Bool c2_tokenizer_Tokenizer_handle_else(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_Tokenizer_handle_endif(c2_tokenizer_Tokenizer* t, token_Token* result);
static _Bool c2_tokenizer_Tokenizer_skip_feature(c2_tokenizer_Tokenizer* t, token_Token* result);
static const char* c2_tokenizer_skip_blanks(const char* p);
static const char* c2_tokenizer_skip_string_literal(const char* p);
static const char* c2_tokenizer_skip_raw_string_literal(const char* p);
static const char* c2_tokenizer_skip_line_comment(const char* p);
static const char* c2_tokenizer_skip_block_comment(const char* p);
static uint32_t c2_tokenizer_hexconv(const char* p, uint32_t maxn, uint32_t* pc);
static uint32_t c2_tokenizer_octconv(const char* p, uint32_t maxn, uint32_t* pc);

static void c2_tokenizer_Tokenizer_init(c2_tokenizer_Tokenizer* t, string_pool_Pool* pool, string_buffer_Buf* buf, const char* input, src_loc_SrcLoc loc_start, const keywords_Info* kwinfo, const string_list_List* features, c2_tokenizer_HandlerFn on_error, c2_tokenizer_HandlerFn on_warning, void* fn_arg, _Bool raw_mode)
{
   memset(t, 0, 1448);
   t->cur = input;
   t->loc_start = loc_start;
   t->input_start = input;
   t->kwinfo = kwinfo;
   t->line_start = input;
   t->pool = pool;
   t->buf = buf;
   t->on_error = on_error;
   t->on_warning = on_warning;
   t->fn_arg = fn_arg;
   t->features = features;
   t->raw_mode = raw_mode;
}

static void c2_tokenizer_Tokenizer_lex(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   if (t->next_count) {
      memcpy(result, &t->next[t->next_head], 16);
      t->next_head = (((t->next_head + 1)) % c2_tokenizer_MaxLookahead);
      t->next_count--;
      return;
   }
   c2_tokenizer_Tokenizer_lex_internal(t, result);
}

static void c2_tokenizer_Tokenizer_lex_internal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   while (1) {
      token_Token_init(result);
      result->loc = (t->loc_start + ((src_loc_SrcLoc)((t->cur - t->input_start))));
      result->len = 1;
      c2_tokenizer_Action act = c2_tokenizer_Char_lookup[((uint8_t)(*t->cur))];
      switch (act) {
      case c2_tokenizer_Action_INVALID: {
         uint32_t len;
         uint32_t cc;
         if ((((*t->cur & 0x80)) && ((len = utf8_decode(t->cur, 4, &cc)) > 0))) {
            if (((cc == 0xfeff) && (t->cur == t->input_start))) {
               t->cur += len;
               continue;
            }
            if (t->raw_mode) {
               result->kind = token_Kind_Invalid;
               result->len = ((uint16_t)(len));
               memcpy(result->invalid, t->cur, len);
               t->cur += len;
               return;
            }
            c2_tokenizer_Tokenizer_error(t, result, "Unicode (UTF-8) is only allowed inside string literals or comments");
            return;
         }
         goto invalid_char;
      }
      case c2_tokenizer_Action_TABSPACE:
         t->cur++;
         while ((*t->cur == ' ')) t->cur++;
         continue;
      case c2_tokenizer_Action_IDENT:
         c2_tokenizer_Tokenizer_lex_identifier(t, result);
         if ((result->name_idx <= t->kwinfo->max_index)) {
            token_Kind k = t->kwinfo->indexes[result->name_idx];
            ((k != token_Kind_None)) || c2_assert("parser/c2_tokenizer.c2", 366, "c2_tokenizer.Tokenizer.lex_internal", "k != Kind.None");
            result->kind = k;
         }
         return;
      case c2_tokenizer_Action_DIGIT:
         c2_tokenizer_Tokenizer_lex_number(t, result);
         return;
      case c2_tokenizer_Action_LPAREN:
         result->kind = token_Kind_LParen;
         t->cur++;
         return;
      case c2_tokenizer_Action_RPAREN:
         result->kind = token_Kind_RParen;
         t->cur++;
         return;
      case c2_tokenizer_Action_LSQUARE:
         result->kind = token_Kind_LSquare;
         t->cur++;
         return;
      case c2_tokenizer_Action_RSQUARE:
         result->kind = token_Kind_RSquare;
         t->cur++;
         return;
      case c2_tokenizer_Action_NEWLINE:
         if (t->stop_at_eol) {
            result->kind = token_Kind_Eof;
            result->len = 0;
            return;
         }
         t->cur++;
         t->line_start = t->cur;
         continue;
      case c2_tokenizer_Action_EXCLAIM:
         t->cur++;
         if ((*t->cur == '=')) {
            result->kind = token_Kind_ExclaimEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Exclaim;
         }
         return;
      case c2_tokenizer_Action_BQUOTE:
         c2_tokenizer_Tokenizer_lex_raw_string_literal(t, result);
         return;
      case c2_tokenizer_Action_DQUOTE:
         c2_tokenizer_Tokenizer_lex_string_literal(t, result);
         return;
      case c2_tokenizer_Action_SQUOTE:
         c2_tokenizer_Tokenizer_lex_char_literal(t, result);
         return;
      case c2_tokenizer_Action_POUND:
         if (!c2_tokenizer_Tokenizer_at_bol(t)) goto invalid_char;

         if (c2_tokenizer_Tokenizer_lex_feature_cmd(t, result)) return;

         if (!c2_tokenizer_Tokenizer_is_enabled(t)) {
            if (c2_tokenizer_Tokenizer_skip_feature(t, result)) return;

         }
         continue;
      case c2_tokenizer_Action_STAR:
         t->cur++;
         if ((*t->cur == '=')) {
            result->kind = token_Kind_StarEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Star;
         }
         return;
      case c2_tokenizer_Action_PLUS:
         t->cur++;
         if ((*t->cur == '+')) {
            t->cur++;
            result->kind = token_Kind_PlusPlus;
            result->len = 2;
            return;
         }
         if ((*t->cur == '=')) {
            t->cur++;
            result->kind = token_Kind_PlusEqual;
            result->len = 2;
            return;
         }
         result->kind = token_Kind_Plus;
         return;
      case c2_tokenizer_Action_MINUS:
         t->cur++;
         if ((*t->cur == '-')) {
            t->cur++;
            result->kind = token_Kind_MinusMinus;
            result->len = 2;
            return;
         }
         if ((*t->cur == '=')) {
            t->cur++;
            result->kind = token_Kind_MinusEqual;
            result->len = 2;
            return;
         }
         if (((*t->cur == '>') && !t->raw_mode)) {
            t->cur--;
            c2_tokenizer_Tokenizer_error(t, result, "use the dot operators instead of '->'");
            return;
         }
         result->kind = token_Kind_Minus;
         return;
      case c2_tokenizer_Action_COMMA:
         result->kind = token_Kind_Comma;
         t->cur++;
         return;
      case c2_tokenizer_Action_DOT:
         t->cur++;
         if ((t->cur[0] == '.')) {
            if ((t->cur[1] == '.')) {
               t->cur += 2;
               result->kind = token_Kind_Ellipsis;
               result->len = 3;
            } else {
               result->kind = token_Kind_Dot;
            }
         } else if (isdigit(t->cur[0])) {
            c2_tokenizer_Tokenizer_lex_number(t, result);
         } else {
            result->kind = token_Kind_Dot;
         }

         return;
      case c2_tokenizer_Action_PERCENT:
         t->cur++;
         if ((*t->cur == '=')) {
            result->kind = token_Kind_PercentEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Percent;
         }
         return;
      case c2_tokenizer_Action_SLASH:
         t->cur++;
         if ((*t->cur == '=')) {
            result->kind = token_Kind_SlashEqual;
            result->len = 2;
            t->cur++;
            return;
         }
         if ((*t->cur == '/')) {
            if (c2_tokenizer_Tokenizer_lex_line_comment(t, result)) return;

            continue;
         }
         if ((*t->cur == '*')) {
            if (c2_tokenizer_Tokenizer_lex_block_comment(t, result)) return;

            continue;
         }
         result->kind = token_Kind_Slash;
         return;
      case c2_tokenizer_Action_COLON:
         result->kind = token_Kind_Colon;
         t->cur++;
         return;
      case c2_tokenizer_Action_SEMI_COLON:
         result->kind = token_Kind_Semicolon;
         t->cur++;
         return;
      case c2_tokenizer_Action_LESS:
         t->cur++;
         if ((*t->cur == '=')) {
            t->cur++;
            result->kind = token_Kind_LessEqual;
            result->len = 2;
            return;
         }
         if ((*t->cur == '<')) {
            t->cur++;
            if ((*t->cur == '=')) {
               t->cur++;
               result->kind = token_Kind_LessLessEqual;
               result->len = 3;
            } else {
               result->kind = token_Kind_LessLess;
               result->len = 2;
            }
            return;
         }
         result->kind = token_Kind_Less;
         return;
      case c2_tokenizer_Action_EQUAL:
         t->cur++;
         if ((*t->cur == '=')) {
            result->kind = token_Kind_EqualEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Equal;
         }
         return;
      case c2_tokenizer_Action_GREATER:
         t->cur++;
         if ((*t->cur == '=')) {
            t->cur++;
            result->kind = token_Kind_GreaterEqual;
            result->len = 2;
            return;
         }
         if ((*t->cur == '>')) {
            t->cur++;
            if ((*t->cur == '=')) {
               t->cur++;
               result->kind = token_Kind_GreaterGreaterEqual;
               result->len = 3;
            } else {
               result->kind = token_Kind_GreaterGreater;
               result->len = 2;
            }
            return;
         }
         result->kind = token_Kind_Greater;
         return;
      case c2_tokenizer_Action_QUESTION:
         result->kind = token_Kind_Question;
         t->cur++;
         return;
      case c2_tokenizer_Action_AT:
         result->kind = token_Kind_At;
         t->cur++;
         return;
      case c2_tokenizer_Action_AMP:
         t->cur++;
         if ((*t->cur == '&')) {
            result->kind = token_Kind_AmpAmp;
            result->len = 2;
            t->cur++;
            return;
         }
         if ((*t->cur == '=')) {
            result->kind = token_Kind_AmpEqual;
            result->len = 2;
            t->cur++;
            return;
         }
         result->kind = token_Kind_Amp;
         return;
      case c2_tokenizer_Action_CARET:
         t->cur++;
         if ((*t->cur == '=')) {
            t->cur++;
            result->kind = token_Kind_CaretEqual;
            result->len = 2;
            return;
         }
         result->kind = token_Kind_Caret;
         return;
      case c2_tokenizer_Action_LBRACE:
         result->kind = token_Kind_LBrace;
         t->cur++;
         return;
      case c2_tokenizer_Action_RBRACE:
         result->kind = token_Kind_RBrace;
         t->cur++;
         return;
      case c2_tokenizer_Action_PIPE:
         t->cur++;
         if ((*t->cur == '|')) {
            result->kind = token_Kind_PipePipe;
            result->len = 2;
            t->cur++;
            return;
         }
         if ((*t->cur == '=')) {
            result->kind = token_Kind_PipeEqual;
            result->len = 2;
            t->cur++;
            return;
         }
         result->kind = token_Kind_Pipe;
         return;
      case c2_tokenizer_Action_TILDE:
         result->kind = token_Kind_Tilde;
         t->cur++;
         return;
      case c2_tokenizer_Action_CR:
         t->cur++;
         if ((*t->cur != '\n')) {
            if (t->raw_mode) continue;

            c2_tokenizer_Tokenizer_error(t, result, "unexpected character 0x%02X after CR", (*t->cur & 0xff));
            return;
         }
         if (t->stop_at_eol) {
            result->kind = token_Kind_Eof;
            return;
         }
         t->cur++;
         t->line_start = t->cur;
         continue;
      case c2_tokenizer_Action_EOF:
         if (t->feature_count) {
            c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
            t->cur = (t->input_start + ((top->loc - t->loc_start)));
            c2_tokenizer_Tokenizer_error(t, result, "un-terminated %s", token_Kind_str(top->kind));
            return;
         }
         result->kind = token_Kind_Eof;
         result->len = 0;
         result->done = true;
         return;
      }
      invalid_char:
      if (t->raw_mode) {
         result->kind = token_Kind_Invalid;
         result->invalid[0] = *t->cur;
         t->cur += 1;
         return;
      }
      if (((*t->cur >= ' ') && (*t->cur < 0x7f))) c2_tokenizer_Tokenizer_error(t, result, "invalid char '%c'", *t->cur);
      else c2_tokenizer_Tokenizer_error(t, result, "invalid char 0x%02X", (*t->cur & 0xff));
      return;
   }
}

static token_Kind c2_tokenizer_Tokenizer_lookahead(c2_tokenizer_Tokenizer* t, uint32_t n, token_Token* tok)
{
   ((n > 0)) || c2_assert("parser/c2_tokenizer.c2", 688, "c2_tokenizer.Tokenizer.lookahead", "n > 0");
   ((n <= c2_tokenizer_MaxLookahead)) || c2_assert("parser/c2_tokenizer.c2", 689, "c2_tokenizer.Tokenizer.lookahead", "n <= MaxLookahead");
   while ((t->next_count < n)) {
      const uint32_t slot = (((t->next_head + t->next_count)) % c2_tokenizer_MaxLookahead);
      c2_tokenizer_Tokenizer_lex_internal(t, &t->next[slot]);
      t->next_count++;
   }
   uint32_t slot = ((((t->next_head + n) - 1)) % c2_tokenizer_MaxLookahead);
   if (tok) *tok = t->next[slot];
   return t->next[slot].kind;
}

__attribute__((__format__(printf, 3, 4))) 
static void c2_tokenizer_Tokenizer_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   vsnprintf(t->error_msg, 256, format, args);
   va_end(args);
   result->loc = (t->loc_start + ((src_loc_SrcLoc)((t->cur - t->input_start))));
   result->kind = token_Kind_Error;
   result->error_msg = t->error_msg;
   result->done = true;
   if (t->on_error) t->on_error(t->fn_arg, result->loc);
}

__attribute__((__format__(printf, 4, 5))) 
static void c2_tokenizer_Tokenizer_num_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   vsnprintf(t->error_msg, 256, format, args);
   va_end(args);
   result->loc = (t->loc_start + ((src_loc_SrcLoc)((p - t->input_start))));
   for (;;) {
      if (((((((*p == 'e') || (*p == 'E')) || (*p == 'p')) || (*p == 'P'))) && (((p[1] == '+') || (p[1] == '-'))))) {
         p += 2;
      } else if (((*p == '\'') && isalnum(p[1]))) {
         p += 2;
      } else if (((isalnum(*p) || (*p == '_')) || (((*p == '.') && (p[1] != '.'))))) {
         p++;
      } else {
         break;
      }


   }
   t->cur = p;
   result->len = ((uint16_t)((((p - t->input_start)) - ((result->loc - t->loc_start)))));
   if (t->on_warning) t->on_warning(t->fn_arg, result->loc);
}

static void c2_tokenizer_Tokenizer_lex_identifier(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_Identifier;
   const char* start = t->cur;
   const char* end = (t->cur + 1);
   while (c2_tokenizer_Identifier_char[((uint8_t)(*end))]) end++;
   size_t len = ((size_t)((end - start)));
   if (((len > constants_MaxIdentifierLen) && !t->raw_mode)) {
      c2_tokenizer_Tokenizer_error(t, result, "identifier too long (max %u chars)", constants_MaxIdentifierLen);
      return;
   }
   t->cur += len;
   result->name_idx = string_pool_Pool_add(t->pool, start, len, true);
   result->len = ((uint16_t)(len));
}

static uint8_t c2_tokenizer_hex2val(char c)
{
   if (((c >= '0') && (c <= '9'))) return ((uint8_t)((c - '0')));

   if (((c >= 'a') && (c <= 'f'))) return ((uint8_t)(((c - 'a') + 10)));

   return ((uint8_t)(((c - 'A') + 10)));
}

static _Bool c2_tokenizer_is_octal(char c)
{
   return (((c >= '0') && (c <= '7')));
}

static _Bool c2_tokenizer_is_binary(char c)
{
   return (((c >= '0') && (c <= '1')));
}

static void c2_tokenizer_Tokenizer_lex_number_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* qual)
{
   if (isdigit(*p)) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid digit '%c' in %s constant", *p, qual);
      return;
   }
   if ((*p == '_')) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "digit separator '%c' not surrounded by digits", *p);
      return;
   }
   if (isalpha(*p)) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid character '%c' in %s constant", *p, qual);
      return;
   }
   c2_tokenizer_Tokenizer_num_error(t, result, p, "missing digits in %s constant", qual);
}

static void c2_tokenizer_Tokenizer_lex_number(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_IntegerLiteral;
   const char* start = t->cur;
   const char* p = start;
   uint64_t value = 0;
   _Bool overflow = false;
   if ((p[0] == '0')) {
      if (((p[1] == 'x') || (p[1] == 'X'))) {
         result->radix = number_radix_Radix_Hex;
         p += 2;
         if (isxdigit(*p)) {
            while (isxdigit(*p)) {
               if ((value > (c2_max_u64 >> 4))) {
                  value = c2_max_u64;
                  overflow = true;
               } else {
                  value = (((value << 4)) + c2_tokenizer_hex2val(*p));
               }
               p++;
               if (((*p == '_') && isxdigit(p[1]))) p++;
            }
            if ((((*p == 'p') || (*p == 'P')) || (((*p == '.') && (p[1] != '.'))))) {
               c2_tokenizer_Tokenizer_lex_floating_point_hex(t, result, start);
               return;
            }
         } else {
            if ((((*p == '.') && (p[1] != '.')) && isxdigit(p[1]))) {
               c2_tokenizer_Tokenizer_lex_floating_point_hex(t, result, start);
               return;
            }
         }
         if ((((*p == '_') || isalpha(*p)) || (p == (start + 2)))) {
            c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "hexadecimal");
            return;
         }
         goto check_overflow;
      }
      if (((p[1] == 'b') || (p[1] == 'B'))) {
         result->radix = number_radix_Radix_Binary;
         p += 2;
         while (c2_tokenizer_is_binary(*p)) {
            if ((value > (c2_max_u64 >> 1))) {
               value = c2_max_u64;
               overflow = true;
            } else {
               value = (((value << 1)) + ((*p - '0')));
            }
            p++;
            if (((*p == '_') && isdigit(p[1]))) p++;
         }
         if ((((*p == '_') || isalnum(*p)) || (p == (start + 2)))) {
            c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "binary");
            return;
         }
         goto check_overflow;
      }
      while (c2_tokenizer_is_octal(*p)) {
         if ((value > (c2_max_u64 >> 3))) {
            value = c2_max_u64;
            overflow = true;
         } else {
            value = (((value << 3)) + ((*p - '0')));
         }
         p++;
         if (((*p == '_') && isdigit(p[1]))) p++;
      }
      const char* p0 = p;
      if (isdigit(*p)) {
         while ((isdigit(*p) || (((*p == '_') && isdigit(p[1]))))) p++;
      }
      if ((((*p == 'e') || (*p == 'E')) || (((*p == '.') && (p[1] != '.'))))) {
         c2_tokenizer_Tokenizer_lex_floating_point(t, result, start);
         return;
      }
      p = p0;
      if (((*p == '_') || isalnum(*p))) {
         c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "octal");
         return;
      }
      t->cur = p;
      if ((p == (start + 1))) {
         return;
      }
      result->radix = number_radix_Radix_Octal;
      goto check_overflow;
   }
   while (isdigit(*p)) {
      uint32_t digit = ((uint32_t)((*p++ - '0')));
      if (((value >= (c2_max_u64 / 10)) && (((value > (c2_max_u64 / 10)) || (digit > (c2_max_u64 % 10)))))) {
         value = c2_max_u64;
         overflow = true;
      } else {
         value = ((value * 10) + digit);
      }
      if (((*p == '_') && isdigit(p[1]))) p++;
   }
   if ((((*p == 'e') || (*p == 'E')) || (((*p == '.') && (p[1] != '.'))))) {
      c2_tokenizer_Tokenizer_lex_floating_point(t, result, start);
      return;
   }
   if (((*p == '_') || isalpha(*p))) {
      c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "decimal");
      return;
   }
   check_overflow:
   t->cur = p;
   result->int_value = value;
   result->len = ((uint16_t)((p - start)));
   if (overflow) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "integer literal is too large to be represented in any integer type");
      return;
   }
}

static void c2_tokenizer_Tokenizer_lex_floating_point(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start)
{
   char buf[4096];
   const char* p = start;
   size_t pos = 0;
   uint8_t seen_dot = 0;
   result->kind = token_Kind_FloatLiteral;
   result->float_value = 0;
   for (;;) {
      if (!isdigit(*p)) {
         if (((*p == '_') && isdigit(p[1]))) p++;
         else if (((*p != '.') || seen_dot++)) break;


      }
      buf[pos++] = *p++;
      if ((pos == 4096)) goto too_large;

   }
   if (((*p == 'e') || (*p == 'E'))) {
      if ((pos >= (4096 - 2))) goto too_large;

      buf[pos++] = *p++;
      if (((*p == '+') || (*p == '-'))) buf[pos++] = *p++;
      if (!isdigit(*p)) {
         c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid exponent in floating point constant");
         return;
      }
      while (isdigit(*p)) {
         buf[pos++] = *p++;
         if ((pos == 4096)) goto too_large;

         if (((*p == '_') && isdigit(p[1]))) p++;
      }
   }
   if (((*p == '_') || isalpha(*p))) {
      c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "floating point");
      return;
   }
   t->cur = p;
   buf[pos] = '\0';
   result->len = ((uint16_t)((p - start)));
   result->float_value = strtod(buf, NULL);
   return;
   too_large:
   c2_tokenizer_Tokenizer_num_error(t, result, p, "floating point constant too large");
   return;
}

static void c2_tokenizer_Tokenizer_lex_floating_point_hex(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start)
{
   char buf[4096];
   const char* p = start;
   size_t pos = 0;
   uint8_t seen_dot = 0;
   result->kind = token_Kind_FloatLiteral;
   result->float_value = 0;
   if (((*p == '0') && (((p[1] == 'x') || (p[1] == 'X'))))) {
      buf[pos++] = *p++;
      buf[pos++] = *p++;
   }
   for (;;) {
      if (!isxdigit(*p)) {
         if (((*p == '_') && isxdigit(p[1]))) p++;
         else if (((*p != '.') || seen_dot++)) break;


      }
      buf[pos++] = *p++;
      if ((pos == 4096)) goto too_large;

   }
   if (((*p == 'p') || (*p == 'P'))) {
      if ((pos >= (4096 - 2))) goto too_large;

      buf[pos++] = *p++;
      if (((*p == '+') || (*p == '-'))) buf[pos++] = *p++;
      if (!isdigit(*p)) {
         c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid exponent in floating point constant");
         return;
      }
      while (isdigit(*p)) {
         buf[pos++] = *p++;
         if ((pos == 4096)) goto too_large;

         if (((*p == '_') && isdigit(p[1]))) p++;
      }
   } else {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "hexadecimal floating constant requires an exponent");
      return;
   }
   if (((*p == '_') || isalpha(*p))) {
      c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "floating point");
      return;
   }
   t->cur = p;
   buf[pos] = '\0';
   result->len = ((uint16_t)((p - start)));
   result->float_value = strtod(buf, NULL);
   return;
   too_large:
   c2_tokenizer_Tokenizer_num_error(t, result, p, "floating point constant too large");
}

static uint32_t c2_tokenizer_Tokenizer_lex_escaped_char(c2_tokenizer_Tokenizer* t, token_Token* result, const char* stype)
{
   const char* p = t->cur;
   uint32_t nc = 1;
   uint32_t cc;
   char c;
   switch (c = *p) {
   case 0:
      fallthrough;
   case '\r':
      fallthrough;
   case '\n':
      c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", stype);
      return 0;
   case '0':
      fallthrough;
   case '1':
      fallthrough;
   case '2':
      fallthrough;
   case '3':
      fallthrough;
   case '4':
      fallthrough;
   case '5':
      fallthrough;
   case '6':
      fallthrough;
   case '7':
      result->radix = number_radix_Radix_Octal;
      nc = c2_tokenizer_octconv(p, 3, &cc);
      if ((cc > 255)) {
         c2_tokenizer_Tokenizer_error(t, result, "octal escape sequence out of range");
         return 0;
      }
      c = (cc & 0xff);
      goto add_char;
   case 'x':
      result->radix = number_radix_Radix_Hex;
      nc = c2_tokenizer_hexconv((p + 1), c2_max_i32, &cc);
      if ((nc == 0)) {
         c2_tokenizer_Tokenizer_error(t, result, "expect hexadecimal number after '\\x'");
         return 0;
      } else if ((nc < 2)) {
         c2_tokenizer_Tokenizer_error(t, result, "expect 2 hexadecimal digits after '\\x'");
         return 0;
      } else if ((nc > 2)) {
         c2_tokenizer_Tokenizer_error(t, result, "too many digits in hexadecimal escape sequence '\\x'");
         return 0;
      }


      nc++;
      c = (cc & 0xff);
      goto add_char;
   case 'a':
      c = '\a';
      goto add_char;
   case 'b':
      c = '\b';
      goto add_char;
   case 'f':
      c = '\f';
      goto add_char;
   case 'n':
      c = '\n';
      goto add_char;
   case 'r':
      c = '\r';
      goto add_char;
   case 't':
      c = '\t';
      goto add_char;
   case 'v':
      c = '\v';
      goto add_char;
   case '"':
      fallthrough;
   case '\'':
      fallthrough;
   case '?':
      fallthrough;
   case '\\':
      add_char:
      string_buffer_Buf_add1(t->buf, c);
      break;
   case 'u':
      result->radix = number_radix_Radix_Hex;
      nc = c2_tokenizer_hexconv((p + 1), 4, &cc);
      if ((nc != 4)) {
         c2_tokenizer_Tokenizer_error(t, result, "expect 4 hexadecimal digits after '\\u'");
         return 0;
      }
      nc++;
      goto add_utf8;
   case 'U':
      result->radix = number_radix_Radix_Hex;
      nc = c2_tokenizer_hexconv((p + 1), 8, &cc);
      if ((nc != 8)) {
         c2_tokenizer_Tokenizer_error(t, result, "expect 8 hexadecimal digits after '\\U'");
         return 0;
      }
      nc++;
      if ((cc > 0x10ffff)) {
         c2_tokenizer_Tokenizer_error(t, result, "code point value out of range: %08x", cc);
         return 0;
      }
      add_utf8:
      {
         char tab[4];
         uint32_t clen = utf8_encode(tab, 4, cc);
         string_buffer_Buf_add2(t->buf, tab, clen);
      }
      break;
   default:
      if (((c < ' ') || (c == 0x7f))) {
         c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", c, stype);
      } else if ((c < 0x80)) {
         c2_tokenizer_Tokenizer_error(t, result, "unknown escape sequence '\\%c'", c);
      } else {
         c2_tokenizer_Tokenizer_error(t, result, "invalid UTF-8 escape sequence");
      }

      nc = 0;
      break;
   }
   return nc;
}

static void c2_tokenizer_Tokenizer_lex_char_literal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_CharLiteral;
   const char* start = t->cur;
   t->cur++;
   switch (*t->cur) {
   case 0:
      fallthrough;
   case '\r':
      fallthrough;
   case '\n':
      c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", "character constant");
      return;
   case '\'':
      c2_tokenizer_Tokenizer_error(t, result, "empty character constant");
      return;
   case '\\': {
      t->cur++;
      string_buffer_Buf_clear(t->buf);
      uint32_t esc_len = c2_tokenizer_Tokenizer_lex_escaped_char(t, result, "character constant");
      if ((esc_len == 0)) {
         return;
      }
      t->cur += esc_len;
      if ((string_buffer_Buf_size(t->buf) != 1)) {
         c2_tokenizer_Tokenizer_error(t, result, "multi-character character constant");
         return;
      }
      result->char_value = *string_buffer_Buf_udata(t->buf);
      break;
   }
   default: {
      uint8_t c = *t->cur;
      uint32_t cc;
      if ((((c & 0x80)) && (utf8_decode(t->cur, 4, &cc) > 0))) {
         c2_tokenizer_Tokenizer_error(t, result, "multi-character character constant");
         return;
      } else if (((c < ' ') || (c == 0x7f))) {
         c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", c, "character constant");
         return;
      } else {
         result->char_value = c;
         t->cur += 1;
      }

      break;
   }
   }
   if ((*t->cur != '\'')) {
      if (((*t->cur != '\0') && (t->cur[1] == '\''))) {
         c2_tokenizer_Tokenizer_error(t, result, "multi-character character constant");
      } else {
         c2_tokenizer_Tokenizer_error(t, result, "missing terminating ' character (GOT %c)", *t->cur);
      }
      return;
   }
   t->cur += 1;
   result->len = ((uint16_t)((t->cur - start)));
}

static void c2_tokenizer_Tokenizer_lex_raw_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_StringLiteral;
   result->raw = 1;
   const char* start = t->cur;
   string_buffer_Buf_clear(t->buf);
   uint32_t count = 1;
   while ((*++t->cur == '`')) count++;
   const char* p = t->cur;
   const char* bol = p;
   uint32_t indent = 0;
   _Bool at_bol = false;
   if ((count >= 3)) {
      for (; (*p && (*p != '\n')); p++) {
         if (((*p == '`') && !memcmp(p, start, count))) break;

      }
      if ((*p == '\n')) {
         p++;
         t->cur = p;
         at_bol = true;
         for (;; p++) {
            for (bol = p; ((*p == ' ') || (*p == '\t')); p++) continue;
;
            indent = ((uint32_t)((p - bol)));
            if ((*p == '\r')) p++;
            if ((*p != '\n')) break;

         }
         for (p = start;;) {
            if (((p == t->input_start) || (p[-1] == '\n'))) {
               bol = p;
               indent = ((uint32_t)((start - bol)));
               break;
            }
            p--;
            if (((*p != ' ') && (*p != '\t'))) break;

         }
      }
   }
   for (p = t->cur;;) {
      if (at_bol) {
         at_bol = false;
         uint32_t i;
         for (i = 0; ((i < indent) && (p[i] == bol[i])); i++) continue;
;
         p += i;
         t->cur = p;
         if ((i < indent)) {
            if (((((*p == '\n') || (*p == '\r')) || !*p) || !strncmp(p, start, count))) continue;

            c2_tokenizer_Tokenizer_error(t, result, "raw string indentation error: expected %u %s%.*s", indent, (*bol == '\t') ? "tab" : "space", (indent > 1) ? 1 : 0, "s");
            return;
         }
      }
      while ((((*p && (*p >= ' ')) && (*p < 0x7f)) && (*p != '`'))) p++;
      string_buffer_Buf_add2(t->buf, t->cur, ((uint32_t)((p - t->cur))));
      t->cur = p;
      switch (*p) {
      case '\0':
         t->cur = start;
         c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", "raw string");
         return;
      case '\t':
         p++;
         continue;
      case '\r':
         if ((p[1] != '\n')) goto invalid;

         p++;
         fallthrough;
      case '\n':
         string_buffer_Buf_add1(t->buf, '\n');
         p++;
         t->cur = p;
         at_bol = true;
         continue;
      case '`': {
         uint32_t i;
         for (i = 1; (*++p == '`'); i++) continue;
;
         if ((i < count)) continue;

         if ((i > count)) string_buffer_Buf_add2(t->buf, t->cur, (i - count));
         t->cur += i;
         uint32_t len = string_buffer_Buf_size(t->buf);
         result->text_len = len;
         result->text_idx = string_pool_Pool_add(t->pool, string_buffer_Buf_data(t->buf), len, true);
         result->len = ((uint16_t)((t->cur - start)));
         return;
      }
      default:
         if ((*p >= 0x80)) {
            uint32_t cc;
            uint32_t nc = utf8_decode(p, 4, &cc);
            if ((nc > 0)) {
               p += nc;
               continue;
            } else {
               c2_tokenizer_Tokenizer_error(t, result, "invalid UTF-8 sequence");
               return;
            }
         }
         invalid:
         c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", *p, "raw string");
         return;
      }
   }
}

static void c2_tokenizer_Tokenizer_lex_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_StringLiteral;
   const char* start = t->cur;
   string_buffer_Buf_clear(t->buf);
   t->cur++;
   for (;;) {
      const char* p = t->cur;
      while (((((*p && (*p != '\\')) && (*p != '"')) && (*p >= ' ')) && (*p < 0x7f))) p++;
      string_buffer_Buf_add2(t->buf, t->cur, ((uint32_t)((p - t->cur))));
      t->cur = p;
      switch (*p) {
      case 0:
         fallthrough;
      case '\r':
         fallthrough;
      case '\n':
         c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", "string");
         return;
      case '"': {
         t->cur++;
         uint32_t len = string_buffer_Buf_size(t->buf);
         result->text_len = len;
         result->text_idx = string_pool_Pool_add(t->pool, string_buffer_Buf_data(t->buf), len, true);
         result->len = ((uint16_t)((t->cur - start)));
         return;
      }
      case '\\': {
         t->cur++;
         uint32_t esc_len = c2_tokenizer_Tokenizer_lex_escaped_char(t, result, "string");
         if ((esc_len == 0)) return;

         t->cur += esc_len;
         break;
      }
      default:
         if ((*p >= 0x80)) {
            uint32_t cc;
            uint32_t nc = utf8_decode(p, 4, &cc);
            if ((nc > 0)) {
               string_buffer_Buf_add2(t->buf, p, nc);
               t->cur += nc;
               break;
            } else {
               c2_tokenizer_Tokenizer_error(t, result, "invalid UTF-8 sequence");
               return;
            }
         } else {
            c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", *p, "string");
            return;
         }
         break;
      }
   }
}

static _Bool c2_tokenizer_Tokenizer_lex_line_comment(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   t->cur += 1;
   const char* start = t->cur;
   const char* end = start;
   while (*end) {
      if (((*end == '\r') || (*end == '\n'))) break;

      end++;
   }
   uint32_t len = ((uint32_t)((end - start)));
   t->cur += len;
   if (t->raw_mode) {
      result->kind = token_Kind_LineComment;
      result->text_len = len;
      result->len = ((uint16_t)((len + 2)));
      result->text_idx = string_pool_Pool_add(t->pool, start, len, false);
      return true;
   }
   return false;
}

static _Bool c2_tokenizer_Tokenizer_lex_block_comment(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   t->cur += 1;
   const char* start = t->cur;
   while (1) {
      switch (*t->cur) {
      case 0:
         c2_tokenizer_Tokenizer_error(t, result, "un-terminated block comment");
         return true;
      case '/':
         if (((t->cur[1] == '*') && !t->raw_mode)) {
            c2_tokenizer_Tokenizer_error(t, result, "'/*' within block comment");
            return true;
         }
         break;
      case '*':
         if ((t->cur[1] == '/')) {
            t->cur += 2;
            if (t->raw_mode) {
               size_t len = ((size_t)(((t->cur - start) - 2)));
               result->kind = token_Kind_BlockComment;
               result->len = ((uint16_t)((len + 2)));
               result->text_idx = string_pool_Pool_add(t->pool, start, len, false);
               return true;
            }
            return false;
         }
         break;
      default:
         break;
      }
      t->cur++;
   }
   return false;
}

static _Bool c2_tokenizer_compare_word(const char* cur, const char* expect)
{
   while (*expect) {
      if ((*cur != *expect)) return false;

      cur++;
      expect++;
   }
   return !c2_tokenizer_Identifier_char[((uint8_t)(*cur))];
}

static _Bool c2_tokenizer_Tokenizer_lex_feature_cmd(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   const char* start = t->cur;
   t->cur = c2_tokenizer_skip_blanks((t->cur + 1));
   token_Kind kind;
   for (kind = token_Kind_Feat_if; (kind < token_Kind_Invalid); kind++) {
      const char* word = (token_Kind_str(kind) + 1);
      if (c2_tokenizer_compare_word(t->cur, word)) {
         t->cur += strlen(word);
         break;
      }
   }
   result->kind = kind;
   if (t->raw_mode) {
      if ((kind == token_Kind_Invalid)) {
         result->invalid[0] = '#';
         result->invalid[1] = '\0';
         t->cur = (start + 1);
      }
      return true;
   }
   t->cur = c2_tokenizer_skip_blanks(t->cur);
   switch (kind) {
   case token_Kind_Feat_if:
      fallthrough;
   case token_Kind_Feat_ifdef:
      fallthrough;
   case token_Kind_Feat_ifndef:
      fallthrough;
   case token_Kind_Feat_elif:
      if (c2_tokenizer_Tokenizer_handle_if(t, result, kind)) return true;

      break;
   case token_Kind_Feat_else:
      if (c2_tokenizer_Tokenizer_handle_else(t, result)) return true;

      break;
   case token_Kind_Feat_endif:
      if (c2_tokenizer_Tokenizer_handle_endif(t, result)) return true;

      break;
   case token_Kind_Feat_error:
      fallthrough;
   case token_Kind_Feat_warning:
      if (!c2_tokenizer_Tokenizer_is_enabled(t)) return false;

      return c2_tokenizer_Tokenizer_parse_error_warn(t, result, kind);
   default:
      if (!c2_tokenizer_Tokenizer_is_enabled(t)) return false;

      t->cur = start;
      c2_tokenizer_Tokenizer_error(t, result, "unknown feature-selection command");
      return true;
   }
   return false;
}

static _Bool c2_tokenizer_Tokenizer_at_bol(c2_tokenizer_Tokenizer* t)
{
   const char* p = t->cur;
   while ((p > t->line_start)) {
      if (!isblank(*--p)) return false;

   }
   return true;
}

static _Bool c2_tokenizer_Tokenizer_parse_error_warn(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind)
{
   const char* start = t->cur;
   while ((((*t->cur != '\0') && (*t->cur != '\r')) && (*t->cur != '\n'))) t->cur++;
   size_t len = ((size_t)((t->cur - start)));
   if ((len > constants_MaxErrorMsgLen)) {
      c2_tokenizer_Tokenizer_error(t, result, "error msg too long (max %u bytes)", constants_MaxErrorMsgLen);
      return true;
   }
   char msg[32];
   memcpy(msg, start, len);
   msg[len] = 0;
   if ((kind == token_Kind_Feat_error)) {
      t->cur = t->line_start;
      c2_tokenizer_Tokenizer_error(t, result, "%s", msg);
   } else {
      strcpy(t->error_msg, msg);
      result->kind = token_Kind_Warning;
      result->len = ((uint16_t)((((t->cur - t->input_start)) - ((result->loc - t->loc_start)))));
      result->error_msg = t->error_msg;
   }
   return true;
}

static _Bool c2_tokenizer_Tokenizer_is_enabled(const c2_tokenizer_Tokenizer* t)
{
   return !t->feature_stack[t->feature_count].skipping;
}

static token_Kind c2_tokenizer_Tokenizer_lex_preproc(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   t->stop_at_eol = true;
   c2_tokenizer_Tokenizer_lex_internal(t, result);
   t->stop_at_eol = false;
   return result->kind;
}

static int64_t c2_tokenizer_Tokenizer_parse_ppexpr(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   c2_tokenizer_Operand stack[16];
   c2_tokenizer_Operand* sp;
   token_Kind op;
   uint8_t prec;
   int64_t val = 0;
   _Bool prefix = true;
   for (sp = stack;;) {
      op = c2_tokenizer_Tokenizer_lex_preproc(t, result);
      if (prefix) {
         switch (op) {
         case token_Kind_Identifier: {
            val = 0;
            const char* id = string_pool_Pool_idx2str(t->pool, result->name_idx);
            if (!strcmp(id, "defined")) {
               _Bool has_paren = false;
               if ((c2_tokenizer_Tokenizer_lex_preproc(t, result) == token_Kind_LParen)) {
                  has_paren = true;
                  c2_tokenizer_Tokenizer_lex_preproc(t, result);
               }
               if ((result->kind == token_Kind_Identifier)) {
                  id = string_pool_Pool_idx2str(t->pool, result->name_idx);
               } else {
                  c2_tokenizer_Tokenizer_error(t, result, "missing identifier after 'defined'");
                  return 0;
               }
               if (has_paren) {
                  if ((c2_tokenizer_Tokenizer_lex_preproc(t, result) != token_Kind_RParen)) goto syntax_error;

               }
               val = string_list_List_contains(t->features, id);
            } else {
               val = string_list_List_contains(t->features, id);
            }
            prefix = false;
            continue;
         }
         case token_Kind_IntegerLiteral:
            val = ((int64_t)(result->int_value));
            prefix = false;
            continue;
         case token_Kind_CharLiteral:
            val = result->char_value;
            prefix = false;
            continue;
         case token_Kind_LParen:
            if ((sp >= (stack + c2_tokenizer_MAX_LEVEL))) goto too_deep;

            sp->op = op;
            sp->prec = 19;
            sp++;
            continue;
         case token_Kind_Exclaim:
            fallthrough;
         case token_Kind_Plus:
            fallthrough;
         case token_Kind_Minus:
            fallthrough;
         case token_Kind_Tilde:
            if ((sp >= (stack + c2_tokenizer_MAX_LEVEL))) goto too_deep;

            sp->op = op;
            sp->prec = 1;
            sp++;
            continue;
         default:
            break;
         }
         c2_tokenizer_Tokenizer_error(t, result, "missing operand in preprocessor expression");
         return 0;
      }
      switch (op) {
      case token_Kind_Identifier:
         fallthrough;
      case token_Kind_IntegerLiteral:
         fallthrough;
      case token_Kind_CharLiteral:
         fallthrough;
      case token_Kind_LParen:
         c2_tokenizer_Tokenizer_error(t, result, "missing operator in preprocessor expression");
         return 0;
      default:
         break;
      }
      prefix = true;
      unary:
      while (((sp > stack) && (sp[-1].prec == 1))) {
         --sp;
         switch (sp->op) {
         case token_Kind_Exclaim:
            val = !val;
            break;
         case token_Kind_Plus:
            break;
         case token_Kind_Minus:
            val = -val;
            break;
         case token_Kind_Tilde:
            val = ~val;
            break;
         default:
            break;
         }
      }
      switch (op) {
      case token_Kind_None:
         prefix = false;
         continue;
      case token_Kind_Eof:
         prec = 20;
         break;
      case token_Kind_RParen:
         prec = 19;
         break;
      case token_Kind_Star:
         fallthrough;
      case token_Kind_Slash:
         fallthrough;
      case token_Kind_Percent:
         prec = 3;
         break;
      case token_Kind_Plus:
         fallthrough;
      case token_Kind_Minus:
         prec = 4;
         break;
      case token_Kind_LessLess:
         fallthrough;
      case token_Kind_GreaterGreater:
         prec = 5;
         break;
      case token_Kind_Less:
         fallthrough;
      case token_Kind_LessEqual:
         fallthrough;
      case token_Kind_Greater:
         fallthrough;
      case token_Kind_GreaterEqual:
         prec = 6;
         break;
      case token_Kind_EqualEqual:
         fallthrough;
      case token_Kind_ExclaimEqual:
         prec = 7;
         break;
      case token_Kind_Amp:
         prec = 8;
         break;
      case token_Kind_Caret:
         prec = 9;
         break;
      case token_Kind_Pipe:
         prec = 10;
         break;
      case token_Kind_AmpAmp:
         prec = 11;
         break;
      case token_Kind_PipePipe:
         prec = 12;
         break;
      case token_Kind_Question:
         fallthrough;
      case token_Kind_Colon:
         prec = 13;
         break;
      default:
         c2_tokenizer_Tokenizer_error(t, result, "invalid token in preprocessor expression '%s'", token_Kind_str(result->kind));
         return 0;
      }
      while (((sp > stack) && (prec >= sp[-1].prec))) {
         sp--;
         switch (sp->op) {
         case token_Kind_LParen:
            if ((op != token_Kind_RParen)) {
               c2_tokenizer_Tokenizer_error(t, result, "missing parenthesis in preprocessor expression");
               return 0;
            }
            op = token_Kind_None;
            goto unary;
         case token_Kind_Star:
            val = (sp->val * val);
            continue;
         case token_Kind_Slash:
            if (val) val = (sp->val / val);
            continue;
         case token_Kind_Percent:
            if ((val && !(((sp->val == c2_min_i64) && (val == -1))))) val = (sp->val % val);
            continue;
         case token_Kind_Plus:
            val = (sp->val + val);
            continue;
         case token_Kind_Minus:
            val = (sp->val - val);
            continue;
         case token_Kind_LessLess:
            val = (sp->val << val);
            continue;
         case token_Kind_GreaterGreater:
            val = (sp->val >> val);
            continue;
         case token_Kind_Less:
            val = (sp->val < val);
            continue;
         case token_Kind_LessEqual:
            val = (sp->val <= val);
            continue;
         case token_Kind_Greater:
            val = (sp->val > val);
            continue;
         case token_Kind_GreaterEqual:
            val = (sp->val >= val);
            continue;
         case token_Kind_EqualEqual:
            val = (sp->val == val);
            continue;
         case token_Kind_ExclaimEqual:
            val = (sp->val != val);
            continue;
         case token_Kind_Amp:
            val = (sp->val & val);
            continue;
         case token_Kind_Caret:
            val = (sp->val ^ val);
            continue;
         case token_Kind_Pipe:
            val = (sp->val | val);
            continue;
         case token_Kind_AmpAmp:
            val = (sp->val && val);
            continue;
         case token_Kind_PipePipe:
            val = (sp->val || val);
            continue;
         case token_Kind_Colon:
            if (((sp > stack) && (sp[-1].op == token_Kind_Question))) {
               sp--;
               val = sp->val ? sp[1].val : val;
               continue;
            }
            fallthrough;
         default:
            c2_tokenizer_Tokenizer_error(t, result, "invalid token in preprocessor expression '%s'", token_Kind_str(sp->op));
            return 0;
         }
         break;
      }
      if ((op == token_Kind_Eof)) break;

      if ((sp >= (stack + c2_tokenizer_MAX_LEVEL))) {
         too_deep:
         c2_tokenizer_Tokenizer_error(t, result, "preprocessor expression too complex");
         return 0;
      }
      sp->val = val;
      sp->op = op;
      sp->prec = prec;
      sp++;
   }
   if ((sp > stack)) {
      syntax_error:
      c2_tokenizer_Tokenizer_error(t, result, "syntax error in preprocessor expression");
      return 0;
   }
   return val;
}

static _Bool c2_tokenizer_Tokenizer_handle_if(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind)
{
   c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
   if ((((kind == token_Kind_Feat_if) || (kind == token_Kind_Feat_ifdef)) || (kind == token_Kind_Feat_ifndef))) {
      if ((t->feature_count >= constants_MaxFeatureDepth)) {
         c2_tokenizer_Tokenizer_error(t, result, "feature nesting too much");
         return true;
      }
      t->feature_count++;
      top++;
      top->kind = kind;
      top->loc = result->loc;
      top->is_else = false;
      top->skipping = 0;
      if (top[-1].skipping) {
         top->skipping = 2;
         return false;
      }
   } else {
      if ((t->feature_count == 0)) {
         c2_tokenizer_Tokenizer_error(t, result, "%s without #if", token_Kind_str(kind));
         return true;
      }
      if (top->is_else) {
         c2_tokenizer_Tokenizer_error(t, result, "%s in #else", token_Kind_str(kind));
         return true;
      }
      top->skipping ^= 1;
      if (top->skipping) {
         top->skipping = 2;
         return false;
      }
   }
   if (((kind == token_Kind_Feat_if) || (kind == token_Kind_Feat_elif))) {
      if (!c2_tokenizer_Tokenizer_parse_ppexpr(t, result)) top->skipping = 1;
   } else {
      if ((c2_tokenizer_Tokenizer_lex_preproc(t, result) == token_Kind_Identifier)) {
         if (!string_list_List_contains(t->features, string_pool_Pool_idx2str(t->pool, result->name_idx))) top->skipping = 1;
         if ((kind == token_Kind_Feat_ifndef)) top->skipping ^= 1;
      } else {
         c2_tokenizer_Tokenizer_error(t, result, "missing identifier after %s, got %s", token_Kind_str(kind), token_Kind_str(result->kind));
         return true;
      }
   }
   return false;
}

static _Bool c2_tokenizer_Tokenizer_handle_else(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   if ((t->feature_count == 0)) {
      c2_tokenizer_Tokenizer_error(t, result, "#else without #if");
      return true;
   }
   c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
   if (top->is_else) {
      c2_tokenizer_Tokenizer_error(t, result, "#else in #else");
      return true;
   }
   top->is_else = true;
   top->skipping ^= 1;
   return false;
}

static _Bool c2_tokenizer_Tokenizer_handle_endif(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   if ((t->feature_count == 0)) {
      c2_tokenizer_Tokenizer_error(t, result, "#endif without #if");
      return true;
   }
   t->feature_count--;
   return false;
}

static _Bool c2_tokenizer_Tokenizer_skip_feature(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   const char* p = t->cur;
   for (;;) {
      switch (*p++) {
      case '\0': {
         c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
         t->cur = (t->input_start + ((top->loc - t->loc_start)));
         c2_tokenizer_Tokenizer_error(t, result, "un-terminated %s", token_Kind_str(top->kind));
         return true;
      }
      case '\n':
         t->line_start = p;
         break;
      case '#':
         t->cur = (p - 1);
         if (!c2_tokenizer_Tokenizer_at_bol(t)) break;

         if (c2_tokenizer_Tokenizer_lex_feature_cmd(t, result)) return true;

         if (c2_tokenizer_Tokenizer_is_enabled(t)) return false;

         p = t->cur;
         break;
      case '"':
         fallthrough;
      case '\'':
         p = c2_tokenizer_skip_string_literal((p - 1));
         break;
      case '`':
         p = c2_tokenizer_skip_raw_string_literal((p - 1));
         break;
      case '/':
         if ((*p == '/')) {
            p = c2_tokenizer_skip_line_comment((p + 1));
            break;
         }
         if ((*p == '*')) {
            p = c2_tokenizer_skip_block_comment((p + 1));
            break;
         }
         break;
      }
   }
   return false;
}

static const char* c2_tokenizer_skip_blanks(const char* p)
{
   while (isblank(*p)) p++;
   return p;
}

static const char* c2_tokenizer_skip_string_literal(const char* p)
{
   char sep = *p++;
   for (;;) {
      switch (*p++) {
      case '\0':
         fallthrough;
      case '\n':
         return (p - 1);
      case '\r':
         return p;
      case '"':
         fallthrough;
      case '\'':
         if ((p[-1] == sep)) return p;

         break;
      case '\\':
         if (((*p == sep) || (*p == '\\'))) p++;
         break;
      }
   }
   return p;
}

static const char* c2_tokenizer_skip_raw_string_literal(const char* p)
{
   uint32_t count;
   for (count = 0; (*p == '`'); count++) p++;
   while (*p) {
      if ((*p++ == '`')) {
         uint32_t i;
         for (i = 1; (*p == '`'); i++) p++;
         if ((i >= count)) break;

      }
   }
   return p;
}

static const char* c2_tokenizer_skip_line_comment(const char* p)
{
   while ((((*p != '\0') && (*p != '\r')) && (*p != '\n'))) p++;
   return p;
}

static const char* c2_tokenizer_skip_block_comment(const char* p)
{
   while ((*p != '\0')) {
      if (((*p == '*') && (p[1] == '/'))) {
         p += 2;
         break;
      }
      p++;
   }
   return p;
}

static uint32_t c2_tokenizer_hexconv(const char* p, uint32_t maxn, uint32_t* pc)
{
   uint32_t cc = 0;
   uint32_t i;
   for (i = 0; (i < maxn); i++) {
      int32_t xval = 0;
      char c = p[i];
      if (((c >= '0') && (c <= '9'))) xval = (c - '0');
      else if (((c >= 'a') && (c <= 'f'))) xval = ((c - 'a') + 10);
      else if (((c >= 'A') && (c <= 'F'))) xval = ((c - 'A') + 10);
      else break;



      cc = ((cc * 16) + xval);
   }
   *pc = cc;
   return i;
}

static uint32_t c2_tokenizer_octconv(const char* p, uint32_t maxn, uint32_t* pc)
{
   uint32_t cc = 0;
   uint32_t i;
   for (i = 0; (i < maxn); i++) {
      char c = p[i];
      if (((c >= '0') && (c <= '7'))) cc = ((cc * 8) + ((c - '0')));
      else break;

   }
   *pc = cc;
   return i;
}


// --- module plugin_info ---
typedef struct plugin_info_Info_ plugin_info_Info;
typedef struct plugin_info_Plugin_ plugin_info_Plugin;

typedef _Bool (*plugin_info_RegisterAttrFn)(void* arg, uint32_t name, ast_AttrHandlerFn func, void* arg2);

typedef void (*plugin_info_AddSourceFn)(void* arg, const char* name, string_buffer_Buf* content);

struct plugin_info_Info_ {
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   build_target_Target* target;
   component_List* components;
   string_pool_Pool* astPool;
   string_pool_Pool* auxPool;
   ast_context_Context* context;
   ast_builder_Builder* builder;
   ast_Globals* ast_globals;
   ast_QualType* ast_builtins;
   plugin_info_AddSourceFn addSource;
   plugin_info_RegisterAttrFn register_attr;
   void* fn_arg;
   char target_name[32];
   char output_dir[256];
};

typedef void* (*plugin_info_LoadFn)(const char* options, _Bool console_timing, _Bool console_debug);

typedef void (*plugin_info_UnloadFn)(void* arg);

typedef void (*plugin_info_InitFn)(void* arg, plugin_info_Info* info);

typedef void (*plugin_info_PostParseFn)(void* arg);

typedef void (*plugin_info_PostAnalysisFn)(void* arg);

struct plugin_info_Plugin_ {
   plugin_info_LoadFn load;
   plugin_info_UnloadFn unload;
   plugin_info_InitFn init;
   plugin_info_PostParseFn post_parse;
   plugin_info_PostAnalysisFn post_analysis;
   const char* name;
};

static _Bool plugin_info_Info_registerAttr(plugin_info_Info* info, uint32_t name, ast_AttrHandlerFn func, void* arg);

static _Bool plugin_info_Info_registerAttr(plugin_info_Info* info, uint32_t name, ast_AttrHandlerFn func, void* arg)
{
   return info->register_attr(info->fn_arg, name, func, arg);
}


// --- module conversion_checker ---
typedef struct conversion_checker_Checker_ conversion_checker_Checker;
typedef struct conversion_checker_ExprWidth_ conversion_checker_ExprWidth;

struct conversion_checker_Checker_ {
   diagnostics_Diags* diags;
   ast_builder_Builder* builder;
   src_loc_SrcLoc loc;
   ast_QualType lhs;
   ast_QualType rhs;
   ast_Expr** expr_ptr;
};

static const uint8_t conversion_checker_Conversions[8][8] = {
   {
   2,
   3,
   1,
   1,
   13,
   15,
   0,
   0
},
   {
   4,
   5,
   1,
   1,
   1,
   6,
   0,
   0
},
   {
   1,
   7,
   8,
   1,
   1,
   1,
   0,
   0
},
   {
   1,
   1,
   1,
   9,
   1,
   1,
   0,
   0
},
   {
   10,
   1,
   1,
   1,
   14,
   1,
   0,
   0
},
   {
   16,
   11,
   1,
   1,
   1,
   12,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
}
};

static const uint8_t conversion_checker_BuiltinConversions[15][15] = {
   {
   0,
   3,
   1,
   1,
   1,
   7,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   7,
   2
},
   {
   3,
   0,
   1,
   1,
   1,
   3,
   3,
   3,
   3,
   1,
   1,
   1,
   3,
   7,
   2
},
   {
   4,
   4,
   0,
   1,
   1,
   3,
   3,
   3,
   3,
   1,
   1,
   1,
   3,
   7,
   2
},
   {
   4,
   4,
   4,
   0,
   1,
   3,
   3,
   3,
   3,
   1,
   1,
   1,
   3,
   7,
   2
},
   {
   4,
   4,
   4,
   4,
   0,
   3,
   3,
   3,
   3,
   1,
   1,
   7,
   3,
   7,
   2
},
   {
   1,
   3,
   3,
   3,
   3,
   0,
   1,
   1,
   1,
   1,
   1,
   3,
   1,
   7,
   2
},
   {
   4,
   4,
   3,
   3,
   3,
   4,
   0,
   1,
   1,
   1,
   1,
   3,
   1,
   7,
   2
},
   {
   4,
   4,
   4,
   3,
   3,
   4,
   4,
   0,
   1,
   1,
   1,
   3,
   1,
   7,
   2
},
   {
   4,
   4,
   4,
   4,
   3,
   4,
   4,
   4,
   0,
   1,
   1,
   3,
   7,
   7,
   2
},
   {
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   0,
   1,
   5,
   5,
   2,
   2
},
   {
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   6,
   0,
   5,
   5,
   2,
   2
},
   {
   4,
   4,
   4,
   4,
   7,
   4,
   4,
   4,
   3,
   1,
   1,
   0,
   3,
   7,
   2
},
   {
   4,
   4,
   4,
   4,
   3,
   4,
   4,
   4,
   7,
   1,
   1,
   3,
   0,
   7,
   2
},
   {
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   0,
   2
},
   {
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   2,
   0
}
};

static const uint8_t conversion_checker_ConditionalOperatorResult[15][15] = {
   {
   0,
   2,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   0,
   14
},
   {
   2,
   1,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   1,
   14
},
   {
   2,
   2,
   2,
   3,
   4,
   2,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   2,
   14
},
   {
   3,
   3,
   3,
   3,
   4,
   3,
   3,
   7,
   8,
   9,
   10,
   11,
   12,
   3,
   14
},
   {
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   8,
   9,
   10,
   11,
   12,
   4,
   14
},
   {
   5,
   5,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   5,
   14
},
   {
   6,
   6,
   6,
   3,
   4,
   6,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   6,
   14
},
   {
   7,
   7,
   7,
   7,
   7,
   7,
   7,
   7,
   8,
   9,
   10,
   11,
   12,
   7,
   14
},
   {
   8,
   8,
   8,
   8,
   8,
   8,
   8,
   8,
   8,
   9,
   10,
   11,
   12,
   8,
   14
},
   {
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   10,
   9,
   9,
   9,
   14
},
   {
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   14
},
   {
   11,
   11,
   11,
   11,
   11,
   11,
   11,
   11,
   8,
   9,
   10,
   11,
   12,
   11,
   14
},
   {
   12,
   12,
   12,
   12,
   12,
   12,
   12,
   12,
   8,
   9,
   10,
   12,
   12,
   12,
   14
},
   {
   0,
   1,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   13,
   14
},
   {
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14,
   14
}
};

static const uint8_t conversion_checker_UsualArithmeticConversions[15][15] = {
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   2,
   2,
   2,
   3,
   2,
   2,
   2,
   2,
   3,
   4,
   5,
   6,
   6,
   2,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   1,
   1,
   1,
   1,
   3,
   1,
   1,
   1,
   3,
   4,
   5,
   6,
   6,
   1,
   6
},
   {
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   4,
   5,
   6,
   6,
   3,
   6
},
   {
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   5,
   4,
   4,
   4,
   6
},
   {
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   6
},
   {
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   3,
   4,
   5,
   6,
   6,
   6,
   6
},
   {
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   4,
   5,
   6,
   6,
   6,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0,
   6
},
   {
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6
}
};

static void conversion_checker_Checker_init(conversion_checker_Checker* c, diagnostics_Diags* diags, ast_builder_Builder* builder);
static _Bool conversion_checker_Checker_check(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, ast_Expr** e_ptr, src_loc_SrcLoc loc);
static _Bool conversion_checker_Checker_checkTypes(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkBuiltins(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkBuiltin2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkPointer2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkPointer2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkIntConversion(conversion_checker_Checker* c, const ast_BuiltinType* bi);
static _Bool conversion_checker_Checker_try_to_fix_type(conversion_checker_Checker* c);
static _Bool conversion_checker_pointer_conversion_allowed(ast_QualType linner, ast_QualType rinner);
static _Bool conversion_checker_Checker_checkPointers(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkFunc2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkEnum2Int(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkFunc2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_checkFunc2Func(const ast_FunctionDecl* fdl, const ast_FunctionDecl* fdr);
static _Bool conversion_checker_Checker_checkFunc2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon, _Bool* other_error);
static _Bool conversion_checker_Checker_checkCast(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, src_loc_SrcLoc lhsLoc, src_loc_SrcLoc rhsLoc);
static _Bool conversion_checker_Checker_checkBuiltin2PointerCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static _Bool conversion_checker_Checker_checkPointer2BuiltinCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static ast_QualType conversion_checker_get_common_arithmetic_type(ast_QualType t1, ast_QualType t2);
static ast_QualType conversion_checker_usual_arithmetic_conversion(const ast_BuiltinType* b1, const ast_BuiltinType* b2);
struct conversion_checker_ExprWidth_ {
   uint8_t width;
   _Bool is_signed;
};

static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeSmaller(conversion_checker_ExprWidth* w1, conversion_checker_ExprWidth* w2);
static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeWider(conversion_checker_ExprWidth* w1, conversion_checker_ExprWidth* w2);
static conversion_checker_ExprWidth conversion_checker_getExprWidth(const ast_Expr* e);
static conversion_checker_ExprWidth conversion_checker_getCondOpWidth(const ast_ConditionalOperator* c);
static conversion_checker_ExprWidth conversion_checker_getUnaryOpWidth(const ast_UnaryOperator* u);
static conversion_checker_ExprWidth conversion_checker_getBinOpWidth(const ast_BinaryOperator* b);
static conversion_checker_ExprWidth conversion_checker_getTypeWidth(ast_QualType qt);

static void conversion_checker_Checker_init(conversion_checker_Checker* c, diagnostics_Diags* diags, ast_builder_Builder* builder)
{
   c->diags = diags;
   c->builder = builder;
}

static _Bool conversion_checker_Checker_check(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, ast_Expr** e_ptr, src_loc_SrcLoc loc)
{
   (lhs.ptr) || c2_assert("analyser/conversion_checker.c2", 123, "conversion_checker.Checker.check", "lhs.ptr");
   (rhs.ptr) || c2_assert("analyser/conversion_checker.c2", 124, "conversion_checker.Checker.check", "rhs.ptr");
   (!ast_Expr_isNValue((*e_ptr))) || c2_assert("analyser/conversion_checker.c2", 125, "conversion_checker.Checker.check", "!(*e_ptr).isNValue()");
   ast_QualType t1 = ast_QualType_getCanonicalType(&lhs);
   ast_QualType t2 = ast_QualType_getCanonicalType(&rhs);
   if (((ast_Expr_isCtv((*e_ptr)) && ast_QualType_isBuiltin(&t1)) && !ast_QualType_isPointer(&t2))) {
      if (ast_QualType_isBool(&t1)) return true;

      return ctv_analyser_check(c->diags, lhs, *e_ptr);
   }
   const ast_Type* lcanon = ast_QualType_getTypeOrNil(&t1);
   const ast_Type* rcanon = ast_QualType_getTypeOrNil(&t2);
   if ((lcanon == rcanon)) {
      if ((((ast_Type_getKind(lcanon) == ast_TypeKind_Pointer) && ast_QualType_isConst(&rhs)) && !ast_QualType_isConst(&lhs))) {
         diagnostics_Diags_error(c->diags, loc, "conversion discards const qualifier");
         return false;
      }
      return true;
   }
   c->lhs = lhs;
   c->rhs = rhs;
   c->expr_ptr = e_ptr;
   c->loc = loc;
   return conversion_checker_Checker_checkTypes(c, lcanon, rcanon);
}

static _Bool conversion_checker_Checker_checkTypes(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   uint8_t res = conversion_checker_Conversions[ast_Type_getKind(rcanon)][ast_Type_getKind(lcanon)];
   switch (res) {
   case 0:
      diagnostics_Diags_error(c->diags, c->loc, "SHOULD NOT HAPPEN (%u - %u)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ast_QualType_dump_full(&c->lhs);
      ast_QualType_dump_full(&c->rhs);
      (0) || c2_assert("analyser/conversion_checker.c2", 169, "conversion_checker.Checker.checkTypes", "0");
      return false;
   case 1:
      diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 2:
      return conversion_checker_Checker_checkBuiltins(c, lcanon, rcanon);
   case 3:
      return conversion_checker_Checker_checkBuiltin2Pointer(c, lcanon, rcanon);
   case 4:
      return conversion_checker_Checker_checkPointer2Builtin(c, lcanon, rcanon);
   case 5:
      return conversion_checker_Checker_checkPointers(c, lcanon, rcanon);
   case 6:
      return conversion_checker_Checker_checkPointer2Func(c, lcanon, rcanon);
   case 7:
      diagnostics_Diags_note(c->diags, c->loc, "SHOULD NOT HAPPEN (Array -> Ptr)");
      ast_QualType_dump_full(&c->lhs);
      ast_QualType_dump_full(&c->rhs);
      (0) || c2_assert("analyser/conversion_checker.c2", 188, "conversion_checker.Checker.checkTypes", "0");
      return false;
   case 8:
      diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 9:
      diagnostics_Diags_error(c->diags, c->loc, "conversion between struct of different types ('%s' to '%s')", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 10:
      return conversion_checker_Checker_checkEnum2Int(c, lcanon, rcanon);
   case 11:
      return conversion_checker_Checker_checkFunc2Pointer(c, lcanon, rcanon);
   case 12:
      return conversion_checker_Checker_checkFunc2Func(c, lcanon, rcanon);
   case 13:
      diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 14:
      diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 15:
      diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 16: {
      _Bool other = false;
      _Bool ok = conversion_checker_Checker_checkFunc2Builtin(c, lcanon, rcanon, &other);
      if ((!ok && !other)) {
         diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      }
      return ok;
   }
   default:
      diagnostics_Diags_note(c->diags, c->loc, "TODO CONVERSION  %u)", res);
      return false;
   }
   return true;
}

static _Bool conversion_checker_Checker_checkBuiltins(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* lbuiltin = ((ast_BuiltinType*)(lcanon));
   const ast_BuiltinType* rbuiltin = ((ast_BuiltinType*)(rcanon));
   if (ast_Expr_isCtv((*c->expr_ptr))) {
      return true;
   }
   uint8_t res = conversion_checker_BuiltinConversions[ast_BuiltinType_getKind(rbuiltin)][ast_BuiltinType_getKind(lbuiltin)];
   switch (res) {
   case 0:
      printf("BUILTIN SHOULD NOT HAPPEN (%u - %u)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      (0) || c2_assert("analyser/conversion_checker.c2", 241, "conversion_checker.Checker.checkBuiltins", "0");
      return false;
   case 1:
      ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      break;
   case 2:
      diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 3:
      if (conversion_checker_Checker_checkIntConversion(c, lbuiltin)) {
         ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      } else {
         diagnostics_Diags_error(c->diags, c->loc, "implicit conversion changes signedness: '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      }
      break;
   case 4:
      if (conversion_checker_Checker_checkIntConversion(c, lbuiltin)) {
         ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      } else {
         ast_Expr* e = *c->expr_ptr;
         diagnostics_Diags_errorRange(c->diags, c->loc, ast_Expr_getRange(e), "implicit conversion loses integer precision: '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      }
      break;
   case 5:
      diagnostics_Diags_error(c->diags, c->loc, "implicit conversion turns floating-point number into integer: '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      break;
   case 6:
      diagnostics_Diags_error(c->diags, c->loc, "implicit conversion loses floating-point precision: '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      break;
   case 7:
      break;
   default:
      (0) || c2_assert("analyser/conversion_checker.c2", 274, "conversion_checker.Checker.checkBuiltins", "0");
      return false;
   }
   return true;
}

static _Bool conversion_checker_Checker_checkBuiltin2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_PointerType* ptr = ((ast_PointerType*)(lcanon));
   const ast_BuiltinType* bi = ((ast_BuiltinType*)(rcanon));
   ast_QualType inner = ast_PointerType_getInner(ptr);
   _Bool ok = ast_QualType_isVoid(&inner);
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   ok &= (((kind == ast_BuiltinKind_USize) || (kind == ast_BuiltinKind_UInt64)));
   if (!ok) {
      diagnostics_Diags_error(c->diags, c->loc, "incompatible integer to pointer conversion: '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   }
   return true;
}

static _Bool conversion_checker_Checker_checkPointer2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* bi = ((ast_BuiltinType*)(lcanon));
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if ((kind == ast_BuiltinKind_Bool)) {
      ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_PointerToBoolean, c->expr_ptr, ast_builtins[ast_BuiltinKind_Bool]);
      return true;
   }
   const ast_PointerType* ptr = ((ast_PointerType*)(rcanon));
   ast_QualType inner = ast_PointerType_getInner(ptr);
   _Bool ok = ast_QualType_isVoid(&inner);
   ok &= (((kind == ast_BuiltinKind_USize) || (kind == ast_BuiltinKind_UInt64)));
   if (!ok) {
      if (conversion_checker_Checker_try_to_fix_type(c)) {
         diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      } else {
         diagnostics_Diags_error(c->diags, c->loc, "incompatible pointer to integer conversion: '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      }
      return false;
   }
   ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_PointerToInteger, c->expr_ptr, ast_builtins[ast_BuiltinKind_USize]);
   return true;
}

static _Bool conversion_checker_Checker_checkPointer2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_PointerType* ptr = ((ast_PointerType*)(rcanon));
   ast_QualType inner = ast_PointerType_getInner(ptr);
   if (!ast_QualType_isVoid(&inner)) {
      diagnostics_Diags_error(c->diags, c->loc, "incompatible pointer to function conversion '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   }
   ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_BitCast, c->expr_ptr, c->lhs);
   return true;
}

static _Bool conversion_checker_Checker_checkIntConversion(conversion_checker_Checker* c, const ast_BuiltinType* bi)
{
   ast_Expr* e = *c->expr_ptr;
   const uint8_t wl = ((uint8_t)(ast_BuiltinType_getWidth(bi)));
   conversion_checker_ExprWidth w = conversion_checker_getExprWidth(e);
   if ((w.is_signed == ast_BuiltinType_isSigned(bi))) {
      return ((w.width <= wl));
   } else {
      if (w.is_signed) return false;

      return (w.width <= wl);
   }
   return false;
}

static _Bool conversion_checker_Checker_try_to_fix_type(conversion_checker_Checker* c)
{
   ast_Expr* e = *c->expr_ptr;
   if (ast_Expr_isImplicitCast(e)) {
      const ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
      if (ast_ImplicitCastExpr_isArrayToPointerDecay(ic)) {
         e = ast_ImplicitCastExpr_getInner(ic);
         c->rhs = ast_Expr_getType(e);
         return true;
      }
   }
   return false;
}

static _Bool conversion_checker_pointer_conversion_allowed(ast_QualType linner, ast_QualType rinner)
{
   const ast_Type* in1 = ast_QualType_getTypeOrNil(&linner);
   const ast_Type* in2 = ast_QualType_getTypeOrNil(&rinner);
   if ((in1 == in2)) return true;

   if (ast_Type_isVoidType(in1)) return true;

   if (ast_Type_isVoidType(in2)) return true;

   if ((ast_QualType_isUInt8(&linner) && ast_QualType_isChar(&rinner))) return true;

   if ((ast_QualType_isChar(&linner) && ast_QualType_isUInt8(&rinner))) return true;

   return false;
}

static _Bool conversion_checker_Checker_checkPointers(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_PointerType* ltype = ((ast_PointerType*)(lcanon));
   const ast_PointerType* rtype = ((ast_PointerType*)(rcanon));
   ast_QualType linner = ast_PointerType_getInner(ltype);
   ast_QualType rinner = ast_PointerType_getInner(rtype);
   if (!conversion_checker_pointer_conversion_allowed(linner, rinner)) {
      if (conversion_checker_Checker_try_to_fix_type(c)) {
         diagnostics_Diags_error(c->diags, c->loc, "invalid type conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      } else {
         diagnostics_Diags_error(c->diags, c->loc, "invalid pointer conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      }
      return false;
   }
   uint32_t rquals = ast_QualType_getQuals(&rinner);
   if ((rquals == 0)) return true;

   uint32_t lquals = ast_QualType_getQuals(&linner);
   if (((((~lquals) & rquals)) & 0x3)) {
      diagnostics_Diags_error(c->diags, c->loc, "pointer conversion discards const qualifier");
      return false;
   }
   return true;
}

static _Bool conversion_checker_Checker_checkFunc2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   ast_PointerType* pt = ((ast_PointerType*)(lcanon));
   ast_QualType inner = ast_PointerType_getInner(pt);
   if (ast_QualType_isVoid(&inner)) return true;

   diagnostics_Diags_error(c->diags, c->loc, "invalid pointer conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
   return false;
}

static _Bool conversion_checker_Checker_checkEnum2Int(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* bi = ((ast_BuiltinType*)(lcanon));
   uint32_t width = ast_BuiltinType_getWidth(bi);
   if ((width == 64)) return true;

   if (ast_Expr_isCtv((*c->expr_ptr))) {
      return ctv_analyser_check(c->diags, c->lhs, *c->expr_ptr);
   } else {
      const ast_EnumType* et = ((ast_EnumType*)(rcanon));
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_QualType impl = ast_EnumTypeDecl_getImplType(etd);
      return conversion_checker_Checker_check(c, c->lhs, impl, c->expr_ptr, c->loc);
   }
   return true;
}

static _Bool conversion_checker_Checker_checkFunc2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   ast_FunctionType* ftl = ((ast_FunctionType*)(lcanon));
   ast_FunctionDecl* fdl = ast_FunctionType_getDecl(ftl);
   ast_FunctionType* ftr = ((ast_FunctionType*)(rcanon));
   ast_FunctionDecl* fdr = ast_FunctionType_getDecl(ftr);
   if (ast_FunctionDecl_getNumAutoArgs(fdr)) {
      diagnostics_Diags_error(c->diags, c->loc, "functions used as function pointers cannot have auto-arguments");
      return false;
   }
   if (!conversion_checker_checkFunc2Func(fdl, fdr)) {
      diagnostics_Diags_error(c->diags, c->loc, "invalid function conversion from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   }
   return true;
}

static _Bool conversion_checker_checkFunc2Func(const ast_FunctionDecl* fdl, const ast_FunctionDecl* fdr)
{
   ast_QualType ql = ast_FunctionDecl_getRType(fdl);
   ast_QualType qr = ast_FunctionDecl_getRType(fdr);
   if ((ql.ptr != qr.ptr)) return false;

   uint32_t num1 = ast_FunctionDecl_getNumParams(fdl);
   uint32_t num2 = ast_FunctionDecl_getNumParams(fdr);
   if ((num1 != num2)) return false;

   ast_Decl** args1 = ((ast_Decl**)(ast_FunctionDecl_getParams(fdl)));
   ast_Decl** args2 = ((ast_Decl**)(ast_FunctionDecl_getParams(fdr)));
   for (uint32_t i = 0; (i < num1); i++) {
      ast_Decl* a1 = args1[i];
      ast_Decl* a2 = args2[i];
      ql = ast_Decl_getType(a1);
      qr = ast_Decl_getType(a2);
      if ((ql.ptr != qr.ptr)) return false;

   }
   if ((ast_FunctionDecl_isVariadic(fdl) != ast_FunctionDecl_isVariadic(fdr))) return false;

   return true;
}

static _Bool conversion_checker_Checker_checkFunc2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon, _Bool* other_error)
{
   uint32_t wordsize = ast_getWordSize();
   const ast_BuiltinType* bi = ((ast_BuiltinType*)(lcanon));
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if ((kind == ast_BuiltinKind_USize)) return true;

   if ((kind == ast_BuiltinKind_Bool)) {
      ast_FunctionType* ft = ((ast_FunctionType*)(rcanon));
      ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      if ((ast_FunctionDecl_isType(fd) || ast_FunctionDecl_hasAttrWeak(fd))) return true;

      diagnostics_Diags_error(c->diags, c->loc, "comparison of function '%s' will always be true", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      *other_error = true;
      return false;
   }
   if (((wordsize == 4) && (kind == ast_BuiltinKind_UInt32))) return true;

   if (((wordsize == 8) && (kind == ast_BuiltinKind_UInt64))) return true;

   return false;
}

static _Bool conversion_checker_Checker_checkCast(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, src_loc_SrcLoc lhsLoc, src_loc_SrcLoc rhsLoc)
{
   c->lhs = lhs;
   c->rhs = rhs;
   c->loc = lhsLoc;
   c->expr_ptr = NULL;
   if ((lhsLoc == 0)) c->loc = rhsLoc;
   ast_QualType t1 = ast_QualType_getCanonicalType(&lhs);
   ast_QualType t2 = ast_QualType_getCanonicalType(&rhs);
   const ast_Type* lcanon = ast_QualType_getTypeOrNil(&t1);
   const ast_Type* rcanon = ast_QualType_getTypeOrNil(&t2);
   uint8_t res = conversion_checker_Conversions[ast_Type_getKind(rcanon)][ast_Type_getKind(lcanon)];
   switch (res) {
   case 0:
      diagnostics_Diags_error(c->diags, lhsLoc, "SHOULD NOT HAPPEN (%u - %u)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ast_QualType_dump_full(&c->lhs);
      ast_QualType_dump_full(&c->rhs);
      (0) || c2_assert("analyser/conversion_checker.c2", 551, "conversion_checker.Checker.checkCast", "0");
      return false;
   case 1:
      diagnostics_Diags_error(c->diags, c->loc, "invalid cast from '%s' to '%s'", ast_QualType_diagName(&c->rhs), ast_QualType_diagName(&c->lhs));
      return false;
   case 2:
      return true;
   case 3:
      return conversion_checker_Checker_checkBuiltin2PointerCast(c, lcanon, rcanon);
   case 4:
      return conversion_checker_Checker_checkPointer2BuiltinCast(c, lcanon, rcanon);
   case 5:
      return true;
   case 6:
      return true;
   case 7:
      diagnostics_Diags_note(c->diags, c->loc, "SHOULD NOT HAPPEN (Array -> Ptr)");
      (0) || c2_assert("analyser/conversion_checker.c2", 569, "conversion_checker.Checker.checkCast", "0");
      return false;
   case 8:
      diagnostics_Diags_error(c->diags, lhsLoc, "SHOULD NOT HAPPEN (%u - %u)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      (0) || c2_assert("analyser/conversion_checker.c2", 573, "conversion_checker.Checker.checkCast", "0");
      return false;
   case 9:
      diagnostics_Diags_error(c->diags, lhsLoc, "SHOULD NOT HAPPEN (%u - %u)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      (0) || c2_assert("analyser/conversion_checker.c2", 577, "conversion_checker.Checker.checkCast", "0");
      return false;
   case 10:
      return true;
   case 11:
      return true;
   case 12:
      return true;
   case 13:
      return true;
   case 14:
      return true;
   case 15:
      return conversion_checker_Checker_checkBuiltin2PointerCast(c, lcanon, rcanon);
   case 16: {
      _Bool other = false;
      _Bool ok = conversion_checker_Checker_checkFunc2Builtin(c, lcanon, rcanon, &other);
      if ((!ok && !other)) {
         ast_QualType valid = ast_getNativeType();
         diagnostics_Diags_error(c->diags, c->loc, "pointers may only be cast to integer type '%s'", ast_QualType_diagName(&valid));
      }
      return ok;
   }
   default:
      diagnostics_Diags_note(c->diags, c->loc, "TODO CONVERSION  %u)", res);
      return false;
   }
   return true;
}

static _Bool conversion_checker_Checker_checkBuiltin2PointerCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   uint32_t wordsize = ast_getWordSize();
   const ast_BuiltinType* bi = ((ast_BuiltinType*)(rcanon));
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if ((kind == ast_BuiltinKind_USize)) return true;

   if (((wordsize == 4) && (kind == ast_BuiltinKind_UInt32))) return true;

   if (((wordsize == 8) && (kind == ast_BuiltinKind_UInt64))) return true;

   ast_QualType valid = ast_getNativeType();
   diagnostics_Diags_error(c->diags, c->loc, "only integers of type '%s' may be cast to a pointer", ast_QualType_diagName(&valid));
   return false;
}

static _Bool conversion_checker_Checker_checkPointer2BuiltinCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   uint32_t wordsize = ast_getWordSize();
   const ast_BuiltinType* bi = ((ast_BuiltinType*)(lcanon));
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if ((kind == ast_BuiltinKind_USize)) return true;

   if (((wordsize == 4) && (kind == ast_BuiltinKind_UInt32))) return true;

   if (((wordsize == 8) && (kind == ast_BuiltinKind_UInt64))) return true;

   ast_QualType valid = ast_getNativeType();
   diagnostics_Diags_error(c->diags, c->loc, "pointers may only be cast to integer type '%s'", ast_QualType_diagName(&valid));
   return false;
}

static ast_QualType conversion_checker_get_common_arithmetic_type(ast_QualType t1, ast_QualType t2)
{
   (ast_QualType_isBuiltin(&t1)) || c2_assert("analyser/conversion_checker.c2", 677, "conversion_checker.get_common_arithmetic_type", "t1.isBuiltin()");
   (ast_QualType_isBuiltin(&t2)) || c2_assert("analyser/conversion_checker.c2", 678, "conversion_checker.get_common_arithmetic_type", "t2.isBuiltin()");
   ast_BuiltinType* bi1 = ast_QualType_getBuiltin(&t1);
   ast_BuiltinType* bi2 = ast_QualType_getBuiltin(&t2);
   ast_BuiltinKind kind = ((ast_BuiltinKind)(conversion_checker_ConditionalOperatorResult[ast_BuiltinType_getKind(bi2)][ast_BuiltinType_getKind(bi1)]));
   return ast_builtins[kind];
}

static ast_QualType conversion_checker_usual_arithmetic_conversion(const ast_BuiltinType* b1, const ast_BuiltinType* b2)
{
   ast_BuiltinKind k1 = ast_BuiltinType_getBaseKind(b1);
   ast_BuiltinKind k2 = ast_BuiltinType_getBaseKind(b2);
   switch (conversion_checker_UsualArithmeticConversions[k2][k1]) {
   case 0:
      return ast_builtins[ast_BuiltinKind_Int32];
   case 1:
      return ast_builtins[ast_BuiltinKind_UInt32];
   case 2:
      return ast_builtins[ast_BuiltinKind_Int64];
   case 3:
      return ast_builtins[ast_BuiltinKind_UInt64];
   case 4:
      return ast_builtins[ast_BuiltinKind_Float32];
   case 5:
      return ast_builtins[ast_BuiltinKind_Float64];
   case 6:
      break;
   }
   return ast_QualType_Invalid;
}

static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeSmaller(conversion_checker_ExprWidth* w1, conversion_checker_ExprWidth* w2)
{
   conversion_checker_ExprWidth result;
   if ((w2->width < w1->width)) result.width = w2->width;
   else result.width = w1->width;
   result.is_signed = (w1->is_signed || w2->is_signed);
   return result;
}

static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeWider(conversion_checker_ExprWidth* w1, conversion_checker_ExprWidth* w2)
{
   conversion_checker_ExprWidth result;
   if ((w2->width > w1->width)) result.width = w2->width;
   else result.width = w1->width;
   result.is_signed = (w1->is_signed || w2->is_signed);
   return result;
}

static conversion_checker_ExprWidth conversion_checker_getExprWidth(const ast_Expr* e)
{
   conversion_checker_ExprWidth result = { };
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ctv_analyser_get_value(e);
      if (ast_Value_isNegative(&v)) {
         result.width = ast_Value_getWidth(&v);
         result.is_signed = true;
      } else {
         result.width = ast_Value_getWidth(&v);
         result.is_signed = false;
      }
      return result;
   }
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      fallthrough;
   case ast_ExprKind_StringLiteral:
      fallthrough;
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      ast_QualType qt = ast_Expr_getType(e);
      qt = ast_QualType_getCanonicalType(&qt);
      if (ast_QualType_isBuiltin(&qt)) {
         ast_BuiltinType* bi = ast_QualType_getBuiltin(&qt);
         result.width = ((uint8_t)(ast_BuiltinType_getWidth(bi)));
         result.is_signed = ast_BuiltinType_isSigned(bi);
      } else {
         result.width = ((uint8_t)((ast_getWordSize() * 8)));
         result.is_signed = true;
      }
      return result;
   }
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      return conversion_checker_getTypeWidth(ast_Expr_getType(e));
   case ast_ExprKind_InitList:
      break;
   case ast_ExprKind_FieldDesignatedInit:
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return conversion_checker_getBinOpWidth(((ast_BinaryOperator*)(e)));
   case ast_ExprKind_UnaryOperator:
      return conversion_checker_getUnaryOpWidth(((ast_UnaryOperator*)(e)));
   case ast_ExprKind_ConditionalOperator:
      return conversion_checker_getCondOpWidth(((ast_ConditionalOperator*)(e)));
   case ast_ExprKind_Builtin:
      break;
   case ast_ExprKind_ArraySubscript:
      fallthrough;
   case ast_ExprKind_Member: {
      ast_QualType qt = ast_Expr_getType(e);
      qt = ast_QualType_getCanonicalType(&qt);
      if (ast_QualType_isPointer(&qt)) {
         result.width = 64;
         result.is_signed = false;
         return result;
      }
      (ast_QualType_isBuiltin(&qt)) || c2_assert("analyser/conversion_checker_expr.c2", 105, "conversion_checker.getExprWidth", "qt.isBuiltin()");
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&qt);
      result.width = ((uint8_t)(ast_BuiltinType_getWidth(bi)));
      result.is_signed = ast_BuiltinType_isSigned(bi);
      return result;
   }
   case ast_ExprKind_Paren: {
      const ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      return conversion_checker_getExprWidth(ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast: {
      ast_QualType qt = ast_Expr_getType(e);
      qt = ast_QualType_getCanonicalType(&qt);
      (ast_QualType_isBuiltin(&qt)) || c2_assert("analyser/conversion_checker_expr.c2", 118, "conversion_checker.getExprWidth", "qt.isBuiltin()");
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&qt);
      result.width = ((uint8_t)(ast_BuiltinType_getWidth(bi)));
      result.is_signed = ast_BuiltinType_isSigned(bi);
      return result;
   }
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* c = ((ast_ImplicitCastExpr*)(e));
      return conversion_checker_getExprWidth(ast_ImplicitCastExpr_getInner(c));
   }
   case ast_ExprKind_Range: {
      ast_RangeExpr* b = ((ast_RangeExpr*)(e));
      conversion_checker_ExprWidth lhs = conversion_checker_getExprWidth(ast_RangeExpr_getLHS(b));
      conversion_checker_ExprWidth rhs = conversion_checker_getExprWidth(ast_RangeExpr_getRHS(b));
      return conversion_checker_ExprWidth_mergeWider(&lhs, &rhs);
   }
   }
   ast_Expr_dump(e);
   (0) || c2_assert("analyser/conversion_checker_expr.c2", 134, "conversion_checker.getExprWidth", "0");
   return result;
}

static conversion_checker_ExprWidth conversion_checker_getCondOpWidth(const ast_ConditionalOperator* c)
{
   conversion_checker_ExprWidth lhs = conversion_checker_getExprWidth(ast_ConditionalOperator_getLHS(c));
   conversion_checker_ExprWidth rhs = conversion_checker_getExprWidth(ast_ConditionalOperator_getRHS(c));
   return conversion_checker_ExprWidth_mergeWider(&lhs, &rhs);
}

static conversion_checker_ExprWidth conversion_checker_getUnaryOpWidth(const ast_UnaryOperator* u)
{
   conversion_checker_ExprWidth w;
   switch (ast_UnaryOperator_getOpcode(u)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec:
      fallthrough;
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec:
      fallthrough;
   case ast_UnaryOpcode_Plus:
      return conversion_checker_getExprWidth(ast_UnaryOperator_getInner(u));
   case ast_UnaryOpcode_AddrOf:
      w.width = ((uint8_t)((ast_getWordSize() * 8)));
      w.is_signed = false;
      break;
   case ast_UnaryOpcode_Deref:
      (0) || c2_assert("analyser/conversion_checker_expr.c2", 161, "conversion_checker.getUnaryOpWidth", "0");
      break;
   case ast_UnaryOpcode_Minus:
      w = conversion_checker_getExprWidth(ast_UnaryOperator_getInner(u));
      w.is_signed = true;
      break;
   case ast_UnaryOpcode_Not:
      w = conversion_checker_getExprWidth(ast_UnaryOperator_getInner(u));
      w.is_signed = false;
      break;
   case ast_UnaryOpcode_LNot:
      w.width = 1;
      w.is_signed = false;
      break;
   }
   return w;
}

static conversion_checker_ExprWidth conversion_checker_getBinOpWidth(const ast_BinaryOperator* b)
{
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_Multiply:
      break;
   case ast_BinaryOpcode_Divide:
      break;
   case ast_BinaryOpcode_Remainder:
      break;
   case ast_BinaryOpcode_Add:
      break;
   case ast_BinaryOpcode_Subtract:
      break;
   case ast_BinaryOpcode_ShiftLeft:
      break;
   case ast_BinaryOpcode_ShiftRight:
      break;
   case ast_BinaryOpcode_LessThan:
      fallthrough;
   case ast_BinaryOpcode_GreaterThan:
      fallthrough;
   case ast_BinaryOpcode_LessEqual:
      fallthrough;
   case ast_BinaryOpcode_GreaterEqual:
      fallthrough;
   case ast_BinaryOpcode_Equal:
      fallthrough;
   case ast_BinaryOpcode_NotEqual: {
      conversion_checker_ExprWidth result = { 1, 0 };
      return result;
   }
   case ast_BinaryOpcode_And: {
      conversion_checker_ExprWidth l = conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
      conversion_checker_ExprWidth r = conversion_checker_getExprWidth(ast_BinaryOperator_getRHS(b));
      return conversion_checker_ExprWidth_mergeSmaller(&l, &r);
   }
   case ast_BinaryOpcode_Xor:
      break;
   case ast_BinaryOpcode_Or:
      break;
   case ast_BinaryOpcode_LAnd:
      fallthrough;
   case ast_BinaryOpcode_LOr: {
      conversion_checker_ExprWidth result = { 1, 0 };
      return result;
   }
   case ast_BinaryOpcode_Assign:
      fallthrough;
   case ast_BinaryOpcode_MulAssign:
      fallthrough;
   case ast_BinaryOpcode_DivAssign:
      fallthrough;
   case ast_BinaryOpcode_RemAssign:
      fallthrough;
   case ast_BinaryOpcode_AddAssign:
      fallthrough;
   case ast_BinaryOpcode_SubAssign:
      fallthrough;
   case ast_BinaryOpcode_ShlAssign:
      fallthrough;
   case ast_BinaryOpcode_ShrAssign:
      fallthrough;
   case ast_BinaryOpcode_AndAssign:
      fallthrough;
   case ast_BinaryOpcode_XorAssign:
      fallthrough;
   case ast_BinaryOpcode_OrAssign:
      return conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
   }
   conversion_checker_ExprWidth lhs = conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
   conversion_checker_ExprWidth rhs = conversion_checker_getExprWidth(ast_BinaryOperator_getRHS(b));
   return conversion_checker_ExprWidth_mergeWider(&lhs, &rhs);
}

static conversion_checker_ExprWidth conversion_checker_getTypeWidth(ast_QualType qt)
{
   if (ast_QualType_isPointer(&qt)) {
      conversion_checker_ExprWidth result = { .width = 64, .is_signed = false };
      return result;
   }
   (ast_QualType_isBuiltin(&qt)) || c2_assert("analyser/conversion_checker_expr.c2", 243, "conversion_checker.getTypeWidth", "qt.isBuiltin()");
   const ast_BuiltinType* bi = ast_QualType_getBuiltin(&qt);
   conversion_checker_ExprWidth result;
   result.width = ((uint8_t)(ast_BuiltinType_getWidth(bi)));
   result.is_signed = ast_BuiltinType_isSigned(bi);
   return result;
}


// --- module module_sorter ---
typedef struct module_sorter_ModuleSorter_ module_sorter_ModuleSorter;

struct module_sorter_ModuleSorter_ {
   component_Component* comp;
   uint32_t num_mods;
   ast_Module** modules;
   dsm_sorter_Sorter* dsm;
   uint32_t cur_mod_idx;
};

static void module_sorter_sort(component_Component* c, diagnostics_Diags* diags);
static void module_sorter_ModuleSorter_print(const module_sorter_ModuleSorter* s);
static void module_sorter_ModuleSorter_handleModule(void* arg, ast_Module* mod);
static void module_sorter_ModuleSorter_handleImport(void* arg, ast_ImportDecl* d);
static uint32_t module_sorter_ModuleSorter_mod2idx(const module_sorter_ModuleSorter* s, const ast_Module* mod);

static void module_sorter_sort(component_Component* c, diagnostics_Diags* diags)
{
   module_list_List* mods = component_Component_getModules(c);
   const uint32_t count = module_list_List_length(mods);
   if ((count <= 1)) return;

   module_sorter_ModuleSorter s;
   s.num_mods = count;
   s.cur_mod_idx = 0;
   s.comp = c;
   ast_Module** orig = module_list_List_get(mods);
   dsm_sorter_Sorter dsm; dsm_sorter_Sorter_init(&dsm, count);
   s.modules = orig;
   s.dsm = &dsm;
   component_Component_visitModules(c, module_sorter_ModuleSorter_handleModule, &s);
   const uint8_t* sorted = dsm_sorter_Sorter_sort(&dsm);
   if (!sorted) {
      diagnostics_Diags_error(diags, 0, "circular dependency between modules");
      module_sorter_ModuleSorter_print(&s);
      exit(-1);
   }
   ast_Module** copy = malloc((count * 8));
   memcpy(copy, orig, (count * 8));
   for (uint32_t i = 0; (i < count); i++) orig[i] = copy[sorted[i]];
   free(copy);
   dsm_sorter_Sorter_free(&dsm);
}

static void module_sorter_ModuleSorter_print(const module_sorter_ModuleSorter* s)
{
   const uint8_t* array = dsm_sorter_Sorter_get_array(s->dsm);
   printf("                     |");
   for (uint32_t y = 0; (y < s->num_mods); y++) {
      printf(" %2u", y);
   }
   printf("\n");
   for (uint32_t y = 0; (y < s->num_mods); y++) {
      printf("%16s  %2u |", ast_Module_getName(s->modules[y]), y);
      for (uint32_t x = 0; (x < s->num_mods); x++) {
         uint8_t value = array[((y * s->num_mods) + x)];
         printf("  %c", value ? 'X' : ' ');
      }
      printf("\n");
   }
}

static void module_sorter_ModuleSorter_handleModule(void* arg, ast_Module* mod)
{
   module_sorter_ModuleSorter* s = arg;
   ast_Module_visitImports(mod, module_sorter_ModuleSorter_handleImport, arg);
   s->cur_mod_idx++;
}

static void module_sorter_ModuleSorter_handleImport(void* arg, ast_ImportDecl* d)
{
   module_sorter_ModuleSorter* s = arg;
   ast_Module* dest = ast_ImportDecl_getDest(d);
   (dest) || c2_assert("analyser/module_sorter.c2", 102, "module_sorter.ModuleSorter.handleImport", "dest");
   if (!component_Component_hasModule(s->comp, dest)) return;

   uint32_t dest_idx = module_sorter_ModuleSorter_mod2idx(s, dest);
   dsm_sorter_Sorter_add_dep(s->dsm, s->cur_mod_idx, dest_idx);
}

static uint32_t module_sorter_ModuleSorter_mod2idx(const module_sorter_ModuleSorter* s, const ast_Module* mod)
{
   for (uint32_t i = 0; (i < s->num_mods); i++) {
      if ((s->modules[i] == mod)) return i;

   }
   (0) || c2_assert("analyser/module_sorter.c2", 115, "module_sorter.ModuleSorter.mod2idx", "0");
   return 0;
}


// --- module size_analyser ---
typedef struct size_analyser_TypeSize_ size_analyser_TypeSize;

struct size_analyser_TypeSize_ {
   uint32_t size;
   uint32_t align;
   uint32_t bitfield_size;
   uint32_t bitfield_width;
};

static size_analyser_TypeSize size_analyser_sizeOfUnion(ast_StructTypeDecl* s);
static size_analyser_TypeSize size_analyser_sizeOfStruct(ast_StructTypeDecl* s);
static size_analyser_TypeSize size_analyser_sizeOfType(ast_QualType qt);

static size_analyser_TypeSize size_analyser_sizeOfUnion(ast_StructTypeDecl* s)
{
   size_analyser_TypeSize result = { 0, 1, 0, 0 };
   result.align = ast_StructTypeDecl_getAttrAlignment(s);
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
   ast_Decl** members = ast_StructTypeDecl_getMembers(s);
   for (uint32_t i = 0; (i < num_members); i++) {
      ast_Decl* d = members[i];
      size_analyser_TypeSize m_size = size_analyser_sizeOfType(ast_Decl_getType(d));
      if ((m_size.size > result.size)) result.size = m_size.size;
      if ((m_size.align > result.align)) result.align = m_size.align;
   }
   return result;
}

static size_analyser_TypeSize size_analyser_sizeOfStruct(ast_StructTypeDecl* s)
{
   if (ast_StructTypeDecl_isUnion(s)) return size_analyser_sizeOfUnion(s);

   size_analyser_TypeSize result = { 0, 1, 0, 0 };
   _Bool packed = ast_StructTypeDecl_isPacked(s);
   result.align = ast_StructTypeDecl_getAttrAlignment(s);
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
   ast_Decl** members = ast_StructTypeDecl_getMembers(s);
   if (packed) {
      for (uint32_t i = 0; (i < num_members); i++) {
         ast_Decl* d = members[i];
         size_analyser_TypeSize member = size_analyser_sizeOfType(ast_Decl_getType(d));
         ast_StructTypeDecl_setMemberOffset(s, i, result.size);
         result.size += member.size;
      }
   } else {
      for (uint32_t i = 0; (i < num_members); i++) {
         ast_Decl* d = members[i];
         size_analyser_TypeSize member = size_analyser_sizeOfType(ast_Decl_getType(d));
         if ((member.align > result.align)) result.align = member.align;
         ast_VarDecl* vd = ast_Decl_isVariable(d) ? ((ast_VarDecl*)(d)) : NULL;
         if (vd) {
            const ast_Expr* bitfield = ast_VarDecl_getBitfield(vd);
            if (bitfield) {
               ast_Value value = ctv_analyser_get_value(bitfield);
               member.bitfield_size = ast_Value_as_u32(&value);
               member.bitfield_width = (member.size * 8);
               member.size = 0;
               member.align = 0;
            }
         }
         if ((result.bitfield_width && (member.align != 0))) {
            uint32_t bytesize = (((result.bitfield_size + 7)) / 8);
            result.size += bytesize;
            if ((bytesize > result.align)) result.align = bytesize;
            result.bitfield_width = 0;
            result.bitfield_size = 0;
         }
         if ((member.align > 1)) {
            if ((member.align > result.align)) result.align = member.align;
            uint32_t rest = (result.size % member.align);
            if ((rest != 0)) {
               uint32_t pad = (member.align - rest);
               result.size += pad;
            }
         }
         ast_StructTypeDecl_setMemberOffset(s, i, result.size);
         if (member.bitfield_width) {
            uint32_t total_bitsize = (result.bitfield_size + member.bitfield_size);
            if ((total_bitsize > member.bitfield_width)) {
               uint32_t bytesize = (((result.bitfield_size + 7)) / 8);
               member.align = bytesize;
               if ((bytesize > 1)) {
                  uint32_t rest = (result.size % bytesize);
                  if ((rest != 0)) {
                     uint32_t pad = (member.align - rest);
                     result.size += pad;
                  }
               }
               result.size += bytesize;
               result.bitfield_size = member.bitfield_size;
               result.bitfield_width = member.bitfield_width;
            } else {
               result.bitfield_size = total_bitsize;
               result.bitfield_width = member.bitfield_width;
            }
         } else {
            result.size += member.size;
         }
      }
      if (result.bitfield_width) {
         uint32_t bytesize = (((result.bitfield_size + 7)) / 8);
         result.size += bytesize;
      }
      uint32_t rest = (result.size % result.align);
      if ((rest != 0)) {
         uint32_t pad = (result.align - rest);
         result.size += pad;
      }
   }
   return result;
}

static size_analyser_TypeSize size_analyser_sizeOfType(ast_QualType qt)
{
   size_analyser_TypeSize result = { 0, 1, 0, 0 };
   if (ast_QualType_isInvalid(&qt)) return result;

   uint32_t pointerSize = ast_getWordSize();
   qt = ast_QualType_getCanonicalType(&qt);
   ast_Type* t = ast_QualType_getType(&qt);
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin: {
      const ast_BuiltinType* bi = ((ast_BuiltinType*)(t));
      result.size = ast_BuiltinType_getAlignment(bi);
      result.align = result.size;
      break;
   }
   case ast_TypeKind_Pointer:
      result.size = pointerSize;
      result.align = result.size;
      break;
   case ast_TypeKind_Array: {
      ast_ArrayType* arrayType = ((ast_ArrayType*)(t));
      result = size_analyser_sizeOfType(ast_ArrayType_getElemType(arrayType));
      result.size *= ast_ArrayType_getSize(arrayType);
      break;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = ((ast_StructType*)(t));
      ast_StructTypeDecl* d = ast_StructType_getDecl(st);
      (ast_Decl_isChecked(ast_StructTypeDecl_asDecl(d))) || c2_assert("analyser/size_analyser.c2", 195, "size_analyser.sizeOfType", "d.asDecl().isChecked()");
      result.size = ast_StructTypeDecl_getSize(d);
      result.align = ast_StructTypeDecl_getAlignment(d);
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = ((ast_EnumType*)(t));
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      return size_analyser_sizeOfType(ast_EnumTypeDecl_getImplType(etd));
   }
   case ast_TypeKind_Function:
      result.size = pointerSize;
      result.align = pointerSize;
      break;
   case ast_TypeKind_Alias:
      (0) || c2_assert("analyser/size_analyser.c2", 208, "size_analyser.sizeOfType", "0");
      break;
   case ast_TypeKind_Module:
      (0) || c2_assert("analyser/size_analyser.c2", 211, "size_analyser.sizeOfType", "0");
      break;
   }
   return result;
}


// --- module c2module_loader ---
typedef struct c2module_loader_CType_ c2module_loader_CType;

struct c2module_loader_CType_ {
   const char* name;
   ast_BuiltinKind kind;
};

static const c2module_loader_CType c2module_loader_CTypes[10] = {
   { "c_char", ast_BuiltinKind_Char },
   { "c_uchar", ast_BuiltinKind_UInt8 },
   { "c_short", ast_BuiltinKind_Int16 },
   { "c_ushort", ast_BuiltinKind_UInt16 },
   { "c_int", ast_BuiltinKind_Int32 },
   { "c_uint", ast_BuiltinKind_UInt32 },
   { "c_longlong", ast_BuiltinKind_Int64 },
   { "c_ulonglong", ast_BuiltinKind_UInt64 },
   { "c_float", ast_BuiltinKind_Float32 },
   { "c_double", ast_BuiltinKind_Float64 }
};

static void c2module_loader_create_signed(ast_context_Context* context, ast_AST* a, string_pool_Pool* pool, const char* name, int64_t value, ast_BuiltinKind kind);
static void c2module_loader_create_unsigned(ast_context_Context* context, ast_AST* a, string_pool_Pool* pool, const char* name, uint64_t value, ast_BuiltinKind kind);
static void c2module_loader_add_ctype(ast_context_Context* context, string_pool_Pool* pool, ast_Module* m, ast_AST* a, const char* name, ast_BuiltinKind kind);
static ast_Module* c2module_loader_load(ast_context_Context* context, string_pool_Pool* pool, string_pool_Pool* auxPool, component_Component* comp);

static void c2module_loader_create_signed(ast_context_Context* context, ast_AST* a, string_pool_Pool* pool, const char* name, int64_t value, ast_BuiltinKind kind)
{
   ast_QualType qt = ast_builtins[kind];
   ast_Expr* ie = ((ast_Expr*)(ast_IntegerLiteral_createSignedConstant(context, 0, value, qt)));
   uint32_t name2 = string_pool_Pool_addStr(pool, name, true);
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   ast_TypeRefHolder_setBuiltin(&ref, kind, 0);
   ast_VarDecl* var = ast_VarDecl_create(context, ast_VarDeclKind_GlobalVar, name2, 0, true, &ref, ast_AST_getIdx(a), 0, ie);
   ast_Decl* d = ((ast_Decl*)(var));
   ast_QualType_setConst(&qt);
   ast_Decl_setType(d, qt);
   ast_Decl_setChecked(d);
   ast_AST_addVarDecl(a, d);
   ast_Module_addSymbol(ast_AST_getMod(a), name2, d);
}

static void c2module_loader_create_unsigned(ast_context_Context* context, ast_AST* a, string_pool_Pool* pool, const char* name, uint64_t value, ast_BuiltinKind kind)
{
   ast_QualType qt = ast_builtins[kind];
   ast_Expr* ie = ((ast_Expr*)(ast_IntegerLiteral_createUnsignedConstant(context, 0, value, qt)));
   uint32_t name2 = string_pool_Pool_addStr(pool, name, true);
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   ast_TypeRefHolder_setBuiltin(&ref, kind, 0);
   ast_VarDecl* var = ast_VarDecl_create(context, ast_VarDeclKind_GlobalVar, name2, 0, true, &ref, ast_AST_getIdx(a), 0, ie);
   ast_Decl* d = ((ast_Decl*)(var));
   ast_QualType_setConst(&qt);
   ast_Decl_setType(d, qt);
   ast_Decl_setChecked(d);
   ast_AST_addVarDecl(a, d);
   ast_Module_addSymbol(ast_AST_getMod(a), name2, d);
}

static void c2module_loader_add_ctype(ast_context_Context* context, string_pool_Pool* pool, ast_Module* m, ast_AST* a, const char* name, ast_BuiltinKind kind)
{
   uint32_t type_name = string_pool_Pool_addStr(pool, name, true);
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   ast_TypeRefHolder_setBuiltin(&ref, kind, 0);
   ast_AliasTypeDecl* t = ast_AliasTypeDecl_create(context, type_name, 0, true, ast_AST_getIdx(a), &ref);
   ast_Decl* d = ast_AliasTypeDecl_asDecl(t);
   ast_QualType qt = ast_builtins[kind];
   ast_Decl_setType(d, qt);
   ast_QualType qt2 = ast_Decl_getType(d);
   ast_QualType_setCanonicalType(&qt2, qt);
   ast_Decl_setChecked(d);
   ast_AST_addTypeDecl(a, d);
   ast_Module_addSymbol(m, type_name, d);
}

static ast_Module* c2module_loader_load(ast_context_Context* context, string_pool_Pool* pool, string_pool_Pool* auxPool, component_Component* comp)
{
   uint32_t name = string_pool_Pool_add(pool, "c2", 2, true);
   ast_Module* m = component_Component_createModule(comp, name);
   ast_Module_setInternal(m);
   ast_Module_setUsed(m);
   ast_AST* a = ast_Module_add(m, auxPool, string_pool_Pool_addStr(auxPool, "<generated>", false), false);
   for (uint32_t i = 0; (i < 10); i++) {
      c2module_loader_add_ctype(context, pool, m, a, c2module_loader_CTypes[i].name, c2module_loader_CTypes[i].kind);
   }
   if ((ast_getWordSize() == 4)) {
      c2module_loader_add_ctype(context, pool, m, a, "c_long", ast_BuiltinKind_Int32);
      c2module_loader_add_ctype(context, pool, m, a, "c_ulong", ast_BuiltinKind_UInt32);
      c2module_loader_add_ctype(context, pool, m, a, "c_size", ast_BuiltinKind_UInt32);
      c2module_loader_add_ctype(context, pool, m, a, "c_ssize", ast_BuiltinKind_Int32);
   } else {
      c2module_loader_add_ctype(context, pool, m, a, "c_long", ast_BuiltinKind_Int64);
      c2module_loader_add_ctype(context, pool, m, a, "c_ulong", ast_BuiltinKind_UInt64);
      c2module_loader_add_ctype(context, pool, m, a, "c_size", ast_BuiltinKind_UInt64);
      c2module_loader_add_ctype(context, pool, m, a, "c_ssize", ast_BuiltinKind_Int64);
   }
   c2module_loader_create_signed(context, a, pool, "min_i8", -128, ast_BuiltinKind_Int8);
   c2module_loader_create_signed(context, a, pool, "max_i8", 127, ast_BuiltinKind_Int8);
   c2module_loader_create_unsigned(context, a, pool, "min_u8", 0, ast_BuiltinKind_UInt8);
   c2module_loader_create_unsigned(context, a, pool, "max_u8", 255, ast_BuiltinKind_UInt8);
   c2module_loader_create_signed(context, a, pool, "min_i16", -32768, ast_BuiltinKind_Int16);
   c2module_loader_create_signed(context, a, pool, "max_i16", 32767, ast_BuiltinKind_Int16);
   c2module_loader_create_unsigned(context, a, pool, "min_u16", 0, ast_BuiltinKind_UInt16);
   c2module_loader_create_unsigned(context, a, pool, "max_u16", 65535, ast_BuiltinKind_UInt16);
   c2module_loader_create_signed(context, a, pool, "min_i32", (-2147483647 - 1), ast_BuiltinKind_Int32);
   c2module_loader_create_signed(context, a, pool, "max_i32", 2147483647, ast_BuiltinKind_Int32);
   c2module_loader_create_unsigned(context, a, pool, "min_u32", 0, ast_BuiltinKind_UInt32);
   c2module_loader_create_unsigned(context, a, pool, "max_u32", 4294967295, ast_BuiltinKind_UInt32);
   c2module_loader_create_signed(context, a, pool, "min_i64", (-9223372036854775807lu - 1), ast_BuiltinKind_Int64);
   c2module_loader_create_signed(context, a, pool, "max_i64", 9223372036854775807lu, ast_BuiltinKind_Int64);
   c2module_loader_create_unsigned(context, a, pool, "min_u64", 0, ast_BuiltinKind_UInt64);
   c2module_loader_create_unsigned(context, a, pool, "max_u64", 18446744073709551615lu, ast_BuiltinKind_UInt64);
   if ((ast_getWordSize() == 4)) {
      c2module_loader_create_signed(context, a, pool, "min_isize", (-2147483647 - 1), ast_BuiltinKind_Int32);
      c2module_loader_create_signed(context, a, pool, "max_isize", 2147483647, ast_BuiltinKind_Int32);
      c2module_loader_create_unsigned(context, a, pool, "min_usize", 0, ast_BuiltinKind_UInt32);
      c2module_loader_create_unsigned(context, a, pool, "max_usize", 4294967295, ast_BuiltinKind_UInt32);
   } else {
      c2module_loader_create_signed(context, a, pool, "min_isize", (-9223372036854775807lu - 1), ast_BuiltinKind_Int64);
      c2module_loader_create_signed(context, a, pool, "max_isize", 9223372036854775807lu, ast_BuiltinKind_Int64);
      c2module_loader_create_unsigned(context, a, pool, "min_usize", 0, ast_BuiltinKind_UInt64);
      c2module_loader_create_unsigned(context, a, pool, "max_usize", 18446744073709551615lu, ast_BuiltinKind_UInt64);
   }
   return m;
}


// --- module manifest ---

static const yaml_Node* manifest_get_checked(yaml_Parser* parser, const char* path);
static _Bool manifest_getYamlInfo(yaml_Parser* parser, string_pool_Pool* astPool, component_Component* comp, string_list_List* mods);
static _Bool manifest_parse(source_mgr_SourceMgr* sm, int32_t file_id, string_pool_Pool* astPool, component_Component* comp, string_list_List* mods);

static const yaml_Node* manifest_get_checked(yaml_Parser* parser, const char* path)
{
   const yaml_Node* node = yaml_Parser_findNode(parser, path);
   if (!node) {
      fprintf(stderr, "error: missing node %s\n", path);
      exit(-1);
   }
   return node;
}

static _Bool manifest_getYamlInfo(yaml_Parser* parser, string_pool_Pool* astPool, component_Component* comp, string_list_List* mods)
{
   manifest_get_checked(parser, "info.language");
   manifest_get_checked(parser, "info.type");
   const yaml_Node* lib_kinds = manifest_get_checked(parser, "info.kinds");
   const yaml_Node* modulesNode = manifest_get_checked(parser, "modules");
   yaml_Iter iter = yaml_Parser_getNodeChildIter(parser, lib_kinds);
   _Bool kind_dynamic = false;
   _Bool kind_static = false;
   while (!yaml_Iter_done(&iter)) {
      const char* kind = yaml_Iter_getValue(&iter);
      switch (c2_strswitch(kind, "\007dynamic" "\006static")) {
      case 2: // "dynamic"
         kind_dynamic = true;
         break;
      case 3: // "static"
         kind_static = true;
         break;
      default:
         fprintf(stderr, "error in manifest: invalid library kind '%s'\n", kind);
         exit(-1);
      }
      yaml_Iter_next(&iter);
   }
   if ((!kind_dynamic && !kind_static)) {
      fprintf(stderr, "error in manifest: a library must be dynamic and/or static\n");
      exit(-1);
   }
   component_Component_setKind(comp, kind_static, kind_dynamic);
   iter = yaml_Parser_getNodeChildIter(parser, modulesNode);
   while (!yaml_Iter_done(&iter)) {
      const char* value = yaml_Iter_getValue(&iter);
      (value) || c2_assert("compiler/manifest.c2", 77, "manifest.getYamlInfo", "value");
      uint32_t modname = string_pool_Pool_addStr(astPool, value, true);
      string_list_List_add(mods, modname);
      yaml_Iter_next(&iter);
   }
   const char* linkname = yaml_Parser_getScalarValue(parser, "info.linkname");
   if (linkname) component_Component_setLinkName(comp, linkname);
   const yaml_Node* deps = yaml_Parser_findNode(parser, "dependencies");
   if (deps) {
      iter = yaml_Parser_getNodeChildIter(parser, deps);
      while (!yaml_Iter_done(&iter)) {
         component_Component_addDep(comp, yaml_Iter_getName(&iter));
         yaml_Iter_next(&iter);
      }
   }
   return true;
}

static _Bool manifest_parse(source_mgr_SourceMgr* sm, int32_t file_id, string_pool_Pool* astPool, component_Component* comp, string_list_List* mods)
{
   const char* data = source_mgr_SourceMgr_get_content(sm, file_id);
   yaml_Parser* parser = yaml_Parser_create();
   _Bool ok = yaml_Parser_parse(parser, data);
   if (ok) {
      manifest_getYamlInfo(parser, astPool, comp, mods);
   } else {
      console_error("%s: %s", source_mgr_SourceMgr_getFileName(sm, file_id), yaml_Parser_getMessage(parser));
   }
   yaml_Parser_destroy(parser);
   return ok;
}


// --- module plugin_mgr ---
typedef struct plugin_mgr_Plugin_ plugin_mgr_Plugin;
typedef struct plugin_mgr_Mgr_ plugin_mgr_Mgr;

struct plugin_mgr_Plugin_ {
   uint32_t name;
   _Bool is_global;
   _Bool is_active;
   void* arg;
   void* handle;
   plugin_info_Plugin* functions;
};

struct plugin_mgr_Mgr_ {
   string_pool_Pool* auxPool;
   _Bool console_timing;
   _Bool console_debug;
   _Bool no_plugins;
   plugin_mgr_Plugin* plugins;
   uint32_t plugin_count;
   uint32_t plugin_max;
   string_list_List paths;
   char error_msg[256];
};

static const char* plugin_mgr_lib_ext = ".so";

static plugin_mgr_Mgr* plugin_mgr_create(string_pool_Pool* auxPool, _Bool console_timing, _Bool console_debug, _Bool no_plugins);
static void plugin_mgr_Mgr_free(plugin_mgr_Mgr* m);
static const char* plugin_mgr_Mgr_getError(const plugin_mgr_Mgr* m);
static void plugin_mgr_Mgr_addPath(plugin_mgr_Mgr* m, uint32_t path);
static void plugin_mgr_Mgr_addPlugin(plugin_mgr_Mgr* m, plugin_mgr_Plugin* p);
static _Bool plugin_mgr_is_plugin(const dirent* entry);
static void plugin_mgr_Mgr_show(const plugin_mgr_Mgr* m);
static _Bool plugin_mgr_Mgr_loadPlugin(plugin_mgr_Mgr* m, uint32_t name, uint32_t options, _Bool is_global);
static _Bool plugin_mgr_Mgr_loadGlobal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options);
static _Bool plugin_mgr_Mgr_loadLocal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options);
static _Bool plugin_mgr_Mgr_find_file(plugin_mgr_Mgr* m, char* fullname, const char* filename);
static void plugin_mgr_Mgr_beginTarget(plugin_mgr_Mgr* m, plugin_info_Info* info);
static void plugin_mgr_Mgr_endTarget(plugin_mgr_Mgr* m);
static void plugin_mgr_Mgr_postParse(plugin_mgr_Mgr* m);
static void plugin_mgr_Mgr_postAnalysis(plugin_mgr_Mgr* m);

static plugin_mgr_Mgr* plugin_mgr_create(string_pool_Pool* auxPool, _Bool console_timing, _Bool console_debug, _Bool no_plugins)
{
   plugin_mgr_Mgr* m = calloc(1, 312);
   m->auxPool = auxPool;
   m->console_timing = console_timing;
   m->console_debug = console_debug;
   m->no_plugins = no_plugins;
   string_list_List_init(&m->paths, auxPool);
   return m;
}

static void plugin_mgr_Mgr_free(plugin_mgr_Mgr* m)
{
   for (uint32_t i = m->plugin_count; (i != 0); i--) {
      plugin_mgr_Plugin* p = &m->plugins[(i - 1)];
      console_debug("plugins: unload %s", string_pool_Pool_idx2str(m->auxPool, p->name));
      p->functions->unload(p->arg);
      dlclose(p->handle);
   }
   free(m->plugins);
   string_list_List_free(&m->paths);
   free(m);
}

static const char* plugin_mgr_Mgr_getError(const plugin_mgr_Mgr* m)
{
   return m->error_msg;
}

static void plugin_mgr_Mgr_addPath(plugin_mgr_Mgr* m, uint32_t path)
{
   if (!string_list_List_contains_idx(&m->paths, path)) string_list_List_add(&m->paths, path);
}

static void plugin_mgr_Mgr_addPlugin(plugin_mgr_Mgr* m, plugin_mgr_Plugin* p)
{
   if ((m->plugin_count == m->plugin_max)) {
      m->plugin_max = m->plugin_max ? (m->plugin_max * 2) : 4;
      plugin_mgr_Plugin* plugins2 = malloc((m->plugin_max * 32));
      if (m->plugin_count) {
         memcpy(plugins2, m->plugins, (m->plugin_count * 32));
         free(m->plugins);
      }
      m->plugins = plugins2;
   }
   m->plugins[m->plugin_count] = *p;
   m->plugin_count++;
}

static _Bool plugin_mgr_is_plugin(const dirent* entry)
{
   const char* filename = entry->d_name;
   if ((entry->d_type != DT_REG)) return false;

   if ((filename[0] == '.')) return false;

   return string_utils_endsWith(filename, plugin_mgr_lib_ext);
}

static void plugin_mgr_Mgr_show(const plugin_mgr_Mgr* m)
{
   console_log("Plugins:");
   for (uint32_t i = 0; (i < string_list_List_length(&m->paths)); i++) {
      const char* path = string_list_List_get(&m->paths, i);
      DIR* dir = opendir(path);
      if ((dir == NULL)) {
         console_warn("cannot read '%s': %s", path, strerror((*__errno_location())));
         continue;
      }
      dirent* entry = readdir(dir);
      while ((entry != NULL)) {
         if (plugin_mgr_is_plugin(entry)) {
            console_log("  %s/%s", path, entry->d_name);
         }
         entry = readdir(dir);
      }
      closedir(dir);
   }
}

static _Bool plugin_mgr_Mgr_loadPlugin(plugin_mgr_Mgr* m, uint32_t name, uint32_t options, _Bool is_global)
{
   if (m->no_plugins) return true;

   for (uint32_t i = 0; (i < m->plugin_count); i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if ((p->name == name)) {
         if (!is_global) p->is_active = true;
         return true;
      }
   }
   const char* name_str = string_pool_Pool_idx2str(m->auxPool, name);
   char filename[128];
   sprintf(filename, "lib%s%s", name_str, plugin_mgr_lib_ext);
   char fullname[512];
   if (!plugin_mgr_Mgr_find_file(m, fullname, filename)) {
      sprintf(m->error_msg, "cannot find plugin %s", name_str);
      return false;
   }
   plugin_mgr_Plugin p = { };
   p.name = name;
   p.is_global = is_global;
   p.is_active = true;
   p.handle = dlopen(fullname, (RTLD_NOW | RTLD_LOCAL));
   if ((p.handle == NULL)) {
      sprintf(m->error_msg, "cannot load plugin: %s", dlerror());
      return false;
   }
   void* handle_symbol = dlsym(p.handle, "plugin_main_handle");
   if (!handle_symbol) {
      sprintf(m->error_msg, "invalid plugin %s: %s", fullname, dlerror());
      dlclose(p.handle);
      return false;
   }
   p.functions = handle_symbol;
   console_debug("plugins: loading %s", fullname);
   p.arg = p.functions->load(string_pool_Pool_idx2str(m->auxPool, options), m->console_timing, m->console_debug);
   if (!p.arg) {
      dlclose(p.handle);
      sprintf(m->error_msg, "plugin failed to load");
      return false;
   }
   plugin_mgr_Mgr_addPlugin(m, &p);
   return true;
}

static _Bool plugin_mgr_Mgr_loadGlobal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options)
{
   return plugin_mgr_Mgr_loadPlugin(m, name, options, true);
}

static _Bool plugin_mgr_Mgr_loadLocal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options)
{
   return plugin_mgr_Mgr_loadPlugin(m, name, options, false);
}

static _Bool plugin_mgr_Mgr_find_file(plugin_mgr_Mgr* m, char* fullname, const char* filename)
{
   for (uint32_t i = 0; (i < string_list_List_length(&m->paths)); i++) {
      const char* path = string_list_List_get(&m->paths, i);
      sprintf(fullname, "%s/%s", path, filename);
      if (file_utils_exists(fullname)) return true;

   }
   return false;
}

static void plugin_mgr_Mgr_beginTarget(plugin_mgr_Mgr* m, plugin_info_Info* info)
{
   for (uint32_t i = 0; (i < m->plugin_count); i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if (p->is_active) p->functions->init(p->arg, info);
   }
}

static void plugin_mgr_Mgr_endTarget(plugin_mgr_Mgr* m)
{
   for (uint32_t i = 0; (i < m->plugin_count); i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      p->is_active = p->is_global;
   }
}

static void plugin_mgr_Mgr_postParse(plugin_mgr_Mgr* m)
{
   for (uint32_t i = 0; (i < m->plugin_count); i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if ((p->is_active && p->functions->post_parse)) p->functions->post_parse(p->arg);
   }
}

static void plugin_mgr_Mgr_postAnalysis(plugin_mgr_Mgr* m)
{
   for (uint32_t i = 0; (i < m->plugin_count); i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if ((p->is_active && p->functions->post_analysis)) p->functions->post_analysis(p->arg);
   }
}


// --- module c_generator ---
typedef struct c_generator_Fragment_ c_generator_Fragment;
typedef struct c_generator_Generator_ c_generator_Generator;
typedef struct c_generator_FormatChanger_ c_generator_FormatChanger;
typedef struct c_generator_ArgValue_ c_generator_ArgValue;
typedef struct c_generator_Evaluator_ c_generator_Evaluator;
typedef struct c_generator_TraceCall_ c_generator_TraceCall;
typedef struct c_generator_TraceCallList_ c_generator_TraceCallList;
typedef struct c_generator_StringList_ c_generator_StringList;

struct c_generator_Fragment_ {
   string_buffer_Buf* buf;
   linked_list_Element list;
};

struct c_generator_TraceCallList_ {
   c_generator_TraceCall* array;
   uint32_t count;
   uint32_t capacity;
};

struct c_generator_StringList_ {
   uint32_t* hash_array;
   uint32_t hash_count;
   uint32_t hash_capacity;
   char** strings;
   uint32_t string_count;
   uint32_t string_capacity;
   const char* last_string;
   uint32_t last_index;
};

struct c_generator_Generator_ {
   string_pool_Pool* astPool;
   string_pool_Pool* auxPool;
   string_buffer_Buf* out;
   const char* target;
   build_target_Kind target_kind;
   const char* results_dir;
   const char* output_dir;
   const char* cgen_dir;
   source_mgr_SourceMgr* sm;
   const build_file_Info* build_info;
   const target_info_Info* targetInfo;
   _Bool enable_asserts;
   _Bool fast_build;
   _Bool asan;
   _Bool msan;
   _Bool ubsan;
   _Bool trace_calls;
   _Bool cur_external;
   ast_FunctionDecl* cur_function;
   const char* mod_name;
   string_list_List imports;
   ast_DeclList decls;
   dep_finder_Finder deps;
   ast_Decl* mainFunc;
   uint32_t stdargName;
   ast_Module* mod;
   string_buffer_Buf* header;
   linked_list_Element free_list;
   linked_list_Element used_list;
   linked_list_Element header_fragments;
   c_generator_TraceCallList calls;
   c_generator_StringList filenames;
   c_generator_StringList funcnames;
};

static const char c_generator_Dir[5] = "cgen";

static const char c_generator_LogFile[10] = "build.log";

static const char* c_generator_builtinType_cnames[15] = {
   "char",
   "int8_t",
   "int16_t",
   "int32_t",
   "int64_t",
   "uint8_t",
   "uint16_t",
   "uint32_t",
   "uint64_t",
   "float",
   "double",
   "ssize_t",
   "size_t",
   "_Bool",
   "void"
};

static const char c_generator_Warning_control[999] = "#if defined(__clang__)\n#  pragma clang diagnostic ignored \"-Wincompatible-library-redeclaration\"\n#  pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  pragma clang diagnostic ignored \"-Wparentheses-equality\"\n#  pragma clang diagnostic ignored \"-Wsometimes-uninitialized\"\n#  pragma clang diagnostic ignored \"-Wtypedef-redefinition\"\n#  pragma clang diagnostic ignored \"-Wstring-plus-int\"\n#  if (__clang_major__ >= 10)\n#    define fallthrough  __attribute__((fallthrough))\n#  endif\n#elif defined(__GNUC__)\n#  if (__GNUC__ >= 11)\n#    define fallthrough  [[fallthrough]]\n#  elif (__GNUC__ >= 7)\n#    define fallthrough  __attribute__((fallthrough))\n#  endif\n#  pragma GCC diagnostic ignored \"-Wmain\"\n#  if (__GNUC__ >= 10)\n#    pragma GCC diagnostic ignored \"-Wzero-length-bounds\"\n#  endif\n#  if (__GNUC__ >= 7)\n#    pragma GCC diagnostic ignored \"-Wformat-overflow\"\n#    pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n#  endif\n#endif\n\n#ifndef fallthrough\n#  define fallthrough\n#endif\n\n";

static const char c_generator_Include_guard1[40] = "#ifndef EXTERNAL_H\n#define EXTERNAL_H\n\n";

static const char c_generator_C_types[499] = "// --- internally added ---\ntypedef unsigned char bool;\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef signed short int16_t;\ntypedef unsigned short uint16_t;\ntypedef signed int int32_t;\ntypedef unsigned int uint32_t;\n// FIXME: these should be target dependent\ntypedef signed long int64_t;\ntypedef unsigned long uint64_t;\ntypedef long ssize_t;\ntypedef unsigned long size_t;\n#define true 1\n#define false 0\n\n#define NULL ((void*)0)\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))\n";

static const char c_generator_C2_assert[289] = "int dprintf(int fd, const char *format, ...);\nvoid abort(void);\nstatic int c2_assert(const char* filename, int line, const char* funcname, const char* condstr) {\n    dprintf(2, \"%s:%d: function %s: Assertion failed: %s\\n\", filename, line, funcname, condstr);\n    abort();\n    return 0;\n}\n";

static const char c_generator_C2_strswitch[489] = "static int c2_strswitch(const char* s1, const char* s2) {\n    if (!s1) return 0;  // nil\n    if (!*s1) return 1; // \"\"\n    int idx = 2;\n    while (*s2) {\n        unsigned len = *s2++ & 0xFF;\n        for (unsigned i = 0;; i++) {\n            if (i == len) {\n                if (s1[i] == '\\0')\n                    goto done;\n                break;\n            }\n            if (s1[i] != s2[i])\n                break;\n        }\n        s2 += len;\n        idx++;\n    }\ndone:\n    return idx;\n}\n";

static c_generator_Fragment* c_generator_Fragment_create(void);
static void c_generator_Fragment_clear(c_generator_Fragment* f);
static void c_generator_Fragment_free(c_generator_Fragment* f);
static string_buffer_Buf* c_generator_Generator_getBuf(c_generator_Generator* gen, _Bool is_public);
static c_generator_Fragment* c_generator_Generator_getFragment(c_generator_Generator* gen);
static void c_generator_Generator_addFragment(c_generator_Generator* gen, c_generator_Fragment* f, _Bool is_public);
static void c_generator_Generator_freeFragment(c_generator_Generator* gen, c_generator_Fragment* f);
static void c_generator_Generator_emitCtv(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Expr* e);
static void c_generator_Generator_emitCName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d);
static void c_generator_Generator_emitCNameMod(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Decl* d, ast_Module* mod);
static void c_generator_Generator_emitDeclName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d);
static void c_generator_Generator_emitEnum(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static void c_generator_Generator_emitGlobalVarTypePre(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitTypePre(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitGlobalVarTypePost(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitTypePost(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_genDeclIfNeeded(c_generator_Generator* gen, ast_Decl* d);
static void c_generator_Generator_genTypeIfNeeded(c_generator_Generator* gen, ast_QualType qt, _Bool full);
static void c_generator_Generator_emitStructMember(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent);
static void c_generator_Generator_emitStruct(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent);
static void c_generator_Generator_emitFunctionType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static void c_generator_Generator_emitAliasType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static _Bool c_generator_emitAsDefine(const ast_VarDecl* vd);
static _Bool c_generator_Generator_emitGlobalVarDecl(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static void c_generator_Generator_emitSectionAttr(c_generator_Generator* gen, string_buffer_Buf* out, const char* name);
static void c_generator_Generator_emitAutoInit(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_on_forward_structs(void* arg, ast_Decl* d);
static void c_generator_Generator_emitForwardStructDecl(c_generator_Generator* gen, ast_Decl* d, string_buffer_Buf* out);
static void c_generator_Generator_emitGlobalDecl(c_generator_Generator* gen, ast_Decl* d);
static void c_generator_Generator_flattenFragments(c_generator_Generator* gen);
static void c_generator_Generator_on_decl(void* arg, ast_Decl* d);
static void c_generator_Generator_on_ast_decl(void* arg, ast_AST* a);
static void c_generator_Generator_gen_func_proto(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out);
static void c_generator_Generator_emitFunction(c_generator_Generator* gen, ast_FunctionDecl* fd);
static void c_generator_Generator_gen_full_func(void* arg, ast_FunctionDecl* fd);
static void c_generator_Generator_gen_full_funcs(void* arg, ast_AST* a);
static void c_generator_Generator_on_interface_import(void* arg, ast_ImportDecl* i);
static void c_generator_Generator_create_interface_imports(void* arg, ast_AST* a);
static void c_generator_Generator_on_interface_decl(void* arg, ast_Decl* d);
static void c_generator_Generator_create_interface_decls(void* arg, ast_AST* a);
static void c_generator_Generator_on_ast_structs(void* arg, ast_AST* a);
static void c_generator_Generator_decl_mark_generated(void* _arg0, ast_Decl* d);
static void c_generator_Generator_decl_clear_generated(void* _arg0, ast_Decl* d);
static void c_generator_Generator_ast_mark_generated(void* arg, ast_AST* a);
static void c_generator_Generator_ast_clear_generated(void* arg, ast_AST* a);
static void c_generator_Generator_on_header_decl(void* arg, ast_Decl* d);
static void c_generator_Generator_emitHeaderDecl(c_generator_Generator* gen, ast_Decl* d);
static void c_generator_add_gen_warning(string_buffer_Buf* out);
static void c_generator_Generator_generateInterfaceFiles(c_generator_Generator* gen, ast_Module* m);
static void c_generator_Generator_on_module(void* arg, ast_Module* m);
static void c_generator_Generator_write_files(c_generator_Generator* gen);
static void c_generator_Generator_init(c_generator_Generator* gen, string_pool_Pool* astPool, const char* target, build_target_Kind kind, const char* results_dir, const char* output_dir, source_mgr_SourceMgr* sm, const build_file_Info* build_info, ast_Decl* mainFunc);
static void c_generator_Generator_free(c_generator_Generator* gen);
static void c_generator_Generator_write(c_generator_Generator* gen, const char* output_dir, const char* filename, string_buffer_Buf* buf);
static void c_generator_generate(string_pool_Pool* astPool, string_pool_Pool* auxPool, const char* target, build_target_Kind kind, const char* output_dir, source_mgr_SourceMgr* sm, const build_file_Info* build_info, const target_info_Info* targetInfo, component_List* comps, const module_list_List* allmodules, ast_Decl* mainFunc, string_list_List* asm_files, _Bool enable_asserts, _Bool fast_build, _Bool asan, _Bool msan, _Bool ubsan, _Bool test_mode, _Bool trace_calls);
static void c_generator_build(const char* output_dir);
static void c_generator_Generator_emit_external_header(c_generator_Generator* gen, _Bool enable_asserts, const char* target);
static void c_generator_Generator_emitCall(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static ast_FunctionDecl* c_generator_get_function(ast_Decl* dest);
struct c_generator_FormatChanger_ {
   const char* format;
   ast_Expr** args;
   uint32_t idx;
   uint32_t last_offset;
   string_buffer_Buf* out;
};

static const _Bool c_generator_Size_prefix[15] = {
   [ast_BuiltinKind_Char] = false,
   [ast_BuiltinKind_Int8] = false,
   [ast_BuiltinKind_Int16] = false,
   [ast_BuiltinKind_Int32] = false,
   [ast_BuiltinKind_Int64] = true,
   [ast_BuiltinKind_UInt8] = false,
   [ast_BuiltinKind_UInt16] = false,
   [ast_BuiltinKind_UInt32] = false,
   [ast_BuiltinKind_UInt64] = true,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = true,
   [ast_BuiltinKind_ISize] = true,
   [ast_BuiltinKind_USize] = true,
   [ast_BuiltinKind_Bool] = false,
   [ast_BuiltinKind_Void] = false
};

static void c_generator_Generator_emitExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitBitOffset(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* base, ast_Expr* index);
static void c_generator_Generator_emitCast(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitBinaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitUnaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_emitDotOrArrow(string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitMemberExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitMemberExprBase(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitFieldDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitArrayDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_emitNumberFormat(ast_BuiltinKind kind, char letter, string_buffer_Buf* out);
static _Bool c_generator_on_format_specifier(void* context, printf_utils_Specifier specifier, uint32_t offset, int32_t stars, char c);
static void c_generator_Generator_emitBuiltinExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
struct c_generator_ArgValue_ {
   uint32_t name;
   ast_Value value;
};

struct c_generator_Evaluator_ {
   c_generator_ArgValue values[16];
   uint32_t num_values;
   ast_Value result;
};

static void c_generator_Evaluator_check(c_generator_Evaluator* eval, ast_FunctionDecl* fd, uint32_t num, ast_Expr** args);
static ast_Value c_generator_Evaluator_get_value(c_generator_Evaluator* eval, const ast_Expr* e);
static ast_Value c_generator_Evaluator_get_binaryop_value(c_generator_Evaluator* eval, const ast_BinaryOperator* e);
static ast_Value c_generator_Evaluator_get_unaryop_value(c_generator_Evaluator* eval, const ast_UnaryOperator* e);
static ast_Value c_generator_Evaluator_get_decl_value(c_generator_Evaluator* eval, const ast_Decl* d);
static void c_generator_Generator_emitPureFunctionCall(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static ast_FunctionDecl* c_generator_expr2function(ast_Expr* e);
static const char c_generator_C2_types_header[671] = "// WARNING: this file is auto-generated by the C2 compiler.\n// Any changes you make might be lost!\n\n#ifndef C2TYPES_H\n#define C2TYPES_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define NULL ((void*)0)\n#define offsetof(type, member) __builtin_offsetof(type, member)\n#define to_container(type, member, ptr) ((type *)((char *)(ptr)-offsetof(type, member)))\n\n// NOTE: 64-bit only for now\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef signed short int int16_t;\ntypedef unsigned short int uint16_t;\ntypedef signed int int32_t;\ntypedef unsigned int uint32_t;\ntypedef signed long int64_t;\ntypedef unsigned long uint64_t;\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n";

static void c_generator_Generator_createMakefile(c_generator_Generator* gen, const char* output_dir, component_List* comps, const module_list_List* allmodules, string_list_List* asm_files, _Bool enable_asserts, uint32_t libc_name);
static void c_generator_Generator_createExportsFile(c_generator_Generator* gen, const char* output_dir, component_Component* mainComp);
static void c_generator_Generator_generateC2TypesHeader(c_generator_Generator* gen);
static void c_generator_Generator_emitVarDecl(c_generator_Generator* gen, ast_VarDecl* vd, string_buffer_Buf* out, _Bool emit_init);
static void c_generator_Generator_emitStmt(c_generator_Generator* gen, ast_Stmt* s, uint32_t indent, _Bool newline);
static void c_generator_emitAsmPart(string_buffer_Buf* out, _Bool multi_line, uint32_t indent);
static void c_generator_Generator_emitAsmOperand(c_generator_Generator* gen, uint32_t name, const ast_Expr* c, ast_Expr* e);
static void c_generator_Generator_emitAsmStmt(c_generator_Generator* gen, ast_AsmStmt* a, uint32_t indent);
static void c_generator_Generator_emitSwitchStmt(c_generator_Generator* gen, ast_Stmt* s, uint32_t indent);
static void c_generator_Generator_emitCase(c_generator_Generator* gen, ast_SwitchCase* c, uint32_t indent, uint32_t* lab);
struct c_generator_TraceCall_ {
   uint8_t filename_idx;
   uint8_t column;
   uint16_t line;
   uint16_t caller_idx;
   uint16_t callee_idx;
};

#define c_generator_HASH_INITIAL 13
#define c_generator_HASH_PRIME 17
#define c_generator_HASH_BUCKETS 256
static uint32_t c_generator_TraceCallList_add(c_generator_TraceCallList* cl, c_generator_TraceCall call);
static void c_generator_TraceCallList_free(c_generator_TraceCallList* cl);
static void c_generator_StringList_free(c_generator_StringList* sl);
static uint32_t c_generator_StringList_length(c_generator_StringList* sl);
static const char* c_generator_StringList_get(c_generator_StringList* sl, uint32_t i);
static uint32_t c_generator_StringList_add(c_generator_StringList* sl, const char* s, _Bool check_last);
static uint32_t c_generator_Generator_addCall(c_generator_Generator* gen, const char* funcname, src_loc_SrcLoc loc);
static void c_generator_Generator_writeCalls(c_generator_Generator* gen, string_buffer_Buf* out);
static void c_generator_Generator_writeCallExterns(c_generator_Generator* gen, string_buffer_Buf* out);

static c_generator_Fragment* c_generator_Fragment_create(void)
{
   c_generator_Fragment* f = malloc(24);
   f->buf = string_buffer_create(128, false, 3);
   return f;
}

static void c_generator_Fragment_clear(c_generator_Fragment* f)
{
   string_buffer_Buf_clear(f->buf);
}

static void c_generator_Fragment_free(c_generator_Fragment* f)
{
   string_buffer_Buf_free(f->buf);
   free(f);
}

static string_buffer_Buf* c_generator_Generator_getBuf(c_generator_Generator* gen, _Bool is_public)
{
   string_buffer_Buf* out = gen->out;
   if ((gen->fast_build && ((is_public || gen->cur_external)))) out = gen->header;
   return out;
}

static c_generator_Fragment* c_generator_Generator_getFragment(c_generator_Generator* gen)
{
   if (linked_list_Element_isEmpty(&gen->free_list)) {
      return c_generator_Fragment_create();
   }
   linked_list_Element* e = linked_list_Element_popFront(&gen->free_list);
   c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
   c_generator_Fragment_clear(f);
   return f;
}

static void c_generator_Generator_addFragment(c_generator_Generator* gen, c_generator_Fragment* f, _Bool is_public)
{
   if ((gen->fast_build && ((is_public || gen->cur_external)))) {
      linked_list_Element_addTail(&gen->header_fragments, &f->list);
   } else {
      linked_list_Element_addTail(&gen->used_list, &f->list);
   }
}

static void c_generator_Generator_freeFragment(c_generator_Generator* gen, c_generator_Fragment* f)
{
   linked_list_Element_addTail(&gen->free_list, &f->list);
}

static void c_generator_Generator_emitCtv(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Expr* e)
{
   ast_Value val = ctv_analyser_get_value(e);
   string_buffer_Buf_print(out, "%s", ast_Value_str(&val));
}

static void c_generator_Generator_emitCName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d)
{
   c_generator_Generator_emitCNameMod(gen, out, d, gen->mod);
}

static void c_generator_Generator_emitCNameMod(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Decl* d, ast_Module* mod)
{
   if (ast_Decl_isExternal(d)) {
      const char* cname = ast_Decl_getCName(d);
      if (cname) {
         string_buffer_Buf_add(out, cname);
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
      return;
   }
   string_buffer_Buf_add(out, ast_Module_getName(mod));
   string_buffer_Buf_add1(out, '_');
   if (ast_Decl_isFunction(d)) {
      ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
      ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
      if (prefix) {
         string_buffer_Buf_add(out, ast_idx2name(prefix->name_idx));
         string_buffer_Buf_add1(out, '_');
      }
   }
   if (ast_Decl_isEnumConstant(d)) {
      ast_QualType qt = ast_Decl_getType(d);
      ast_EnumType* et = ((ast_EnumType*)(ast_QualType_getType(&qt)));
      string_buffer_Buf_add(out, ast_EnumType_getName(et));
      string_buffer_Buf_add1(out, '_');
   }
   string_buffer_Buf_add(out, ast_Decl_getName(d));
}

static void c_generator_Generator_emitDeclName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d)
{
   if (ast_Decl_isVariable(d)) {
      ast_VarDecl* vd = ((ast_VarDecl*)(d));
      if (!ast_VarDecl_isGlobal(vd)) {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
         return;
      }
   }
   c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
}

static void c_generator_Generator_emitEnum(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_EnumTypeDecl* etd = ((ast_EnumTypeDecl*)(d));
   string_buffer_Buf_add(out, "typedef enum {\n");
   ast_Decl_setGenerated(d);
   uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(etd);
   ast_EnumConstantDecl** decls = ast_EnumTypeDecl_getConstants(etd);
   for (uint32_t i = 0; (i < num_constants); i++) {
      ast_EnumConstantDecl* ecd = decls[i];
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_add(out, gen->mod_name);
      string_buffer_Buf_add1(out, '_');
      string_buffer_Buf_add(out, ast_Decl_getName(d));
      string_buffer_Buf_add1(out, '_');
      string_buffer_Buf_add(out, ast_Decl_getName(ast_EnumConstantDecl_asDecl(ecd)));
      ast_Expr* ie = ast_EnumConstantDecl_getInit(ecd);
      ast_Decl_setGenerated(ast_EnumConstantDecl_asDecl(ecd));
      if (ie) {
         string_buffer_Buf_add(out, " = ");
         c_generator_Generator_emitExpr(gen, out, ie);
      }
      string_buffer_Buf_add(out, ",\n");
   }
   ast_QualType implType = ast_EnumTypeDecl_getImplType(etd);
   const ast_BuiltinType* bi = ast_QualType_getBuiltin(&implType);
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_print(out, "_%s_%s_max = ", gen->mod_name, ast_Decl_getName(d));
   switch (ast_BuiltinType_getAlignment(bi)) {
   case 1:
      string_buffer_Buf_add(out, "255");
      break;
   case 2:
      string_buffer_Buf_add(out, "65535");
      break;
   case 4:
      string_buffer_Buf_add(out, "4294967295");
      break;
   case 8:
      string_buffer_Buf_add(out, "18446744073709551615");
      break;
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_add(out, "} __attribute__((packed)) ");
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ";\n\n");
}

static void c_generator_Generator_emitGlobalVarTypePre(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   if ((gen->cur_external && ast_QualType_isArray(&qt))) {
      ast_ArrayType* at = ((ast_ArrayType*)(ast_QualType_getType(&qt)));
      c_generator_Generator_emitGlobalVarTypePre(gen, out, ast_ArrayType_getElemType(at));
      string_buffer_Buf_add1(out, '*');
   } else {
      c_generator_Generator_emitTypePre(gen, out, qt);
   }
}

static void c_generator_Generator_emitTypePre(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   ast_Decl* decl = NULL;
   if (ast_QualType_isConst(&qt)) string_buffer_Buf_add(out, "const ");
   if (ast_QualType_isVolatile(&qt)) string_buffer_Buf_add(out, "volatile ");
   switch (ast_QualType_getKind(&qt)) {
   case ast_TypeKind_Builtin: {
      ast_BuiltinType* bt = ((ast_BuiltinType*)(ast_QualType_getType(&qt)));
      string_buffer_Buf_add(out, c_generator_builtinType_cnames[ast_BuiltinType_getKind(bt)]);
      return;
   }
   case ast_TypeKind_Pointer: {
      ast_PointerType* pt = ((ast_PointerType*)(ast_QualType_getType(&qt)));
      c_generator_Generator_emitTypePre(gen, out, ast_PointerType_getInner(pt));
      string_buffer_Buf_add1(out, '*');
      return;
   }
   case ast_TypeKind_Array: {
      ast_ArrayType* at = ((ast_ArrayType*)(ast_QualType_getType(&qt)));
      c_generator_Generator_emitTypePre(gen, out, ast_ArrayType_getElemType(at));
      return;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = ((ast_StructType*)(ast_QualType_getType(&qt)));
      ast_StructTypeDecl* std = ast_StructType_getDecl(st);
      if (ast_StructTypeDecl_hasAttrNoTypeDef(std)) {
         string_buffer_Buf_add(out, ast_StructTypeDecl_isStruct(std) ? "struct " : "union ");
      }
      decl = ((ast_Decl*)(ast_StructType_getDecl(st)));
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = ((ast_EnumType*)(ast_QualType_getType(&qt)));
      decl = ((ast_Decl*)(ast_EnumType_getDecl(et)));
      break;
   }
   case ast_TypeKind_Function: {
      ast_FunctionType* ft = ((ast_FunctionType*)(ast_QualType_getType(&qt)));
      decl = ((ast_Decl*)(ast_FunctionType_getDecl(ft)));
      break;
   }
   case ast_TypeKind_Alias: {
      ast_AliasType* at = ((ast_AliasType*)(ast_QualType_getType(&qt)));
      decl = ((ast_Decl*)(ast_AliasType_getDecl(at)));
      break;
   }
   case ast_TypeKind_Module:
      (0) || c2_assert("generator/c/c_generator.c2", 315, "c_generator.Generator.emitTypePre", "0");
      return;
   }
   c_generator_Generator_emitCNameMod(gen, out, decl, ast_Decl_getModule(decl));
}

static void c_generator_Generator_emitGlobalVarTypePost(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   if (!ast_QualType_isArray(&qt)) return;

   if (gen->cur_external) return;

   c_generator_Generator_emitTypePost(gen, out, qt);
}

static void c_generator_Generator_emitTypePost(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   if (!ast_QualType_isArray(&qt)) return;

   ast_ArrayType* at = ((ast_ArrayType*)(ast_QualType_getType(&qt)));
   string_buffer_Buf_add1(out, '[');
   if (ast_ArrayType_hasSize(at)) string_buffer_Buf_print(out, "%u", ast_ArrayType_getSize(at));
   string_buffer_Buf_add1(out, ']');
   c_generator_Generator_emitTypePost(gen, out, ast_ArrayType_getElemType(at));
}

static void c_generator_Generator_genDeclIfNeeded(c_generator_Generator* gen, ast_Decl* d)
{
   if (ast_Decl_isGenerated(d)) return;

   if (ast_Decl_isVariable(d)) {
      ast_VarDecl* vd = ((ast_VarDecl*)(d));
      if (!ast_VarDecl_isGlobal(vd)) return;

   }
   c_generator_Generator_emitGlobalDecl(gen, d);
}

static void c_generator_Generator_genTypeIfNeeded(c_generator_Generator* gen, ast_QualType qt, _Bool full)
{
   ast_Decl* d = NULL;
   switch (ast_QualType_getKind(&qt)) {
   case ast_TypeKind_Builtin:
      return;
   case ast_TypeKind_Pointer: {
      ast_PointerType* pt = ((ast_PointerType*)(ast_QualType_getType(&qt)));
      c_generator_Generator_genTypeIfNeeded(gen, ast_PointerType_getInner(pt), false);
      return;
   }
   case ast_TypeKind_Array: {
      ast_ArrayType* at = ((ast_ArrayType*)(ast_QualType_getType(&qt)));
      c_generator_Generator_genTypeIfNeeded(gen, ast_ArrayType_getElemType(at), true);
      return;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = ((ast_StructType*)(ast_QualType_getType(&qt)));
      if (!full) return;

      d = ((ast_Decl*)(ast_StructType_getDecl(st)));
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = ((ast_EnumType*)(ast_QualType_getType(&qt)));
      d = ((ast_Decl*)(ast_EnumType_getDecl(et)));
      break;
   }
   case ast_TypeKind_Function: {
      ast_FunctionType* et = ((ast_FunctionType*)(ast_QualType_getType(&qt)));
      d = ((ast_Decl*)(ast_FunctionType_getDecl(et)));
      break;
   }
   case ast_TypeKind_Alias: {
      ast_AliasType* at = ((ast_AliasType*)(ast_QualType_getType(&qt)));
      d = ((ast_Decl*)(ast_AliasType_getDecl(at)));
      break;
   }
   case ast_TypeKind_Module:
      (0) || c2_assert("generator/c/c_generator.c2", 381, "c_generator.Generator.genTypeIfNeeded", "0");
      return;
   }
   if (!ast_Decl_isGenerated(d)) c_generator_Generator_emitGlobalDecl(gen, d);
}

static void c_generator_Generator_emitStructMember(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent)
{
   if (ast_Decl_isVariable(d)) {
      c_generator_Generator_genTypeIfNeeded(gen, ast_Decl_getType(d), true);
      string_buffer_Buf_indent(out, indent);
      c_generator_Generator_emitTypePre(gen, out, ast_Decl_getType(d));
      string_buffer_Buf_space(out);
      if (ast_Decl_getNameIdx(d)) string_buffer_Buf_add(out, ast_Decl_getName(d));
      c_generator_Generator_emitTypePost(gen, out, ast_Decl_getType(d));
      ast_VarDecl* vd = ((ast_VarDecl*)(d));
      ast_Expr* bitfield = ast_VarDecl_getBitfield(vd);
      if (bitfield) {
         string_buffer_Buf_add(out, " : ");
         c_generator_Generator_emitCtv(gen, out, bitfield);
      }
      string_buffer_Buf_add(out, ";\n");
   } else {
      (ast_Decl_isStructType(d)) || c2_assert("generator/c/c_generator.c2", 410, "c_generator.Generator.emitStructMember", "d.isStructType()");
      c_generator_Generator_emitStruct(gen, out, d, indent);
   }
}

static void c_generator_Generator_emitStruct(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent)
{
   ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
   if (ast_StructTypeDecl_isGlobal(std)) {
      if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct ");
      else string_buffer_Buf_add(out, "union ");
      c_generator_Generator_emitCName(gen, out, d);
      if (!ast_StructTypeDecl_hasAttrNoTypeDef(std)) string_buffer_Buf_add1(out, '_');
      string_buffer_Buf_add(out, " {\n");
   } else {
      string_buffer_Buf_indent(out, indent);
      if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct");
      else string_buffer_Buf_add(out, "union");
      string_buffer_Buf_add(out, " {\n");
   }
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   for (uint32_t i = 0; (i < num_members); i++) {
      c_generator_Generator_emitStructMember(gen, out, members[i], (indent + 1));
   }
   if (ast_StructTypeDecl_isGlobal(std)) {
      string_buffer_Buf_add(out, "}");
      if (ast_StructTypeDecl_isPacked(std)) string_buffer_Buf_add(out, " __attribute__((packed))");
      string_buffer_Buf_add(out, ";\n\n");
   } else {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add1(out, '}');
      if (ast_Decl_getNameIdx(d)) {
         string_buffer_Buf_space(out);
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
      string_buffer_Buf_add(out, ";\n");
   }
}

static void c_generator_Generator_emitFunctionType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_FunctionTypeDecl* ftd = ((ast_FunctionTypeDecl*)(d));
   ast_FunctionDecl* fd = ast_FunctionTypeDecl_getDecl(ftd);
   ast_Decl_setGenerated(ast_FunctionDecl_asDecl(fd));
   string_buffer_Buf_add(out, "typedef ");
   c_generator_Generator_emitTypePre(gen, out, ast_FunctionDecl_getRType(fd));
   string_buffer_Buf_add(out, " (*");
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ")(");
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; (i < num_params); i++) {
      ast_Decl* arg = ((ast_Decl*)(params[i]));
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitTypePre(gen, out, ast_Decl_getType(arg));
      const char* name = ast_Decl_getName(arg);
      string_buffer_Buf_space(out);
      if (name) string_buffer_Buf_add(out, name);
      else string_buffer_Buf_print(out, "_arg%u", i);
   }
   if (ast_FunctionDecl_isVariadic(fd)) {
      if (num_params) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_add(out, "...");
   }
   if (((num_params == 0) && !ast_FunctionDecl_isVariadic(fd))) string_buffer_Buf_add(out, "void");
   string_buffer_Buf_add(out, ")");
   if (ast_Decl_hasAttrUnused(d)) string_buffer_Buf_add(out, " __attribute__((unused))");
   string_buffer_Buf_add(out, ";\n\n");
}

static void c_generator_Generator_emitAliasType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_QualType qt = ast_Decl_getType(d);
   qt = ast_QualType_getCanonicalType(&qt);
   string_buffer_Buf_add(out, "typedef ");
   c_generator_Generator_emitTypePre(gen, out, qt);
   c_generator_Generator_emitTypePost(gen, out, qt);
   string_buffer_Buf_space(out);
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ";\n\n");
}

static _Bool c_generator_emitAsDefine(const ast_VarDecl* vd)
{
   const ast_Decl* d = ((ast_Decl*)(vd));
   ast_QualType qt = ast_Decl_getType(d);
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   if (ast_VarDecl_isAddrUsed(vd)) return false;

   const ast_Expr* initExpr = ast_VarDecl_getInit(vd);
   if (!initExpr) return false;

   if (!ast_QualType_isArray(&canon)) {
      if (!ast_QualType_isConst(&qt)) return false;

      if (ast_QualType_isVolatile(&qt)) return false;

      if (ast_QualType_isBuiltin(&canon)) return true;

   }
   return false;
}

static _Bool c_generator_Generator_emitGlobalVarDecl(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_VarDecl* vd = ((ast_VarDecl*)(d));
   ast_QualType qt = ast_Decl_getType(d);
   if (c_generator_emitAsDefine(vd)) {
      string_buffer_Buf_add(out, "#define ");
      c_generator_Generator_emitCName(gen, out, d);
      string_buffer_Buf_space(out);
      ast_Expr* ie = ast_VarDecl_getInit(vd);
      if (ast_Expr_isCall(ie)) {
         c_generator_Generator_emitPureFunctionCall(gen, out, ie);
      } else {
         c_generator_Generator_emitExpr(gen, out, ie);
      }
      string_buffer_Buf_newline(out);
      return true;
   }
   _Bool emit_header = (gen->fast_build && ast_Decl_isPublic(d));
   if (gen->cur_external) {
      string_buffer_Buf_add(out, "extern ");
   } else {
      if ((!ast_Decl_isExported(d) && !emit_header)) string_buffer_Buf_add(out, "static ");
   }
   const char* cdef = ast_Decl_getCDef(d);
   if (cdef) {
      string_buffer_Buf_add(out, cdef);
   } else {
      c_generator_Generator_emitGlobalVarTypePre(gen, out, qt);
      string_buffer_Buf_space(out);
      c_generator_Generator_emitCName(gen, out, d);
      c_generator_Generator_emitGlobalVarTypePost(gen, out, qt);
   }
   if (ast_VarDecl_hasAttrWeak(vd)) string_buffer_Buf_add(out, " __attribute__((weak))");
   const char* section = ast_Decl_getSection(d);
   if (section) {
      string_buffer_Buf_space(out);
      c_generator_Generator_emitSectionAttr(gen, out, section);
   }
   ast_Expr* ie = ast_VarDecl_getInit(vd);
   if (!gen->cur_external) {
      string_buffer_Buf_add(out, " = ");
      if (ie) {
         if (ast_Expr_isCall(ie)) {
            c_generator_Generator_emitPureFunctionCall(gen, out, ie);
         } else {
            c_generator_Generator_emitExpr(gen, out, ie);
         }
      } else {
         c_generator_Generator_emitAutoInit(gen, out, qt);
      }
   }
   string_buffer_Buf_add(out, ";\n\n");
   if (emit_header) {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      out = f->buf;
      string_buffer_Buf_add(out, "extern ");
      if (cdef) {
         string_buffer_Buf_add(out, cdef);
      } else {
         c_generator_Generator_emitGlobalVarTypePre(gen, out, qt);
         string_buffer_Buf_space(out);
         c_generator_Generator_emitCName(gen, out, d);
         c_generator_Generator_emitGlobalVarTypePost(gen, out, qt);
      }
      if (ast_VarDecl_hasAttrWeak(vd)) string_buffer_Buf_add(out, " __attribute__((weak))");
      if (section) {
         string_buffer_Buf_space(out);
         c_generator_Generator_emitSectionAttr(gen, out, section);
      }
      string_buffer_Buf_add(out, ";\n");
      c_generator_Generator_addFragment(gen, f, true);
   }
   return false;
}

static void c_generator_Generator_emitSectionAttr(c_generator_Generator* gen, string_buffer_Buf* out, const char* name)
{
   string_buffer_Buf_print(out, "__attribute__((section(\"%s\")))", name);
}

static void c_generator_Generator_emitAutoInit(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   qt = ast_QualType_getCanonicalType(&qt);
   if ((ast_QualType_isArray(&qt) || ast_QualType_isStruct(&qt))) {
      string_buffer_Buf_add(out, "{ }");
   } else if (ast_QualType_isPointer(&qt)) {
      string_buffer_Buf_add(out, "NULL");
   } else {
      string_buffer_Buf_add1(out, '0');
   }

}

static void c_generator_Generator_on_forward_structs(void* arg, ast_Decl* d)
{
   c_generator_Generator* gen = arg;
   if (!ast_Decl_isUsed(d)) return;

   if (!ast_Decl_isStructType(d)) return;

   if ((gen->cur_external && !ast_Decl_isUsed(d))) return;

   c_generator_Generator_emitForwardStructDecl(gen, d, c_generator_Generator_getBuf(gen, ast_Decl_isPublic(d)));
}

static void c_generator_Generator_emitForwardStructDecl(c_generator_Generator* gen, ast_Decl* d, string_buffer_Buf* out)
{
   ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
   if (ast_StructTypeDecl_hasAttrNoTypeDef(std)) return;

   string_buffer_Buf_add(out, "typedef ");
   if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct");
   else string_buffer_Buf_add(out, "union");
   string_buffer_Buf_space(out);
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, "_ ");
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ";\n");
}

static void c_generator_Generator_emitGlobalDecl(c_generator_Generator* gen, ast_Decl* d)
{
   (!ast_Decl_isGenerated(d)) || c2_assert("generator/c/c_generator.c2", 650, "c_generator.Generator.emitGlobalDecl", "!d.isGenerated()");
   if ((gen->cur_external && !ast_Decl_isUsed(d))) {
      ast_Decl_setGenerated(d);
      return;
   }
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function: {
      ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
      if (ast_FunctionDecl_isTemplate(fd)) break;

      string_buffer_Buf* out = c_generator_Generator_getBuf(gen, ast_Decl_isPublic(d));
      c_generator_Generator_gen_func_proto(gen, fd, out);
      if (ast_FunctionDecl_isInline(fd)) {
         string_buffer_Buf_newline(out);
         string_buffer_Buf* saved = gen->out;
         gen->out = out;
         c_generator_Generator_emitStmt(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))), 0, true);
         gen->out = saved;
         string_buffer_Buf_newline(out);
      } else {
         string_buffer_Buf_add(out, ";\n");
      }
      break;
   }
   case ast_DeclKind_Import: {
      (gen->fast_build) || c2_assert("generator/c/c_generator.c2", 677, "c_generator.Generator.emitGlobalDecl", "gen.fast_build");
      ast_ImportDecl* id = ((ast_ImportDecl*)(d));
      ast_Module* dest = ast_ImportDecl_getDest(id);
      string_buffer_Buf* out = c_generator_Generator_getBuf(gen, ((dest != gen->mod) && ast_Decl_isUsedPublic(d)));
      string_buffer_Buf_print(out, "#include \"%s.h\"\n", ast_Module_getName(dest));
      break;
   }
   case ast_DeclKind_StructType: {
      ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitStruct(gen, f->buf, d, 0);
      c_generator_Generator_addFragment(gen, f, (ast_Decl_isPublic(d) && !ast_StructTypeDecl_isOpaque(std)));
      break;
   }
   case ast_DeclKind_EnumType: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitEnum(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d));
      break;
   }
   case ast_DeclKind_EnumConstant:
      console_warn("TODO gen enum %u", ast_Decl_isGenerated(d));
      break;
   case ast_DeclKind_FunctionType: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitFunctionType(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d));
      break;
   }
   case ast_DeclKind_AliasType: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitAliasType(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d));
      break;
   }
   case ast_DeclKind_Variable: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      _Bool in_header = c_generator_Generator_emitGlobalVarDecl(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, in_header);
      break;
   }
   }
   ast_Decl_setGenerated(d);
   c_generator_Generator_flattenFragments(gen);
}

static void c_generator_Generator_flattenFragments(c_generator_Generator* gen)
{
   while (!linked_list_Element_isEmpty(&gen->used_list)) {
      linked_list_Element* e = linked_list_Element_popFront(&gen->used_list);
      c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
      string_buffer_Buf_add2(gen->out, string_buffer_Buf_data(f->buf), string_buffer_Buf_size(f->buf));
      c_generator_Generator_freeFragment(gen, f);
   }
   if (!gen->fast_build) {
      (linked_list_Element_isEmpty(&gen->header_fragments)) || c2_assert("generator/c/c_generator.c2", 737, "c_generator.Generator.flattenFragments", "gen.header_fragments.isEmpty()");
   }
   while (!linked_list_Element_isEmpty(&gen->header_fragments)) {
      linked_list_Element* e = linked_list_Element_popFront(&gen->header_fragments);
      c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
      string_buffer_Buf_add2(gen->header, string_buffer_Buf_data(f->buf), string_buffer_Buf_size(f->buf));
      c_generator_Generator_freeFragment(gen, f);
   }
}

static void c_generator_Generator_on_decl(void* arg, ast_Decl* d)
{
   if ((ast_Decl_isGenerated(d) || !ast_Decl_isUsed(d))) return;

   c_generator_Generator* gen = arg;
   if (ast_Decl_isImport(d)) {
      if (!gen->fast_build) return;

      ast_ImportDecl* id = ((ast_ImportDecl*)(d));
      if ((gen->cur_external && (gen->mod == ast_ImportDecl_getDest(id)))) return;

   }
   dep_finder_Finder_check(&gen->deps, d);
   c_generator_Generator_emitGlobalDecl(gen, d);
}

static void c_generator_Generator_on_ast_decl(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_on_decl, arg);
}

static void c_generator_Generator_gen_func_proto(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out)
{
   ast_Decl* d = ((ast_Decl*)(fd));
   if (ast_FunctionDecl_isTemplate(fd)) return;

   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   _Bool has_attr = false;
   const char* section = ast_Decl_getSection(d);
   if (section) {
      has_attr = true;
      c_generator_Generator_emitSectionAttr(gen, out, section);
      string_buffer_Buf_space(out);
   }
   if (ast_FunctionDecl_hasAttrInline(fd)) {
      if (has_attr) string_buffer_Buf_space(out);
      string_buffer_Buf_add(out, "static inline ");
      has_attr = true;
   }
   if (ast_FunctionDecl_hasAttrWeak(fd)) {
      string_buffer_Buf_add(out, "__attribute__((weak)) ");
      has_attr = true;
   }
   if (ast_FunctionDecl_hasAttrConstructor(fd)) {
      string_buffer_Buf_add(out, "__attribute__((constructor)) ");
      has_attr = true;
   }
   if (ast_FunctionDecl_hasAttrDestructor(fd)) {
      string_buffer_Buf_add(out, "__attribute__((destructor)) ");
      has_attr = true;
   }
   uint8_t printf_arg = ast_FunctionDecl_getAttrPrintf(fd);
   if (printf_arg) {
      string_buffer_Buf_print(out, "__attribute__((__format__(printf, %u, %u))) ", printf_arg, (num_params + 1));
      has_attr = true;
   }
   if (has_attr) string_buffer_Buf_newline(out);
   if ((d == gen->mainFunc)) {
      string_buffer_Buf_add(out, "int32_t main");
   } else {
      if ((((!ast_FunctionDecl_hasAttrInline(fd) && !gen->cur_external) && !ast_Decl_isExported(d)) && !((gen->fast_build && ast_Decl_isPublic(d))))) string_buffer_Buf_add(out, "static ");
      c_generator_Generator_emitTypePre(gen, out, ast_FunctionDecl_getRType(fd));
      string_buffer_Buf_space(out);
      c_generator_Generator_emitCName(gen, out, d);
   }
   string_buffer_Buf_lparen(out);
   for (uint32_t i = 0; (i < num_params); i++) {
      ast_Decl* argx = ((ast_Decl*)(params[i]));
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitTypePre(gen, out, ast_Decl_getType(argx));
      string_buffer_Buf_space(out);
      const char* name = ast_Decl_getName(argx);
      if (name) string_buffer_Buf_add(out, name);
      else string_buffer_Buf_print(out, "_arg%u", i);
   }
   if (ast_FunctionDecl_isVariadic(fd)) {
      if (num_params) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_add(out, "...");
   } else {
      if ((num_params == 0)) string_buffer_Buf_add(out, "void");
   }
   string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitFunction(c_generator_Generator* gen, ast_FunctionDecl* fd)
{
   c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
   string_buffer_Buf* out = f->buf;
   c_generator_Generator_gen_func_proto(gen, fd, out);
   string_buffer_Buf_newline(out);
   string_buffer_Buf* saved = gen->out;
   gen->out = out;
   c_generator_Generator_emitStmt(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))), 0, true);
   string_buffer_Buf_newline(out);
   gen->out = saved;
   c_generator_Generator_addFragment(gen, f, false);
}

static void c_generator_Generator_gen_full_func(void* arg, ast_FunctionDecl* fd)
{
   if (!ast_Decl_isUsed(ast_FunctionDecl_asDecl(fd))) return;

   if (!ast_FunctionDecl_getBody(fd)) return;

   c_generator_Generator* gen = arg;
   if (ast_FunctionDecl_isTemplate(fd)) return;

   if (ast_FunctionDecl_isInline(fd)) return;

   gen->cur_function = fd;
   c_generator_Generator_emitFunction(gen, fd);
   gen->cur_function = NULL;
   c_generator_Generator_flattenFragments(gen);
}

static void c_generator_Generator_gen_full_funcs(void* arg, ast_AST* a)
{
   ast_AST_visitFunctions(a, c_generator_Generator_gen_full_func, arg);
}

static void c_generator_Generator_on_interface_import(void* arg, ast_ImportDecl* i)
{
   c_generator_Generator* gen = arg;
   ast_Decl* d = ((ast_Decl*)(i));
   if (!ast_Decl_isUsedPublic(d)) return;

   uint32_t name_idx = ast_Decl_getNameIdx(d);
   if (string_list_List_contains_idx(&gen->imports, name_idx)) return;

   string_list_List_add(&gen->imports, name_idx);
   string_buffer_Buf_print(gen->header, "#include \"%s.h\"\n", ast_Decl_getName(d));
}

static void c_generator_Generator_create_interface_imports(void* arg, ast_AST* a)
{
   ast_AST_visitImports(a, c_generator_Generator_on_interface_import, arg);
}

static void c_generator_Generator_on_interface_decl(void* arg, ast_Decl* d)
{
   c_generator_Generator* gen = arg;
   if (!ast_Decl_isExported(d)) return;

   if (ast_Decl_isImport(d)) return;

   if (ast_Decl_isStructType(d)) {
      c_generator_Generator_emitForwardStructDecl(gen, d, gen->header);
      string_buffer_Buf_newline(gen->header);
      ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
      if (ast_StructTypeDecl_isOpaque(std)) return;

   }
   ast_DeclList_add(&gen->decls, d);
}

static void c_generator_Generator_create_interface_decls(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_on_interface_decl, arg);
}

static void c_generator_Generator_on_ast_structs(void* arg, ast_AST* a)
{
   ast_AST_visitTypeDecls(a, c_generator_Generator_on_forward_structs, arg);
}

static void c_generator_Generator_decl_mark_generated(void* _arg0, ast_Decl* d)
{
   ast_Decl_setGenerated(d);
}

static void c_generator_Generator_decl_clear_generated(void* _arg0, ast_Decl* d)
{
   ast_Decl_clearGenerated(d);
}

static void c_generator_Generator_ast_mark_generated(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_decl_mark_generated, arg);
}

static void c_generator_Generator_ast_clear_generated(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_decl_clear_generated, arg);
}

static void c_generator_Generator_on_header_decl(void* arg, ast_Decl* d)
{
   if (ast_Decl_isGenerated(d)) return;

   c_generator_Generator* gen = arg;
   dep_finder_Finder_check(&gen->deps, d);
   c_generator_Generator_emitHeaderDecl(gen, d);
   ast_Decl_setGenerated(d);
}

static void c_generator_Generator_emitHeaderDecl(c_generator_Generator* gen, ast_Decl* d)
{
   string_buffer_Buf* out = gen->header;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function: {
      ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
      if (ast_FunctionDecl_isTemplate(fd)) break;

      c_generator_Generator_gen_func_proto(gen, fd, out);
      if (ast_FunctionDecl_isInline(fd)) {
         string_buffer_Buf_newline(out);
         c_generator_Generator_emitStmt(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))), 0, true);
         string_buffer_Buf_newline(out);
      } else {
         string_buffer_Buf_add(out, ";\n");
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_DeclKind_Import:
      (0) || c2_assert("generator/c/c_generator.c2", 984, "c_generator.Generator.emitHeaderDecl", "0");
      return;
   case ast_DeclKind_StructType:
      c_generator_Generator_emitStruct(gen, out, d, 0);
      break;
   case ast_DeclKind_EnumType:
      c_generator_Generator_emitEnum(gen, out, d);
      break;
   case ast_DeclKind_EnumConstant:
      (0) || c2_assert("generator/c/c_generator.c2", 993, "c_generator.Generator.emitHeaderDecl", "0");
      return;
   case ast_DeclKind_FunctionType:
      c_generator_Generator_emitFunctionType(gen, out, d);
      break;
   case ast_DeclKind_AliasType:
      c_generator_Generator_emitAliasType(gen, out, d);
      break;
   case ast_DeclKind_Variable:
      c_generator_Generator_emitGlobalVarDecl(gen, out, d);
      break;
   }
}

static void c_generator_add_gen_warning(string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "// WARNING: this file is auto-generated by the C2 compiler.\n");
   string_buffer_Buf_add(out, "// Any changes you make might be lost!\n\n");
}

static void c_generator_Generator_generateInterfaceFiles(c_generator_Generator* gen, ast_Module* m)
{
   string_list_List_clear(&gen->imports);
   string_buffer_Buf_clear(gen->header);
   ast_DeclList_clear(&gen->decls);
   c2i_generator_generate(gen->results_dir, m);
   string_buffer_Buf* hdr = gen->header;
   c_generator_add_gen_warning(hdr);
   char upper_name[32];
   string_utils_toUpper(ast_Module_getName(m), upper_name);
   string_buffer_Buf_print(hdr, "#ifndef %s_H\n", upper_name);
   string_buffer_Buf_print(hdr, "#define %s_H\n\n", upper_name);
   string_buffer_Buf_add(hdr, "#include \"c2types.h\"\n\n");
   string_buffer_Buf_add(hdr, "#ifdef __cplusplus\nextern \"C\" {\n#endif\n");
   gen->cur_external = true;
   ast_Module_visitASTs(m, c_generator_Generator_ast_clear_generated, gen);
   ast_Module_visitASTs(m, c_generator_Generator_create_interface_imports, gen);
   string_buffer_Buf_newline(hdr);
   ast_Module_visitASTs(m, c_generator_Generator_create_interface_decls, gen);
   dep_finder_Finder_init(&gen->deps, m, gen, c_generator_Generator_on_header_decl);
   string_buffer_Buf* saved = gen->out;
   gen->out = hdr;
   for (uint32_t i = 0; (i < ast_DeclList_size(&gen->decls)); i++) {
      c_generator_Generator_on_header_decl(gen, ast_DeclList_get(&gen->decls, i));
   }
   gen->out = saved;
   string_buffer_Buf_add(hdr, "#ifdef __cplusplus\n}\n#endif\n\n");
   string_buffer_Buf_add(hdr, "#endif\n");
   file_utils_Writer writer;
   char fullname[512];
   snprintf(fullname, 512, "%s/%s.h", gen->results_dir, ast_Module_getName(m));
   if (!file_utils_Writer_write(&writer, fullname, string_buffer_Buf_data(hdr), string_buffer_Buf_size(hdr))) {
      console_error("cannot write to %s: %s", fullname, file_utils_Writer_getError(&writer));
   }
   gen->cur_external = false;
}

static void c_generator_Generator_on_module(void* arg, ast_Module* m)
{
   if (!ast_Module_isUsed(m)) return;

   c_generator_Generator* gen = arg;
   string_buffer_Buf* out = gen->out;
   gen->mod_name = ast_Module_getName(m);
   gen->mod = m;
   if (gen->fast_build) {
      string_buffer_Buf_clear(out);
      string_buffer_Buf_clear(gen->header);
      c_generator_add_gen_warning(gen->header);
      char upper_name[32];
      string_utils_toUpper(gen->mod_name, upper_name);
      string_buffer_Buf_print(gen->header, "#ifndef %s_H\n", upper_name);
      string_buffer_Buf_print(gen->header, "#define %s_H\n\n", upper_name);
      string_buffer_Buf_add(gen->header, "#include \"_external.h\"\n\n");
      c_generator_add_gen_warning(out);
   } else {
      string_buffer_Buf_print(out, "\n// --- module %s ---\n", gen->mod_name);
   }
   if ((ast_Module_getNameIdx(m) == gen->stdargName)) {
      if (gen->fast_build) out = gen->header;
      const char builtin_defs[167] = "// Note: this module is a special case and is custom generated\n#define va_list __builtin_va_list\n#define va_start __builtin_va_start\n#define va_end __builtin_va_end\n\n";
      string_buffer_Buf_add(out, builtin_defs);
      ast_Module_visitASTs(m, c_generator_Generator_ast_mark_generated, arg);
      if (gen->fast_build) c_generator_Generator_write_files(gen);
      return;
   }
   ast_Module_visitASTs(m, c_generator_Generator_ast_clear_generated, gen);
   ast_Module_visitASTs(m, c_generator_Generator_on_ast_structs, arg);
   string_buffer_Buf_newline(gen->out);
   dep_finder_Finder_init(&gen->deps, m, gen, c_generator_Generator_on_decl);
   ast_Module_visitASTs(m, c_generator_Generator_on_ast_decl, arg);
   string_buffer_Buf_newline(gen->out);
   ast_Module_visitASTs(m, c_generator_Generator_gen_full_funcs, arg);
   if (gen->fast_build) c_generator_Generator_write_files(gen);
   if (ast_Module_isExported(m)) c_generator_Generator_generateInterfaceFiles(gen, m);
}

static void c_generator_Generator_write_files(c_generator_Generator* gen)
{
   (gen->fast_build) || c2_assert("generator/c/c_generator.c2", 1115, "c_generator.Generator.write_files", "gen.fast_build");
   string_buffer_Buf_add(gen->header, "\n#endif\n\n");
   char outfile[64];
   if (!gen->cur_external) {
      sprintf(outfile, "%s.c", gen->mod_name);
      c_generator_Generator_write(gen, gen->cgen_dir, outfile, gen->out);
   }
   sprintf(outfile, "%s.h", gen->mod_name);
   c_generator_Generator_write(gen, gen->cgen_dir, outfile, gen->header);
   string_buffer_Buf_clear(gen->out);
   string_buffer_Buf_clear(gen->header);
}

static void c_generator_Generator_init(c_generator_Generator* gen, string_pool_Pool* astPool, const char* target, build_target_Kind kind, const char* results_dir, const char* output_dir, source_mgr_SourceMgr* sm, const build_file_Info* build_info, ast_Decl* mainFunc)
{
   memset(gen, 0, 408);
   gen->out = string_buffer_create((256 * 1024), false, 3);
   gen->target = target;
   gen->target_kind = kind;
   gen->results_dir = results_dir;
   gen->output_dir = output_dir;
   gen->sm = sm;
   gen->build_info = build_info;
   gen->mainFunc = mainFunc;
   linked_list_Element_init(&gen->free_list);
   linked_list_Element_init(&gen->used_list);
   linked_list_Element_init(&gen->header_fragments);
   gen->header = string_buffer_create(8192, false, 2);
   string_list_List_init(&gen->imports, NULL);
   ast_DeclList_init(&gen->decls);
   gen->astPool = astPool;
   gen->stdargName = string_pool_Pool_addStr(astPool, "stdarg", true);
}

static void c_generator_Generator_free(c_generator_Generator* gen)
{
   while (!linked_list_Element_isEmpty(&gen->free_list)) {
      linked_list_Element* e = linked_list_Element_popFront(&gen->free_list);
      c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
      c_generator_Fragment_free(f);
   }
   string_buffer_Buf_free(gen->out);
   string_buffer_Buf_free(gen->header);
   string_list_List_free(&gen->imports);
   ast_DeclList_free(&gen->decls);
   c_generator_TraceCallList_free(&gen->calls);
   c_generator_StringList_free(&gen->filenames);
   c_generator_StringList_free(&gen->funcnames);
}

static void c_generator_Generator_write(c_generator_Generator* gen, const char* output_dir, const char* filename, string_buffer_Buf* buf)
{
   char fullname[512];
   snprintf(fullname, 512, "%s/%s", output_dir, filename);
   file_utils_Writer writer;
   _Bool ok = file_utils_Writer_write(&writer, fullname, string_buffer_Buf_udata(buf), string_buffer_Buf_size(buf));
   if (!ok) {
      console_error("cannot write to %s: %s", fullname, file_utils_Writer_getError(&writer));
   }
}

static void c_generator_generate(string_pool_Pool* astPool, string_pool_Pool* auxPool, const char* target, build_target_Kind kind, const char* output_dir, source_mgr_SourceMgr* sm, const build_file_Info* build_info, const target_info_Info* targetInfo, component_List* comps, const module_list_List* allmodules, ast_Decl* mainFunc, string_list_List* asm_files, _Bool enable_asserts, _Bool fast_build, _Bool asan, _Bool msan, _Bool ubsan, _Bool test_mode, _Bool trace_calls)
{
   char dir[512];
   sprintf(dir, "%s/%s", output_dir, c_generator_Dir);
   int32_t err = file_utils_create_directory(dir);
   if (err) {
      console_error("cannot create directory %s: %s", dir, strerror(err));
      return;
   }
   c_generator_Generator gen;
   c_generator_Generator_init(&gen, astPool, target, kind, output_dir, dir, sm, build_info, mainFunc);
   gen.auxPool = auxPool;
   gen.enable_asserts = enable_asserts;
   gen.fast_build = fast_build;
   gen.asan = asan;
   gen.msan = msan;
   gen.ubsan = ubsan;
   gen.trace_calls = trace_calls;
   gen.targetInfo = targetInfo;
   gen.cgen_dir = dir;
   string_buffer_Buf* out = gen.out;
   if (!fast_build) {
      c_generator_add_gen_warning(out);
   }
   c_generator_Generator_emit_external_header(&gen, enable_asserts, target);
   if (fast_build) {
      c_generator_Generator_write(&gen, gen.cgen_dir, "_external.h", gen.out);
      string_buffer_Buf_clear(out);
      gen.cur_external = true;
   }
   component_Component* mainComp = component_List_getLast(comps);
   if ((gen.target_kind != build_target_Kind_Executable)) {
      c_generator_Generator_generateC2TypesHeader(&gen);
   }
   for (uint32_t i = 0; (i < (component_List_size(comps) - 1)); i++) {
      component_Component* c = component_List_get(comps, i);
      gen.cur_external = component_Component_isExternal(c);
      component_Component_visitModules(c, c_generator_Generator_on_module, &gen);
   }
   gen.cur_external = false;
   component_Component_visitModules(mainComp, c_generator_Generator_on_module, &gen);
   if (fast_build) string_buffer_Buf_clear(gen.out);
   if (gen.trace_calls) c_generator_Generator_writeCalls(&gen, gen.out);
   if ((!fast_build || gen.trace_calls)) {
      c_generator_Generator_write(&gen, dir, "build.c", gen.out);
   }
   uint32_t libc_name = string_pool_Pool_addStr(auxPool, "libc", true);
   c_generator_Generator_createMakefile(&gen, dir, comps, allmodules, asm_files, enable_asserts, libc_name);
   c_generator_Generator_createExportsFile(&gen, dir, component_List_get(comps, (component_List_size(comps) - 1)));
   if (component_Component_isLibrary(mainComp)) manifest_writer_write(output_dir, mainComp, constants_manifest_name);
   c_generator_Generator_free(&gen);
}

static void c_generator_build(const char* output_dir)
{
   const char* make = "make";
   char dir[512];
   sprintf(dir, "%s/%s/", output_dir, c_generator_Dir);
   int32_t retval = process_utils_run_args(dir, make, "-j", c_generator_LogFile);
   if ((retval != 0)) {
      console_error("error during external C compilation");
      console_log("see %s%s for details", dir, c_generator_LogFile);
   }
}

static void c_generator_Generator_emit_external_header(c_generator_Generator* gen, _Bool enable_asserts, const char* target)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_add(out, c_generator_Include_guard1);
   string_buffer_Buf_add(out, c_generator_Warning_control);
   string_buffer_Buf_add(out, c_generator_C_types);
   string_buffer_Buf_add(out, "#define offsetof(type, member) __builtin_offsetof(type, member)\n");
   string_buffer_Buf_add(out, "#define to_container(type, member, ptr) ((type*)((char*)(ptr) - offsetof(type, member)))\n\n");
   if (enable_asserts) {
      string_buffer_Buf_add(out, c_generator_C2_assert);
   }
   string_buffer_Buf_add(out, c_generator_C2_strswitch);
   if (gen->trace_calls) c_generator_Generator_writeCallExterns(gen, out);
   string_buffer_Buf_add(out, "#endif\n");
}

static void c_generator_Generator_emitCall(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_CallExpr* call = ((ast_CallExpr*)(e));
   _Bool is_tf = ast_CallExpr_isTypeFunc(call);
   ast_Decl* dest;
   if (ast_CallExpr_isTemplateCall(call)) {
      ast_Expr* func = ast_CallExpr_getFunc(call);
      ast_QualType qt = ast_Expr_getType(func);
      ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(&qt);
      ast_FunctionDecl* template_fd = ast_FunctionType_getDecl(ft);
      uint32_t idx = ast_CallExpr_getTemplateIdx(call);
      ast_FunctionDecl* instance = ast_Module_getInstance(gen->mod, template_fd, idx);
      (instance) || c2_assert("generator/c/c_generator_call.c2", 37, "c_generator.Generator.emitCall", "instance");
      dest = ast_FunctionDecl_asDecl(instance);
      if (!ast_Decl_isGenerated(dest)) {
         c_generator_Generator_emitFunction(gen, instance);
         ast_Decl_setGenerated(ast_FunctionDecl_asDecl(instance));
      }
      c_generator_Generator_emitDeclName(gen, out, dest);
      string_buffer_Buf_lparen(out);
   } else {
      ast_Expr* func = ast_CallExpr_getFunc(call);
      if ((ast_Expr_getKind(func) == ast_ExprKind_ImplicitCast)) {
         ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(func));
         func = ast_ImplicitCastExpr_getInner(ic);
      }
      if ((is_tf || ast_CallExpr_isStaticTypeFunc(call))) {
         ((ast_Expr_getKind(func) == ast_ExprKind_Member)) || c2_assert("generator/c/c_generator_call.c2", 54, "c_generator.Generator.emitCall", "func.getKind() == ExprKind.Member");
         ast_MemberExpr* m = ((ast_MemberExpr*)(func));
         dest = ast_MemberExpr_getFullDecl(m);
         if (gen->trace_calls) {
            string_buffer_Buf_print(out, "(c2_trace_counts[%u]++, ", c_generator_Generator_addCall(gen, ast_Decl_getFullName(dest), ast_CallExpr_getStartLoc(call)));
            c_generator_Generator_emitCNameMod(gen, out, dest, ast_Decl_getModule(dest));
            string_buffer_Buf_add1(out, ')');
         } else {
            c_generator_Generator_emitCNameMod(gen, out, dest, ast_Decl_getModule(dest));
         }
         string_buffer_Buf_lparen(out);
         if (is_tf) {
            switch (ast_MemberExpr_getConversion(m)) {
            case ast_MemberConversion_None:
               break;
            case ast_MemberConversion_Addr:
               string_buffer_Buf_add1(out, '&');
               break;
            case ast_MemberConversion_Deref:
               string_buffer_Buf_add1(out, '*');
               break;
            }
            c_generator_Generator_emitMemberExprBase(gen, out, func);
         }
      } else {
         _Bool no_trace = false;
         if ((ast_Expr_getKind(func) == ast_ExprKind_Identifier)) {
            ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(func));
            const char* name = ast_IdentifierExpr_getName(i);
            if ((((name && (name[0] == 'v')) && (name[1] == 'a')) && (name[2] == '_'))) no_trace = true;
            dest = ast_IdentifierExpr_getDecl(i);
         } else if ((ast_Expr_getKind(func) == ast_ExprKind_Member)) {
            ast_MemberExpr* m = ((ast_MemberExpr*)(func));
            dest = ast_MemberExpr_getFullDecl(m);
         } else {
            ast_Expr_dump(func);
            (0) || c2_assert("generator/c/c_generator_call.c2", 95, "c_generator.Generator.emitCall", "0");
         }

         if ((gen->trace_calls && !no_trace)) {
            string_buffer_Buf_print(out, "(c2_trace_counts[%u]++, ", c_generator_Generator_addCall(gen, ast_Decl_getFullName(dest), ast_CallExpr_getStartLoc(call)));
            c_generator_Generator_emitExpr(gen, out, func);
            string_buffer_Buf_add1(out, ')');
         } else {
            c_generator_Generator_emitExpr(gen, out, func);
         }
         string_buffer_Buf_lparen(out);
      }
   }
   (dest) || c2_assert("generator/c/c_generator_call.c2", 109, "c_generator.Generator.emitCall", "dest");
   _Bool needs_comma = is_tf;
   uint32_t call_num_args = ast_CallExpr_getNumArgs(call);
   ast_Expr** args = ast_CallExpr_getArgs(call);
   ast_FunctionDecl* fd = c_generator_get_function(dest);
   uint32_t func_num_args = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** func_args = ast_FunctionDecl_getParams(fd);
   uint32_t format_idx = ast_CallExpr_needFormatChange(call) ? ast_CallExpr_getPrintfFormat(call) : 1000;
   uint32_t call_index = 0;
   uint32_t func_index = 0;
   if (is_tf) func_index++;
   source_mgr_Location loc;
   if (ast_CallExpr_hasAutoArgs(call)) loc = source_mgr_SourceMgr_locate(gen->sm, ast_Expr_getLoc(e));
   while (1) {
      if (((func_index == func_num_args) && (call_index == call_num_args))) break;

      if ((func_index < func_num_args)) {
         ast_VarDecl* vd = func_args[func_index];
         if (needs_comma) string_buffer_Buf_add(out, ", ");
         if (ast_VarDecl_hasAutoAttr(vd)) {
            if (ast_VarDecl_hasAttrAutoFile(vd)) {
               string_buffer_Buf_print(out, "\"%s\"", loc.filename);
            }
            if (ast_VarDecl_hasAttrAutoLine(vd)) {
               string_buffer_Buf_print(out, "%u", loc.line);
            }
            needs_comma = true;
            func_index++;
            continue;
         }
         if ((call_index == format_idx)) {
            src_loc_SrcLoc format_loc;
            ast_Expr* format = args[call_index];
            (ast_Expr_isImplicitCast(format)) || c2_assert("generator/c/c_generator_call.c2", 148, "c_generator.Generator.emitCall", "format.isImplicitCast()");
            ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(format));
            if (!ast_ImplicitCastExpr_isArrayToPointerDecay(ic)) return;

            format = ast_ImplicitCastExpr_getInner(ic);
            const char* format_text = printf_utils_get_format(format, &format_loc);
            (format_text) || c2_assert("generator/c/c_generator_call.c2", 153, "c_generator.Generator.emitCall", "format_text");
            c_generator_FormatChanger fc = { format_text, &args[(call_index + 1)], 0, 0, out };
            string_buffer_Buf_add1(out, '"');
            printf_utils_parseFormat(format_text, c_generator_on_format_specifier, &fc);
            string_buffer_Buf_encodeBytes(out, (format_text + fc.last_offset), ((uint32_t)(strlen((format_text + fc.last_offset)))), '"');
            string_buffer_Buf_add1(out, '"');
         } else {
            ast_Expr* arg = args[call_index];
            if (ast_Expr_isInitList(arg)) {
               ast_Decl* d = ((ast_Decl*)(func_args[func_index]));
               c_generator_Generator_emitCast(gen, out, ast_Decl_getType(d));
            }
            c_generator_Generator_emitExpr(gen, out, arg);
         }
         call_index++;
         func_index++;
         needs_comma = true;
      } else {
         if (needs_comma) string_buffer_Buf_add(out, ", ");
         c_generator_Generator_emitExpr(gen, out, args[call_index]);
         call_index++;
         needs_comma = true;
      }
   }
   string_buffer_Buf_rparen(out);
}

static ast_FunctionDecl* c_generator_get_function(ast_Decl* dest)
{
   if ((ast_Decl_getKind(dest) == ast_DeclKind_Variable)) {
      ast_QualType qt = ast_Decl_getType(dest);
      (ast_QualType_isFunction(&qt)) || c2_assert("generator/c/c_generator_call.c2", 187, "c_generator.get_function", "qt.isFunction()");
      ast_FunctionType* ft = ast_QualType_getFunctionType(&qt);
      ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      dest = ((ast_Decl*)(fd));
   }
   ((ast_Decl_getKind(dest) == ast_DeclKind_Function)) || c2_assert("generator/c/c_generator_call.c2", 192, "c_generator.get_function", "dest.getKind() == DeclKind.Function");
   return ((ast_FunctionDecl*)(dest));
}

static void c_generator_Generator_emitExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral: {
      ast_IntegerLiteral* i = ((ast_IntegerLiteral*)(e));
      ast_IntegerLiteral_printLiteral(i, out);
      break;
   }
   case ast_ExprKind_FloatLiteral: {
      ast_FloatLiteral* f = ((ast_FloatLiteral*)(e));
      ast_FloatLiteral_printLiteral(f, out);
      break;
   }
   case ast_ExprKind_BooleanLiteral: {
      ast_BooleanLiteral* b = ((ast_BooleanLiteral*)(e));
      if (ast_BooleanLiteral_getValue(b)) string_buffer_Buf_add(out, "true");
      else string_buffer_Buf_add(out, "false");
      break;
   }
   case ast_ExprKind_CharLiteral: {
      ast_CharLiteral* c = ((ast_CharLiteral*)(e));
      ast_CharLiteral_printLiteral(c, out);
      break;
   }
   case ast_ExprKind_StringLiteral: {
      ast_StringLiteral* s = ((ast_StringLiteral*)(e));
      ast_StringLiteral_printLiteral(s, out);
      break;
   }
   case ast_ExprKind_Nil:
      string_buffer_Buf_add(out, "NULL");
      break;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      ast_Decl* d = ast_IdentifierExpr_getDecl(i);
      c_generator_Generator_genDeclIfNeeded(gen, d);
      c_generator_Generator_emitDeclName(gen, out, d);
      break;
   }
   case ast_ExprKind_Type:
      c_generator_Generator_emitTypePre(gen, out, ast_Expr_getType(e));
      c_generator_Generator_emitTypePost(gen, out, ast_Expr_getType(e));
      break;
   case ast_ExprKind_Call:
      c_generator_Generator_emitCall(gen, out, e);
      break;
   case ast_ExprKind_InitList: {
      ast_InitListExpr* ile = ((ast_InitListExpr*)(e));
      string_buffer_Buf_add1(out, '{');
      uint32_t num_values = ast_InitListExpr_getNumValues(ile);
      ast_Expr** values = ast_InitListExpr_getValues(ile);
      _Bool newlines = false;
      if ((num_values > 6)) newlines = true;
      if ((num_values && ast_Expr_isInitList(values[0]))) {
         newlines = true;
      }
      if (newlines) string_buffer_Buf_newline(out);
      else string_buffer_Buf_space(out);
      for (uint32_t i = 0; (i < num_values); i++) {
         if (newlines) string_buffer_Buf_indent(out, 1);
         c_generator_Generator_emitExpr(gen, out, values[i]);
         if (((i + 1) != num_values)) string_buffer_Buf_add1(out, ',');
         if (newlines) string_buffer_Buf_newline(out);
         else string_buffer_Buf_space(out);
      }
      string_buffer_Buf_add1(out, '}');
      break;
   }
   case ast_ExprKind_FieldDesignatedInit:
      c_generator_Generator_emitFieldDesigExpr(gen, out, e);
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      c_generator_Generator_emitArrayDesigExpr(gen, out, e);
      break;
   case ast_ExprKind_BinaryOperator:
      c_generator_Generator_emitBinaryOperator(gen, out, e);
      break;
   case ast_ExprKind_UnaryOperator:
      c_generator_Generator_emitUnaryOperator(gen, out, e);
      break;
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = ((ast_ConditionalOperator*)(e));
      c_generator_Generator_emitExpr(gen, out, ast_ConditionalOperator_getCond(c));
      string_buffer_Buf_add(out, " ? ");
      c_generator_Generator_emitExpr(gen, out, ast_ConditionalOperator_getLHS(c));
      string_buffer_Buf_add(out, " : ");
      c_generator_Generator_emitExpr(gen, out, ast_ConditionalOperator_getRHS(c));
      break;
   }
   case ast_ExprKind_Builtin:
      c_generator_Generator_emitBuiltinExpr(gen, out, e);
      break;
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      if (ast_Expr_isBitOffset(index)) {
         c_generator_Generator_emitBitOffset(gen, out, ast_ArraySubscriptExpr_getBase(a), index);
      } else {
         c_generator_Generator_emitExpr(gen, out, ast_ArraySubscriptExpr_getBase(a));
         string_buffer_Buf_add1(out, '[');
         c_generator_Generator_emitExpr(gen, out, index);
         string_buffer_Buf_add1(out, ']');
      }
      break;
   }
   case ast_ExprKind_Member:
      c_generator_Generator_emitMemberExpr(gen, out, e);
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      string_buffer_Buf_lparen(out);
      c_generator_Generator_emitExpr(gen, out, ast_ParenExpr_getInner(p));
      string_buffer_Buf_rparen(out);
      break;
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* c = ((ast_ExplicitCastExpr*)(e));
      string_buffer_Buf_add(out, "((");
      c_generator_Generator_emitTypePre(gen, out, ast_ExplicitCastExpr_getDestType(c));
      if (ast_ExplicitCastExpr_getCStyle(c)) {
         string_buffer_Buf_add1(out, ')');
         c_generator_Generator_emitExpr(gen, out, ast_ExplicitCastExpr_getInner(c));
         string_buffer_Buf_add1(out, ')');
      } else {
         string_buffer_Buf_add(out, ")(");
         c_generator_Generator_emitExpr(gen, out, ast_ExplicitCastExpr_getInner(c));
         string_buffer_Buf_add(out, "))");
      }
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* i = ((ast_ImplicitCastExpr*)(e));
      c_generator_Generator_emitExpr(gen, out, ast_ImplicitCastExpr_getInner(i));
      break;
   }
   case ast_ExprKind_Range: {
      const ast_RangeExpr* b = ((ast_RangeExpr*)(e));
      c_generator_Generator_emitExpr(gen, out, ast_RangeExpr_getLHS(b));
      string_buffer_Buf_print(out, " ... ");
      c_generator_Generator_emitExpr(gen, out, ast_RangeExpr_getRHS(b));
      return;
   }
   }
}

static void c_generator_Generator_emitBitOffset(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* base, ast_Expr* index)
{
   ast_BitOffsetExpr* bo = ((ast_BitOffsetExpr*)(index));
   string_buffer_Buf_add(out, "((");
   c_generator_Generator_emitExpr(gen, out, base);
   string_buffer_Buf_add(out, ">>");
   c_generator_Generator_emitExpr(gen, out, ast_BitOffsetExpr_getRHS(bo));
   string_buffer_Buf_add(out, ") & ");
   uint64_t mask = 1;
   mask <<= ast_BitOffsetExpr_getWidth(bo);
   mask--;
   string_buffer_Buf_print(out, "0x%lx", mask);
   string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitCast(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   string_buffer_Buf_add1(out, '(');
   c_generator_Generator_emitTypePre(gen, out, qt);
   c_generator_Generator_emitTypePost(gen, out, qt);
   string_buffer_Buf_add1(out, ')');
}

static void c_generator_Generator_emitBinaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ast_BinaryOpcode opcode = ast_BinaryOperator_getOpcode(b);
   _Bool need_paren = (opcode <= ast_BinaryOpcode_LOr);
   if (need_paren) string_buffer_Buf_lparen(out);
   ast_Expr* lhs = ast_BinaryOperator_getLHS(b);
   c_generator_Generator_emitExpr(gen, out, lhs);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_BinaryOperator_getOpcodeStr(b));
   string_buffer_Buf_space(out);
   ast_Expr* rhs = ast_BinaryOperator_getRHS(b);
   if (((opcode == ast_BinaryOpcode_Assign) && ast_Expr_isInitList(rhs))) {
      c_generator_Generator_emitCast(gen, out, ast_Expr_getType(lhs));
   }
   c_generator_Generator_emitExpr(gen, out, rhs);
   if (need_paren) string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitUnaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_UnaryOperator* u = ((ast_UnaryOperator*)(e));
   if (ast_UnaryOperator_isBefore(u)) {
      string_buffer_Buf_add(out, ast_UnaryOperator_getOpcodeStr(u));
      c_generator_Generator_emitExpr(gen, out, ast_UnaryOperator_getInner(u));
   } else {
      c_generator_Generator_emitExpr(gen, out, ast_UnaryOperator_getInner(u));
      string_buffer_Buf_add(out, ast_UnaryOperator_getOpcodeStr(u));
   }
}

static void c_generator_emitDotOrArrow(string_buffer_Buf* out, ast_QualType qt)
{
   if (ast_QualType_isPointer(&qt)) string_buffer_Buf_add(out, "->");
   else string_buffer_Buf_add1(out, '.');
}

static void c_generator_Generator_emitMemberExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_MemberExpr* m = ((ast_MemberExpr*)(e));
   _Bool need_dot = false;
   ast_QualType baseType = { };
   if (ast_MemberExpr_hasExpr(m)) {
      ast_Expr* base = ast_MemberExpr_getExprBase(m);
      c_generator_Generator_emitExpr(gen, out, base);
      baseType = ast_Expr_getType(base);
      need_dot = true;
   }
   uint32_t numrefs = ast_MemberExpr_getNumRefs(m);
   _Bool is_local = false;
   for (uint32_t i = 0; (i < numrefs); i++) {
      ast_Decl* d = ast_MemberExpr_getDecl(m, i);
      switch (ast_Decl_getKind(d)) {
      case ast_DeclKind_Function:
         if (need_dot) c_generator_emitDotOrArrow(out, baseType);
         baseType = ast_Decl_getType(d);
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         break;
      case ast_DeclKind_Import:
         break;
      case ast_DeclKind_StructType: {
         if (need_dot) c_generator_emitDotOrArrow(out, baseType);
         ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(d));
         if (!ast_StructTypeDecl_isGlobal(std)) {
            baseType = ast_Decl_getType(d);
            string_buffer_Buf_add(out, ast_Decl_getName(d));
            need_dot = true;
         }
         break;
      }
      case ast_DeclKind_EnumType:
         c_generator_Generator_genDeclIfNeeded(gen, d);
         break;
      case ast_DeclKind_EnumConstant:
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         break;
      case ast_DeclKind_FunctionType:
         (0) || c2_assert("generator/c/c_generator_expr.c2", 256, "c_generator.Generator.emitMemberExpr", "0");
         break;
      case ast_DeclKind_AliasType:
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         break;
      case ast_DeclKind_Variable:
         if (need_dot) c_generator_emitDotOrArrow(out, baseType);
         baseType = ast_Decl_getType(d);
         if (is_local) {
            string_buffer_Buf_add(out, ast_Decl_getName(d));
         } else {
            c_generator_Generator_emitDeclName(gen, out, d);
         }
         need_dot = true;
         is_local = true;
         break;
      }
   }
}

static void c_generator_Generator_emitMemberExprBase(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_MemberExpr* m = ((ast_MemberExpr*)(e));
   _Bool need_dot = false;
   ast_QualType baseType = { };
   if (ast_MemberExpr_hasExpr(m)) {
      ast_Expr* base = ast_MemberExpr_getExprBase(m);
      c_generator_Generator_emitExpr(gen, out, base);
      baseType = ast_Expr_getType(base);
      need_dot = true;
   }
   uint32_t numrefs = ast_MemberExpr_getNumRefs(m);
   numrefs -= 1;
   _Bool is_local = false;
   for (uint32_t i = 0; (i < numrefs); i++) {
      ast_Decl* d = ast_MemberExpr_getDecl(m, i);
      switch (ast_Decl_getKind(d)) {
      case ast_DeclKind_Function:
         if (need_dot) c_generator_emitDotOrArrow(out, baseType);
         baseType = ast_Decl_getType(d);
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         break;
      case ast_DeclKind_Import:
         break;
      case ast_DeclKind_StructType:
         if (need_dot) c_generator_emitDotOrArrow(out, baseType);
         baseType = ast_Decl_getType(d);
         string_buffer_Buf_add(out, ast_Decl_getName(d));
         need_dot = true;
         break;
      case ast_DeclKind_EnumType:
         c_generator_Generator_genDeclIfNeeded(gen, d);
         break;
      case ast_DeclKind_EnumConstant:
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         break;
      case ast_DeclKind_FunctionType:
         (0) || c2_assert("generator/c/c_generator_expr.c2", 319, "c_generator.Generator.emitMemberExprBase", "0");
         break;
      case ast_DeclKind_AliasType:
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         break;
      case ast_DeclKind_Variable:
         if (need_dot) c_generator_emitDotOrArrow(out, baseType);
         baseType = ast_Decl_getType(d);
         if (is_local) {
            string_buffer_Buf_add(out, ast_Decl_getName(d));
         } else {
            c_generator_Generator_emitDeclName(gen, out, d);
         }
         need_dot = true;
         is_local = true;
         break;
      }
   }
}

static void c_generator_Generator_emitFieldDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_FieldDesignatedInitExpr* fdi = ((ast_FieldDesignatedInitExpr*)(e));
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_FieldDesignatedInitExpr_getFieldName(fdi));
   string_buffer_Buf_add(out, " = ");
   c_generator_Generator_emitExpr(gen, out, ast_FieldDesignatedInitExpr_getInit(fdi));
}

static void c_generator_Generator_emitArrayDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_ArrayDesignatedInitExpr* ad = ((ast_ArrayDesignatedInitExpr*)(e));
   string_buffer_Buf_add1(out, '[');
   c_generator_Generator_emitExpr(gen, out, ast_ArrayDesignatedInitExpr_getDesignator(ad));
   string_buffer_Buf_add(out, "] = ");
   c_generator_Generator_emitExpr(gen, out, ast_ArrayDesignatedInitExpr_getInit(ad));
}

static void c_generator_emitNumberFormat(ast_BuiltinKind kind, char letter, string_buffer_Buf* out)
{
   if (c_generator_Size_prefix[kind]) string_buffer_Buf_add1(out, 'l');
   if (((letter == 'd') && !ast_builtinKind2Signed(kind))) letter = 'u';
   string_buffer_Buf_add1(out, letter);
}

static _Bool c_generator_on_format_specifier(void* context, printf_utils_Specifier specifier, uint32_t offset, int32_t stars, char c)
{
   c_generator_FormatChanger* fc = context;
   string_buffer_Buf_encodeBytes(fc->out, (fc->format + fc->last_offset), (offset - fc->last_offset), '"');
   fc->idx += stars;
   ast_QualType qt = ast_Expr_getType(fc->args[fc->idx]);
   qt = ast_QualType_getCanonicalType(&qt);
   switch (specifier) {
   case printf_utils_Specifier_Integer:
      if (ast_QualType_isEnum(&qt)) {
         ast_EnumType* et = ast_QualType_getEnumType(&qt);
         qt = ast_EnumType_getImplType(et);
      }
      fallthrough;
   case printf_utils_Specifier_FloatingPoint: {
      ast_BuiltinType* bt = ast_QualType_getBuiltinTypeOrNil(&qt);
      if (!bt) {
         ast_Expr_dump(fc->args[fc->idx]);
      }
      (bt) || c2_assert("generator/c/c_generator_expr.c2", 422, "c_generator.on_format_specifier", "bt");
      c_generator_emitNumberFormat(ast_BuiltinType_getKind(bt), c, fc->out);
      break;
   }
   default:
      string_buffer_Buf_add1(fc->out, c);
      break;
   }
   fc->last_offset = (offset + 1);
   fc->idx++;
   return true;
}

static void c_generator_Generator_emitBuiltinExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_BuiltinExpr* b = ((ast_BuiltinExpr*)(e));
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_Elemsof: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_EnumMin: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_EnumMax: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_OffsetOf: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_ToContainer:
      string_buffer_Buf_add(out, "to_container(");
      c_generator_Generator_emitExpr(gen, out, ast_BuiltinExpr_getInner(b));
      string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitExpr(gen, out, ast_BuiltinExpr_getToContainerMember(b));
      string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitExpr(gen, out, ast_BuiltinExpr_getToContainerPointer(b));
      string_buffer_Buf_rparen(out);
      break;
   }
}

static void c_generator_Evaluator_check(c_generator_Evaluator* eval, ast_FunctionDecl* fd, uint32_t num, ast_Expr** args)
{
   ast_Value_setUnsigned(&eval->result, 0);
   eval->num_values = num;
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; (i < num); i++) {
      ast_Decl* d = ((ast_Decl*)(params[i]));
      c_generator_ArgValue* v = &eval->values[i];
      v->name = ast_Decl_getNameIdx(d);
      v->value = ctv_analyser_get_value(args[i]);
   }
   ast_CompoundStmt* body = ast_FunctionDecl_getBody(fd);
   uint32_t count = ast_CompoundStmt_getCount(body);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(body);
   ((count == 1)) || c2_assert("generator/c/c_generator_pure_call.c2", 48, "c_generator.Evaluator.check", "count == 1");
   (ast_Stmt_isReturn(stmts[0])) || c2_assert("generator/c/c_generator_pure_call.c2", 49, "c_generator.Evaluator.check", "stmts[0].isReturn()");
   ast_ReturnStmt* r = ((ast_ReturnStmt*)(stmts[0]));
   eval->result = c_generator_Evaluator_get_value(eval, ast_ReturnStmt_getValue(r));
}

static ast_Value c_generator_Evaluator_get_value(c_generator_Evaluator* eval, const ast_Expr* e)
{
   ast_Value result = { };
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral: {
      const ast_IntegerLiteral* i = ((ast_IntegerLiteral*)(e));
      if (ast_IntegerLiteral_isSigned(i)) ast_Value_setSigned(&result, ((int64_t)(ast_IntegerLiteral_getValue(i))));
      else ast_Value_setUnsigned(&result, ast_IntegerLiteral_getValue(i));
      break;
   }
   case ast_ExprKind_FloatLiteral: {
      const ast_FloatLiteral* f = ((ast_FloatLiteral*)(e));
      ast_Value_setFloat(&result, ast_FloatLiteral_getValue(f));
      break;
   }
   case ast_ExprKind_BooleanLiteral: {
      const ast_BooleanLiteral* b = ((ast_BooleanLiteral*)(e));
      ast_Value_setUnsigned(&result, ast_BooleanLiteral_getValue(b));
      break;
   }
   case ast_ExprKind_CharLiteral: {
      const ast_CharLiteral* c = ((ast_CharLiteral*)(e));
      ast_Value_setUnsigned(&result, ((uint8_t)(ast_CharLiteral_getValue(c))));
      break;
   }
   case ast_ExprKind_StringLiteral:
      (0) || c2_assert("generator/c/c_generator_pure_call.c2", 79, "c_generator.Evaluator.get_value", "0");
      break;
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      const ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      return c_generator_Evaluator_get_decl_value(eval, ast_IdentifierExpr_getDecl(i));
   }
   case ast_ExprKind_Type:
      fallthrough;
   case ast_ExprKind_Call:
      fallthrough;
   case ast_ExprKind_InitList:
      fallthrough;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return c_generator_Evaluator_get_binaryop_value(eval, ((ast_BinaryOperator*)(e)));
   case ast_ExprKind_UnaryOperator:
      return c_generator_Evaluator_get_unaryop_value(eval, ((ast_UnaryOperator*)(e)));
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = ((ast_ConditionalOperator*)(e));
      ast_Value v = c_generator_Evaluator_get_value(eval, ast_ConditionalOperator_getCond(c));
      return !ast_Value_isZero(&v) ? c_generator_Evaluator_get_value(eval, ast_ConditionalOperator_getLHS(c)) : c_generator_Evaluator_get_value(eval, ast_ConditionalOperator_getRHS(c));
   }
   case ast_ExprKind_Builtin: {
      const ast_BuiltinExpr* bi = ((ast_BuiltinExpr*)(e));
      result = ast_BuiltinExpr_getValue(bi);
      break;
   }
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      result = c_generator_Evaluator_get_value(eval, ast_ArraySubscriptExpr_getBase(a));
      ((ast_Value_isDecimal(&result) && !ast_Value_isNegative(&result))) || c2_assert("generator/c/c_generator_pure_call.c2", 111, "c_generator.Evaluator.get_value", "result.isDecimal() && !result.isNegative()");
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      (ast_Expr_isBitOffset(index)) || c2_assert("generator/c/c_generator_pure_call.c2", 114, "c_generator.Evaluator.get_value", "index.isBitOffset()");
      ast_BitOffsetExpr* bo = ((ast_BitOffsetExpr*)(index));
      ast_Value high = c_generator_Evaluator_get_value(eval, ast_BitOffsetExpr_getLHS(bo));
      ast_Value low = c_generator_Evaluator_get_value(eval, ast_BitOffsetExpr_getRHS(bo));
      ast_Value width = ast_Value_minus(&high, &low);
      ast_Value_incr(&width);
      result = ast_Value_right_shift(&result, &low);
      ast_Value_mask(&result, ast_Value_as_u32(&width));
      break;
   }
   case ast_ExprKind_Member: {
      const ast_MemberExpr* m = ((ast_MemberExpr*)(e));
      return c_generator_Evaluator_get_decl_value(eval, ast_MemberExpr_getFullDecl(m));
   }
   case ast_ExprKind_Paren: {
      const ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      return c_generator_Evaluator_get_value(eval, ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast:
      (0) || c2_assert("generator/c/c_generator_pure_call.c2", 134, "c_generator.Evaluator.get_value", "0");
      break;
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* i = ((ast_ImplicitCastExpr*)(e));
      return c_generator_Evaluator_get_value(eval, ast_ImplicitCastExpr_getInner(i));
   }
   case ast_ExprKind_Range:
      (0) || c2_assert("generator/c/c_generator_pure_call.c2", 149, "c_generator.Evaluator.get_value", "0");
      break;
   }
   return result;
}

static ast_Value c_generator_Evaluator_get_binaryop_value(c_generator_Evaluator* eval, const ast_BinaryOperator* e)
{
   ast_Value result = { };
   ast_Value left = c_generator_Evaluator_get_value(eval, ast_BinaryOperator_getLHS(e));
   ast_Value right = c_generator_Evaluator_get_value(eval, ast_BinaryOperator_getRHS(e));
   switch (ast_BinaryOperator_getOpcode(e)) {
   case ast_BinaryOpcode_Multiply:
      result = ast_Value_multiply(&left, &right);
      break;
   case ast_BinaryOpcode_Divide:
      result = ast_Value_divide(&left, &right);
      break;
   case ast_BinaryOpcode_Remainder:
      result = ast_Value_remainder(&left, &right);
      break;
   case ast_BinaryOpcode_Add:
      result = ast_Value_add(&left, &right);
      break;
   case ast_BinaryOpcode_Subtract:
      result = ast_Value_minus(&left, &right);
      break;
   case ast_BinaryOpcode_ShiftLeft:
      result = ast_Value_left_shift(&left, &right);
      break;
   case ast_BinaryOpcode_ShiftRight:
      result = ast_Value_right_shift(&left, &right);
      break;
   case ast_BinaryOpcode_LessThan:
      ast_Value_setUnsigned(&result, ast_Value_is_less(&left, &right));
      break;
   case ast_BinaryOpcode_GreaterThan:
      ast_Value_setUnsigned(&result, ast_Value_is_greater(&left, &right));
      break;
   case ast_BinaryOpcode_LessEqual:
      ast_Value_setUnsigned(&result, ast_Value_is_less_equal(&left, &right));
      break;
   case ast_BinaryOpcode_GreaterEqual:
      ast_Value_setUnsigned(&result, ast_Value_is_greater_equal(&left, &right));
      break;
   case ast_BinaryOpcode_Equal:
      ast_Value_setUnsigned(&result, ast_Value_is_equal(&left, &right));
      break;
   case ast_BinaryOpcode_NotEqual:
      ast_Value_setUnsigned(&result, !ast_Value_is_equal(&left, &right));
      break;
   case ast_BinaryOpcode_And:
      result = ast_Value_and(&left, &right);
      break;
   case ast_BinaryOpcode_Xor:
      result = ast_Value_xor(&left, &right);
      break;
   case ast_BinaryOpcode_Or:
      result = ast_Value_or(&left, &right);
      break;
   case ast_BinaryOpcode_LAnd:
      result = ast_Value_land(&left, &right);
      break;
   case ast_BinaryOpcode_LOr:
      result = ast_Value_lor(&left, &right);
      break;
   case ast_BinaryOpcode_Assign:
      fallthrough;
   case ast_BinaryOpcode_MulAssign:
      fallthrough;
   case ast_BinaryOpcode_DivAssign:
      fallthrough;
   case ast_BinaryOpcode_RemAssign:
      fallthrough;
   case ast_BinaryOpcode_AddAssign:
      fallthrough;
   case ast_BinaryOpcode_SubAssign:
      fallthrough;
   case ast_BinaryOpcode_ShlAssign:
      fallthrough;
   case ast_BinaryOpcode_ShrAssign:
      fallthrough;
   case ast_BinaryOpcode_AndAssign:
      fallthrough;
   case ast_BinaryOpcode_XorAssign:
      fallthrough;
   case ast_BinaryOpcode_OrAssign:
      (0) || c2_assert("generator/c/c_generator_pure_call.c2", 236, "c_generator.Evaluator.get_binaryop_value", "0");
      break;
   }
   return result;
}

static ast_Value c_generator_Evaluator_get_unaryop_value(c_generator_Evaluator* eval, const ast_UnaryOperator* e)
{
   ast_Value result = { };
   const ast_Expr* inner = ast_UnaryOperator_getInner(e);
   ast_Value res2 = c_generator_Evaluator_get_value(eval, inner);
   switch (ast_UnaryOperator_getOpcode(e)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec:
      fallthrough;
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec:
      break;
   case ast_UnaryOpcode_AddrOf:
      fallthrough;
   case ast_UnaryOpcode_Deref:
      break;
   case ast_UnaryOpcode_Plus:
      result = res2;
      break;
   case ast_UnaryOpcode_Minus:
      result = ast_Value_negate(&res2);
      break;
   case ast_UnaryOpcode_Not:
      (ast_Value_isDecimal(&res2)) || c2_assert("generator/c/c_generator_pure_call.c2", 265, "c_generator.Evaluator.get_unaryop_value", "res2.isDecimal()");
      result = ast_Value_bitnot(&res2);
      break;
   case ast_UnaryOpcode_LNot:
      (ast_Value_isDecimal(&res2)) || c2_assert("generator/c/c_generator_pure_call.c2", 269, "c_generator.Evaluator.get_unaryop_value", "res2.isDecimal()");
      result = ast_Value_lnot(&res2);
      break;
   }
   return result;
}

static ast_Value c_generator_Evaluator_get_decl_value(c_generator_Evaluator* eval, const ast_Decl* d)
{
   (d) || c2_assert("generator/c/c_generator_pure_call.c2", 277, "c_generator.Evaluator.get_decl_value", "d");
   ast_Value result;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_EnumConstant: {
      const ast_EnumConstantDecl* ecd = ((ast_EnumConstantDecl*)(d));
      result = ast_EnumConstantDecl_getValue(ecd);
      break;
   }
   case ast_DeclKind_Variable: {
      const uint32_t name_idx = ast_Decl_getNameIdx(d);
      ast_VarDecl* vd = ((ast_VarDecl*)(d));
      ast_VarDeclKind vk = ast_VarDecl_getKind(vd);
      if ((vk == ast_VarDeclKind_FunctionParam)) {
         for (uint32_t i = 0; (i < eval->num_values); i++) {
            c_generator_ArgValue* v = &eval->values[i];
            if ((v->name == name_idx)) {
               return v->value;
            }
         }
         (0) || c2_assert("generator/c/c_generator_pure_call.c2", 295, "c_generator.Evaluator.get_decl_value", "0");
      } else {
         const ast_Expr* initval = ast_VarDecl_getInit(vd);
         (initval) || c2_assert("generator/c/c_generator_pure_call.c2", 298, "c_generator.Evaluator.get_decl_value", "initval");
         return c_generator_Evaluator_get_value(eval, initval);
      }
      break;
   }
   default:
      (0) || c2_assert("generator/c/c_generator_pure_call.c2", 303, "c_generator.Evaluator.get_decl_value", "0");
      break;
   }
   return result;
}

static void c_generator_Generator_emitPureFunctionCall(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_CallExpr* c = ((ast_CallExpr*)(e));
   uint32_t num_args = ast_CallExpr_getNumArgs(c);
   ast_Expr** args = ast_CallExpr_getArgs(c);
   ast_FunctionDecl* fd = c_generator_expr2function(ast_CallExpr_getFunc(c));
   c_generator_Evaluator eval;
   c_generator_Evaluator_check(&eval, fd, num_args, args);
   string_buffer_Buf_add(out, ast_Value_str(&eval.result));
}

static ast_FunctionDecl* c_generator_expr2function(ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      return ((ast_FunctionDecl*)(ast_IdentifierExpr_getDecl(i)));
   }
   case ast_ExprKind_Member: {
      ast_MemberExpr* m = ((ast_MemberExpr*)(e));
      return ((ast_FunctionDecl*)(ast_MemberExpr_getFullDecl(m)));
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
      return c_generator_expr2function(ast_ImplicitCastExpr_getInner(ic));
   }
   default:
      (0) || c2_assert("generator/c/c_generator_pure_call.c2", 337, "c_generator.expr2function", "0");
      break;
   }
   return NULL;
}

static void c_generator_Generator_createMakefile(c_generator_Generator* gen, const char* output_dir, component_List* comps, const module_list_List* allmodules, string_list_List* asm_files, _Bool enable_asserts, uint32_t libc_name)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, "# This makefile is auto-generated, any modifications will be lost\n\n");
   const char* cc = "gcc";
   const char* cflags = NULL;
   const char* ldflags = "";
   const char* ldflags2 = "";
   const char* asmflags = "";
   if (((gen->targetInfo->sys == target_info_System_FreeBSD) || (gen->targetInfo->sys == target_info_System_OpenBSD))) {
      cc = "clang";
   }
   if (gen->build_info) {
      const build_file_Info* info = gen->build_info;
      if (build_file_Info_getCC(info)) cc = build_file_Info_getCC(info);
      if (build_file_Info_getCFlags(info)) cflags = build_file_Info_getCFlags(info);
      if (build_file_Info_getLdFlags(info)) ldflags = build_file_Info_getLdFlags(info);
      if (build_file_Info_getLdFlags2(info)) ldflags2 = build_file_Info_getLdFlags2(info);
      if (build_file_Info_getAsmFlags(info)) asmflags = build_file_Info_getAsmFlags(info);
   }
   string_buffer_Buf_print(out, "CC=%s\n", cc);
   string_buffer_Buf_add(out, "CFLAGS=-Wall -Wextra -Wno-unused -Wno-switch\n");
   string_buffer_Buf_add(out, "CFLAGS+=-Wno-unused-parameter -Wno-missing-field-initializers -Wno-format-zero-length\n");
   string_buffer_Buf_add(out, "CFLAGS+=-pipe -std=c99 -funsigned-char\n");
   if (gen->fast_build) string_buffer_Buf_add(out, "CFLAGS+=-O0 -g\n");
   else string_buffer_Buf_add(out, "CFLAGS+=-O2 -g\n");
   if (!enable_asserts) string_buffer_Buf_add(out, "CFLAGS+=-DNDEBUG\n");
   if (cflags) string_buffer_Buf_print(out, "CFLAGS+=%s\n", cflags);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_print(out, "ASMFLAGS=%s\n", asmflags ? asmflags : "");
   string_buffer_Buf_print(out, "LDFLAGS=%s\n", ldflags ? ldflags : "");
   string_buffer_Buf_print(out, "LDFLAGS2=%s\n", ldflags2 ? ldflags2 : "");
   string_buffer_Buf_newline(out);
   if (gen->asan) {
      string_buffer_Buf_add(out, "CFLAGS+=-fsanitize=address -D__ASAN__ -O0\n");
      string_buffer_Buf_add(out, "LDFLAGS+=-fsanitize=address\n");
   }
   if (gen->msan) {
      string_buffer_Buf_add(out, "CFLAGS+=-fsanitize=memory -D__MSAN__ -O0\n");
      string_buffer_Buf_add(out, "LDFLAGS+=-fsanitize=memory\n");
   }
   if (gen->ubsan) {
      string_buffer_Buf_add(out, "CFLAGS+=-fsanitize=undefined -D__UBSAN__ -O0\n");
      string_buffer_Buf_add(out, "LDFLAGS+=-fsanitize=undefined\n");
   }
   char target_name[128];
   if (gen->fast_build) {
      string_buffer_Buf_add(out, "objects := ");
      for (uint32_t i = 0; (i < module_list_List_length(allmodules)); i++) {
         const ast_Module* m = module_list_List_at(allmodules, i);
         if ((!ast_Module_isExternal(m) && ast_Module_isUsed(m))) string_buffer_Buf_print(out, " %s.o", ast_Module_getName(m));
      }
      if (gen->trace_calls) {
         string_buffer_Buf_add(out, " build.o");
      }
      string_buffer_Buf_newline(out);
   } else {
      string_buffer_Buf_add(out, "objects := build.o\n");
   }
   string_buffer_Buf_add(out, "headers := $(wildcard *.h)\n\n");
   string_buffer_Buf_add(out, "%.o: %.c\n");
   string_buffer_Buf_print(out, "\t\t$(CC) $(CFLAGS) -o $@ -c $<\n\n");
   switch (gen->target_kind) {
   case build_target_Kind_Image:
      fallthrough;
   case build_target_Kind_Executable: {
      strcpy(target_name, gen->target);
      string_buffer_Buf_print(out, "all: ../%s\n\n", target_name);
      string_buffer_Buf_print(out, "../%s: $(objects) $(headers)\n", target_name);
      for (uint32_t i = 0; (i < string_list_List_length(asm_files)); i++) {
         const char* filename = string_list_List_get(asm_files, i);
         string_buffer_Buf_print(out, "\t\t$(CC) $(ASMFLAGS) -o %s.o -c ../../../%s\n", filename, filename);
      }
      string_buffer_Buf_print(out, "\t\t$(CC) $(LDFLAGS) -o ../%s $(objects)", target_name);
      for (uint32_t i = 0; (i < string_list_List_length(asm_files)); i++) {
         const char* filename = string_list_List_get(asm_files, i);
         string_buffer_Buf_print(out, " %s.o", filename);
      }
      const char* triplet = target_info_Info_str(gen->targetInfo);
      for (uint32_t i = component_List_size(comps); (i != 0); i--) {
         component_Component* c = component_List_get(comps, (i - 1));
         if (!component_Component_isExternal(c)) continue;

         const char* linkname = component_Component_getLinkName(c);
         if (((gen->targetInfo->sys == target_info_System_FreeBSD) || (gen->targetInfo->sys == target_info_System_OpenBSD))) {
            if ((linkname && !strcmp(linkname, "dl"))) continue;

         }
         if (component_Component_isStaticLib(c)) {
            string_buffer_Buf_print(out, " -L%s/%s", component_Component_getPath(c), triplet);
            if ((component_Component_getNameIdx(c) == libc_name)) string_buffer_Buf_add(out, " --static");
         }
         if (linkname) string_buffer_Buf_print(out, " -l%s", linkname);
      }
      string_buffer_Buf_add(out, " $(LDFLAGS2)\n");
      string_buffer_Buf_newline(out);
      break;
   }
   case build_target_Kind_StaticLibrary:
      sprintf(target_name, "lib%s.a", gen->target);
      string_buffer_Buf_print(out, "all: ../%s\n\n", target_name);
      string_buffer_Buf_print(out, "../%s: $(objects) $(headers)\n", target_name);
      string_buffer_Buf_print(out, "\t\tar rcs ../%s $(objects)\n", target_name);
      break;
   case build_target_Kind_DynamicLibrary:
      string_buffer_Buf_add(out, "CFLAGS+=-fPIC\n");
      if ((gen->targetInfo->sys == target_info_System_Darwin)) {
         sprintf(target_name, "lib%s.dylib", gen->target);
      } else {
         sprintf(target_name, "lib%s.so", gen->target);
      }
      string_buffer_Buf_print(out, "all: ../%s\n\n", target_name);
      string_buffer_Buf_print(out, "../%s: $(objects) $(headers)\n", target_name);
      if ((gen->targetInfo->sys == target_info_System_Darwin)) {
         string_buffer_Buf_print(out, "\t\t$(CC) $(LDFLAGS) $(objects) -shared -o ../%s $(LDFLAGS2)\n", target_name);
      } else {
         string_buffer_Buf_print(out, "\t\t$(CC) $(LDFLAGS) $(objects) -shared -o ../%s -Wl,-soname,%s.1 -Wl,--version-script=exports.version $(LDFLAGS2)\n", target_name, target_name);
      }
      break;
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_add(out, "symbols:\n");
   string_buffer_Buf_add(out, "\t\tnm -g");
   if (build_target_has_dynamic(gen->target_kind)) string_buffer_Buf_add(out, " -D");
   string_buffer_Buf_print(out, " -C --defined-only ../%s\n\n", target_name);
   string_buffer_Buf_add(out, "clean:\n");
   string_buffer_Buf_print(out, "\t\trm -f *.o *.a ../%s\n\n", target_name);
   c_generator_Generator_write(gen, output_dir, "Makefile", gen->out);
}

static void c_generator_Generator_createExportsFile(c_generator_Generator* gen, const char* output_dir, component_Component* mainComp)
{
   if ((gen->target_kind != build_target_Kind_DynamicLibrary)) return;

   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, "LIB_1.0 {\n");
   string_buffer_Buf_add(out, "\tglobal:\n");
   module_list_List* mods = component_Component_getModules(mainComp);
   uint32_t count = module_list_List_length(mods);
   for (uint32_t i = 0; (i < count); i++) {
      const ast_SymbolTable* symbols = ast_Module_getSymbols(module_list_List_at(mods, i));
      ast_Decl** decls = ast_SymbolTable_getDecls(symbols);
      uint32_t num_symbols = ast_SymbolTable_size(symbols);
      for (uint32_t j = 0; (j < num_symbols); j++) {
         ast_Decl* d = decls[j];
         if (!ast_Decl_isExported(d)) continue;

         if ((!ast_Decl_isFunction(d) && !ast_Decl_isVariable(d))) continue;

         string_buffer_Buf_add(out, "\t\t");
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         string_buffer_Buf_add(out, ";\n");
      }
   }
   string_buffer_Buf_add(out, "\tlocal:\n\t\t*;\n");
   string_buffer_Buf_add(out, "};\n");
   c_generator_Generator_write(gen, output_dir, "exports.version", gen->out);
}

static void c_generator_Generator_generateC2TypesHeader(c_generator_Generator* gen)
{
   string_buffer_Buf* out = gen->header;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, c_generator_C2_types_header);
   char fullname[512];
   snprintf(fullname, 512, "%s/c2types.h", gen->results_dir);
   file_utils_Writer writer;
   if (!file_utils_Writer_write(&writer, fullname, string_buffer_Buf_data(out), string_buffer_Buf_size(out))) {
      console_error("cannot write to %s: %s", fullname, file_utils_Writer_getError(&writer));
   }
   string_buffer_Buf_clear(out);
}

static void c_generator_Generator_emitVarDecl(c_generator_Generator* gen, ast_VarDecl* vd, string_buffer_Buf* out, _Bool emit_init)
{
   ast_Decl* d = ((ast_Decl*)(vd));
   if (ast_VarDecl_hasLocalQualifier(vd)) string_buffer_Buf_add(out, "static ");
   c_generator_Generator_emitTypePre(gen, out, ast_Decl_getType(d));
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_Decl_getName(d));
   c_generator_Generator_emitTypePost(gen, out, ast_Decl_getType(d));
   ast_Decl_setGenerated(d);
   ast_Expr* ie = ast_VarDecl_getInit(vd);
   if ((ie && emit_init)) {
      if (ast_VarDecl_hasInitCall(vd)) {
         string_buffer_Buf_add(out, "; ");
      } else {
         string_buffer_Buf_add(out, " = ");
      }
      c_generator_Generator_emitExpr(gen, out, ie);
   }
}

static void c_generator_Generator_emitStmt(c_generator_Generator* gen, ast_Stmt* s, uint32_t indent, _Bool newline)
{
   string_buffer_Buf* out = gen->out;
   if (newline) string_buffer_Buf_indent(out, indent);
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      string_buffer_Buf_add(out, "return");
      ast_ReturnStmt* r = ((ast_ReturnStmt*)(s));
      ast_Expr* val = ast_ReturnStmt_getValue(r);
      if (val) {
         string_buffer_Buf_space(out);
         if (ast_Expr_isInitList(val)) {
            c_generator_Generator_emitCast(gen, out, ast_FunctionDecl_getRType(gen->cur_function));
         }
         c_generator_Generator_emitExpr(gen, out, val);
      }
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Expr:
      c_generator_Generator_emitExpr(gen, out, ((ast_Expr*)(s)));
      if (newline) string_buffer_Buf_add(out, ";\n");
      break;
   case ast_StmtKind_If: {
      ast_IfStmt* i = ((ast_IfStmt*)(s));
      ast_Stmt* cond = ast_IfStmt_getCond(i);
      _Bool is_decl = ast_Stmt_isDecl(cond);
      if (is_decl) {
         c_generator_Generator_emitStmt(gen, cond, 0, true);
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "if (");
         ast_DeclStmt* ds = ((ast_DeclStmt*)(cond));
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
      } else {
         string_buffer_Buf_add(out, "if (");
         c_generator_Generator_emitStmt(gen, cond, 0, false);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* thenStmt = ast_IfStmt_getThen(i);
      c_generator_Generator_emitStmt(gen, thenStmt, indent, false);
      if (!ast_Stmt_isCompound(thenStmt)) {
         if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
      }
      ast_Stmt* elseStmt = ast_IfStmt_getElse(i);
      if (elseStmt) {
         if (ast_Stmt_isCompound(thenStmt)) {
            string_buffer_Buf_space(out);
         } else {
            if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_newline(out);
            string_buffer_Buf_indent(out, indent);
         }
         string_buffer_Buf_add(out, "else ");
         c_generator_Generator_emitStmt(gen, elseStmt, indent, false);
         if (!ast_Stmt_isCompound(elseStmt)) {
            if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
         }
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_While: {
      ast_WhileStmt* w = ((ast_WhileStmt*)(s));
      ast_Stmt* cond = ast_WhileStmt_getCond(w);
      _Bool is_decl = ast_Stmt_isDecl(cond);
      if (is_decl) {
         string_buffer_Buf_add(out, "{\n");
         indent++;
         ast_DeclStmt* ds = ((ast_DeclStmt*)(cond));
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
         string_buffer_Buf_indent(out, indent);
         c_generator_Generator_emitVarDecl(gen, vd, out, false);
         string_buffer_Buf_add(out, ";\n");
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "while (");
         string_buffer_Buf_add1(out, '(');
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
         string_buffer_Buf_add(out, " = ");
         ast_Expr* ie = ast_VarDecl_getInit(vd);
         (ie) || c2_assert("generator/c/c_generator_stmt.c2", 123, "c_generator.Generator.emitStmt", "ie");
         c_generator_Generator_emitExpr(gen, out, ie);
         string_buffer_Buf_add1(out, ')');
      } else {
         string_buffer_Buf_add(out, "while (");
         c_generator_Generator_emitStmt(gen, cond, 0, false);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* body = ast_WhileStmt_getBody(w);
      c_generator_Generator_emitStmt(gen, body, indent, false);
      if (!ast_Stmt_isCompound(body)) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      if (is_decl) {
         indent--;
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "}\n");
      }
      break;
   }
   case ast_StmtKind_For: {
      ast_ForStmt* f = ((ast_ForStmt*)(s));
      string_buffer_Buf_add(out, "for (");
      ast_Stmt* initStmt = ast_ForStmt_getInit(f);
      if (initStmt) {
         c_generator_Generator_emitStmt(gen, initStmt, 0, false);
      }
      string_buffer_Buf_add1(out, ';');
      if (ast_ForStmt_getCond(f)) {
         string_buffer_Buf_space(out);
         c_generator_Generator_emitExpr(gen, out, ast_ForStmt_getCond(f));
      }
      string_buffer_Buf_add1(out, ';');
      ast_Expr* cont = ast_ForStmt_getCont(f);
      if (cont) {
         string_buffer_Buf_space(out);
         c_generator_Generator_emitExpr(gen, out, cont);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* body = ast_ForStmt_getBody(f);
      c_generator_Generator_emitStmt(gen, body, indent, false);
      if (!ast_Stmt_isCompound(body)) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_Switch:
      c_generator_Generator_emitSwitchStmt(gen, s, indent);
      break;
   case ast_StmtKind_Break:
      string_buffer_Buf_add(out, "break;\n");
      break;
   case ast_StmtKind_Continue:
      string_buffer_Buf_add(out, "continue;\n");
      break;
   case ast_StmtKind_Fallthrough:
      string_buffer_Buf_add(out, "fallthrough;\n");
      break;
   case ast_StmtKind_Label: {
      ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      string_buffer_Buf_add(out, ast_LabelStmt_getName(ls));
      string_buffer_Buf_add1(out, ':');
      if ((!stmt || ast_Stmt_isDecl(stmt))) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      if (stmt) {
         c_generator_Generator_emitStmt(gen, stmt, indent, true);
      }
      break;
   }
   case ast_StmtKind_Goto: {
      ast_GotoStmt* g = ((ast_GotoStmt*)(s));
      string_buffer_Buf_add(out, "goto ");
      string_buffer_Buf_add(out, ast_GotoStmt_getName(g));
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      string_buffer_Buf_add(out, "{\n");
      uint32_t count = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; (i < count); i++) {
         c_generator_Generator_emitStmt(gen, stmts[i], (indent + 1), true);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add1(out, '}');
      if (newline) string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_Decl: {
      ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      c_generator_Generator_emitVarDecl(gen, vd, out, true);
      if (newline) string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Asm:
      c_generator_Generator_emitAsmStmt(gen, ((ast_AsmStmt*)(s)), indent);
      break;
   case ast_StmtKind_Assert: {
      if (!gen->enable_asserts) break;

      ast_AssertStmt* a = ((ast_AssertStmt*)(s));
      source_mgr_Location loc = source_mgr_SourceMgr_locate(gen->sm, ast_Stmt_getLoc(s));
      const char* funcname = ast_Decl_getFullName(ast_FunctionDecl_asDecl(gen->cur_function));
      string_buffer_Buf_add(out, "(");
      ast_Expr* inner = ast_AssertStmt_getInner(a);
      c_generator_Generator_emitExpr(gen, out, inner);
      string_buffer_Buf_print(out, ") || c2_assert(\"%s\", %u, \"%s\", \"", loc.filename, loc.line, funcname);
      string_buffer_Buf* str = string_buffer_create(128, false, 0);
      ast_Expr_printLiteral(inner, str);
      string_buffer_Buf_encodeBytes(out, string_buffer_Buf_data(str), string_buffer_Buf_size(str), '"');
      string_buffer_Buf_free(str);
      string_buffer_Buf_add(out, "\");\n");
      break;
   }
   }
}

static void c_generator_emitAsmPart(string_buffer_Buf* out, _Bool multi_line, uint32_t indent)
{
   if (multi_line) {
      string_buffer_Buf_newline(out);
      string_buffer_Buf_indent(out, indent);
   } else {
      string_buffer_Buf_space(out);
   }
   string_buffer_Buf_add(out, ": ");
}

static void c_generator_Generator_emitAsmOperand(c_generator_Generator* gen, uint32_t name, const ast_Expr* c, ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   if (name) {
      string_buffer_Buf_print(out, "[%s] ", ast_idx2name(name));
   }
   const ast_StringLiteral* cs = ((ast_StringLiteral*)(c));
   ast_StringLiteral_printLiteral(cs, out);
   string_buffer_Buf_add(out, " (");
   c_generator_Generator_emitExpr(gen, out, e);
   string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitAsmStmt(c_generator_Generator* gen, ast_AsmStmt* a, uint32_t indent)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_add(out, "__asm__ ");
   if (ast_AsmStmt_isVolatile(a)) string_buffer_Buf_add(out, "volatile ");
   string_buffer_Buf_lparen(out);
   ast_StringLiteral* str = ast_AsmStmt_getString(a);
   ast_StringLiteral_printLiteral(str, out);
   uint32_t num_outputs = ast_AsmStmt_getNumOutputs(a);
   uint32_t num_inputs = ast_AsmStmt_getNumInputs(a);
   uint32_t num_clobbers = ast_AsmStmt_getNumClobbers(a);
   _Bool multi_line = false;
   if ((((((num_outputs + num_inputs) + num_clobbers)) > 4) || (num_clobbers != 0))) multi_line = true;
   if (((num_outputs + num_inputs) + num_clobbers)) {
      uint32_t* names = ast_AsmStmt_getNames(a);
      const ast_Expr** constraints = ast_AsmStmt_getConstraints(a);
      ast_Expr** exprs = ast_AsmStmt_getExprs(a);
      c_generator_emitAsmPart(out, multi_line, indent);
      for (uint32_t i = 0; (i < num_outputs); i++) {
         if ((i != 0)) string_buffer_Buf_add(out, ", ");
         c_generator_Generator_emitAsmOperand(gen, names[i], constraints[i], exprs[i]);
      }
      if ((num_inputs | num_clobbers)) {
         c_generator_emitAsmPart(out, multi_line, indent);
         for (uint32_t i = 0; (i < num_inputs); i++) {
            if ((i != 0)) string_buffer_Buf_add(out, ", ");
            uint32_t idx = (i + num_outputs);
            c_generator_Generator_emitAsmOperand(gen, names[idx], constraints[idx], exprs[idx]);
         }
      }
      if (num_clobbers) {
         ast_Expr** clobbers = ast_AsmStmt_getClobbers(a);
         c_generator_emitAsmPart(out, multi_line, indent);
         for (uint32_t i = 0; (i < num_clobbers); i++) {
            if ((i != 0)) string_buffer_Buf_add(out, ", ");
            ast_StringLiteral* l = ((ast_StringLiteral*)(clobbers[i]));
            ast_StringLiteral_printLiteral(l, out);
         }
      }
   }
   string_buffer_Buf_rparen(out);
   string_buffer_Buf_add(out, ";\n");
}

static void c_generator_Generator_emitSwitchStmt(c_generator_Generator* gen, ast_Stmt* s, uint32_t indent)
{
   string_buffer_Buf* out = gen->out;
   ast_SwitchStmt* sw = ((ast_SwitchStmt*)(s));
   const uint32_t num_cases = ast_SwitchStmt_getNumCases(sw);
   ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
   if (ast_SwitchStmt_isString(sw)) {
      string_buffer_Buf_add(out, "switch (c2_strswitch(");
      c_generator_Generator_emitExpr(gen, out, ast_SwitchStmt_getCond(sw));
      string_buffer_Buf_add(out, ",");
      _Bool has_s2 = false;
      for (uint32_t i = 0; (i < num_cases); i++) {
         ast_SwitchCase* c = cases[i];
         if (ast_SwitchCase_isDefault(c)) continue;

         ast_Expr* e = ast_SwitchCase_getCond(c, 0);
         if (ast_Expr_isImplicitCast(e)) {
            const ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
            e = ast_ImplicitCastExpr_getInner(ic);
         }
         if (ast_Expr_isNil(e)) continue;

         if (ast_Expr_isStringLiteral(e)) {
            ast_StringLiteral* lit = ((ast_StringLiteral*)(e));
            const char* p = ast_StringLiteral_getText(lit);
            if (*p) {
               string_buffer_Buf_print(out, " \"\\%03o%s\"", (((ast_StringLiteral_getSize(lit) - 1)) & 0xff), p);
               has_s2 = true;
            }
         } else {
            ast_Expr_dump(e);
            (0) || c2_assert("generator/c/c_generator_stmt.c2", 352, "c_generator.Generator.emitSwitchStmt", "0");
         }
      }
      if (!has_s2) string_buffer_Buf_add(out, "nil");
      string_buffer_Buf_add(out, ")) {\n");
      uint32_t lab = 2;
      for (uint32_t i = 0; (i < num_cases); i++) {
         c_generator_Generator_emitCase(gen, cases[i], indent, &lab);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   } else {
      string_buffer_Buf_add(out, "switch (");
      c_generator_Generator_emitExpr(gen, out, ast_SwitchStmt_getCond(sw));
      string_buffer_Buf_add(out, ") {\n");
      for (uint32_t i = 0; (i < num_cases); i++) {
         c_generator_Generator_emitCase(gen, cases[i], indent, NULL);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   }
}

static void c_generator_Generator_emitCase(c_generator_Generator* gen, ast_SwitchCase* c, uint32_t indent, uint32_t* lab)
{
   string_buffer_Buf* out = gen->out;
   if (ast_SwitchCase_isDefault(c)) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "default:");
   } else {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "case ");
      if (lab) {
         ast_Expr* e = ast_SwitchCase_getCond(c, 0);
         if (ast_Expr_isImplicitCast(e)) {
            const ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
            e = ast_ImplicitCastExpr_getInner(ic);
         }
         if (ast_Expr_isNil(e)) {
            string_buffer_Buf_add(out, "0: // nil");
         } else if (ast_Expr_isStringLiteral(e)) {
            ast_StringLiteral* lit = ((ast_StringLiteral*)(e));
            const char* p = ast_StringLiteral_getText(lit);
            if (*p) {
               string_buffer_Buf_print(out, "%u:", *lab);
               string_buffer_Buf_print(out, " // \"%s\"", p);
               *lab += 1;
            } else {
               string_buffer_Buf_add(out, "1: // \"\"");
            }
         } else {
            ast_Expr_dump(e);
            (0) || c2_assert("generator/c/c_generator_stmt.c2", 407, "c_generator.Generator.emitCase", "0");
         }

      } else {
         uint32_t num_conds = ast_SwitchCase_getNumConds(c);
         for (uint32_t i = 0; (i < num_conds); i++) {
            if (i) {
               string_buffer_Buf_add(out, ":\n");
               string_buffer_Buf_indent(out, indent);
               string_buffer_Buf_add(out, "case ");
            }
            c_generator_Generator_emitExpr(gen, out, ast_SwitchCase_getCond(c, i));
         }
         string_buffer_Buf_add1(out, ':');
      }
   }
   if (ast_SwitchCase_hasDecls(c)) string_buffer_Buf_add(out, " {");
   string_buffer_Buf_newline(out);
   const uint32_t num_stmts = ast_SwitchCase_getNumStmts(c);
   if ((num_stmts == 0)) {
      string_buffer_Buf_indent(out, (indent + 1));
      string_buffer_Buf_add(out, "fallthrough;\n");
   } else {
      ast_Stmt** stmts = ast_SwitchCase_getStmts(c);
      for (uint32_t i = 0; (i < num_stmts); i++) {
         c_generator_Generator_emitStmt(gen, stmts[i], (indent + 1), true);
      }
   }
   if (ast_SwitchCase_hasDecls(c)) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   }
}

static uint32_t c_generator_TraceCallList_add(c_generator_TraceCallList* cl, c_generator_TraceCall call)
{
   if ((cl->count >= cl->capacity)) {
      cl->capacity += ((cl->capacity / 2) + 16);
      c_generator_TraceCall* array2 = malloc((cl->capacity * 8));
      if (cl->array) {
         memcpy(array2, cl->array, (cl->count * 8));
         free(cl->array);
      }
      cl->array = array2;
   }
   uint32_t index = cl->count++;
   cl->array[index] = call;
   return index;
}

static void c_generator_TraceCallList_free(c_generator_TraceCallList* cl)
{
   if (cl->array) {
      free(cl->array);
      cl->array = NULL;
      cl->count = 0;
      cl->capacity = 0;
   }
}

static void c_generator_StringList_free(c_generator_StringList* sl)
{
   if (sl->strings) {
      for (uint32_t i = 0; (i < sl->string_count); i++) {
         free(sl->strings[i]);
      }
      free(sl->strings);
      free(sl->hash_array);
      memset(sl, 0, 48);
   }
}

static uint32_t c_generator_StringList_length(c_generator_StringList* sl)
{
   return sl->string_count;
}

static const char* c_generator_StringList_get(c_generator_StringList* sl, uint32_t i)
{
   return sl->strings[i];
}

static uint32_t c_generator_StringList_add(c_generator_StringList* sl, const char* s, _Bool check_last)
{
   if ((check_last && (s == sl->last_string))) return sl->last_index;

   sl->last_string = s;
   uint32_t hash = c_generator_HASH_INITIAL;
   for (uint32_t i = 0; s[i]; i++) {
      hash ^= s[i];
      hash *= c_generator_HASH_PRIME;
   }
   uint32_t bucket = (hash % c_generator_HASH_BUCKETS);
   if (sl->hash_array) {
      for (uint32_t i = bucket;; i--) {
         uint32_t ii = sl->hash_array[i];
         uint32_t n = ((uint16_t)(ii));
         if (!strcmp(sl->strings[n], s)) return sl->last_index = n;

         i = (ii >> 16);
         if ((i == 0)) break;

      }
   }
   if (!sl->hash_capacity) {
      sl->hash_capacity = (c_generator_HASH_BUCKETS + 32);
      sl->hash_count = c_generator_HASH_BUCKETS;
      sl->hash_array = calloc((sl->hash_capacity * 4), 1);
   }
   uint32_t slot = sl->string_count;
   if (sl->hash_array[bucket]) {
      if ((sl->hash_count >= sl->hash_capacity)) {
         sl->hash_capacity += (sl->hash_capacity / 2);
         uint32_t* hash_array2 = malloc((sl->hash_capacity * 4));
         memcpy(hash_array2, sl->hash_array, (sl->hash_count * 4));
         free(sl->hash_array);
         sl->hash_array = hash_array2;
      }
      uint32_t next = sl->hash_count++;
      sl->hash_array[next] = sl->hash_array[bucket];
      slot |= (((next + 1)) << 16);
   }
   sl->hash_array[bucket] = slot;
   if ((sl->string_count >= sl->string_capacity)) {
      sl->string_capacity += ((sl->string_capacity / 2) + 16);
      char** strings2 = malloc((sl->string_capacity * 8));
      if (sl->strings) {
         memcpy(strings2, sl->strings, (sl->string_count * 8));
         free(sl->strings);
      }
      sl->strings = strings2;
   }
   uint32_t index = sl->string_count++;
   sl->strings[index] = strdup(s);
   return sl->last_index = index;
}

static uint32_t c_generator_Generator_addCall(c_generator_Generator* gen, const char* funcname, src_loc_SrcLoc loc)
{
   source_mgr_Location location = source_mgr_SourceMgr_locate(gen->sm, loc);
   c_generator_TraceCall call = { .filename_idx = ((uint8_t)(c_generator_StringList_add(&gen->filenames, location.filename, true))), .column = ((uint8_t)(location.column)), .line = ((uint16_t)(location.line)), .callee_idx = ((uint16_t)(c_generator_StringList_add(&gen->funcnames, funcname, false))), .caller_idx = ((uint16_t)(gen->cur_function ? c_generator_StringList_add(&gen->funcnames, ast_Decl_getFullName(ast_FunctionDecl_asDecl(gen->cur_function)), false) : 0)) };
   return c_generator_TraceCallList_add(&gen->calls, call);
}

static void c_generator_Generator_writeCalls(c_generator_Generator* gen, string_buffer_Buf* out)
{
   if (!gen->trace_calls) return;

   string_buffer_Buf_add(out, "static const char *c2_filenames[] = {\n");
   uint32_t n = c_generator_StringList_length(&gen->filenames);
   for (uint32_t i = 0; (i < n); i++) {
      string_buffer_Buf_print(out, "    \"%s\",\n", c_generator_StringList_get(&gen->filenames, i));
   }
   string_buffer_Buf_add(out, "};\n\n");
   const char begin[170] = "struct c2_func_t {\n    unsigned count;\n    unsigned short filename_idx;\n    unsigned short line;\n    const char *funcname;\n};\nstatic struct c2_func_t c2_func_data[] = {\n";
   string_buffer_Buf_add(out, begin);
   n = c_generator_StringList_length(&gen->funcnames);
   for (uint32_t i = 0; (i < n); i++) {
      string_buffer_Buf_print(out, "    { 0, 0, 0, \"%s\" },\n", c_generator_StringList_get(&gen->funcnames, i));
   }
   string_buffer_Buf_add(out, "};\n\n");
   string_buffer_Buf_add(out, "struct c2_trace_t {\n    unsigned count;\n    unsigned char filename_idx;\n    unsigned char column;\n    unsigned short line;\n    unsigned short caller_idx;\n    unsigned short callee_idx;\n};\nstatic struct c2_trace_t c2_trace_data[] = {\n");
   for (uint32_t i = 0; (i < gen->calls.count); i++) {
      string_buffer_Buf_print(out, "    { 0, %u, %u, %u, %u, %u },\n", gen->calls.array[i].filename_idx, gen->calls.array[i].column, gen->calls.array[i].line, gen->calls.array[i].caller_idx, gen->calls.array[i].callee_idx);
   }
   string_buffer_Buf_add(out, "};\n\n");
   string_buffer_Buf_add(out, "static const unsigned c2_trace_length = sizeof(c2_trace_data) / sizeof(c2_trace_data[0]);\nunsigned c2_trace_counts[sizeof(c2_trace_data) / sizeof(c2_trace_data[0])];\n\n");
   string_buffer_Buf_add(out, "char *getenv(const char *);\nint dprintf(int fd, const char *format, ...);\nint strcmp(const char *s1, const char *s2);\ntypedef unsigned long size_t;\nvoid qsort(void *base, size_t nmemb, size_t size, int (*compar)(const void *, const void *));\nint sscanf(const char *, const char *, ...);\n\n");
   string_buffer_Buf_add(out, "static int c2_match_name(const char *name, const char *pattern) {\n    for (;;) {\n        char c1, c2;\n        while ((c1 = *name++) == (c2 = *pattern++)) {\n            if (!c1) return 1;\n        }\n        if (c2 == '?') {\n            if (c1) continue;\n            return 0;\n        }\n        if (c2 == '*') {\n            c2 = *pattern++;\n            if (!c2 || c2 == ',' || c2 == ';') return 1;\n            for (; c1; c1 = *name++) {\n                if (c1 == c2 && c2_match_name(name, pattern)) return 1;\n            }\n            return 0;\n        }\n        return (!c1 && (c2 == ',' || c2 == ';'));\n    }\n}\n\n");
   string_buffer_Buf_add(out, "static int c2_match_pattern(const char *name, const char *pattern) {\n    if (!pattern || !*pattern) return 1;\n    for (const char *p = pattern; *p;) {\n        if (c2_match_name(name, p)) return 1;\n        char c;\n        while ((c = *p++) != 0 && c != ',' && c != ';') continue;\n        if (c != ',') break;\n    }\n    return 0;\n}\n\n");
   string_buffer_Buf_add(out, "static int c2_cmp_funcs(const void *a, const void *b) {\n    const struct c2_trace_t *aa = a;\n    const struct c2_trace_t *bb = b;\n    struct c2_func_t *fa = &c2_func_data[aa->callee_idx];\n    struct c2_func_t *fb = &c2_func_data[bb->callee_idx];\n    if (fa->count != fb->count) return fa->count < fb->count ? 1 : -1;\n    if (fa != fb) return strcmp(fa->funcname, fb->funcname);\n    return (aa->count < bb->count) - (aa->count > bb->count);\n}\n\n");
   string_buffer_Buf_add(out, "static int c2_cmp_calls(const void *a, const void *b) {\n    const struct c2_trace_t *aa = a;\n    const struct c2_trace_t *bb = b;\n    return (aa->count < bb->count) - (aa->count > bb->count);\n}\n\n");
   string_buffer_Buf_add(out, "void __attribute__((destructor)) c2_trace_calls(void) {\n    const char *p = getenv(\"C2_TRACE\");\n    const char *pattern = 0;\n    const char *filename = 0;\n    const char *caller = 0;\n    if (!p || !*p) return;\n    unsigned min = 1, min2 = 1;\n    int pos = 0, mode = 3, fd = 1, indent = 2;\n    for (; *p; p += pos) {\n        for (pos = 0;;) {\n            sscanf(p, \" min%*1[=]%n%u\", &pos, &min);\n            if (pos) break;\n            sscanf(p, \" min2%*1[=]%n%u\", &pos, &min2);\n            if (pos) break;\n            sscanf(p, \" indent%*1[=]%n%u\", &pos, &indent);\n            if (pos) break;\n            sscanf(p, \" mode%*1[=]%n%d\", &pos, &mode);\n            if (pos) break;\n            sscanf(p, \" fd%*1[=]%n%d\", &pos, &fd);\n            if (pos) break;\n            sscanf(p, \" name%*1[=]%n\", &pos);\n            if (pos) { pattern = p + pos; break; }\n            sscanf(p, \" filename%*1[=]%n\", &pos);\n            if (pos) { filename = p + pos; break; }\n            sscanf(p, \" caller%*1[=]%n\", &pos);\n            if (pos) { caller = p + pos; break; }\n            sscanf(p, \"%*[^;=]%*1[=]%n%\", &pos);\n            break;\n        }\n        if (!pos) pattern = p;\n        while (p[pos] && p[pos++] != ';') continue;\n    }\n    if (!mode) return;\n    unsigned *counts = c2_trace_counts;\n    struct c2_trace_t* data = c2_trace_data;\n    unsigned n = c2_trace_length;\n    for (unsigned i = 0; i < n; i++) {\n        struct c2_trace_t *cp = &data[i];\n        if (c2_match_pattern(c2_func_data[cp->callee_idx].funcname, pattern)\n        &&  c2_match_pattern(c2_filenames[cp->filename_idx], filename)\n        &&  c2_match_pattern(c2_func_data[cp->caller_idx].funcname, caller)) {\n            cp->count = counts[i];\n            c2_func_data[cp->callee_idx].count += counts[i];\n        }\n    }\n    if (mode == 2) {\n        qsort(data, n, sizeof(*data), c2_cmp_calls);\n        indent = 0;\n        min2 = min;\n    } else {\n        qsort(data, n, sizeof(*data), c2_cmp_funcs);\n    }\n    struct c2_func_t *last = 0;\n    int show = 0;\n    for (unsigned i = 0; i < n; i++) {\n        struct c2_trace_t *cp = &data[i];\n        struct c2_func_t *func = &c2_func_data[cp->callee_idx];\n        unsigned count1 = func->count;\n        unsigned count2 = cp->count;\n        if (count1 < min) continue;\n        if (func != last) {\n            show = mode & 2;\n            if (mode & 1) {\n                dprintf(fd, \"%.*s%s: %u call%.*s\\n\", show, \"\\n\",\n                        func->funcname, count1, count1 != 1, \"s\");\n            }\n            last = func;\n        }\n        if (show && count2 >= min2) {\n            dprintf(fd, \"%*s%s:%d:%d: %s: %u call%.*s from %s\\n\",\n                    indent, \"\",\n                    c2_filenames[cp->filename_idx], cp->line, cp->column,\n                    func->funcname, count2, count2 != 1, \"s\",\n                    c2_func_data[cp->caller_idx].funcname);\n        }\n    }\n}\n");
}

static void c_generator_Generator_writeCallExterns(c_generator_Generator* gen, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "extern unsigned c2_trace_counts[];\nextern void c2_trace_calls(void);\nextern int atexit(void (*func)(void));\n");
}


// --- module generator_utils ---
typedef struct generator_utils_Wrapper_ generator_utils_Wrapper;

struct generator_utils_Wrapper_ {
   ast_visitor_Visitor* visitor;
};

static void generator_utils_clear_used_decl(void* arg, ast_Decl* d);
static void generator_utils_clear_used_mod(void* arg, ast_Module* m);
static _Bool generator_utils_isEntryPoint(ast_Decl* d);
static void generator_utils_check_exported_decls(void* arg, ast_Decl* d);
static void generator_utils_check_module(void* arg, ast_Module* m);
static void generator_utils_mark_used_decl(void* arg, const ast_Ref* ref);
static void generator_utils_mark_test_mode_decl(void* arg, ast_Decl* d);
static void generator_utils_mark_test_mode_mod(void* arg, ast_Module* m);
static void generator_utils_mark_used(component_Component* mainComp, const module_list_List* allmodules, _Bool test_mode);

static void generator_utils_clear_used_decl(void* arg, ast_Decl* d)
{
   ast_Decl_clearUsed(d);
}

static void generator_utils_clear_used_mod(void* arg, ast_Module* m)
{
   if (!ast_Module_isUsed(m)) return;

   ast_Module_visitDeclsWithoutImports(m, generator_utils_clear_used_decl, NULL);
}

static _Bool generator_utils_isEntryPoint(ast_Decl* d)
{
   if ((ast_Decl_isExported(d) && ast_Decl_isPublic(d))) return true;

   if (ast_Decl_isFunction(d)) {
      ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
      if ((ast_FunctionDecl_hasAttrConstructor(fd) || ast_FunctionDecl_hasAttrDestructor(fd))) return true;

   }
   return false;
}

static void generator_utils_check_exported_decls(void* arg, ast_Decl* d)
{
   if (ast_Decl_isUsed(d)) return;

   if (generator_utils_isEntryPoint(d)) {
      ast_Decl_setUsed(d);
      generator_utils_Wrapper* w = arg;
      ast_visitor_Visitor_handle(w->visitor, d);
   }
}

static void generator_utils_check_module(void* arg, ast_Module* m)
{
   ast_Module_visitDecls(m, generator_utils_check_exported_decls, arg);
}

static void generator_utils_mark_used_decl(void* arg, const ast_Ref* ref)
{
   ast_Decl* d = ref->decl;
   if (ast_Decl_isUsed(d)) return;

   ast_Decl_setUsed(d);
   generator_utils_Wrapper* w = arg;
   ast_visitor_Visitor_handle(w->visitor, d);
}

static void generator_utils_mark_test_mode_decl(void* arg, ast_Decl* d)
{
   ast_Decl_setUsed(d);
}

static void generator_utils_mark_test_mode_mod(void* arg, ast_Module* m)
{
   ast_Module_visitDecls(m, generator_utils_mark_test_mode_decl, arg);
}

static void generator_utils_mark_used(component_Component* mainComp, const module_list_List* allmodules, _Bool test_mode)
{
   if (test_mode) {
      component_Component_visitModules(mainComp, generator_utils_mark_test_mode_mod, NULL);
      return;
   }
   module_list_List_visit(allmodules, generator_utils_clear_used_mod, NULL);
   generator_utils_Wrapper wrapper = { };
   ast_visitor_Visitor* visitor = ast_visitor_create(&wrapper, generator_utils_mark_used_decl);
   wrapper.visitor = visitor;
   component_Component_visitModules(mainComp, generator_utils_check_module, &wrapper);
   ast_visitor_Visitor_free(visitor);
}


// --- module qbe_generator ---
typedef struct qbe_generator_JumpScope_ qbe_generator_JumpScope;
typedef struct qbe_generator_Generator_ qbe_generator_Generator;
typedef struct qbe_generator_ExprRef_ qbe_generator_ExprRef;

struct qbe_generator_JumpScope_ {
   char break_block[24];
   char continue_block[24];
};

struct qbe_generator_Generator_ {
   string_buffer_Buf* out;
   qbe_locals_Locals locals;
   string_pool_Pool* names;
   value_maplist_List labels;
   uint32_t block_idx;
   _Bool block_terminated;
   qbe_generator_JumpScope scopes[32];
   uint32_t num_scopes;
   _Bool cur_external;
   _Bool assert_generated;
   _Bool print;
   _Bool enable_asserts;
   uint32_t string_idx;
   uint32_t substruct_idx;
   string_buffer_Buf* start;
   string_buffer_Buf* globals;
   const char* target;
   const char* output_dir;
   source_mgr_SourceMgr* sm;
   ast_FunctionDecl* cur_function;
};

static const char qbe_generator_QBE_Dir[4] = "qbe";

static const char qbe_generator_QBE_Filename[9] = "main.qbe";

static const char qbe_generator_LogFile[10] = "build.log";

static void qbe_generator_Generator_pushScope(qbe_generator_Generator* gen, const char* break_block, const char* continue_block);
static void qbe_generator_Generator_popScope(qbe_generator_Generator* gen);
static uint32_t qbe_generator_Generator_getNewBlockIndex(qbe_generator_Generator* gen);
static void qbe_generator_Generator_startBlock(qbe_generator_Generator* gen, const char* name, const char* comments);
static void qbe_generator_addStructName(string_buffer_Buf* out, const ast_Decl* d);
static void qbe_generator_getGlobalName(char* result, const ast_Decl* d);
static void qbe_generator_addGlobalName(string_buffer_Buf* out, const ast_Decl* d);
static void qbe_generator_addType(string_buffer_Buf* out, ast_QualType qt);
static void qbe_generator_Generator_addParam(qbe_generator_Generator* gen, uint32_t idx, ast_VarDecl* vd);
static char qbe_generator_align2char(uint32_t align);
static char qbe_generator_align2store(uint32_t align);
static void qbe_generator_Generator_emitFunction(qbe_generator_Generator* gen, ast_Decl* d);
static void qbe_generator_Generator_emitFunctionBody(qbe_generator_Generator* gen, const ast_FunctionDecl* fd);
static void qbe_generator_Generator_doArrayInit(qbe_generator_Generator* gen, const ast_ArrayType* at, const ast_Expr* e);
static void qbe_generator_Generator_doStructInit(qbe_generator_Generator* gen, const ast_StructType* st, const ast_Expr* e);
static void qbe_generator_Generator_emitGlobalVarDecl(qbe_generator_Generator* gen, ast_Decl* d);
static void qbe_generator_Generator_emitVarDeclInit(qbe_generator_Generator* gen, const ast_Decl* d, string_buffer_Buf* out);
static void qbe_generator_addMember(string_buffer_Buf* out, ast_QualType qt);
static uint32_t qbe_generator_Generator_createStruct(qbe_generator_Generator* gen, ast_StructTypeDecl* s, _Bool is_global);
static void qbe_generator_Generator_emitStructType(qbe_generator_Generator* gen, ast_Decl* d);
static void qbe_generator_Generator_on_decl(void* arg, ast_Decl* d);
static void qbe_generator_Generator_on_ast(void* arg, ast_AST* a);
static void qbe_generator_Generator_on_module(void* arg, ast_Module* m);
static void qbe_generator_Generator_init(qbe_generator_Generator* gen, source_mgr_SourceMgr* sm, const char* target, const char* output_dir, _Bool enable_asserts, _Bool print);
static void qbe_generator_Generator_free(qbe_generator_Generator* gen);
static void qbe_generator_Generator_write(qbe_generator_Generator* gen, const char* output_dir, const char* filename);
static void qbe_generator_Generator_createMakefile(qbe_generator_Generator* gen, const char* output_dir);
static void qbe_generator_generate(const char* target, const char* output_dir, component_List* comps, source_mgr_SourceMgr* sm, _Bool enable_asserts, _Bool print);
static void qbe_generator_build(const char* output_dir);
static void qbe_generator_Generator_addLocalVar(qbe_generator_Generator* gen, ast_VarDecl* vd);
static void qbe_generator_Generator_collectLocals(qbe_generator_Generator* gen, const ast_FunctionDecl* fd);
static void qbe_generator_Generator_collectLocalVars(qbe_generator_Generator* gen, ast_Stmt* s);
static void qbe_generator_Generator_createTemp(qbe_generator_Generator* gen, char* out);
static uint32_t qbe_generator_Generator_getLabelBlock(qbe_generator_Generator* gen, uint32_t label_idx);
struct qbe_generator_ExprRef_ {
   char ref[80];
};

static void qbe_generator_Generator_createString(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const char* text);
static void qbe_generator_Generator_emitExpr(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static void qbe_generator_Generator_emitMemberExpr(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static void qbe_generator_Generator_emitIdentifier(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static void qbe_generator_Generator_emitVarDecl(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Decl* d);
static void qbe_generator_Generator_emitUnaryOperator(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static void qbe_generator_Generator_emitBinaryOperator(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static void qbe_generator_Generator_emitOpAssign(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static void qbe_generator_Generator_emitLogicalOp(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e, _Bool is_and);
static void qbe_generator_Generator_emitShift(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e);
static _Bool qbe_generator_Generator_emitStmt(qbe_generator_Generator* gen, const ast_Stmt* s);
static void qbe_generator_Generator_emitCondition(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Stmt* s);
static void qbe_generator_Generator_emitIfStmt(qbe_generator_Generator* gen, const ast_Stmt* s);
static void qbe_generator_Generator_emitWhileStmt(qbe_generator_Generator* gen, const ast_Stmt* s);
static void qbe_generator_Generator_emitForStmt(qbe_generator_Generator* gen, const ast_Stmt* s);
static void qbe_generator_Generator_emitAssertStmt(qbe_generator_Generator* gen, const ast_Stmt* s);

static void qbe_generator_Generator_pushScope(qbe_generator_Generator* gen, const char* break_block, const char* continue_block)
{
   ((gen->num_scopes < 32)) || c2_assert("generator/qbe/qbe_generator.c2", 70, "qbe_generator.Generator.pushScope", "gen.num_scopes < elemsof(gen.scopes)");
   qbe_generator_JumpScope* js = &gen->scopes[gen->num_scopes];
   strcpy(js->break_block, break_block);
   strcpy(js->continue_block, continue_block);
   gen->num_scopes++;
}

static void qbe_generator_Generator_popScope(qbe_generator_Generator* gen)
{
   ((gen->num_scopes > 0)) || c2_assert("generator/qbe/qbe_generator.c2", 78, "qbe_generator.Generator.popScope", "gen.num_scopes > 0");
   gen->num_scopes--;
}

static uint32_t qbe_generator_Generator_getNewBlockIndex(qbe_generator_Generator* gen)
{
   return gen->block_idx++;
}

static void qbe_generator_Generator_startBlock(qbe_generator_Generator* gen, const char* name, const char* comments)
{
   gen->block_terminated = false;
   string_buffer_Buf_add(gen->out, name);
   string_buffer_Buf_newline(gen->out);
}

static void qbe_generator_addStructName(string_buffer_Buf* out, const ast_Decl* d)
{
   (ast_Decl_getName(d)) || c2_assert("generator/qbe/qbe_generator.c2", 96, "qbe_generator.addStructName", "d.getName()");
   string_buffer_Buf_add1(out, ':');
   string_buffer_Buf_add(out, ast_Decl_getModuleName(d));
   string_buffer_Buf_add1(out, '_');
   string_buffer_Buf_add(out, ast_Decl_getName(d));
}

static void qbe_generator_getGlobalName(char* result, const ast_Decl* d)
{
   string_buffer_Buf* out = string_buffer_create_static(128, false, result);
   qbe_generator_addGlobalName(out, d);
   string_buffer_Buf_free(out);
}

static void qbe_generator_addGlobalName(string_buffer_Buf* out, const ast_Decl* d)
{
   string_buffer_Buf_add1(out, '$');
   if (ast_Decl_isExternal(d)) {
      const char* cname = ast_Decl_getCName(d);
      if (cname) {
         string_buffer_Buf_add(out, cname);
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
   } else {
      string_buffer_Buf_add(out, ast_Decl_getModuleName(d));
      string_buffer_Buf_add1(out, '_');
      if (ast_Decl_isFunction(d)) {
         ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
         ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
         if (prefix) {
            string_buffer_Buf_add(out, ast_idx2name(prefix->name_idx));
            string_buffer_Buf_add1(out, '_');
         }
      }
      if (ast_Decl_isEnumConstant(d)) {
         ast_QualType qt = ast_Decl_getType(d);
         ast_EnumType* et = ((ast_EnumType*)(ast_QualType_getType(&qt)));
         string_buffer_Buf_add(out, ast_EnumType_getName(et));
         string_buffer_Buf_add1(out, '_');
      }
      string_buffer_Buf_add(out, ast_Decl_getName(d));
   }
}

static void qbe_generator_addType(string_buffer_Buf* out, ast_QualType qt)
{
   const ast_StructType* s = ast_QualType_getStructTypeOrNil(&qt);
   if (s) {
      qbe_generator_addStructName(out, ((ast_Decl*)(ast_StructType_getDecl(s))));
   } else {
      if ((ast_QualType_getAlignment(&qt) == 8)) string_buffer_Buf_add1(out, 'l');
      else string_buffer_Buf_add1(out, 'w');
   }
}

static void qbe_generator_Generator_addParam(qbe_generator_Generator* gen, uint32_t idx, ast_VarDecl* vd)
{
   string_buffer_Buf* out = gen->out;
   qbe_Var* var = qbe_locals_Locals_find(&gen->locals, vd);
   (var) || c2_assert("generator/qbe/qbe_generator.c2", 156, "qbe_generator.Generator.addParam", "var");
   switch (var->align) {
   case 1:
      string_buffer_Buf_add1(out, 'w');
      string_buffer_Buf_print(gen->start, "\tstoreb %%.%u, %%.%u\n", idx, var->slot);
      break;
   case 2:
      string_buffer_Buf_add1(out, 'w');
      string_buffer_Buf_print(gen->start, "\tstoreh %%.%u, %%.%u\n", idx, var->slot);
      break;
   case 4:
      string_buffer_Buf_add1(out, 'w');
      string_buffer_Buf_print(gen->start, "\tstorew %%.%u, %%.%u\n", idx, var->slot);
      break;
   case 8:
      string_buffer_Buf_add1(out, 'l');
      string_buffer_Buf_print(gen->start, "\tstorel %%.%u, %%.%u\n", idx, var->slot);
      break;
   default:
      (0) || c2_assert("generator/qbe/qbe_generator.c2", 176, "qbe_generator.Generator.addParam", "0");
      break;
   }
   string_buffer_Buf_print(out, " %%.%u", idx);
}

static char qbe_generator_align2char(uint32_t align)
{
   if ((align == 8)) return 'l';

   if ((align == 4)) return 'w';

   if ((align == 2)) return 's';

   if ((align == 1)) return 'b';

   (0) || c2_assert("generator/qbe/qbe_generator.c2", 187, "qbe_generator.align2char", "0");
   return '?';
}

static char qbe_generator_align2store(uint32_t align)
{
   if ((align == 4)) return 'w';

   if ((align == 2)) return 'h';

   if ((align == 1)) return 'b';

   return 'l';
}

static void qbe_generator_Generator_emitFunction(qbe_generator_Generator* gen, ast_Decl* d)
{
   value_maplist_List_clear(&gen->labels);
   string_buffer_Buf_clear(gen->start);
   qbe_locals_Locals_clear(&gen->locals);
   ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
   gen->cur_function = fd;
   string_buffer_Buf* out = gen->out;
   if (ast_Decl_isPublic(d)) string_buffer_Buf_add(out, "export ");
   string_buffer_Buf_add(out, "function ");
   if (ast_FunctionDecl_hasReturn(fd)) {
      qbe_generator_addType(out, ast_FunctionDecl_getRType(fd));
      string_buffer_Buf_space(out);
   }
   string_buffer_Buf_add1(out, '$');
   _Bool has_prefix = (!ast_Decl_isPublic(d) || ((strcmp(ast_Decl_getName(d), "main") != 0)));
   if (has_prefix) {
      string_buffer_Buf_add(out, ast_Decl_getModuleName(d));
      string_buffer_Buf_add1(out, '_');
   }
   const ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
   if (prefix) {
      string_buffer_Buf_add(out, ast_Ref_getName(prefix));
      string_buffer_Buf_add1(out, '_');
   }
   string_buffer_Buf_add(out, ast_Decl_getName(d));
   string_buffer_Buf_lparen(out);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   string_buffer_Buf_clear(gen->start);
   string_buffer_Buf_print(gen->start, "@start.%u\n", qbe_generator_Generator_getNewBlockIndex(gen));
   gen->block_terminated = false;
   qbe_generator_Generator_collectLocals(gen, fd);
   ast_VarDecl** fn_params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; (i < num_params); i++) {
      if ((i != 0)) string_buffer_Buf_add(out, ", ");
      qbe_generator_Generator_addParam(gen, (i + 1), fn_params[i]);
   }
   if (ast_FunctionDecl_isVariadic(fd)) {
      if (num_params) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_add(out, "...");
   }
   string_buffer_Buf_add(out, ") {\n");
   string_buffer_Buf_add(out, string_buffer_Buf_data(gen->start));
   string_buffer_Buf_clear(gen->start);
   qbe_generator_Generator_emitFunctionBody(gen, fd);
   string_buffer_Buf_add(out, "}\n\n");
}

static void qbe_generator_Generator_emitFunctionBody(qbe_generator_Generator* gen, const ast_FunctionDecl* fd)
{
   ast_CompoundStmt* body = ast_FunctionDecl_getBody(fd);
   const uint32_t num_stmts = ast_CompoundStmt_getCount(body);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(body);
   for (uint32_t i = 0; (i < num_stmts); i++) {
      const ast_Stmt* s = stmts[i];
      qbe_generator_Generator_emitStmt(gen, s);
   }
   if (!gen->block_terminated) string_buffer_Buf_add(gen->out, "\tret\n");
}

static void qbe_generator_Generator_doArrayInit(qbe_generator_Generator* gen, const ast_ArrayType* at, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   uint32_t num_elems = ast_ArrayType_getSize(at);
   ast_QualType elem = ast_ArrayType_getElemType(at);
   uint32_t elemSize = ast_QualType_getSize(&elem, false);
   uint32_t len;
   if (ast_Expr_isStringLiteral(e)) {
      const ast_StringLiteral* str = ((ast_StringLiteral*)(e));
      const char* text = ast_StringLiteral_getText(str);
      string_buffer_Buf_print(out, "b \"%s\\000\"", text);
      len = (((uint32_t)(strlen(text))) + 1);
   } else {
      (ast_Expr_isInitList(e)) || c2_assert("generator/qbe/qbe_generator.c2", 286, "qbe_generator.Generator.doArrayInit", "e.isInitList()");
      ast_InitListExpr* ile = ((ast_InitListExpr*)(e));
      uint32_t count = ast_InitListExpr_getNumValues(ile);
      ast_Expr** inits = ast_InitListExpr_getValues(ile);
      const ast_StructType* st = ast_QualType_getStructTypeOrNil(&elem);
      if (st) {
         for (uint32_t i = 0; (i < count); i++) {
            if ((i != 0)) string_buffer_Buf_add(out, ", ");
            qbe_generator_Generator_doStructInit(gen, st, inits[i]);
         }
      } else {
         char name = qbe_generator_align2store(elemSize);
         for (uint32_t i = 0; (i < count); i++) {
            if ((i != 0)) string_buffer_Buf_add(out, ", ");
            string_buffer_Buf_print(out, "%c ", name);
            qbe_generator_ExprRef result;
            qbe_generator_Generator_emitExpr(gen, &result, inits[i]);
         }
      }
      len = (count * elemSize);
   }
   uint32_t num_zeroes = (((num_elems * elemSize)) - len);
   if (num_zeroes) {
      if (len) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_print(out, "z %u", num_zeroes);
   }
}

static void qbe_generator_Generator_doStructInit(qbe_generator_Generator* gen, const ast_StructType* st, const ast_Expr* e)
{
}

static void qbe_generator_Generator_emitGlobalVarDecl(qbe_generator_Generator* gen, ast_Decl* d)
{
   string_buffer_Buf* out = gen->out;
   if (ast_Decl_isPublic(d)) string_buffer_Buf_add(out, "export ");
   string_buffer_Buf_add(out, "data ");
   qbe_generator_addGlobalName(out, d);
   qbe_generator_Generator_emitVarDeclInit(gen, d, out);
}

static void qbe_generator_Generator_emitVarDeclInit(qbe_generator_Generator* gen, const ast_Decl* d, string_buffer_Buf* out)
{
   const ast_VarDecl* vd = ((ast_VarDecl*)(d));
   ast_QualType qt = ast_Decl_getType(d);
   uint32_t align = ast_QualType_getAlignment(&qt);
   uint32_t size = ast_QualType_getSize(&qt, false);
   string_buffer_Buf_print(out, " = align %u { ", align);
   const ast_Expr* initExpr = ast_VarDecl_getInit(vd);
   if (initExpr) {
      ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(&qt);
      const ast_StructType* st = ast_QualType_getStructTypeOrNil(&qt);
      if (at) {
         qbe_generator_Generator_doArrayInit(gen, at, initExpr);
      } else if (st) {
         qbe_generator_Generator_doStructInit(gen, st, initExpr);
      } else {
         qbe_generator_ExprRef result;
         qbe_generator_Generator_emitExpr(gen, &result, initExpr);
         string_buffer_Buf_print(out, "%c %s", qbe_generator_align2store(size), result.ref);
      }

   } else {
      string_buffer_Buf_print(out, "z %u", size);
   }
   string_buffer_Buf_add(out, " }\n");
}

static void qbe_generator_addMember(string_buffer_Buf* out, ast_QualType qt)
{
   const ast_StructType* s = ast_QualType_getStructTypeOrNil(&qt);
   if (s) {
      qbe_generator_addStructName(out, ((ast_Decl*)(ast_StructType_getDecl(s))));
      return;
   }
   const ast_ArrayType* a = ast_QualType_getArrayTypeOrNil(&qt);
   uint32_t align = ast_QualType_getAlignment(&qt);
   if (a) {
      uint32_t size = ast_ArrayType_getSize(a);
      while (1) {
         qt = ast_ArrayType_getElemType(a);
         a = ast_QualType_getArrayTypeOrNil(&qt);
         if (!a) break;

         size *= ast_ArrayType_getSize(a);
      }
      string_buffer_Buf_add1(out, qbe_generator_align2char(align));
      string_buffer_Buf_print(out, " %u", size);
      return;
   }
   string_buffer_Buf_add1(out, qbe_generator_align2char(align));
}

static uint32_t qbe_generator_Generator_createStruct(qbe_generator_Generator* gen, ast_StructTypeDecl* s, _Bool is_global)
{
   string_buffer_Buf* out = gen->out;
   if (ast_Decl_isGenerated(ast_StructTypeDecl_asDecl(s))) return 0;

   const uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
   ast_Decl** members = ast_StructTypeDecl_getMembers(s);
   uint32_t anon_id = 0;
   string_buffer_Buf_add(out, "type ");
   if (is_global) {
      qbe_generator_addStructName(out, ((ast_Decl*)(s)));
   } else {
      anon_id = gen->substruct_idx;
      string_buffer_Buf_print(out, ":anon%u", anon_id);
      gen->substruct_idx++;
   }
   string_buffer_Buf_add(out, " = { ");
   _Bool is_union = ast_StructTypeDecl_isUnion(s);
   const char* inter = is_union ? " " : ", ";
   for (uint32_t i = 0; (i < num_members); i++) {
      ast_Decl* member = members[i];
      if ((i != 0)) string_buffer_Buf_add(out, inter);
      if (is_union) string_buffer_Buf_add1(out, '{');
      if (ast_Decl_isStructType(member)) {
         uint32_t sub_id = qbe_generator_Generator_createStruct(gen, ((ast_StructTypeDecl*)(member)), false);
         string_buffer_Buf_print(out, ":anon%u", sub_id);
      } else {
         (ast_Decl_isVariable(member)) || c2_assert("generator/qbe/qbe_generator.c2", 422, "qbe_generator.Generator.createStruct", "member.isVariable()");
         ast_QualType qt = ast_Decl_getType(member);
         ast_StructType* st = ast_QualType_getStructTypeOrNil(&qt);
         if (st) {
            ast_StructTypeDecl* s2 = ast_StructType_getDecl(st);
            if (!ast_Decl_isGenerated(ast_StructTypeDecl_asDecl(s2))) {
               qbe_generator_Generator_createStruct(gen, s2, true);
            }
         }
         qbe_generator_addMember(out, ast_Decl_getType(member));
      }
      if (is_union) string_buffer_Buf_add1(out, '}');
   }
   string_buffer_Buf_add(out, " }\n");
   ast_Decl_setGenerated(ast_StructTypeDecl_asDecl(s));
   return anon_id;
}

static void qbe_generator_Generator_emitStructType(qbe_generator_Generator* gen, ast_Decl* d)
{
   if (ast_Decl_isGenerated(d)) return;

   ast_StructTypeDecl* s = ((ast_StructTypeDecl*)(d));
   qbe_generator_Generator_createStruct(gen, s, true);
}

static void qbe_generator_Generator_on_decl(void* arg, ast_Decl* d)
{
   if (!ast_Decl_isUsed(d)) return;

   qbe_generator_Generator* gen = arg;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      if (!gen->cur_external) qbe_generator_Generator_emitFunction(gen, d);
      break;
   case ast_DeclKind_Import:
      return;
   case ast_DeclKind_StructType:
      qbe_generator_Generator_emitStructType(gen, d);
      break;
   case ast_DeclKind_EnumType:
      break;
   case ast_DeclKind_EnumConstant:
      break;
   case ast_DeclKind_FunctionType:
      break;
   case ast_DeclKind_AliasType:
      break;
   case ast_DeclKind_Variable:
      qbe_generator_Generator_emitGlobalVarDecl(gen, d);
      break;
   }
}

static void qbe_generator_Generator_on_ast(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, qbe_generator_Generator_on_decl, arg);
}

static void qbe_generator_Generator_on_module(void* arg, ast_Module* m)
{
   if (!ast_Module_isUsed(m)) return;

   qbe_generator_Generator* gen = arg;
   string_buffer_Buf_print(gen->out, "\n# --- module %s ---\n\n", ast_Module_getName(m));
   ast_Module_visitASTs(m, qbe_generator_Generator_on_ast, arg);
   string_buffer_Buf_add(gen->out, string_buffer_Buf_data(gen->globals));
   string_buffer_Buf_clear(gen->globals);
}

static void qbe_generator_Generator_init(qbe_generator_Generator* gen, source_mgr_SourceMgr* sm, const char* target, const char* output_dir, _Bool enable_asserts, _Bool print)
{
   memset(gen, 0, 1664);
   gen->out = string_buffer_create((256 * 1024), false, 1);
   gen->start = string_buffer_create(1024, false, 1);
   gen->globals = string_buffer_create((4 * 1024), false, 1);
   gen->names = string_pool_create((16 * 1024), 2048);
   value_maplist_List_init(&gen->labels);
   gen->target = target;
   gen->output_dir = output_dir;
   gen->string_idx = 1;
   qbe_locals_Locals_init(&gen->locals);
   gen->enable_asserts = enable_asserts;
   gen->print = print;
   gen->sm = sm;
}

static void qbe_generator_Generator_free(qbe_generator_Generator* gen)
{
   string_pool_Pool_free(gen->names);
   value_maplist_List_free(&gen->labels);
   qbe_locals_Locals_free(&gen->locals);
   string_buffer_Buf_free(gen->globals);
   string_buffer_Buf_free(gen->start);
   string_buffer_Buf_free(gen->out);
}

static void qbe_generator_Generator_write(qbe_generator_Generator* gen, const char* output_dir, const char* filename)
{
   char fullname[512];
   snprintf(fullname, 512, "%s/%s", output_dir, filename);
   file_utils_Writer writer;
   _Bool ok = file_utils_Writer_write(&writer, fullname, string_buffer_Buf_data(gen->out), string_buffer_Buf_size(gen->out));
   if (!ok) {
      console_error("cannot write to %s: %s", fullname, file_utils_Writer_getError(&writer));
   }
}

static void qbe_generator_Generator_createMakefile(qbe_generator_Generator* gen, const char* output_dir)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, "# This makefile is auto-generated, any modifications will be lost\n\n");
   string_buffer_Buf_print(out, "../%s: main.o\n", gen->target);
   string_buffer_Buf_print(out, "\t\tgcc main.o -o ../%s\n\n", gen->target);
   string_buffer_Buf_add(out, "main.o: main.s\n");
   string_buffer_Buf_add(out, "\t\tas main.s -o main.o\n\n");
   string_buffer_Buf_add(out, "main.s: main.qbe\n");
   string_buffer_Buf_add(out, "\t\tqbe -t amd64_sysv main.qbe -o main.s\n\n");
   string_buffer_Buf_add(out, "clean:\n");
   string_buffer_Buf_add(out, "\t\trm -f main.o main.s test\n\n");
   qbe_generator_Generator_write(gen, output_dir, "Makefile");
}

static void qbe_generator_generate(const char* target, const char* output_dir, component_List* comps, source_mgr_SourceMgr* sm, _Bool enable_asserts, _Bool print)
{
   char qbe_dir[512];
   sprintf(qbe_dir, "%s/%s", output_dir, qbe_generator_QBE_Dir);
   int32_t err = file_utils_create_directory(qbe_dir);
   if (err) {
      console_error("cannot create directory %s: %s", qbe_dir, strerror(err));
      return;
   }
   qbe_generator_Generator gen;
   qbe_generator_Generator_init(&gen, sm, target, qbe_dir, enable_asserts, print);
   for (uint32_t i = 0; (i < component_List_size(comps)); i++) {
      component_Component* c = component_List_get(comps, i);
      gen.cur_external = component_Component_isExternal(c);
      component_Component_visitModules(c, qbe_generator_Generator_on_module, &gen);
   }
   if (gen.print) puts(string_buffer_Buf_data(gen.out));
   qbe_generator_Generator_write(&gen, qbe_dir, qbe_generator_QBE_Filename);
   qbe_generator_Generator_createMakefile(&gen, qbe_dir);
   qbe_generator_Generator_free(&gen);
}

static void qbe_generator_build(const char* output_dir)
{
   const char* make = "make";
   char dir[512];
   sprintf(dir, "%s/%s/", output_dir, qbe_generator_QBE_Dir);
   int32_t retval = process_utils_run_args(dir, make, "", qbe_generator_LogFile);
   if ((retval != 0)) {
      console_error("error during external QBE compilation");
      console_log("see %s%s for details", dir, qbe_generator_LogFile);
   }
}

static void qbe_generator_Generator_addLocalVar(qbe_generator_Generator* gen, ast_VarDecl* vd)
{
   ast_QualType qt = ast_Decl_getType(ast_VarDecl_asDecl(vd));
   const ast_StructType* s = ast_QualType_getStructTypeOrNil(&qt);
   uint32_t width;
   uint32_t align;
   if (s) {
      const ast_StructTypeDecl* std = ast_StructType_getDecl(s);
      width = ast_StructTypeDecl_getSize(std);
      align = ast_StructTypeDecl_getAlignment(std);
   } else {
      width = ast_QualType_getAlignment(&qt);
      align = width;
   }
   uint32_t size = ast_QualType_getSize(&qt, false);
   uint32_t slot = qbe_locals_Locals_add(&gen->locals, vd, width, align, size);
   string_buffer_Buf* out = gen->start;
   switch (align) {
   case 1:
      string_buffer_Buf_print(out, "\t%%.%u =l alloc4 %u", slot, size);
      break;
   case 2:
      string_buffer_Buf_print(out, "\t%%.%u =l alloc4 %u", slot, size);
      break;
   case 4:
      string_buffer_Buf_print(out, "\t%%.%u =l alloc4 %u", slot, size);
      break;
   case 8:
      string_buffer_Buf_print(out, "\t%%.%u =l alloc8 %u", slot, size);
      break;
   default:
      string_buffer_Buf_print(out, "\t%%.%u =l alloc4 %u", slot, size);
      break;
   }
   string_buffer_Buf_print(out, "\t\t# %s\n", ast_VarDecl_getName(vd));
}

static void qbe_generator_Generator_collectLocals(qbe_generator_Generator* gen, const ast_FunctionDecl* fd)
{
   ast_VarDecl** fn_params = ast_FunctionDecl_getParams(fd);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   qbe_locals_Locals_skipSlots(&gen->locals, num_params);
   for (uint32_t i = 0; (i < num_params); i++) {
      qbe_generator_Generator_addLocalVar(gen, fn_params[i]);
   }
   qbe_generator_Generator_collectLocalVars(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))));
}

static void qbe_generator_Generator_collectLocalVars(qbe_generator_Generator* gen, ast_Stmt* s)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_If: {
      const ast_IfStmt* if_stmt = ((ast_IfStmt*)(s));
      qbe_generator_Generator_collectLocalVars(gen, ast_IfStmt_getCond(if_stmt));
      ast_Stmt* then_stmt = ast_IfStmt_getThen(if_stmt);
      if (then_stmt) qbe_generator_Generator_collectLocalVars(gen, then_stmt);
      ast_Stmt* else_stmt = ast_IfStmt_getElse(if_stmt);
      if (else_stmt) qbe_generator_Generator_collectLocalVars(gen, else_stmt);
      break;
   }
   case ast_StmtKind_While:
      break;
   case ast_StmtKind_For:
      break;
   case ast_StmtKind_Switch:
      break;
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      const uint32_t num_stmts = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; (i < num_stmts); i++) {
         qbe_generator_Generator_collectLocalVars(gen, stmts[i]);
      }
      break;
   }
   case ast_StmtKind_Decl: {
      const ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      if (ast_VarDecl_hasLocalQualifier(vd)) {
         string_buffer_Buf* gbl = gen->globals;
         string_buffer_Buf_add(gbl, "data ");
         qbe_generator_addGlobalName(gbl, ((ast_Decl*)(gen->cur_function)));
         string_buffer_Buf_add1(gbl, '.');
         ast_Decl* d = ((ast_Decl*)(vd));
         string_buffer_Buf_add(gbl, ast_Decl_getName(d));
         qbe_generator_Generator_emitVarDeclInit(gen, d, gbl);
      } else {
         qbe_generator_Generator_addLocalVar(gen, vd);
      }
      break;
   }
   default:
      break;
   }
}

static void qbe_generator_Generator_createTemp(qbe_generator_Generator* gen, char* out)
{
   sprintf(out, "%%.%u", qbe_locals_Locals_get(&gen->locals));
}

static uint32_t qbe_generator_Generator_getLabelBlock(qbe_generator_Generator* gen, uint32_t label_idx)
{
   uint32_t blkname_idx = value_maplist_List_get(&gen->labels, label_idx);
   if (!blkname_idx) {
      char blkname[32];
      sprintf(blkname, "@label.%u", qbe_generator_Generator_getNewBlockIndex(gen));
      blkname_idx = string_pool_Pool_addStr(gen->names, blkname, false);
      value_maplist_List_add(&gen->labels, label_idx, blkname_idx);
   }
   return blkname_idx;
}

static void qbe_generator_Generator_createString(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const char* text)
{
   sprintf(result->ref, "$string.%u", gen->string_idx);
   gen->string_idx++;
   string_buffer_Buf_print(gen->globals, "data %s = align 1 { b \"%s\\000\" }\n", result->ref, text);
}

static void qbe_generator_Generator_emitExpr(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   result->ref[0] = 0;
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ctv_analyser_get_value(e);
      sprintf(result->ref, "%s", ast_Value_str(&v));
      return;
   }
   string_buffer_Buf* out = gen->out;
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 56, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_StringLiteral: {
      ast_StringLiteral* s = ((ast_StringLiteral*)(e));
      qbe_generator_Generator_createString(gen, result, ast_StringLiteral_getText(s));
      break;
   }
   case ast_ExprKind_Nil:
      string_buffer_Buf_add1(out, '0');
      break;
   case ast_ExprKind_Identifier:
      qbe_generator_Generator_emitIdentifier(gen, result, e);
      break;
   case ast_ExprKind_Type:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 70, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_Call: {
      ast_CallExpr* ce = ((ast_CallExpr*)(e));
      uint32_t num_args = ast_CallExpr_getNumArgs(ce);
      ast_Expr** args = ast_CallExpr_getArgs(ce);
      qbe_generator_ExprRef func;
      qbe_generator_Generator_emitExpr(gen, &func, ast_CallExpr_getFunc(ce));
      qbe_generator_ExprRef arg_refs[24];
      for (uint32_t a = 0; (a < num_args); a++) {
         const ast_Expr* arg = args[a];
         qbe_generator_Generator_emitExpr(gen, &arg_refs[a], arg);
      }
      ast_QualType qt = ast_Expr_getType(e);
      string_buffer_Buf_add1(out, '\t');
      if (!ast_QualType_isVoid(&qt)) {
         qbe_generator_Generator_createTemp(gen, result->ref);
         string_buffer_Buf_print(out, "%s =w ", result->ref);
      }
      string_buffer_Buf_print(out, "call %s(", func.ref);
      for (uint32_t a = 0; (a < num_args); a++) {
         if ((a != 0)) string_buffer_Buf_add(out, ", ");
         string_buffer_Buf_print(out, "l %s", arg_refs[a].ref);
      }
      string_buffer_Buf_add(out, ")\n");
      break;
   }
   case ast_ExprKind_InitList:
      fallthrough;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 104, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_BinaryOperator:
      qbe_generator_Generator_emitBinaryOperator(gen, result, e);
      break;
   case ast_ExprKind_UnaryOperator:
      qbe_generator_Generator_emitUnaryOperator(gen, result, e);
      break;
   case ast_ExprKind_ConditionalOperator:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 113, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_Builtin:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 117, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_ArraySubscript: {
      const ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      ast_Expr* base = ast_ArraySubscriptExpr_getBase(a);
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      ast_QualType qt = ast_Expr_getType(base);
      uint32_t base_size = ast_QualType_getSize(&qt, true);
      if (ast_Expr_isCtv(index)) {
         ast_Value v = ctv_analyser_get_value(index);
         uint32_t offset = (ast_Value_as_u32(&v) * base_size);
         qbe_generator_ExprRef base_ref;
         qbe_generator_Generator_emitExpr(gen, &base_ref, base);
         qbe_generator_Generator_createTemp(gen, result->ref);
         string_buffer_Buf_print(out, "\t%s =l add %s, %u\n", result->ref, base_ref.ref, offset);
      } else {
         qbe_generator_ExprRef idx_ref;
         qbe_generator_Generator_emitExpr(gen, &idx_ref, index);
         qbe_generator_ExprRef tmp;
         qbe_generator_Generator_createTemp(gen, tmp.ref);
         string_buffer_Buf_print(out, "\t%s =l mul %u, %s\n", tmp.ref, base_size, idx_ref.ref);
         qbe_generator_ExprRef base_ref;
         qbe_generator_Generator_emitExpr(gen, &base_ref, base);
         qbe_generator_Generator_createTemp(gen, result->ref);
         string_buffer_Buf_print(out, "\t%s =l add %s, %s\n", result->ref, base_ref.ref, tmp.ref);
      }
      break;
   }
   case ast_ExprKind_Member:
      qbe_generator_Generator_emitMemberExpr(gen, result, e);
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      qbe_generator_Generator_emitExpr(gen, result, ast_ParenExpr_getInner(p));
      break;
   }
   case ast_ExprKind_BitOffset:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 162, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_ExplicitCast:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 166, "qbe_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
      switch (ast_ImplicitCastExpr_getKind(ic)) {
      case ast_ImplicitCastKind_ArrayToPointerDecay:
         qbe_generator_Generator_emitExpr(gen, result, ast_ImplicitCastExpr_getInner(ic));
         break;
      case ast_ImplicitCastKind_LValueToRValue: {
         qbe_generator_ExprRef res;
         qbe_generator_Generator_emitExpr(gen, &res, ast_ImplicitCastExpr_getInner(ic));
         qbe_generator_Generator_createTemp(gen, result->ref);
         string_buffer_Buf_print(out, "\t%s =w loadw %s\n", result->ref, res.ref);
         break;
      }
      case ast_ImplicitCastKind_PointerToBoolean:
         (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 185, "qbe_generator.Generator.emitExpr", "0");
         break;
      case ast_ImplicitCastKind_PointerToInteger:
         (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 188, "qbe_generator.Generator.emitExpr", "0");
         break;
      case ast_ImplicitCastKind_IntegralCast:
         printf("WARNING: IntegralCast (skipping for now)\n");
         qbe_generator_Generator_emitExpr(gen, result, ast_ImplicitCastExpr_getInner(ic));
         break;
      case ast_ImplicitCastKind_BitCast:
         (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 195, "qbe_generator.Generator.emitExpr", "0");
         break;
      }
      break;
   }
   case ast_ExprKind_Range:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 200, "qbe_generator.Generator.emitExpr", "0");
      break;
   }
}

static void qbe_generator_Generator_emitMemberExpr(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_MemberExpr* m = ((ast_MemberExpr*)(e));
   ast_IdentifierKind kind = ast_MemberExpr_getKind(m);
   if (((kind == ast_IdentifierKind_Var) || (kind == ast_IdentifierKind_Function))) {
      (!ast_MemberExpr_hasExpr(m)) || c2_assert("generator/qbe/qbe_generator_expr.c2", 211, "qbe_generator.Generator.emitMemberExpr", "!m.hasExpr()");
      ast_Decl* d = ast_MemberExpr_getFullDecl(m);
      qbe_generator_getGlobalName(result->ref, d);
      return;
   }
   ((kind == ast_IdentifierKind_StructMember)) || c2_assert("generator/qbe/qbe_generator_expr.c2", 217, "qbe_generator.Generator.emitMemberExpr", "kind == IdentifierKind.StructMember");
   qbe_generator_ExprRef base_ref;
   ast_QualType base_type;
   if (ast_MemberExpr_hasExpr(m)) {
      const ast_Expr* base = ast_MemberExpr_getExprBase(m);
      qbe_generator_Generator_emitExpr(gen, &base_ref, base);
      base_type = ast_Expr_getType(base);
   } else {
      const ast_Decl* base = ast_MemberExpr_getDecl(m, 0);
      (ast_Decl_isVarDecl(base)) || c2_assert("generator/qbe/qbe_generator_expr.c2", 228, "qbe_generator.Generator.emitMemberExpr", "base.isVarDecl()");
      qbe_generator_Generator_emitVarDecl(gen, &base_ref, base);
      base_type = ast_Decl_getType(base);
   }
   const ast_StructType* st = ast_QualType_getStructType(&base_type);
   const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   ast_Decl* d = ast_MemberExpr_getFullDecl(m);
   uint32_t offset = 0;
   qbe_generator_Generator_createTemp(gen, result->ref);
   string_buffer_Buf_print(out, "\t%s =l add %s, %u\n", result->ref, base_ref.ref, offset);
}

static void qbe_generator_Generator_emitIdentifier(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
   const ast_Decl* d = ast_IdentifierExpr_getDecl(i);
   switch (ast_IdentifierExpr_getKind(i)) {
   case ast_IdentifierKind_Unresolved:
      fallthrough;
   case ast_IdentifierKind_Module:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 253, "qbe_generator.Generator.emitIdentifier", "0");
      break;
   case ast_IdentifierKind_Function:
      qbe_generator_getGlobalName(result->ref, d);
      break;
   case ast_IdentifierKind_Type:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 259, "qbe_generator.Generator.emitIdentifier", "0");
      break;
   case ast_IdentifierKind_Var:
      qbe_generator_Generator_emitVarDecl(gen, result, d);
      break;
   case ast_IdentifierKind_EnumConstant:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 265, "qbe_generator.Generator.emitIdentifier", "0");
      break;
   case ast_IdentifierKind_StructMember:
      fallthrough;
   case ast_IdentifierKind_Label:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 269, "qbe_generator.Generator.emitIdentifier", "0");
      break;
   }
}

static void qbe_generator_Generator_emitVarDecl(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Decl* d)
{
   const ast_VarDecl* vd = ((ast_VarDecl*)(d));
   if (ast_VarDecl_isGlobal(vd)) {
      qbe_generator_getGlobalName(result->ref, d);
   } else if (ast_VarDecl_hasLocalQualifier(vd)) {
      string_buffer_Buf* tmp = string_buffer_create(128, false, 0);
      qbe_generator_addGlobalName(tmp, ((ast_Decl*)(gen->cur_function)));
      string_buffer_Buf_add1(tmp, '.');
      string_buffer_Buf_add(tmp, ast_Decl_getName(d));
      strcpy(result->ref, string_buffer_Buf_data(tmp));
      string_buffer_Buf_free(tmp);
   } else if ((ast_VarDecl_isLocal(vd) || ast_VarDecl_isParameter(vd))) {
      qbe_Var* var = qbe_locals_Locals_find(&gen->locals, vd);
      (var) || c2_assert("generator/qbe/qbe_generator_expr.c2", 288, "qbe_generator.Generator.emitVarDecl", "var");
      sprintf(result->ref, "%%.%u", var->slot);
   } else {
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 291, "qbe_generator.Generator.emitVarDecl", "0");
   }


}

static void qbe_generator_Generator_emitUnaryOperator(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_UnaryOperator* uo = ((ast_UnaryOperator*)(e));
   switch (ast_UnaryOperator_getOpcode(uo)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec: {
      qbe_generator_ExprRef inner;
      qbe_generator_Generator_emitExpr(gen, &inner, ast_UnaryOperator_getInner(uo));
      qbe_generator_Generator_createTemp(gen, result->ref);
      string_buffer_Buf_print(out, "\t%s =w loadw %s\n", result->ref, inner.ref);
      qbe_generator_ExprRef tmp2;
      qbe_generator_Generator_createTemp(gen, tmp2.ref);
      const char* instr = (ast_UnaryOperator_getOpcode(uo) == ast_UnaryOpcode_PostInc) ? "add" : "sub";
      string_buffer_Buf_print(out, "\t%s =w %s %s, 1\n", tmp2.ref, instr, result->ref);
      string_buffer_Buf_print(out, "\tstorew %s, %s\n", tmp2.ref, inner.ref);
      break;
   }
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec: {
      qbe_generator_ExprRef inner;
      qbe_generator_Generator_emitExpr(gen, &inner, ast_UnaryOperator_getInner(uo));
      qbe_generator_ExprRef tmp1;
      qbe_generator_Generator_createTemp(gen, tmp1.ref);
      string_buffer_Buf_print(out, "\t%s =w loadw %s\n", tmp1.ref, inner.ref);
      qbe_generator_Generator_createTemp(gen, result->ref);
      const char* instr = (ast_UnaryOperator_getOpcode(uo) == ast_UnaryOpcode_PreInc) ? "add" : "sub";
      string_buffer_Buf_print(out, "\t%s =w %s %s, 1\n", result->ref, instr, tmp1.ref);
      string_buffer_Buf_print(out, "\tstorew %s, %s\n", result->ref, inner.ref);
      break;
   }
   case ast_UnaryOpcode_AddrOf:
      fallthrough;
   case ast_UnaryOpcode_Deref:
      qbe_generator_Generator_emitExpr(gen, result, ast_UnaryOperator_getInner(uo));
      break;
   case ast_UnaryOpcode_Plus:
      fallthrough;
   case ast_UnaryOpcode_Minus: {
      (ast_Expr_isCtc(e)) || c2_assert("generator/qbe/qbe_generator_expr.c2", 341, "qbe_generator.Generator.emitUnaryOperator", "e.isCtc()");
      ast_Value v = ctv_analyser_get_value(e);
      string_buffer_Buf_print(out, "%u", ast_Value_as_u32(&v));
      break;
   }
   case ast_UnaryOpcode_Not: {
      qbe_generator_ExprRef inner;
      qbe_generator_Generator_emitExpr(gen, &inner, ast_UnaryOperator_getInner(uo));
      qbe_generator_Generator_createTemp(gen, result->ref);
      string_buffer_Buf_print(out, "\t%s =w xor %s, %lu\n", result->ref, inner.ref, c2_max_u64);
      break;
   }
   case ast_UnaryOpcode_LNot: {
      qbe_generator_ExprRef inner;
      qbe_generator_Generator_emitExpr(gen, &inner, ast_UnaryOperator_getInner(uo));
      qbe_generator_Generator_createTemp(gen, result->ref);
      string_buffer_Buf_print(out, "\t%s =w ceqw %s, 0\n", result->ref, inner.ref);
      break;
   }
   }
}

static void qbe_generator_Generator_emitBinaryOperator(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_Multiply:
      fallthrough;
   case ast_BinaryOpcode_Divide:
      fallthrough;
   case ast_BinaryOpcode_Remainder:
      fallthrough;
   case ast_BinaryOpcode_Add:
      fallthrough;
   case ast_BinaryOpcode_Subtract:
      break;
   case ast_BinaryOpcode_ShiftLeft:
      fallthrough;
   case ast_BinaryOpcode_ShiftRight:
      qbe_generator_Generator_emitShift(gen, result, e);
      return;
   case ast_BinaryOpcode_LessThan:
      fallthrough;
   case ast_BinaryOpcode_GreaterThan:
      fallthrough;
   case ast_BinaryOpcode_LessEqual:
      fallthrough;
   case ast_BinaryOpcode_GreaterEqual:
      fallthrough;
   case ast_BinaryOpcode_Equal:
      fallthrough;
   case ast_BinaryOpcode_NotEqual:
      break;
   case ast_BinaryOpcode_And:
      fallthrough;
   case ast_BinaryOpcode_Xor:
      fallthrough;
   case ast_BinaryOpcode_Or:
      break;
   case ast_BinaryOpcode_LAnd:
      fallthrough;
   case ast_BinaryOpcode_LOr:
      qbe_generator_Generator_emitLogicalOp(gen, result, e, (ast_BinaryOperator_getOpcode(b) == ast_BinaryOpcode_LAnd));
      return;
   case ast_BinaryOpcode_Assign: {
      qbe_generator_ExprRef src;
      qbe_generator_Generator_emitExpr(gen, &src, ast_BinaryOperator_getRHS(b));
      qbe_generator_ExprRef dest;
      qbe_generator_Generator_emitExpr(gen, &dest, ast_BinaryOperator_getLHS(b));
      string_buffer_Buf_print(out, "\tstorew %s, %s\n", src.ref, dest.ref);
      return;
   }
   case ast_BinaryOpcode_MulAssign:
      fallthrough;
   case ast_BinaryOpcode_DivAssign:
      fallthrough;
   case ast_BinaryOpcode_RemAssign:
      fallthrough;
   case ast_BinaryOpcode_AddAssign:
      fallthrough;
   case ast_BinaryOpcode_SubAssign:
      fallthrough;
   case ast_BinaryOpcode_ShlAssign:
      fallthrough;
   case ast_BinaryOpcode_ShrAssign:
      fallthrough;
   case ast_BinaryOpcode_AndAssign:
      fallthrough;
   case ast_BinaryOpcode_XorAssign:
      fallthrough;
   case ast_BinaryOpcode_OrAssign:
      qbe_generator_Generator_emitOpAssign(gen, result, e);
      return;
   }
   const char* instr;
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_Multiply:
      instr = "mul";
      break;
   case ast_BinaryOpcode_Divide:
      instr = "div";
      break;
   case ast_BinaryOpcode_Remainder:
      instr = "rem";
      break;
   case ast_BinaryOpcode_Add:
      instr = "add";
      break;
   case ast_BinaryOpcode_Subtract:
      instr = "sub";
      break;
   case ast_BinaryOpcode_LessThan:
      instr = "csltw";
      break;
   case ast_BinaryOpcode_GreaterThan:
      instr = "csgtw";
      break;
   case ast_BinaryOpcode_LessEqual:
      instr = "cslew";
      break;
   case ast_BinaryOpcode_GreaterEqual:
      instr = "csgew";
      break;
   case ast_BinaryOpcode_Equal:
      instr = "ceqw";
      break;
   case ast_BinaryOpcode_NotEqual:
      instr = "cnew";
      break;
   case ast_BinaryOpcode_And:
      instr = "and";
      break;
   case ast_BinaryOpcode_Xor:
      instr = "xor";
      break;
   case ast_BinaryOpcode_Or:
      instr = "or";
      break;
   default:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 465, "qbe_generator.Generator.emitBinaryOperator", "0");
      break;
   }
   qbe_generator_ExprRef left;
   qbe_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   qbe_generator_ExprRef right;
   qbe_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   qbe_generator_Generator_createTemp(gen, result->ref);
   string_buffer_Buf_print(out, "\t%s =w %s %s, %s\n", result->ref, instr, left.ref, right.ref);
}

static void qbe_generator_Generator_emitOpAssign(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   const char* instr;
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_MulAssign:
      instr = "mul";
      break;
   case ast_BinaryOpcode_DivAssign:
      instr = "div";
      break;
   case ast_BinaryOpcode_RemAssign:
      instr = "rem";
      break;
   case ast_BinaryOpcode_AddAssign:
      instr = "and";
      break;
   case ast_BinaryOpcode_SubAssign:
      instr = "sub";
      break;
   case ast_BinaryOpcode_ShlAssign:
      instr = "shl";
      break;
   case ast_BinaryOpcode_ShrAssign:
      instr = "shr";
      break;
   case ast_BinaryOpcode_AndAssign:
      instr = "and";
      break;
   case ast_BinaryOpcode_XorAssign:
      instr = "xor";
      break;
   case ast_BinaryOpcode_OrAssign:
      instr = "or";
      break;
   default:
      (0) || c2_assert("generator/qbe/qbe_generator_expr.c2", 524, "qbe_generator.Generator.emitOpAssign", "0");
      return;
   }
   const ast_Expr* lhs = ast_BinaryOperator_getLHS(b);
   qbe_generator_ExprRef left;
   qbe_generator_Generator_emitExpr(gen, &left, lhs);
   qbe_generator_ExprRef right;
   qbe_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   qbe_generator_ExprRef tmp1;
   qbe_generator_Generator_createTemp(gen, tmp1.ref);
   string_buffer_Buf_print(out, "\t%s =w loadw %s\n", tmp1.ref, left.ref);
   qbe_generator_Generator_createTemp(gen, result->ref);
   string_buffer_Buf_print(out, "\t%s =w %s %s, %s\n", result->ref, instr, tmp1.ref, right.ref);
   string_buffer_Buf_print(out, "\tstorew %s, %s\n", result->ref, left.ref);
}

static void qbe_generator_Generator_emitLogicalOp(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e, _Bool is_and)
{
   string_buffer_Buf* out = gen->out;
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
}

static void qbe_generator_Generator_emitShift(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   const char* instr;
   if ((ast_BinaryOperator_getOpcode(b) == ast_BinaryOpcode_ShiftLeft)) {
      instr = "shl";
   } else {
      ast_QualType qt = ast_Expr_getType(e);
      if (ast_QualType_isUnsigned(&qt)) instr = "shr";
      else instr = "sar";
   }
   qbe_generator_ExprRef left;
   qbe_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   qbe_generator_ExprRef right;
   qbe_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   qbe_generator_Generator_createTemp(gen, result->ref);
   string_buffer_Buf_print(out, "\t%s =w %s %s, %s\n", result->ref, instr, left.ref, right.ref);
}

static _Bool qbe_generator_Generator_emitStmt(qbe_generator_Generator* gen, const ast_Stmt* s)
{
   string_buffer_Buf* out = gen->out;
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      const ast_ReturnStmt* r = ((ast_ReturnStmt*)(s));
      const ast_Expr* retval = ast_ReturnStmt_getValue(r);
      if (retval) {
         qbe_generator_ExprRef res;
         qbe_generator_Generator_emitExpr(gen, &res, retval);
         string_buffer_Buf_print(out, "\tret %s", res.ref);
      } else {
         string_buffer_Buf_add(out, "\tret");
      }
      string_buffer_Buf_newline(out);
      gen->block_terminated = true;
      return false;
   }
   case ast_StmtKind_Expr: {
      qbe_generator_ExprRef dontcare;
      qbe_generator_Generator_emitExpr(gen, &dontcare, ((ast_Expr*)(s)));
      return true;
   }
   case ast_StmtKind_If:
      qbe_generator_Generator_emitIfStmt(gen, s);
      return true;
   case ast_StmtKind_While:
      qbe_generator_Generator_emitWhileStmt(gen, s);
      return true;
   case ast_StmtKind_For:
      qbe_generator_Generator_emitForStmt(gen, s);
      return true;
   case ast_StmtKind_Switch:
      break;
   case ast_StmtKind_Break:
      (gen->num_scopes) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 58, "qbe_generator.Generator.emitStmt", "gen.num_scopes");
      string_buffer_Buf_print(out, "\tjmp %s\n", gen->scopes[(gen->num_scopes - 1)].break_block);
      gen->block_terminated = true;
      return false;
   case ast_StmtKind_Continue:
      (gen->num_scopes) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 63, "qbe_generator.Generator.emitStmt", "gen.num_scopes");
      string_buffer_Buf_print(out, "\tjmp %s\n", gen->scopes[(gen->num_scopes - 1)].continue_block);
      gen->block_terminated = true;
      return false;
   case ast_StmtKind_Fallthrough:
      break;
   case ast_StmtKind_Label: {
      const ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      uint32_t blkname_idx = qbe_generator_Generator_getLabelBlock(gen, ast_LabelStmt_getNameIdx(ls));
      const char* name = string_pool_Pool_idx2str(gen->names, blkname_idx);
      qbe_generator_Generator_startBlock(gen, name, name);
      const ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      if (stmt) {
         return qbe_generator_Generator_emitStmt(gen, stmt);
      }
      return true;
   }
   case ast_StmtKind_Goto: {
      const ast_GotoStmt* g = ((ast_GotoStmt*)(s));
      uint32_t blkname_idx = qbe_generator_Generator_getLabelBlock(gen, ast_GotoStmt_getNameIdx(g));
      string_buffer_Buf_print(out, "\tjmp %s\n", string_pool_Pool_idx2str(gen->names, blkname_idx));
      gen->block_terminated = true;
      return false;
   }
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      const uint32_t num_stmts = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; (i < num_stmts); i++) {
         _Bool more = qbe_generator_Generator_emitStmt(gen, stmts[i]);
         if (!more) break;

      }
      return true;
   }
   case ast_StmtKind_Decl: {
      const ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      const ast_Expr* ie = ast_VarDecl_getInit(vd);
      if (ie) {
         qbe_Var* var = qbe_locals_Locals_find(&gen->locals, vd);
         (var) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 100, "qbe_generator.Generator.emitStmt", "var");
         qbe_generator_ExprRef res;
         qbe_generator_Generator_emitExpr(gen, &res, ie);
         ast_QualType qt = ast_Decl_getType(ast_VarDecl_asDecl(vd));
         string_buffer_Buf_print(out, "\tstore%c %s, %%.%u\n", qbe_generator_align2store(ast_QualType_getAlignment(&qt)), res.ref, var->slot);
      }
      return true;
   }
   case ast_StmtKind_Asm:
      break;
   case ast_StmtKind_Assert:
      if (gen->enable_asserts) qbe_generator_Generator_emitAssertStmt(gen, s);
      return true;
   }
   ast_Stmt_dump(s);
   (0) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 114, "qbe_generator.Generator.emitStmt", "0");
   return true;
}

static void qbe_generator_Generator_emitCondition(qbe_generator_Generator* gen, qbe_generator_ExprRef* result, const ast_Stmt* s)
{
   (ast_Stmt_isExpr(s)) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 119, "qbe_generator.Generator.emitCondition", "s.isExpr()");
   const ast_Expr* e = ((ast_Expr*)(s));
   qbe_generator_Generator_emitExpr(gen, result, e);
}

static void qbe_generator_Generator_emitIfStmt(qbe_generator_Generator* gen, const ast_Stmt* s)
{
   string_buffer_Buf* out = gen->out;
   const ast_IfStmt* if_stmt = ((ast_IfStmt*)(s));
   const ast_Stmt* cond = ast_IfStmt_getCond(if_stmt);
   const ast_Stmt* then_stmt = ast_IfStmt_getThen(if_stmt);
   const ast_Stmt* else_stmt = ast_IfStmt_getElse(if_stmt);
   (ast_Stmt_isExpr(cond)) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 134, "qbe_generator.Generator.emitIfStmt", "cond.isExpr()");
   ast_Expr* e = ((ast_Expr*)(cond));
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ctv_analyser_get_value(e);
      if (ast_Value_isZero(&v)) {
         if (else_stmt) qbe_generator_Generator_emitStmt(gen, else_stmt);
      } else {
         qbe_generator_Generator_emitStmt(gen, then_stmt);
      }
      return;
   }
   qbe_generator_ExprRef res;
   qbe_generator_Generator_emitCondition(gen, &res, cond);
   char then_blk[32];
   char else_blk[32];
   char join_blk[32];
   sprintf(then_blk, "@if_true.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(join_blk, "@if_join.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   if (else_stmt) {
      sprintf(else_blk, "@if_false.%u", qbe_generator_Generator_getNewBlockIndex(gen));
      string_buffer_Buf_print(out, "\tjnz %s, %s, %s\n", res.ref, then_blk, else_blk);
   } else {
      string_buffer_Buf_print(out, "\tjnz %s, %s, %s\n", res.ref, then_blk, join_blk);
   }
   gen->block_terminated = true;
   qbe_generator_Generator_startBlock(gen, then_blk, then_blk);
   qbe_generator_Generator_emitStmt(gen, then_stmt);
   if (!gen->block_terminated) {
      string_buffer_Buf_print(out, "\tjmp %s\n", join_blk);
      gen->block_terminated = true;
   }
   if (else_stmt) {
      qbe_generator_Generator_startBlock(gen, else_blk, else_blk);
      qbe_generator_Generator_emitStmt(gen, else_stmt);
   }
   qbe_generator_Generator_startBlock(gen, join_blk, join_blk);
}

static void qbe_generator_Generator_emitWhileStmt(qbe_generator_Generator* gen, const ast_Stmt* s)
{
   string_buffer_Buf* out = gen->out;
   const ast_WhileStmt* w = ((ast_WhileStmt*)(s));
   char cond_blk[32];
   char body_blk[32];
   char join_blk[32];
   sprintf(cond_blk, "@while_cond.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(body_blk, "@while_body.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(join_blk, "@while_join.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   qbe_generator_Generator_startBlock(gen, cond_blk, cond_blk);
   qbe_generator_ExprRef res;
   qbe_generator_Generator_emitCondition(gen, &res, ast_WhileStmt_getCond(w));
   if (!gen->block_terminated) {
      string_buffer_Buf_print(out, "\tjnz %s, %s, %s\n", res.ref, body_blk, join_blk);
      gen->block_terminated = true;
   }
   qbe_generator_Generator_startBlock(gen, body_blk, body_blk);
   qbe_generator_Generator_pushScope(gen, join_blk, cond_blk);
   qbe_generator_Generator_emitStmt(gen, ast_WhileStmt_getBody(w));
   qbe_generator_Generator_popScope(gen);
   if (!gen->block_terminated) {
      string_buffer_Buf_print(out, "\tjmp %s\n", cond_blk);
      gen->block_terminated = true;
   }
   qbe_generator_Generator_startBlock(gen, join_blk, join_blk);
}

static void qbe_generator_Generator_emitForStmt(qbe_generator_Generator* gen, const ast_Stmt* s)
{
   string_buffer_Buf* out = gen->out;
   const ast_ForStmt* w = ((ast_ForStmt*)(s));
   qbe_generator_Generator_emitStmt(gen, ast_ForStmt_getInit(w));
   char cond_blk[32];
   char body_blk[32];
   char cont_blk[32];
   char join_blk[32];
   sprintf(cond_blk, "@for_cond.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(body_blk, "@for_body.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(cont_blk, "@for_cont.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(join_blk, "@for_join.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   qbe_generator_Generator_startBlock(gen, cond_blk, cond_blk);
   qbe_generator_ExprRef res;
   qbe_generator_Generator_emitCondition(gen, &res, ((ast_Stmt*)(ast_ForStmt_getCond(w))));
   (!gen->block_terminated) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 242, "qbe_generator.Generator.emitForStmt", "!gen.block_terminated");
   string_buffer_Buf_print(out, "\tjnz %s, %s, %s\n", res.ref, body_blk, join_blk);
   gen->block_terminated = true;
   qbe_generator_Generator_startBlock(gen, body_blk, body_blk);
   qbe_generator_Generator_pushScope(gen, join_blk, cont_blk);
   qbe_generator_Generator_emitStmt(gen, ast_ForStmt_getBody(w));
   qbe_generator_Generator_popScope(gen);
   qbe_generator_Generator_startBlock(gen, cont_blk, cont_blk);
   qbe_generator_ExprRef dontcare;
   qbe_generator_Generator_emitExpr(gen, &dontcare, ast_ForStmt_getCont(w));
   (!gen->block_terminated) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 256, "qbe_generator.Generator.emitForStmt", "!gen.block_terminated");
   string_buffer_Buf_print(out, "\tjmp %s\n", cond_blk);
   gen->block_terminated = true;
   qbe_generator_Generator_startBlock(gen, join_blk, join_blk);
}

static void qbe_generator_Generator_emitAssertStmt(qbe_generator_Generator* gen, const ast_Stmt* s)
{
   string_buffer_Buf* out = gen->out;
   const ast_AssertStmt* a = ((ast_AssertStmt*)(s));
   char body_blk[32];
   char join_blk[32];
   sprintf(body_blk, "@assert_body.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   sprintf(join_blk, "@assert_join.%u", qbe_generator_Generator_getNewBlockIndex(gen));
   qbe_generator_ExprRef check;
   qbe_generator_Generator_emitCondition(gen, &check, ((ast_Stmt*)(ast_AssertStmt_getInner(a))));
   (!gen->block_terminated) || c2_assert("generator/qbe/qbe_generator_stmt.c2", 278, "qbe_generator.Generator.emitAssertStmt", "!gen.block_terminated");
   string_buffer_Buf_print(out, "\tjnz %s, %s, %s\n", check.ref, join_blk, body_blk);
   qbe_generator_Generator_startBlock(gen, body_blk, body_blk);
   source_mgr_Location loc = source_mgr_SourceMgr_locate(gen->sm, ast_Stmt_getLoc(s));
   const char* funcname = ast_Decl_getFullName(ast_FunctionDecl_asDecl(gen->cur_function));
   char location[512];
   sprintf(location, "%s:%u: %s", loc.filename, loc.line, funcname);
   qbe_generator_ExprRef loc_str;
   qbe_generator_Generator_createString(gen, &loc_str, location);
   ast_Expr* inner = ast_AssertStmt_getInner(a);
   string_buffer_Buf_clear(gen->start);
   ast_Expr_printLiteral(inner, gen->start);
   qbe_generator_ExprRef cond_str;
   qbe_generator_Generator_createString(gen, &cond_str, string_buffer_Buf_data(gen->start));
   static const char name[16] = "$gbl_assert_str";
   static const char self[10] = "$self_str";
   if (!gen->assert_generated) {
      string_buffer_Buf_print(gen->globals, "data %s = align 1 { b \"%s\\000\" }\n", self, gen->target);
      string_buffer_Buf_print(gen->globals, "data %s = align 1 { b \"%%s: %%s: Assertion '%%s' failed\n\\000\" }\n", name);
      gen->assert_generated = true;
   }
   string_buffer_Buf_print(out, "\tcall $dprintf(l 2, l %s, l %s, l %s, l %s)\n", name, self, loc_str.ref, cond_str.ref);
   string_buffer_Buf_print(out, "\tcall $abort()\n");
   qbe_generator_Generator_startBlock(gen, join_blk, join_blk);
}


// --- module ir_gen_locals ---
typedef struct ir_gen_locals_StackVar_ ir_gen_locals_StackVar;
typedef struct ir_gen_locals_Locals_ ir_gen_locals_Locals;

struct ir_gen_locals_StackVar_ {
   ir_Ref ref;
   ir_Type ir_type;
   uint32_t size;
   const ast_VarDecl* vd;
};

struct ir_gen_locals_Locals_ {
   ir_gen_locals_StackVar* vars;
   uint32_t count;
   uint32_t capacity;
   uint32_t index;
};

static void ir_gen_locals_Locals_init(ir_gen_locals_Locals* l);
static void ir_gen_locals_Locals_free(ir_gen_locals_Locals* l);
static void ir_gen_locals_Locals_clear(ir_gen_locals_Locals* l);
static void ir_gen_locals_Locals_resize(ir_gen_locals_Locals* l, uint32_t capacity);
static void ir_gen_locals_Locals_skipSlots(ir_gen_locals_Locals* l, uint32_t amount);
static void ir_gen_locals_Locals_add(ir_gen_locals_Locals* l, ast_VarDecl* vd, uint32_t width, uint32_t align, uint32_t size, ir_Ref slot, ir_Type ir_type);
static ir_gen_locals_StackVar* ir_gen_locals_Locals_find(const ir_gen_locals_Locals* l, const ast_VarDecl* vd);
static void ir_gen_locals_Locals_dump(const ir_gen_locals_Locals* l);

static void ir_gen_locals_Locals_init(ir_gen_locals_Locals* l)
{
   ir_gen_locals_Locals_clear(l);
   ir_gen_locals_Locals_resize(l, 128);
}

static void ir_gen_locals_Locals_free(ir_gen_locals_Locals* l)
{
   free(l->vars);
}

static void ir_gen_locals_Locals_clear(ir_gen_locals_Locals* l)
{
   l->count = 0;
   l->index = 1;
}

static void ir_gen_locals_Locals_resize(ir_gen_locals_Locals* l, uint32_t capacity)
{
   l->capacity = capacity;
   ir_gen_locals_StackVar* vars2 = malloc((capacity * 24));
   if (l->count) {
      memcpy(vars2, l->vars, (l->count * 24));
      free(l->vars);
   }
   l->vars = vars2;
}

static void ir_gen_locals_Locals_skipSlots(ir_gen_locals_Locals* l, uint32_t amount)
{
   l->index += amount;
}

static void ir_gen_locals_Locals_add(ir_gen_locals_Locals* l, ast_VarDecl* vd, uint32_t width, uint32_t align, uint32_t size, ir_Ref slot, ir_Type ir_type)
{
   if ((l->count == l->capacity)) ir_gen_locals_Locals_resize(l, (l->capacity * 2));
   ir_gen_locals_StackVar* var = &l->vars[l->count];
   var->vd = vd;
   var->ref = slot;
   var->ir_type = ir_type;
   var->size = size;
   ast_Decl* d = ((ast_Decl*)(vd));
   ast_Decl_setGenIdx(d, l->count);
   l->count++;
}

static ir_gen_locals_StackVar* ir_gen_locals_Locals_find(const ir_gen_locals_Locals* l, const ast_VarDecl* vd)
{
   const ast_Decl* d = ((ast_Decl*)(vd));
   if (!ast_Decl_hasGenIdx(d)) {
      ast_Decl_dump(d);
   }
   (ast_Decl_hasGenIdx(d)) || c2_assert("generator/ir/ir_generator_locals.c2", 93, "ir_gen_locals.Locals.find", "d.hasGenIdx()");
   uint32_t idx = ast_Decl_getGenIdx(d);
   return &l->vars[idx];
}

static void ir_gen_locals_Locals_dump(const ir_gen_locals_Locals* l)
{
   printf("Locals %u/%u last %u\n", l->count, l->capacity, l->index);
   for (uint32_t i = 0; (i < l->count); i++) {
      const ir_gen_locals_StackVar* v = &l->vars[i];
      printf("  [%2u] slot %u  %s  %s\n", i, v->ref.value, ir_Type_str(v->ir_type), ast_VarDecl_getName(v->vd));
   }
}


// --- module ref_list_pool ---
typedef struct ref_list_pool_Elem_ ref_list_pool_Elem;
typedef struct ref_list_pool_Pool_ ref_list_pool_Pool;

struct ref_list_pool_Elem_ {
   ir_RefList ref;
   linked_list_Element list;
};

struct ref_list_pool_Pool_ {
   linked_list_Element list;
};

static ref_list_pool_Elem* ref_list_pool_Elem_create(void);
static void ref_list_pool_Elem_free(ref_list_pool_Elem* e);
static void ref_list_pool_Pool_init(ref_list_pool_Pool* p, uint32_t initial);
static void ref_list_pool_Pool_free(ref_list_pool_Pool* p);
static ir_RefList* ref_list_pool_Pool_get(ref_list_pool_Pool* p);
static void ref_list_pool_Pool_put(ref_list_pool_Pool* p, ir_RefList* l);

static ref_list_pool_Elem* ref_list_pool_Elem_create(void)
{
   ref_list_pool_Elem* e = malloc(32);
   ir_RefList_init(&e->ref, 4);
   linked_list_Element_init(&e->list);
   return e;
}

static void ref_list_pool_Elem_free(ref_list_pool_Elem* e)
{
   ir_RefList_free(&e->ref);
   free(e);
}

static void ref_list_pool_Pool_init(ref_list_pool_Pool* p, uint32_t initial)
{
   linked_list_Element_init(&p->list);
   for (uint32_t i = 0; (i < initial); i++) {
      ref_list_pool_Elem* e = ref_list_pool_Elem_create();
      linked_list_Element_addTail(&p->list, &e->list);
   }
}

static void ref_list_pool_Pool_free(ref_list_pool_Pool* p)
{
   linked_list_Element* cur = p->list.next;
   while ((cur != &p->list)) {
      ref_list_pool_Elem* e = to_container(ref_list_pool_Elem, list, cur);
      cur = cur->next;
      ref_list_pool_Elem_free(e);
   }
}

static ir_RefList* ref_list_pool_Pool_get(ref_list_pool_Pool* p)
{
   ref_list_pool_Elem* e;
   if (linked_list_Element_isEmpty(&p->list)) {
      e = ref_list_pool_Elem_create();
   } else {
      linked_list_Element* head = linked_list_Element_popFront(&p->list);
      e = to_container(ref_list_pool_Elem, list, head);
      ir_RefList_clear(&e->ref);
   }
   return &e->ref;
}

static void ref_list_pool_Pool_put(ref_list_pool_Pool* p, ir_RefList* l)
{
   ref_list_pool_Elem* e = to_container(ref_list_pool_Elem, ref, l);
   linked_list_Element_addFront(&p->list, &e->list);
}


// --- module c2_parser ---
typedef struct c2_parser_Parser_ c2_parser_Parser;

struct c2_parser_Parser_ {
   c2_tokenizer_Tokenizer tokenizer;
   token_Token tok;
   src_loc_SrcLoc prev_loc;
   int32_t file_id;
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   string_pool_Pool* pool;
   ast_builder_Builder* builder;
   const string_list_List* features;
   const keywords_Info* kwinfo;
   _Bool is_interface;
   __jmp_buf_tag jmpbuf;
   char multi_string[65536];
};

static const ast_BuiltinKind c2_parser_Tok2builtin[19] = {
   ast_BuiltinKind_Bool,
   ast_BuiltinKind_Char,
   ast_BuiltinKind_Int8,
   ast_BuiltinKind_Int16,
   ast_BuiltinKind_Int32,
   ast_BuiltinKind_Int64,
   ast_BuiltinKind_UInt8,
   ast_BuiltinKind_UInt16,
   ast_BuiltinKind_UInt32,
   ast_BuiltinKind_UInt64,
   ast_BuiltinKind_UInt8,
   ast_BuiltinKind_UInt16,
   ast_BuiltinKind_UInt32,
   ast_BuiltinKind_UInt64,
   ast_BuiltinKind_ISize,
   ast_BuiltinKind_USize,
   ast_BuiltinKind_Float32,
   ast_BuiltinKind_Float64,
   ast_BuiltinKind_Void
};

static c2_parser_Parser* c2_parser_create(source_mgr_SourceMgr* sm, diagnostics_Diags* diags, string_pool_Pool* pool, ast_builder_Builder* builder, const keywords_Info* kwinfo, const string_list_List* features);
static void c2_parser_Parser_free(c2_parser_Parser* p);
static void c2_parser_Parser_parse(c2_parser_Parser* p, int32_t file_id, _Bool is_interface, _Bool is_generated);
static void c2_parser_on_tokenizer_error(void* arg, src_loc_SrcLoc loc);
static void c2_parser_on_tokenizer_warning(void* arg, src_loc_SrcLoc loc);
static void c2_parser_Parser_consumeToken(c2_parser_Parser* p);
static void c2_parser_Parser_expectAndConsume(c2_parser_Parser* p, token_Kind kind);
static void c2_parser_Parser_expect(c2_parser_Parser* p, token_Kind kind);
static void c2_parser_Parser_expectError(c2_parser_Parser* p, token_Kind kind);
static void c2_parser_Parser_expectIdentifier(c2_parser_Parser* p);
__attribute__((__format__(printf, 2, 3))) 
static void c2_parser_Parser_error(c2_parser_Parser* p, const char* format, ...);
static void c2_parser_Parser_parseModule(c2_parser_Parser* p, _Bool is_generated);
static void c2_parser_Parser_parseImports(c2_parser_Parser* p);
static void c2_parser_Parser_parseTopLevel(c2_parser_Parser* p);
static void c2_parser_Parser_parseOptionalAttributes(c2_parser_Parser* p);
static void c2_parser_Parser_parseParamOptionalAttributes(c2_parser_Parser* p, ast_VarDecl* d);
static void c2_parser_Parser_parseFuncDecl(c2_parser_Parser* p, _Bool is_public);
static _Bool c2_parser_Parser_parseFunctionParams(c2_parser_Parser* p, ast_DeclList* params, _Bool is_public);
static ast_VarDecl* c2_parser_Parser_parseParamDecl(c2_parser_Parser* p, _Bool is_public);
static void c2_parser_Parser_parseTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref, _Bool allow_qualifier, _Bool allow_array);
static void c2_parser_Parser_parseOptionalArray(c2_parser_Parser* p, ast_TypeRefHolder* ref, ast_QualType base, _Bool allow_array);
static void c2_parser_Parser_parseArrayEntry(c2_parser_Parser* p);
static void c2_parser_Parser_parseVarDecl(c2_parser_Parser* p, _Bool is_public);
static void c2_parser_Parser_parseStaticAssert(c2_parser_Parser* p);
static _Bool c2_parser_Parser_parseOptionalAccessSpecifier(c2_parser_Parser* p);
static uint32_t c2_parser_Parser_parseOptionalTypeQualifier(c2_parser_Parser* p);
static ast_BuiltinKind c2_parser_tokKindToBuiltinKind(token_Kind kind);
static void c2_parser_Parser_parseSingleTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref, _Bool allow_qualifier);
static void c2_parser_Parser_parseFullTypeIdentifier(c2_parser_Parser* p, ast_TypeRefHolder* ref);
static void c2_parser_Parser_dump_token(c2_parser_Parser* p, const token_Token* tok);
static _Bool c2_parser_checkName(const char* name, _Bool is_interface);
typedef enum {
   c2_parser_Prec_Unknown = 0,
   c2_parser_Prec_Comma = 1,
   c2_parser_Prec_Assignment = 2,
   c2_parser_Prec_Conditional = 3,
   c2_parser_Prec_LogicalAndOr = 4,
   c2_parser_Prec_Relational = 5,
   c2_parser_Prec_Additive = 6,
   c2_parser_Prec_Bitwise = 7,
   c2_parser_Prec_Shift = 8,
   c2_parser_Prec_Multiplicative = 9,
   _c2_parser_Prec_max = 255
} __attribute__((packed)) c2_parser_Prec;

static const c2_parser_Prec c2_parser_BinOpPrecLookup[128] = {
   [token_Kind_Comma] = c2_parser_Prec_Comma,
   [token_Kind_Equal] = c2_parser_Prec_Assignment,
   [token_Kind_StarEqual] = c2_parser_Prec_Assignment,
   [token_Kind_SlashEqual] = c2_parser_Prec_Assignment,
   [token_Kind_PercentEqual] = c2_parser_Prec_Assignment,
   [token_Kind_PlusEqual] = c2_parser_Prec_Assignment,
   [token_Kind_MinusEqual] = c2_parser_Prec_Assignment,
   [token_Kind_LessLessEqual] = c2_parser_Prec_Assignment,
   [token_Kind_GreaterGreaterEqual] = c2_parser_Prec_Assignment,
   [token_Kind_AmpEqual] = c2_parser_Prec_Assignment,
   [token_Kind_CaretEqual] = c2_parser_Prec_Assignment,
   [token_Kind_PipeEqual] = c2_parser_Prec_Assignment,
   [token_Kind_Question] = c2_parser_Prec_Conditional,
   [token_Kind_PipePipe] = c2_parser_Prec_LogicalAndOr,
   [token_Kind_AmpAmp] = c2_parser_Prec_LogicalAndOr,
   [token_Kind_ExclaimEqual] = c2_parser_Prec_Relational,
   [token_Kind_EqualEqual] = c2_parser_Prec_Relational,
   [token_Kind_LessEqual] = c2_parser_Prec_Relational,
   [token_Kind_Less] = c2_parser_Prec_Relational,
   [token_Kind_Greater] = c2_parser_Prec_Relational,
   [token_Kind_GreaterEqual] = c2_parser_Prec_Relational,
   [token_Kind_Plus] = c2_parser_Prec_Additive,
   [token_Kind_Minus] = c2_parser_Prec_Additive,
   [token_Kind_Pipe] = c2_parser_Prec_Bitwise,
   [token_Kind_Caret] = c2_parser_Prec_Bitwise,
   [token_Kind_Amp] = c2_parser_Prec_Bitwise,
   [token_Kind_LessLess] = c2_parser_Prec_Shift,
   [token_Kind_GreaterGreater] = c2_parser_Prec_Shift,
   [token_Kind_Percent] = c2_parser_Prec_Multiplicative,
   [token_Kind_Slash] = c2_parser_Prec_Multiplicative,
   [token_Kind_Star] = c2_parser_Prec_Multiplicative
};

static const ast_BinaryOpcode c2_parser_BinOpTokenLookup[128] = {
   [token_Kind_Star] = ast_BinaryOpcode_Multiply,
   [token_Kind_Slash] = ast_BinaryOpcode_Divide,
   [token_Kind_Percent] = ast_BinaryOpcode_Remainder,
   [token_Kind_Plus] = ast_BinaryOpcode_Add,
   [token_Kind_Minus] = ast_BinaryOpcode_Subtract,
   [token_Kind_LessLess] = ast_BinaryOpcode_ShiftLeft,
   [token_Kind_GreaterGreater] = ast_BinaryOpcode_ShiftRight,
   [token_Kind_Less] = ast_BinaryOpcode_LessThan,
   [token_Kind_Greater] = ast_BinaryOpcode_GreaterThan,
   [token_Kind_LessEqual] = ast_BinaryOpcode_LessEqual,
   [token_Kind_GreaterEqual] = ast_BinaryOpcode_GreaterEqual,
   [token_Kind_EqualEqual] = ast_BinaryOpcode_Equal,
   [token_Kind_ExclaimEqual] = ast_BinaryOpcode_NotEqual,
   [token_Kind_Amp] = ast_BinaryOpcode_And,
   [token_Kind_Caret] = ast_BinaryOpcode_Xor,
   [token_Kind_Pipe] = ast_BinaryOpcode_Or,
   [token_Kind_AmpAmp] = ast_BinaryOpcode_LAnd,
   [token_Kind_PipePipe] = ast_BinaryOpcode_LOr,
   [token_Kind_Equal] = ast_BinaryOpcode_Assign,
   [token_Kind_StarEqual] = ast_BinaryOpcode_MulAssign,
   [token_Kind_SlashEqual] = ast_BinaryOpcode_DivAssign,
   [token_Kind_PercentEqual] = ast_BinaryOpcode_RemAssign,
   [token_Kind_PlusEqual] = ast_BinaryOpcode_AddAssign,
   [token_Kind_MinusEqual] = ast_BinaryOpcode_SubAssign,
   [token_Kind_LessLessEqual] = ast_BinaryOpcode_ShlAssign,
   [token_Kind_GreaterGreaterEqual] = ast_BinaryOpcode_ShrAssign,
   [token_Kind_AmpEqual] = ast_BinaryOpcode_AndAssign,
   [token_Kind_CaretEqual] = ast_BinaryOpcode_XorAssign,
   [token_Kind_PipeEqual] = ast_BinaryOpcode_OrAssign
};

static const uint8_t c2_parser_CastExprTokenLookup[128] = {
   [token_Kind_Identifier] = 1,
   [token_Kind_IntegerLiteral] = 2,
   [token_Kind_FloatLiteral] = 3,
   [token_Kind_CharLiteral] = 4,
   [token_Kind_StringLiteral] = 5,
   [token_Kind_LParen] = 6,
   [token_Kind_Star] = 7,
   [token_Kind_Tilde] = 7,
   [token_Kind_Plus] = 7,
   [token_Kind_Minus] = 7,
   [token_Kind_Exclaim] = 7,
   [token_Kind_Amp] = 7,
   [token_Kind_PlusPlus] = 7,
   [token_Kind_MinusMinus] = 7,
   [token_Kind_KW_cast] = 8,
   [token_Kind_KW_elemsof] = 9,
   [token_Kind_KW_enum_min] = 10,
   [token_Kind_KW_enum_max] = 10,
   [token_Kind_KW_false] = 11,
   [token_Kind_KW_true] = 11,
   [token_Kind_KW_nil] = 12,
   [token_Kind_KW_offsetof] = 13,
   [token_Kind_KW_sizeof] = 14,
   [token_Kind_KW_to_container] = 15
};

static ast_Expr* c2_parser_Parser_parseExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseAssignmentExpression(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseRHSOfBinaryExpression(c2_parser_Parser* p, ast_Expr* lhs, c2_parser_Prec minPrec);
static ast_UnaryOpcode c2_parser_convertTokenToUnaryOpcode(token_Kind kind);
static ast_Expr* c2_parser_Parser_parseCastExpr(c2_parser_Parser* p, _Bool _arg1, _Bool _arg2);
static ast_Expr* c2_parser_Parser_parsePostfixExprSuffix(c2_parser_Parser* p, ast_Expr* lhs, _Bool couldBeTemplateCall);
static ast_Expr* c2_parser_Parser_parseCallExpr(c2_parser_Parser* p, ast_Expr* func);
static ast_Expr* c2_parser_Parser_parseTemplateCallExpr(c2_parser_Parser* p, ast_Expr* func, const ast_TypeRefHolder* ref);
static ast_Expr* c2_parser_Parser_parseImpureMemberExpr(c2_parser_Parser* p, ast_Expr* base);
static ast_Expr* c2_parser_Parser_parsePureMemberExpr(c2_parser_Parser* p);
static ast_IdentifierExpr* c2_parser_Parser_parseIdentifier(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseStringLiteral(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseParenExpr(c2_parser_Parser* p);
static _Bool c2_parser_Parser_isTemplateFunctionCall(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseSizeof(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseElemsof(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseInitValue(c2_parser_Parser* p, _Bool* need_semi, _Bool allow_designators);
static ast_Expr* c2_parser_Parser_parseInitList(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseFieldDesignator(c2_parser_Parser* p, _Bool* need_semi);
static ast_Expr* c2_parser_Parser_parseArrayDesignator(c2_parser_Parser* p, _Bool* need_semi);
static ast_Expr* c2_parser_Parser_parseExplicitCastExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseEnumMinMax(c2_parser_Parser* p, _Bool is_min);
static ast_Expr* c2_parser_Parser_parseOffsetOfExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseToContainerExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseFullIdentifier(c2_parser_Parser* p);
static _Bool c2_parser_Parser_parseAsType(c2_parser_Parser* p, _Bool* has_brackets);
static uint32_t c2_parser_Parser_parseAsCastType(c2_parser_Parser* p, uint32_t ahead, token_Kind close_tok, _Bool* brackets);
static ast_Stmt* c2_parser_Parser_parseStmt(c2_parser_Parser* p);
static _Bool c2_parser_Parser_isTypeSpec(c2_parser_Parser* p);
static uint32_t c2_parser_Parser_skipArray(c2_parser_Parser* p, uint32_t lookahead);
static ast_Stmt* c2_parser_Parser_parseDeclOrStmt(c2_parser_Parser* p);
static ast_CompoundStmt* c2_parser_Parser_parseCompoundStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseAsmStmt(c2_parser_Parser* p);
static void c2_parser_Parser_parseAsmOperandsOpt(c2_parser_Parser* p, string_list_List* names, ast_ExprList* constraints, ast_ExprList* exprs);
static ast_Stmt* c2_parser_Parser_parseAssertStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseBreakStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseContinueStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseFallthroughStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseCondition(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseIfStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseReturnStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseForStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseWhileStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseDeclStmt(c2_parser_Parser* p, _Bool checkSemi, _Bool allowLocal);
static void c2_parser_Parser_consumeSemicolon(c2_parser_Parser* p, _Bool need_semi);
static ast_Stmt* c2_parser_Parser_parseExprStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseLabelStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseGotoStmt(c2_parser_Parser* p);
static _Bool c2_parser_Parser_isDeclaration(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseSwitchStmt(c2_parser_Parser* p);
static void c2_parser_Parser_parseCaseCondition(c2_parser_Parser* p, expr_list_List* list);
static ast_SwitchCase* c2_parser_Parser_parseCase(c2_parser_Parser* p, _Bool is_default);
static void c2_parser_Parser_parseTypeDecl(c2_parser_Parser* p, _Bool is_public);
static void c2_parser_Parser_parseFunctionType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, _Bool is_public);
static void c2_parser_Parser_parseStructType(c2_parser_Parser* p, _Bool is_struct, uint32_t name, src_loc_SrcLoc loc, _Bool is_public);
static void c2_parser_Parser_parseStructBlock(c2_parser_Parser* p, ast_DeclList* members, _Bool is_public);
static void c2_parser_Parser_parseEnumType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, _Bool is_public);
static void c2_parser_Parser_parseAliasType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, _Bool is_public);

static c2_parser_Parser* c2_parser_create(source_mgr_SourceMgr* sm, diagnostics_Diags* diags, string_pool_Pool* pool, ast_builder_Builder* builder, const keywords_Info* kwinfo, const string_list_List* features)
{
   c2_parser_Parser* p = calloc(1, 67264);
   p->sm = sm;
   p->diags = diags;
   p->pool = pool;
   p->builder = builder;
   p->features = features;
   p->kwinfo = kwinfo;
   return p;
}

static void c2_parser_Parser_free(c2_parser_Parser* p)
{
   free(p);
}

static void c2_parser_Parser_parse(c2_parser_Parser* p, int32_t file_id, _Bool is_interface, _Bool is_generated)
{
   p->file_id = file_id;
   p->is_interface = is_interface;
   string_buffer_Buf* buf = string_buffer_create(1024, true, 0);
   int32_t res = setjmp(&p->jmpbuf);
   if ((res == 0)) {
      c2_tokenizer_Tokenizer_init(&p->tokenizer, p->pool, buf, source_mgr_SourceMgr_get_content(p->sm, p->file_id), source_mgr_SourceMgr_get_offset(p->sm, p->file_id), p->kwinfo, p->features, c2_parser_on_tokenizer_error, c2_parser_on_tokenizer_warning, p, false);
      token_Token_init(&p->tok);
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_parseModule(p, is_generated);
      c2_parser_Parser_parseImports(p);
      while (!p->tok.done) {
         c2_parser_Parser_parseTopLevel(p);
      }
   }
   string_buffer_Buf_free(buf);
}

static void c2_parser_on_tokenizer_error(void* arg, src_loc_SrcLoc loc)
{
   c2_parser_Parser* p = arg;
   p->tok.loc = loc;
   c2_parser_Parser_error(p, "%s", p->tokenizer.error_msg);
}

static void c2_parser_on_tokenizer_warning(void* arg, src_loc_SrcLoc loc)
{
   c2_parser_Parser* p = arg;
   diagnostics_Diags_error(p->diags, loc, "%s", p->tokenizer.error_msg);
}

static void c2_parser_Parser_consumeToken(c2_parser_Parser* p)
{
   p->prev_loc = (p->tok.loc + p->tok.len);
   c2_tokenizer_Tokenizer_lex(&p->tokenizer, &p->tok);
}

static void c2_parser_Parser_expectAndConsume(c2_parser_Parser* p, token_Kind kind)
{
   if ((p->tok.kind == kind)) {
      c2_parser_Parser_consumeToken(p);
      return;
   }
   c2_parser_Parser_expectError(p, kind);
}

static void c2_parser_Parser_expect(c2_parser_Parser* p, token_Kind kind)
{
   if ((p->tok.kind == kind)) return;

   c2_parser_Parser_expectError(p, kind);
}

static void c2_parser_Parser_expectError(c2_parser_Parser* p, token_Kind kind)
{
   if (p->prev_loc) {
      p->tok.loc = p->prev_loc;
   } else {
   }
   c2_parser_Parser_error(p, "expected '%s'", token_Kind_str(kind));
}

static void c2_parser_Parser_expectIdentifier(c2_parser_Parser* p)
{
   if ((p->tok.kind == token_Kind_Identifier)) return;

   c2_parser_Parser_error(p, "expected identifier");
}

__attribute__((__format__(printf, 2, 3))) 
static void c2_parser_Parser_error(c2_parser_Parser* p, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_error2(p->diags, p->tok.loc, format, args);
   va_end(args);
   longjmp(&p->jmpbuf, 1);
}

static void c2_parser_Parser_parseModule(c2_parser_Parser* p, _Bool is_generated)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_KW_module);
   c2_parser_Parser_expectIdentifier(p);
   const char* modname = string_pool_Pool_idx2str(p->pool, p->tok.name_idx);
   if (!islower(modname[0])) {
      c2_parser_Parser_error(p, "a module name must start with a lower case character");
   }
   ast_builder_Builder_actOnModule(p->builder, p->tok.name_idx, p->tok.loc, source_mgr_SourceMgr_getFileNameIdx(p->sm, p->file_id), is_generated);
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
}

static void c2_parser_Parser_parseImports(c2_parser_Parser* p)
{
   while ((p->tok.kind == token_Kind_KW_import)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      uint32_t mod_name = p->tok.name_idx;
      src_loc_SrcLoc mod_loc = p->tok.loc;
      uint32_t alias_name = 0;
      src_loc_SrcLoc alias_loc = 0;
      c2_parser_Parser_consumeToken(p);
      if ((p->tok.kind == token_Kind_KW_as)) {
         c2_parser_Parser_consumeToken(p);
         c2_parser_Parser_expectIdentifier(p);
         alias_name = p->tok.name_idx;
         alias_loc = p->tok.loc;
         if (!c2_parser_checkName(string_pool_Pool_idx2str(p->pool, alias_name), false)) {
            c2_parser_Parser_error(p, "a module name must start with a lower case character");
         }
         c2_parser_Parser_consumeToken(p);
      }
      _Bool islocal = false;
      if ((p->tok.kind == token_Kind_KW_local)) {
         c2_parser_Parser_consumeToken(p);
         islocal = true;
      }
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
      ast_builder_Builder_actOnImport(p->builder, mod_name, mod_loc, alias_name, alias_loc, islocal);
   }
}

static void c2_parser_Parser_parseTopLevel(c2_parser_Parser* p)
{
   ast_builder_Builder_clearAttributes(p->builder);
   _Bool is_public = c2_parser_Parser_parseOptionalAccessSpecifier(p);
   switch (p->tok.kind) {
   case token_Kind_KW_assert:
      c2_parser_Parser_error(p, "assert can only be used inside a function");
      break;
   case token_Kind_KW_fn:
      c2_parser_Parser_parseFuncDecl(p, is_public);
      break;
   case token_Kind_KW_import:
      c2_parser_Parser_error(p, "no imports allowed after declarations");
      break;
   case token_Kind_KW_static_assert:
      if (is_public) c2_parser_Parser_error(p, "static_assert cannot be public");
      c2_parser_Parser_parseStaticAssert(p);
      break;
   case token_Kind_KW_type:
      c2_parser_Parser_parseTypeDecl(p, is_public);
      break;
   case token_Kind_Eof:
      break;
   case token_Kind_Identifier: {
      token_Kind kind = c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 1, NULL);
      if ((kind == token_Kind_PlusEqual)) {
         if (is_public) c2_parser_Parser_error(p, "incremental array entries cannot be public");
         c2_parser_Parser_parseArrayEntry(p);
         break;
      }
      fallthrough;
   }
   default:
      c2_parser_Parser_parseVarDecl(p, is_public);
      break;
   }
}

static void c2_parser_Parser_parseOptionalAttributes(c2_parser_Parser* p)
{
   if ((p->tok.kind != token_Kind_At)) return;

   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   while (1) {
      c2_parser_Parser_expectIdentifier(p);
      attr_Attr a;
      a.name = p->tok.name_idx;
      a.loc = p->tok.loc;
      a.value_kind = attr_ValueKind_None;
      c2_parser_Parser_consumeToken(p);
      if ((p->tok.kind == token_Kind_Equal)) {
         c2_parser_Parser_consumeToken(p);
         a.value.loc = p->tok.loc;
         switch (p->tok.kind) {
         case token_Kind_StringLiteral:
            a.value_kind = attr_ValueKind_String;
            a.value.text = p->tok.text_idx;
            if ((p->tok.text_len == 0)) {
               c2_parser_Parser_error(p, "attribute argument cannot be an empty string");
            }
            c2_parser_Parser_consumeToken(p);
            break;
         case token_Kind_IntegerLiteral:
            a.value_kind = attr_ValueKind_Number;
            a.value.number = ((uint32_t)(p->tok.int_value));
            c2_parser_Parser_consumeToken(p);
            break;
         default:
            c2_parser_Parser_error(p, "expected attribute argument");
            return;
         }
      }
      ast_builder_Builder_actOnAttr(p->builder, &a);
      if ((p->tok.kind != token_Kind_Comma)) break;

      c2_parser_Parser_consumeToken(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
}

static void c2_parser_Parser_parseParamOptionalAttributes(c2_parser_Parser* p, ast_VarDecl* d)
{
   if ((p->tok.kind != token_Kind_At)) return;

   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   while (1) {
      c2_parser_Parser_expectIdentifier(p);
      uint32_t attr_id = p->tok.name_idx;
      src_loc_SrcLoc loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      if ((p->tok.kind == token_Kind_Equal)) {
         c2_parser_Parser_error(p, "a parameter attribute cannot have a value");
      }
      ast_builder_Builder_actOnParamAttr(p->builder, d, attr_id, loc);
      if ((p->tok.kind != token_Kind_Comma)) break;

      c2_parser_Parser_consumeToken(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
}

static void c2_parser_Parser_parseFuncDecl(c2_parser_Parser* p, _Bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   ast_TypeRefHolder rtype; ast_TypeRefHolder_init(&rtype);
   c2_parser_Parser_parseTypeSpecifier(p, &rtype, true, true);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t func_name = p->tok.name_idx;
   src_loc_SrcLoc func_loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Ref prefix_ref;
   ast_Ref* prefix = NULL;
   if ((p->tok.kind == token_Kind_Dot)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      prefix_ref.loc = func_loc;
      prefix_ref.name_idx = func_name;
      prefix_ref.decl = NULL;
      prefix = &prefix_ref;
      func_name = p->tok.name_idx;
      func_loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
   }
   if (!c2_parser_checkName(string_pool_Pool_idx2str(p->pool, func_name), p->is_interface)) {
      p->tok.loc = func_loc;
      c2_parser_Parser_error(p, "a function name must start with a lower case character");
   }
   ast_DeclList params; ast_DeclList_init(&params);
   _Bool is_variadic = c2_parser_Parser_parseFunctionParams(p, &params, is_public);
   ast_FunctionDecl* f;
   if ((p->tok.kind == token_Kind_KW_template)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      uint32_t template_name = p->tok.name_idx;
      src_loc_SrcLoc template_loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      f = ast_builder_Builder_actOnTemplateFunctionDecl(p->builder, func_name, func_loc, is_public, &rtype, template_name, template_loc, ((ast_VarDecl**)(ast_DeclList_getDecls(&params))), ast_DeclList_size(&params), is_variadic);
   } else {
      f = ast_builder_Builder_actOnFunctionDecl(p->builder, func_name, func_loc, is_public, &rtype, prefix, ((ast_VarDecl**)(ast_DeclList_getDecls(&params))), ast_DeclList_size(&params), is_variadic);
   }
   ast_DeclList_free(&params);
   c2_parser_Parser_parseOptionalAttributes(p);
   ast_builder_Builder_applyAttributes(p->builder, ((ast_Decl*)(f)));
   if ((p->is_interface && (p->tok.kind == token_Kind_Semicolon))) {
      c2_parser_Parser_consumeToken(p);
      return;
   }
   if (p->is_interface) {
      ast_FunctionDecl_setAttrInline(f);
   }
   ast_CompoundStmt* body = c2_parser_Parser_parseCompoundStmt(p);
   ast_builder_Builder_actOnFunctionBody(p->builder, f, body);
}

static _Bool c2_parser_Parser_parseFunctionParams(c2_parser_Parser* p, ast_DeclList* params, _Bool is_public)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   if ((p->tok.kind == token_Kind_RParen)) {
      c2_parser_Parser_consumeToken(p);
      return false;
   }
   _Bool is_variadic = false;
   while ((p->tok.kind != token_Kind_RParen)) {
      ast_VarDecl* decl = c2_parser_Parser_parseParamDecl(p, is_public);
      ast_DeclList_add(params, ast_VarDecl_asDecl(decl));
      if ((p->tok.kind != token_Kind_Comma)) break;

      c2_parser_Parser_consumeToken(p);
      if ((p->tok.kind == token_Kind_Ellipsis)) {
         is_variadic = true;
         c2_parser_Parser_consumeToken(p);
         break;
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return is_variadic;
}

static ast_VarDecl* c2_parser_Parser_parseParamDecl(c2_parser_Parser* p, _Bool is_public)
{
   if ((p->tok.kind == token_Kind_KW_local)) c2_parser_Parser_error(p, "keyword 'local' is not allowed here");
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref, true, true);
   uint32_t name = 0;
   src_loc_SrcLoc loc = p->tok.loc;
   if ((p->tok.kind == token_Kind_Identifier)) {
      name = p->tok.name_idx;
      if (!c2_parser_checkName(string_pool_Pool_idx2str(p->pool, name), p->is_interface)) {
         c2_parser_Parser_error(p, "a parameter name must start with a lower case character");
      }
      c2_parser_Parser_consumeToken(p);
   }
   if ((p->tok.kind == token_Kind_Equal)) {
      c2_parser_Parser_error(p, "default parameter values are not allowed");
   }
   ast_VarDecl* param = ast_builder_Builder_actOnFunctionParam(p->builder, name, loc, is_public, &ref);
   c2_parser_Parser_parseParamOptionalAttributes(p, param);
   return param;
}

static void c2_parser_Parser_parseTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref, _Bool allow_qualifier, _Bool allow_array)
{
   c2_parser_Parser_parseSingleTypeSpecifier(p, ref, allow_qualifier);
   c2_parser_Parser_parseOptionalArray(p, ref, ast_QualType_Invalid, allow_array);
}

static void c2_parser_Parser_parseOptionalArray(c2_parser_Parser* p, ast_TypeRefHolder* ref, ast_QualType base, _Bool allow_array)
{
   if ((p->tok.kind != token_Kind_LSquare)) return;

   if (!allow_array) c2_parser_Parser_error(p, "array types are not allowed here");
   if ((ast_TypeRefHolder_getNumArrays(ref) == 3)) c2_parser_Parser_error(p, "arrays cannot have more than 3 dimensions");
   if (ast_TypeRefHolder_isIncrArray(ref)) c2_parser_Parser_error(p, "incremental arrays cannot have more than 1 dimension");
   c2_parser_Parser_consumeToken(p);
   ast_Expr* size = NULL;
   if ((p->tok.kind == token_Kind_RSquare)) {
      ast_TypeRefHolder_addArray(ref, NULL);
      c2_parser_Parser_consumeToken(p);
   } else if (((p->tok.kind == token_Kind_Plus) && (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 1, NULL) == token_Kind_RSquare))) {
      if (ast_TypeRefHolder_getNumArrays(ref)) c2_parser_Parser_error(p, "incremental arrays cannot have more than 1 dimension");
      c2_parser_Parser_consumeToken(p);
      ast_TypeRefHolder_setIncrArray(ref);
      c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
   } else {
      size = c2_parser_Parser_parseExpr(p);
      ast_TypeRefHolder_addArray(ref, size);
      c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
   }

   c2_parser_Parser_parseOptionalArray(p, ref, base, true);
}

static void c2_parser_Parser_parseArrayEntry(c2_parser_Parser* p)
{
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_consumeToken(p);
   _Bool need_semi = true;
   ast_Expr* initValue = c2_parser_Parser_parseInitValue(p, &need_semi, false);
   c2_parser_Parser_consumeSemicolon(p, need_semi);
   ast_builder_Builder_actOnArrayValue(p->builder, name, loc, initValue);
}

static void c2_parser_Parser_parseVarDecl(c2_parser_Parser* p, _Bool is_public)
{
   if ((p->tok.kind == token_Kind_KW_local)) c2_parser_Parser_error(p, "keyword 'local' cannot be used at file scope");
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref, true, true);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   _Bool need_semi = true;
   ast_Expr* initValue = NULL;
   src_loc_SrcLoc assignLoc = 0;
   c2_parser_Parser_parseOptionalAttributes(p);
   if ((p->tok.kind == token_Kind_Dot)) c2_parser_Parser_error(p, "global variables cannot have an init call");
   if ((p->tok.kind == token_Kind_Equal)) {
      assignLoc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      initValue = c2_parser_Parser_parseInitValue(p, &need_semi, false);
   }
   c2_parser_Parser_consumeSemicolon(p, need_semi);
   ast_Decl* d = ast_builder_Builder_actOnGlobalVarDecl(p->builder, name, loc, is_public, &ref, assignLoc, initValue);
   ast_builder_Builder_applyAttributes(p->builder, d);
}

static void c2_parser_Parser_parseStaticAssert(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* lhs = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* rhs = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_builder_Builder_actOnStaticAssert(p->builder, loc, lhs, rhs);
}

static _Bool c2_parser_Parser_parseOptionalAccessSpecifier(c2_parser_Parser* p)
{
   if ((p->tok.kind == token_Kind_KW_public)) {
      c2_parser_Parser_consumeToken(p);
      return true;
   }
   return false;
}

static uint32_t c2_parser_Parser_parseOptionalTypeQualifier(c2_parser_Parser* p)
{
   uint32_t qualifiers = 0;
   if ((p->tok.kind == token_Kind_KW_const)) {
      c2_parser_Parser_consumeToken(p);
      qualifiers |= ast_QualType_Const;
   }
   if ((p->tok.kind == token_Kind_KW_volatile)) {
      c2_parser_Parser_consumeToken(p);
      qualifiers |= ast_QualType_Volatile;
   }
   return qualifiers;
}

static ast_BuiltinKind c2_parser_tokKindToBuiltinKind(token_Kind kind)
{
   return c2_parser_Tok2builtin[(kind - token_Kind_KW_bool)];
}

static void c2_parser_Parser_parseSingleTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref, _Bool allow_qualifier)
{
   if (allow_qualifier) {
      uint32_t type_qualifier = c2_parser_Parser_parseOptionalTypeQualifier(p);
      ast_TypeRefHolder_setQualifiers(ref, type_qualifier);
   }
   token_Kind kind = p->tok.kind;
   if (((kind >= token_Kind_KW_bool) && (kind <= token_Kind_KW_void))) {
      ast_TypeRefHolder_setBuiltin(ref, c2_parser_tokKindToBuiltinKind(p->tok.kind), p->tok.loc);
      if (((kind >= token_Kind_KW_reg8) && (kind <= token_Kind_KW_reg64))) ast_TypeRefHolder_setVolatile(ref);
      c2_parser_Parser_consumeToken(p);
   } else if ((kind == token_Kind_Identifier)) {
      c2_parser_Parser_parseFullTypeIdentifier(p, ref);
   } else {
      c2_parser_Parser_error(p, "expected type specifier");
   }

   uint32_t depth = 0;
   while ((p->tok.kind == token_Kind_Star)) {
      depth++;
      if ((depth > 3)) c2_parser_Parser_error(p, "pointers have a maximum nesting of 3");
      ast_TypeRefHolder_addPointer(ref);
      c2_parser_Parser_consumeToken(p);
   }
}

static void c2_parser_Parser_parseFullTypeIdentifier(c2_parser_Parser* p, ast_TypeRefHolder* ref)
{
   ast_TypeRefHolder_setUser(ref, p->tok.loc, p->tok.name_idx);
   c2_parser_Parser_consumeToken(p);
   if ((p->tok.kind == token_Kind_Dot)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      ast_TypeRefHolder_setPrefix(ref, p->tok.loc, p->tok.name_idx);
      c2_parser_Parser_consumeToken(p);
   }
}

static void c2_parser_Parser_dump_token(c2_parser_Parser* p, const token_Token* tok)
{
   string_buffer_Buf* out = p->tokenizer.buf;
   string_buffer_Buf_clear(out);
   if (token_is_keyword(tok->kind)) string_buffer_Buf_color(out, color_Green);
   string_buffer_Buf_print(out, "%12s", token_Kind_str(tok->kind));
   if (token_is_keyword(tok->kind)) string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_print(out, "  %6u %s  ", tok->loc, source_mgr_SourceMgr_loc2str(p->sm, tok->loc));
   string_buffer_Buf_color(out, color_Cyan);
   switch (tok->kind) {
   case token_Kind_Identifier:
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(p->pool, tok->name_idx));
      break;
   case token_Kind_IntegerLiteral:
      switch (token_Token_getRadix(tok)) {
      case number_radix_Radix_Default:
         string_buffer_Buf_print(out, "%lu", tok->int_value);
         break;
      case number_radix_Radix_Hex:
         string_buffer_Buf_print(out, "0x%lx", tok->int_value);
         break;
      case number_radix_Radix_Octal:
         string_buffer_Buf_print(out, "0%lo", tok->int_value);
         break;
      case number_radix_Radix_Binary:
         string_buffer_Buf_print(out, "0b%lb", tok->int_value);
         break;
      }
      break;
   case token_Kind_FloatLiteral:
      switch (token_Token_getRadix(tok)) {
      case number_radix_Radix_Hex:
         string_buffer_Buf_print(out, "%la", tok->float_value);
         break;
      default: {
         char buf[32];
         string_buffer_Buf_add(out, ast_ftoa(buf, 32, tok->float_value));
         break;
      }
      }
      break;
   case token_Kind_CharLiteral:
      switch (token_Token_getRadix(tok)) {
      case number_radix_Radix_Hex:
         string_buffer_Buf_print(out, "'\\x%02x'", tok->char_value);
         break;
      case number_radix_Radix_Octal:
         string_buffer_Buf_print(out, "'\\%o'", tok->char_value);
         break;
      default: {
         char cc = tok->char_value;
         string_buffer_Buf_add1(out, '\'');
         string_buffer_Buf_encodeBytes(out, &cc, 1, '\'');
         string_buffer_Buf_add1(out, '\'');
         break;
      }
      }
      break;
   case token_Kind_StringLiteral:
      string_buffer_Buf_add1(out, '"');
      string_buffer_Buf_encodeBytes(out, string_pool_Pool_idx2str(p->pool, tok->text_idx), tok->text_len, '"');
      string_buffer_Buf_add1(out, '"');
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_print(out, " (len %u)", tok->text_len);
      break;
   case token_Kind_LineComment:
      string_buffer_Buf_add(out, "//");
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(p->pool, tok->text_idx));
      break;
   case token_Kind_BlockComment:
      string_buffer_Buf_add(out, "/*");
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(p->pool, tok->text_idx));
      string_buffer_Buf_add(out, "*/");
      break;
   case token_Kind_Warning:
      string_buffer_Buf_color(out, color_Yellow);
      string_buffer_Buf_add(out, tok->error_msg);
      break;
   case token_Kind_Error:
      string_buffer_Buf_color(out, color_Red);
      string_buffer_Buf_add(out, p->tokenizer.error_msg);
      break;
   default:
      break;
   }
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_newline(out);
   fputs(string_buffer_Buf_data(out), stdout);
}

static _Bool c2_parser_checkName(const char* name, _Bool is_interface)
{
   if (is_interface) return true;

   char c = name[0];
   if (islower(c)) return true;

   return false;
}

static ast_Expr* c2_parser_Parser_parseExpr(c2_parser_Parser* p)
{
   ast_Expr* lhs = c2_parser_Parser_parseAssignmentExpression(p);
   if (ast_Expr_isInitlistAssignment(lhs)) return lhs;

   return c2_parser_Parser_parseRHSOfBinaryExpression(p, lhs, c2_parser_Prec_Comma);
}

static ast_Expr* c2_parser_Parser_parseAssignmentExpression(c2_parser_Parser* p)
{
   ast_Expr* lhs = c2_parser_Parser_parseCastExpr(p, false, false);
   return c2_parser_Parser_parseRHSOfBinaryExpression(p, lhs, c2_parser_Prec_Assignment);
}

static ast_Expr* c2_parser_Parser_parseRHSOfBinaryExpression(c2_parser_Parser* p, ast_Expr* lhs, c2_parser_Prec minPrec)
{
   c2_parser_Prec nextTokPrec = c2_parser_BinOpPrecLookup[p->tok.kind];
   src_loc_SrcLoc colonLoc = 0;
   while (1) {
      if ((nextTokPrec < minPrec)) return lhs;

      if ((p->tok.kind == token_Kind_Comma)) return lhs;

      token_Token opToken = p->tok;
      c2_parser_Parser_consumeToken(p);
      ast_Expr* ternaryMiddle = NULL;
      if ((nextTokPrec == c2_parser_Prec_Conditional)) {
         if ((p->tok.kind == token_Kind_Colon)) {
            c2_parser_Parser_error(p, "TODO conditional expr");
         } else {
            ternaryMiddle = c2_parser_Parser_parseExpr(p);
         }
         if ((p->tok.kind == token_Kind_Colon)) {
            colonLoc = p->tok.loc;
            c2_parser_Parser_consumeToken(p);
         }
      }
      if (((p->tok.kind == token_Kind_LBrace) && (opToken.kind == token_Kind_Equal))) {
         ast_Expr* rhs = c2_parser_Parser_parseInitList(p);
         ast_BinaryOpcode opcode = ast_BinaryOpcode_Assign;
         return ast_builder_Builder_actOnBinaryOperator(p->builder, opToken.loc, opcode, lhs, rhs);
      }
      ast_Expr* rhs = c2_parser_Parser_parseCastExpr(p, false, false);
      c2_parser_Prec thisPrec = nextTokPrec;
      nextTokPrec = c2_parser_BinOpPrecLookup[p->tok.kind];
      _Bool isRightAssoc = (((thisPrec == c2_parser_Prec_Conditional) || (thisPrec == c2_parser_Prec_Assignment)));
      if (((thisPrec < nextTokPrec) || (((thisPrec == nextTokPrec) && isRightAssoc)))) {
         rhs = c2_parser_Parser_parseRHSOfBinaryExpression(p, rhs, (thisPrec + !isRightAssoc));
         nextTokPrec = c2_parser_BinOpPrecLookup[p->tok.kind];
      }
      if (ternaryMiddle) {
         lhs = ast_builder_Builder_actOnConditionalOperator(p->builder, opToken.loc, colonLoc, lhs, ternaryMiddle, rhs);
      } else {
         ast_BinaryOpcode opcode = c2_parser_BinOpTokenLookup[opToken.kind];
         lhs = ast_builder_Builder_actOnBinaryOperator(p->builder, opToken.loc, opcode, lhs, rhs);
      }
   }
   return NULL;
}

static ast_UnaryOpcode c2_parser_convertTokenToUnaryOpcode(token_Kind kind)
{
   switch (kind) {
   case token_Kind_Exclaim:
      return ast_UnaryOpcode_LNot;
   case token_Kind_Star:
      return ast_UnaryOpcode_Deref;
   case token_Kind_Amp:
      return ast_UnaryOpcode_AddrOf;
   case token_Kind_PlusPlus:
      return ast_UnaryOpcode_PreInc;
   case token_Kind_Plus:
      return ast_UnaryOpcode_Plus;
   case token_Kind_Minus:
      return ast_UnaryOpcode_Minus;
   case token_Kind_MinusMinus:
      return ast_UnaryOpcode_PreDec;
   case token_Kind_Tilde:
      return ast_UnaryOpcode_Not;
   default:
      (0) || c2_assert("parser/c2_parser_expr.c2", 233, "c2_parser.convertTokenToUnaryOpcode", "0");
      break;
   }
   return ast_UnaryOpcode_PreInc;
}

static ast_Expr* c2_parser_Parser_parseCastExpr(c2_parser_Parser* p, _Bool _arg1, _Bool _arg2)
{
   token_Kind savedKind = p->tok.kind;
   ast_Expr* res = NULL;
   _Bool couldBeTemplateCall = false;
   switch (c2_parser_CastExprTokenLookup[savedKind]) {
   case 0:
      c2_parser_Parser_error(p, "expected expression");
      break;
   case 1:
      if ((c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 1, NULL) == token_Kind_Dot)) {
         res = c2_parser_Parser_parsePureMemberExpr(p);
      } else {
         res = ast_IdentifierExpr_asExpr(c2_parser_Parser_parseIdentifier(p));
      }
      couldBeTemplateCall = true;
      break;
   case 2:
      res = ast_builder_Builder_actOnIntegerLiteral(p->builder, p->tok.loc, p->tok.len, p->tok.int_value, token_Token_getRadix(&p->tok));
      c2_parser_Parser_consumeToken(p);
      break;
   case 3:
      res = ast_builder_Builder_actOnFloatLiteral(p->builder, p->tok.loc, p->tok.len, p->tok.float_value, token_Token_getRadix(&p->tok));
      c2_parser_Parser_consumeToken(p);
      break;
   case 4:
      res = ast_builder_Builder_actOnCharLiteral(p->builder, p->tok.loc, p->tok.len, p->tok.char_value, token_Token_getRadix(&p->tok));
      c2_parser_Parser_consumeToken(p);
      break;
   case 5:
      res = c2_parser_Parser_parseStringLiteral(p);
      break;
   case 6:
      res = c2_parser_Parser_parseParenExpr(p);
      break;
   case 7: {
      src_loc_SrcLoc loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      _Bool is_addrof_op = ((savedKind == token_Kind_Amp));
      res = c2_parser_Parser_parseCastExpr(p, false, is_addrof_op);
      ast_UnaryOpcode opcode = c2_parser_convertTokenToUnaryOpcode(savedKind);
      return ast_builder_Builder_actOnUnaryOperator(p->builder, loc, opcode, res);
   }
   case 8:
      res = c2_parser_Parser_parseExplicitCastExpr(p);
      break;
   case 9:
      res = c2_parser_Parser_parseElemsof(p);
      break;
   case 10:
      return c2_parser_Parser_parseEnumMinMax(p, (savedKind == token_Kind_KW_enum_min));
   case 11:
      res = ast_builder_Builder_actOnBooleanConstant(p->builder, p->tok.loc, (savedKind == token_Kind_KW_true));
      c2_parser_Parser_consumeToken(p);
      break;
   case 12:
      res = ast_builder_Builder_actOnNilExpr(p->builder, p->tok.loc);
      c2_parser_Parser_consumeToken(p);
      break;
   case 13:
      return c2_parser_Parser_parseOffsetOfExpr(p);
   case 14:
      return c2_parser_Parser_parseSizeof(p);
   case 15:
      res = c2_parser_Parser_parseToContainerExpr(p);
      break;
   }
   return c2_parser_Parser_parsePostfixExprSuffix(p, res, couldBeTemplateCall);
}

static ast_Expr* c2_parser_Parser_parsePostfixExprSuffix(c2_parser_Parser* p, ast_Expr* lhs, _Bool couldBeTemplateCall)
{
   while (1) {
      switch (p->tok.kind) {
      case token_Kind_Identifier:
         return lhs;
      case token_Kind_LParen:
         lhs = c2_parser_Parser_parseCallExpr(p, lhs);
         break;
      case token_Kind_LSquare: {
         src_loc_SrcLoc loc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* idx = c2_parser_Parser_parseExpr(p);
         if ((p->tok.kind == token_Kind_Colon)) {
            src_loc_SrcLoc colon_loc = p->tok.loc;
            c2_parser_Parser_consumeToken(p);
            ast_Expr* rhs = c2_parser_Parser_parseExpr(p);
            idx = ast_builder_Builder_actOnBitOffsetExpr(p->builder, colon_loc, idx, rhs);
         }
         uint32_t src_len = ((p->tok.loc + 1) - loc);
         c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
         lhs = ast_builder_Builder_actOnArraySubscriptExpr(p->builder, loc, src_len, lhs, idx);
         break;
      }
      case token_Kind_Dot:
         lhs = c2_parser_Parser_parseImpureMemberExpr(p, lhs);
         break;
      case token_Kind_PlusPlus:
         lhs = ast_builder_Builder_actOnUnaryOperator(p->builder, p->tok.loc, ast_UnaryOpcode_PostInc, lhs);
         c2_parser_Parser_consumeToken(p);
         break;
      case token_Kind_MinusMinus:
         lhs = ast_builder_Builder_actOnUnaryOperator(p->builder, p->tok.loc, ast_UnaryOpcode_PostDec, lhs);
         c2_parser_Parser_consumeToken(p);
         break;
      case token_Kind_Less:
         if ((couldBeTemplateCall && c2_parser_Parser_isTemplateFunctionCall(p))) {
            c2_parser_Parser_consumeToken(p);
            ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
            c2_parser_Parser_parseTypeSpecifier(p, &ref, false, false);
            c2_parser_Parser_expectAndConsume(p, token_Kind_Greater);
            if ((p->tok.kind != token_Kind_LParen)) {
               c2_parser_Parser_error(p, "missing argument list for template function call");
            }
            lhs = c2_parser_Parser_parseTemplateCallExpr(p, lhs, &ref);
            break;
         }
         return lhs;
      default:
         return lhs;
      }
   }
   (0) || c2_assert("parser/c2_parser_expr.c2", 381, "c2_parser.Parser.parsePostfixExprSuffix", "0");
   return NULL;
}

static ast_Expr* c2_parser_Parser_parseCallExpr(c2_parser_Parser* p, ast_Expr* func)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_ExprList args; ast_ExprList_init(&args);
   while ((p->tok.kind != token_Kind_RParen)) {
      if ((p->tok.kind == token_Kind_LBrace)) ast_ExprList_add(&args, c2_parser_Parser_parseInitList(p));
      else ast_ExprList_add(&args, c2_parser_Parser_parseExpr(p));
      if ((p->tok.kind != token_Kind_Comma)) break;

      c2_parser_Parser_consumeToken(p);
   }
   src_loc_SrcLoc endLoc = (p->tok.loc + 1);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   ast_Expr* res = ast_builder_Builder_actOnCallExpr(p->builder, loc, endLoc, func, ast_ExprList_getExprs(&args), ast_ExprList_size(&args));
   ast_ExprList_free(&args);
   return res;
}

static ast_Expr* c2_parser_Parser_parseTemplateCallExpr(c2_parser_Parser* p, ast_Expr* func, const ast_TypeRefHolder* ref)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_ExprList args; ast_ExprList_init(&args);
   while ((p->tok.kind != token_Kind_RParen)) {
      ast_ExprList_add(&args, c2_parser_Parser_parseExpr(p));
      if ((p->tok.kind != token_Kind_Comma)) break;

      c2_parser_Parser_consumeToken(p);
   }
   src_loc_SrcLoc endLoc = (p->tok.loc + 1);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   ast_Expr* res = ast_builder_Builder_actOnTemplateCallExpr(p->builder, loc, endLoc, func, ast_ExprList_getExprs(&args), ast_ExprList_size(&args), ref);
   ast_ExprList_free(&args);
   return res;
}

static ast_Expr* c2_parser_Parser_parseImpureMemberExpr(c2_parser_Parser* p, ast_Expr* base)
{
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   ast_Ref ref[7];
   ref[0].loc = p->tok.loc;
   ref[0].name_idx = p->tok.name_idx;
   uint32_t refcount = 1;
   c2_parser_Parser_consumeToken(p);
   while ((p->tok.kind == token_Kind_Dot)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      if ((refcount == 7)) c2_parser_Parser_error(p, "max member depth is %u", ast_MemberExprMaxDepth);
      ref[refcount].loc = p->tok.loc;
      ref[refcount].name_idx = p->tok.name_idx;
      refcount++;
      c2_parser_Parser_consumeToken(p);
   }
   return ast_builder_Builder_actOnMemberExpr(p->builder, base, ref, refcount);
}

static ast_Expr* c2_parser_Parser_parsePureMemberExpr(c2_parser_Parser* p)
{
   ast_Ref ref[7];
   ref[0].loc = p->tok.loc;
   ref[0].name_idx = p->tok.name_idx;
   uint32_t refcount = 1;
   c2_parser_Parser_consumeToken(p);
   while ((p->tok.kind == token_Kind_Dot)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      if ((refcount == 7)) c2_parser_Parser_error(p, "max member depth is %u", ast_MemberExprMaxDepth);
      ref[refcount].loc = p->tok.loc;
      ref[refcount].name_idx = p->tok.name_idx;
      refcount++;
      c2_parser_Parser_consumeToken(p);
   }
   return ast_builder_Builder_actOnMemberExpr(p->builder, NULL, ref, refcount);
}

static ast_IdentifierExpr* c2_parser_Parser_parseIdentifier(c2_parser_Parser* p)
{
   ast_IdentifierExpr* e = ast_builder_Builder_actOnIdentifier(p->builder, p->tok.loc, p->tok.name_idx);
   c2_parser_Parser_consumeToken(p);
   return e;
}

static ast_Expr* c2_parser_Parser_parseStringLiteral(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   uint32_t src_len = p->tok.len;
   uint32_t idx = p->tok.text_idx;
   uint32_t len = p->tok.text_len;
   c2_parser_Parser_consumeToken(p);
   if ((p->tok.kind == token_Kind_StringLiteral)) {
      char* tmp = p->multi_string;
      const char* p1 = string_pool_Pool_idx2str(p->pool, idx);
      if ((len > constants_MaxMultiString)) {
         c2_parser_Parser_error(p, "multi-string literal too long");
      }
      memcpy(tmp, p1, len);
      while ((p->tok.kind == token_Kind_StringLiteral)) {
         const char* p2 = string_pool_Pool_idx2str(p->pool, p->tok.text_idx);
         size_t len2 = p->tok.text_len;
         if (((len + len2) > constants_MaxMultiString)) {
            c2_parser_Parser_error(p, "multi-string literal too long");
         }
         memcpy((tmp + len), p2, len2);
         len += len2;
         src_len = ((p->tok.loc + p->tok.len) - loc);
         c2_parser_Parser_consumeToken(p);
      }
      idx = string_pool_Pool_add(p->pool, tmp, len, true);
   }
   return ast_builder_Builder_actOnStringLiteral(p->builder, loc, src_len, idx, len);
}

static ast_Expr* c2_parser_Parser_parseParenExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   _Bool has_brackets = false;
   if (c2_parser_Parser_parseAsCastType(p, 0, token_Kind_RParen, &has_brackets)) {
      ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
      c2_parser_Parser_parseTypeSpecifier(p, &ref, true, has_brackets);
      c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
      if ((p->tok.kind == token_Kind_LBrace)) {
         c2_parser_Parser_error(p, "Compound literals are not supported");
      } else {
         if (has_brackets) c2_parser_Parser_error(p, "array types are not allowed here");
         ast_Expr* expr = c2_parser_Parser_parseCastExpr(p, false, false);
         uint32_t src_len = (p->prev_loc - loc);
         return ast_builder_Builder_actOnExplicitCast(p->builder, loc, src_len, &ref, expr, true);
      }
   }
   ast_Expr* res = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnParenExpr(p->builder, loc, src_len, res);
}

static _Bool c2_parser_Parser_isTemplateFunctionCall(c2_parser_Parser* p)
{
   ((p->tok.kind == token_Kind_Less)) || c2_assert("parser/c2_parser_expr.c2", 545, "c2_parser.Parser.isTemplateFunctionCall", "p.tok.kind == Kind.Less");
   uint32_t ahead = 1;
   token_Kind kind = c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, NULL);
   if (((kind >= token_Kind_KW_bool) && (kind <= token_Kind_KW_void))) return true;

   while ((ahead < 8)) {
      switch (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, NULL)) {
      case token_Kind_Identifier:
         fallthrough;
      case token_Kind_Star:
         fallthrough;
      case token_Kind_Dot:
         break;
      case token_Kind_Greater:
         return (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, (ahead + 1), NULL) == token_Kind_LParen);
      case token_Kind_KW_const:
         return true;
      default:
         return false;
      }
      ahead++;
   }
   return false;
}

static ast_Expr* c2_parser_Parser_parseSizeof(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* res = NULL;
   _Bool has_brackets = false;
   src_loc_SrcLoc type_loc = p->tok.loc;
   if (c2_parser_Parser_parseAsType(p, &has_brackets)) {
      if (has_brackets) {
         while ((p->tok.kind != token_Kind_LSquare)) c2_parser_Parser_consumeToken(p);
         c2_parser_Parser_error(p, "arrays or subscripts expressions are not allowed inside a sizeof expression");
      }
      ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
      c2_parser_Parser_parseTypeSpecifier(p, &ref, false, true);
      uint32_t src_len = (p->prev_loc - type_loc);
      res = ast_builder_Builder_actOnTypeExpr(p->builder, type_loc, src_len, &ref);
   } else {
      if ((p->tok.kind != token_Kind_Identifier)) {
         c2_parser_Parser_error(p, "expect a type or variable name");
      }
      res = c2_parser_Parser_parseFullIdentifier(p);
      while ((p->tok.kind == token_Kind_LSquare)) {
         src_loc_SrcLoc loc1 = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* idx = c2_parser_Parser_parseExpr(p);
         uint32_t src_len = ((p->tok.loc + 1) - loc1);
         c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
         res = ast_builder_Builder_actOnArraySubscriptExpr(p->builder, loc1, src_len, res, idx);
      }
   }
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnBuiltinExpr(p->builder, loc, src_len, res, ast_BuiltinExprKind_Sizeof);
}

static ast_Expr* c2_parser_Parser_parseElemsof(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   c2_parser_Parser_expectIdentifier(p);
   ast_Expr* res = c2_parser_Parser_parseFullIdentifier(p);
   res = c2_parser_Parser_parsePostfixExprSuffix(p, res, false);
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnBuiltinExpr(p->builder, loc, src_len, res, ast_BuiltinExprKind_Elemsof);
}

static ast_Expr* c2_parser_Parser_parseInitValue(c2_parser_Parser* p, _Bool* need_semi, _Bool allow_designators)
{
   switch (p->tok.kind) {
   case token_Kind_LBrace:
      *need_semi = false;
      return c2_parser_Parser_parseInitList(p);
   case token_Kind_Dot:
      if (!allow_designators) c2_parser_Parser_error(p, "designator not allowed here");
      return c2_parser_Parser_parseFieldDesignator(p, need_semi);
   case token_Kind_LSquare:
      if (!allow_designators) c2_parser_Parser_error(p, "designator not allowed here");
      return c2_parser_Parser_parseArrayDesignator(p, need_semi);
   default:
      break;
   }
   *need_semi = true;
   return c2_parser_Parser_parseAssignmentExpression(p);
}

static ast_Expr* c2_parser_Parser_parseInitList(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   ast_ExprList values; ast_ExprList_init(&values);
   while ((p->tok.kind != token_Kind_RBrace)) {
      _Bool unused;
      ast_Expr* e = c2_parser_Parser_parseInitValue(p, &unused, true);
      ast_ExprList_add(&values, e);
      if ((p->tok.kind == token_Kind_Comma)) {
         c2_parser_Parser_consumeToken(p);
      } else {
         break;
      }
   }
   if ((p->tok.kind == token_Kind_LBrace)) c2_parser_Parser_expect(p, token_Kind_Comma);
   src_loc_SrcLoc endLoc = (p->tok.loc + 1);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_Expr* e = ast_builder_Builder_actOnInitList(p->builder, loc, endLoc, ast_ExprList_getExprs(&values), ast_ExprList_size(&values));
   ast_ExprList_free(&values);
   return e;
}

static ast_Expr* c2_parser_Parser_parseFieldDesignator(c2_parser_Parser* p, _Bool* need_semi)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t field = p->tok.name_idx;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Equal);
   ast_Expr* value = c2_parser_Parser_parseInitValue(p, need_semi, false);
   return ast_builder_Builder_actOnFieldDesignatedInit(p->builder, loc, field, value);
}

static ast_Expr* c2_parser_Parser_parseArrayDesignator(c2_parser_Parser* p, _Bool* need_semi)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Expr* designator = c2_parser_Parser_parseAssignmentExpression(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Equal);
   ast_Expr* initValue = c2_parser_Parser_parseInitValue(p, need_semi, false);
   return ast_builder_Builder_actOnArrayDesignatedInit(p->builder, loc, designator, initValue);
}

static ast_Expr* c2_parser_Parser_parseExplicitCastExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Less);
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref, true, false);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Greater);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* expr = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnExplicitCast(p->builder, loc, src_len, &ref, expr, false);
}

static ast_Expr* c2_parser_Parser_parseEnumMinMax(c2_parser_Parser* p, _Bool is_min)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   c2_parser_Parser_expectIdentifier(p);
   ast_Expr* expr = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnBuiltinExpr(p->builder, loc, src_len, expr, is_min ? ast_BuiltinExprKind_EnumMin : ast_BuiltinExprKind_EnumMax);
}

static ast_Expr* c2_parser_Parser_parseOffsetOfExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* structExpr = c2_parser_Parser_parseFullIdentifier(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* member = c2_parser_Parser_parseFullIdentifier(p);
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnOffsetOfExpr(p->builder, loc, src_len, structExpr, member);
}

static ast_Expr* c2_parser_Parser_parseToContainerExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* structExpr = c2_parser_Parser_parseFullIdentifier(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* member = c2_parser_Parser_parseFullIdentifier(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* pointer = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = ((p->tok.loc + 1) - loc);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnToContainerExpr(p->builder, loc, src_len, structExpr, member, pointer);
}

static ast_Expr* c2_parser_Parser_parseFullIdentifier(c2_parser_Parser* p)
{
   c2_parser_Parser_expectIdentifier(p);
   if ((c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 1, NULL) == token_Kind_Dot)) {
      return c2_parser_Parser_parsePureMemberExpr(p);
   }
   return ast_IdentifierExpr_asExpr(c2_parser_Parser_parseIdentifier(p));
}

static _Bool c2_parser_Parser_parseAsType(c2_parser_Parser* p, _Bool* has_brackets)
{
   const token_Kind kind = p->tok.kind;
   if (((kind >= token_Kind_KW_bool) && (kind <= token_Kind_KW_void))) return true;

   if ((p->tok.kind != token_Kind_Identifier)) return false;

   uint32_t lookahead = 1;
   while (1) {
      switch (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, lookahead, NULL)) {
      case token_Kind_Identifier:
         break;
      case token_Kind_Star:
         return true;
      case token_Kind_Dot:
         break;
      case token_Kind_LSquare:
         *has_brackets = true;
         return true;
      case token_Kind_Less:
         return true;
      default:
         return false;
      }
      lookahead++;
   }
   return false;
}

static uint32_t c2_parser_Parser_parseAsCastType(c2_parser_Parser* p, uint32_t ahead, token_Kind close_tok, _Bool* brackets)
{
   token_Token t2 = p->tok;
   _Bool is_lower = false;
   _Bool ambiguous = true;
   for (;;) {
      if (ahead) c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, &t2);
      ahead++;
      token_Kind kind = t2.kind;
      if (((kind == token_Kind_KW_const) || (kind == token_Kind_KW_volatile))) {
         ambiguous = false;
         continue;
      }
      if (((kind >= token_Kind_KW_bool) && (kind <= token_Kind_KW_void))) {
         ambiguous = false;
         break;
      }
      if ((kind != token_Kind_Identifier)) return 0;

      for (;;) {
         is_lower = islower(string_pool_Pool_idx2str(p->pool, t2.name_idx)[0]);
         if ((c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, NULL) != token_Kind_Dot)) break;

         ahead++;
         if ((c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, &t2) != token_Kind_Identifier)) return 0;

         ahead++;
      }
      break;
   }
   int32_t stars = 0;
   while (1) {
      switch (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, NULL)) {
      case token_Kind_Star:
         if ((stars < 0)) return 0;

         if ((stars > 0)) ambiguous = false;
         stars++;
         ahead++;
         break;
      case token_Kind_RParen:
         if ((close_tok != token_Kind_RParen)) return 0;

         ahead++;
         if (!ambiguous) return ahead;

         switch (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, ahead, NULL)) {
         case token_Kind_Identifier:
            fallthrough;
         case token_Kind_IntegerLiteral:
            fallthrough;
         case token_Kind_FloatLiteral:
            fallthrough;
         case token_Kind_CharLiteral:
            fallthrough;
         case token_Kind_StringLiteral:
            fallthrough;
         case token_Kind_Tilde:
            fallthrough;
         case token_Kind_Exclaim:
            fallthrough;
         case token_Kind_KW_cast:
            fallthrough;
         case token_Kind_KW_elemsof:
            fallthrough;
         case token_Kind_KW_enum_min:
            fallthrough;
         case token_Kind_KW_enum_max:
            fallthrough;
         case token_Kind_KW_false:
            fallthrough;
         case token_Kind_KW_true:
            fallthrough;
         case token_Kind_KW_nil:
            fallthrough;
         case token_Kind_KW_offsetof:
            fallthrough;
         case token_Kind_KW_sizeof:
            fallthrough;
         case token_Kind_KW_to_container:
            fallthrough;
         case token_Kind_LBrace:
            return ahead;
         case token_Kind_PlusPlus:
            fallthrough;
         case token_Kind_MinusMinus:
            fallthrough;
         case token_Kind_LParen:
            if (is_lower) return 0;

            return ahead;
         default:
            break;
         }
         return 0;
      case token_Kind_LSquare:
         if (!brackets) return 0;

         *brackets = true;
         ahead = c2_parser_Parser_skipArray(p, ahead);
         if (!ahead) return 0;

         stars = -1;
         break;
      case token_Kind_Less:
         ahead = c2_parser_Parser_parseAsCastType(p, ahead, token_Kind_Greater, NULL);
         if (!ahead) return 0;

         stars = 0;
         break;
      case token_Kind_Greater:
         if ((close_tok != token_Kind_Greater)) return 0;

         ahead++;
         return ahead;
      default:
         return 0;
      }
   }
   return 0;
}

static ast_Stmt* c2_parser_Parser_parseStmt(c2_parser_Parser* p)
{
   switch (p->tok.kind) {
   case token_Kind_Identifier:
      return c2_parser_Parser_parseDeclOrStmt(p);
   case token_Kind_LBrace:
      return ((ast_Stmt*)(c2_parser_Parser_parseCompoundStmt(p)));
   case token_Kind_RBrace:
      c2_parser_Parser_error(p, "expected stmt");
      break;
   case token_Kind_KW_asm:
      return c2_parser_Parser_parseAsmStmt(p);
   case token_Kind_KW_assert:
      return c2_parser_Parser_parseAssertStmt(p);
   case token_Kind_KW_break:
      return c2_parser_Parser_parseBreakStmt(p);
   case token_Kind_KW_continue:
      return c2_parser_Parser_parseContinueStmt(p);
   case token_Kind_KW_fallthrough:
      return c2_parser_Parser_parseFallthroughStmt(p);
   case token_Kind_KW_for:
      return c2_parser_Parser_parseForStmt(p);
   case token_Kind_KW_goto:
      return c2_parser_Parser_parseGotoStmt(p);
   case token_Kind_KW_if:
      return c2_parser_Parser_parseIfStmt(p);
   case token_Kind_KW_return:
      return c2_parser_Parser_parseReturnStmt(p);
   case token_Kind_KW_switch:
      return c2_parser_Parser_parseSwitchStmt(p);
   case token_Kind_KW_bool:
      fallthrough;
   case token_Kind_KW_char:
      fallthrough;
   case token_Kind_KW_const:
      fallthrough;
   case token_Kind_KW_i8:
      fallthrough;
   case token_Kind_KW_i16:
      fallthrough;
   case token_Kind_KW_i32:
      fallthrough;
   case token_Kind_KW_i64:
      fallthrough;
   case token_Kind_KW_isize:
      fallthrough;
   case token_Kind_KW_f32:
      fallthrough;
   case token_Kind_KW_f64:
      fallthrough;
   case token_Kind_KW_local:
      fallthrough;
   case token_Kind_KW_reg8:
      fallthrough;
   case token_Kind_KW_reg16:
      fallthrough;
   case token_Kind_KW_reg32:
      fallthrough;
   case token_Kind_KW_reg64:
      fallthrough;
   case token_Kind_KW_u8:
      fallthrough;
   case token_Kind_KW_u16:
      fallthrough;
   case token_Kind_KW_u32:
      fallthrough;
   case token_Kind_KW_u64:
      fallthrough;
   case token_Kind_KW_usize:
      fallthrough;
   case token_Kind_KW_volatile:
      fallthrough;
   case token_Kind_KW_void:
      return c2_parser_Parser_parseDeclStmt(p, true, true);
   case token_Kind_KW_while:
      return c2_parser_Parser_parseWhileStmt(p);
   default:
      return c2_parser_Parser_parseExprStmt(p);
   }
   return NULL;
}

static _Bool c2_parser_Parser_isTypeSpec(c2_parser_Parser* p)
{
   ((p->tok.kind == token_Kind_Identifier)) || c2_assert("parser/c2_parser_stmt.c2", 104, "c2_parser.Parser.isTypeSpec", "p.tok.kind == Kind.Identifier");
   token_Kind kind;
   uint32_t state = 0;
   uint32_t lookahead = 1;
   while (1) {
      switch (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, lookahead, NULL)) {
      case token_Kind_Identifier:
         if ((state == 4)) return false;

         state = 4;
         lookahead++;
         break;
      case token_Kind_LSquare:
         if ((state == 4)) return false;

         lookahead = c2_parser_Parser_skipArray(p, lookahead);
         state = 3;
         break;
      case token_Kind_Star:
         if ((state >= 3)) return false;

         state = 2;
         lookahead++;
         break;
      case token_Kind_Dot:
         if ((state == 4)) {
            return true;
         }
         if ((state == 0)) {
            kind = c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, (lookahead + 1), NULL);
            if ((kind != token_Kind_Identifier)) {
               return false;
            }
            state = 2;
            lookahead += 2;
         } else {
            return false;
         }
         break;
      case token_Kind_Equal:
         fallthrough;
      case token_Kind_Semicolon:
         return (state == 4);
      default:
         return false;
      }
   }
   return false;
}

static uint32_t c2_parser_Parser_skipArray(c2_parser_Parser* p, uint32_t lookahead)
{
   lookahead++;
   uint32_t square_depth = 1;
   uint32_t paren_depth = 0;
   while (square_depth) {
      token_Token next;
      switch (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, lookahead, &next)) {
      case token_Kind_LParen:
         paren_depth++;
         break;
      case token_Kind_RParen:
         if ((paren_depth == 0)) {
            p->tok.loc = next.loc;
            c2_parser_Parser_error(p, "expected ']'");
         }
         paren_depth--;
         break;
      case token_Kind_LSquare:
         square_depth++;
         break;
      case token_Kind_RSquare:
         square_depth--;
         break;
      case token_Kind_Eof:
         p->tok.loc = next.loc;
         c2_parser_Parser_error(p, "unexpected end-of-file");
         break;
      default:
         break;
      }
      lookahead++;
   }
   return lookahead;
}

static ast_Stmt* c2_parser_Parser_parseDeclOrStmt(c2_parser_Parser* p)
{
   ((p->tok.kind == token_Kind_Identifier)) || c2_assert("parser/c2_parser_stmt.c2", 206, "c2_parser.Parser.parseDeclOrStmt", "p.tok.kind == Kind.Identifier");
   _Bool isDecl = c2_parser_Parser_isTypeSpec(p);
   if (isDecl) return c2_parser_Parser_parseDeclStmt(p, true, true);

   token_Kind kind = c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 1, NULL);
   if ((kind == token_Kind_Colon)) return c2_parser_Parser_parseLabelStmt(p);

   return c2_parser_Parser_parseExprStmt(p);
}

static ast_CompoundStmt* c2_parser_Parser_parseCompoundStmt(c2_parser_Parser* p)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   stmt_list_List stmts; stmt_list_List_init(&stmts);
   while ((p->tok.kind != token_Kind_RBrace)) {
      stmt_list_List_add(&stmts, c2_parser_Parser_parseStmt(p));
   }
   src_loc_SrcLoc endLoc = (p->tok.loc + 1);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_CompoundStmt* s = ast_builder_Builder_actOnCompoundStmt(p->builder, endLoc, stmt_list_List_getData(&stmts), stmt_list_List_size(&stmts));
   stmt_list_List_free(&stmts);
   return s;
}

static ast_Stmt* c2_parser_Parser_parseAsmStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   uint32_t quals = c2_parser_Parser_parseOptionalTypeQualifier(p);
   _Bool is_volatile = ((quals == ast_QualType_Volatile));
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   c2_parser_Parser_expect(p, token_Kind_StringLiteral);
   ast_Expr* str = c2_parser_Parser_parseStringLiteral(p);
   ast_ExprList constraints; ast_ExprList_init(&constraints);
   ast_ExprList exprs; ast_ExprList_init(&exprs);
   ast_ExprList clobbers; ast_ExprList_init(&clobbers);
   if ((p->tok.kind == token_Kind_RParen)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
      ast_Stmt* s = ast_builder_Builder_actOnAsmStmt(p->builder, loc, true, is_volatile, 0, 0, NULL, &constraints, &exprs, &clobbers, str);
      ast_ExprList_free(&constraints);
      ast_ExprList_free(&exprs);
      ast_ExprList_free(&clobbers);
      return s;
   }
   string_list_List names; string_list_List_init(&names, p->pool);
   if ((p->tok.kind == token_Kind_Colon)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_parseAsmOperandsOpt(p, &names, &constraints, &exprs);
   }
   uint32_t num_outputs = string_list_List_length(&names);
   if ((p->tok.kind == token_Kind_Colon)) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_parseAsmOperandsOpt(p, &names, &constraints, &exprs);
   }
   uint32_t num_inputs = (string_list_List_length(&names) - num_outputs);
   if ((p->tok.kind == token_Kind_Colon)) {
      c2_parser_Parser_consumeToken(p);
      if ((p->tok.kind != token_Kind_RParen)) {
         while (1) {
            c2_parser_Parser_expect(p, token_Kind_StringLiteral);
            ast_Expr* e = c2_parser_Parser_parseStringLiteral(p);
            ast_ExprList_add(&clobbers, e);
            if ((p->tok.kind != token_Kind_Comma)) break;

            c2_parser_Parser_consumeToken(p);
         }
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_Stmt* s = ast_builder_Builder_actOnAsmStmt(p->builder, loc, false, is_volatile, num_outputs, num_inputs, string_list_List_getData(&names), &constraints, &exprs, &clobbers, str);
   string_list_List_free(&names);
   ast_ExprList_free(&constraints);
   ast_ExprList_free(&exprs);
   ast_ExprList_free(&clobbers);
   return s;
}

static void c2_parser_Parser_parseAsmOperandsOpt(c2_parser_Parser* p, string_list_List* names, ast_ExprList* constraints, ast_ExprList* exprs)
{
   if (((p->tok.kind != token_Kind_StringLiteral) && (p->tok.kind != token_Kind_LSquare))) return;

   while (1) {
      if ((p->tok.kind == token_Kind_LSquare)) {
         c2_parser_Parser_consumeToken(p);
         c2_parser_Parser_expectIdentifier(p);
         uint32_t name = p->tok.name_idx;
         c2_parser_Parser_consumeToken(p);
         string_list_List_add(names, name);
         c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
      } else {
         string_list_List_add(names, 0);
      }
      c2_parser_Parser_expect(p, token_Kind_StringLiteral);
      ast_Expr* e = c2_parser_Parser_parseStringLiteral(p);
      ast_ExprList_add(constraints, e);
      c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
      e = c2_parser_Parser_parseExpr(p);
      c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
      ast_ExprList_add(exprs, e);
      if ((p->tok.kind != token_Kind_Comma)) return;

      c2_parser_Parser_consumeToken(p);
   }
}

static ast_Stmt* c2_parser_Parser_parseAssertStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* inner = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnAssertStmt(p->builder, loc, inner);
}

static ast_Stmt* c2_parser_Parser_parseBreakStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnBreakStmt(p->builder, loc);
}

static ast_Stmt* c2_parser_Parser_parseContinueStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnContinueStmt(p->builder, loc);
}

static ast_Stmt* c2_parser_Parser_parseFallthroughStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnFallthroughStmt(p->builder, loc);
}

static ast_Stmt* c2_parser_Parser_parseCondition(c2_parser_Parser* p)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Stmt* s;
   if (c2_parser_Parser_isDeclaration(p)) {
      s = c2_parser_Parser_parseDeclStmt(p, false, false);
   } else {
      ast_Expr* cond = c2_parser_Parser_parseExpr(p);
      s = ast_Expr_asStmt(cond);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return s;
}

static ast_Stmt* c2_parser_Parser_parseIfStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Stmt* cond = c2_parser_Parser_parseCondition(p);
   ast_Stmt* then = c2_parser_Parser_parseStmt(p);
   ast_Stmt* else_stmt = NULL;
   if ((p->tok.kind == token_Kind_KW_else)) {
      c2_parser_Parser_consumeToken(p);
      else_stmt = c2_parser_Parser_parseStmt(p);
   }
   return ast_builder_Builder_actOnIfStmt(p->builder, loc, cond, then, else_stmt);
}

static ast_Stmt* c2_parser_Parser_parseReturnStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Expr* ret = NULL;
   if ((p->tok.kind != token_Kind_Semicolon)) {
      if ((p->tok.kind == token_Kind_LBrace)) {
         ret = c2_parser_Parser_parseInitList(p);
      } else {
         ret = c2_parser_Parser_parseExpr(p);
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnReturnStmt(p->builder, loc, ret);
}

static ast_Stmt* c2_parser_Parser_parseForStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Stmt* init = NULL;
   if ((p->tok.kind != token_Kind_Semicolon)) {
      if (c2_parser_Parser_isDeclaration(p)) {
         init = c2_parser_Parser_parseDeclStmt(p, false, false);
      } else {
         init = ast_Expr_asStmt(c2_parser_Parser_parseExpr(p));
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_Expr* cond = NULL;
   if ((p->tok.kind != token_Kind_Semicolon)) {
      cond = c2_parser_Parser_parseExpr(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_Expr* incr = NULL;
   if ((p->tok.kind != token_Kind_RParen)) {
      incr = c2_parser_Parser_parseExpr(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   ast_Stmt* body = c2_parser_Parser_parseStmt(p);
   return ast_builder_Builder_actOnForStmt(p->builder, loc, init, cond, incr, body);
}

static ast_Stmt* c2_parser_Parser_parseWhileStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Stmt* cond = c2_parser_Parser_parseCondition(p);
   ast_Stmt* then = c2_parser_Parser_parseStmt(p);
   return ast_builder_Builder_actOnWhileStmt(p->builder, loc, cond, then);
}

static ast_Stmt* c2_parser_Parser_parseDeclStmt(c2_parser_Parser* p, _Bool checkSemi, _Bool allowLocal)
{
   _Bool has_local = false;
   if ((p->tok.kind == token_Kind_KW_local)) {
      has_local = true;
      if (!allowLocal) c2_parser_Parser_error(p, "keyword 'local' is not allowed here");
      c2_parser_Parser_consumeToken(p);
   }
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref, true, true);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   _Bool has_init_call = false;
   _Bool need_semi = true;
   ast_Expr* initValue = NULL;
   src_loc_SrcLoc assignLoc = 0;
   switch (p->tok.kind) {
   case token_Kind_Equal:
      assignLoc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      initValue = c2_parser_Parser_parseInitValue(p, &need_semi, false);
      break;
   case token_Kind_Dot:
      if (((c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 1, NULL) == token_Kind_Identifier) && (c2_tokenizer_Tokenizer_lookahead(&p->tokenizer, 2, NULL) == token_Kind_LParen))) {
         if (has_local) c2_parser_Parser_error(p, "local qualified variables cannot have an init call");
         if (!checkSemi) c2_parser_Parser_error(p, "cannot use an init call inside a condition");
         c2_parser_Parser_consumeToken(p);
         ast_Ref refs[2];
         refs[0].loc = loc;
         refs[0].name_idx = name;
         refs[1].loc = p->tok.loc;
         refs[1].name_idx = p->tok.name_idx;
         ast_Expr* func = ast_builder_Builder_actOnMemberExpr(p->builder, NULL, refs, 2);
         c2_parser_Parser_consumeToken(p);
         initValue = c2_parser_Parser_parseCallExpr(p, func);
         has_init_call = true;
         break;
      }
      break;
   case token_Kind_LSquare:
      c2_parser_Parser_error(p, "array indices should go after type");
      break;
   default:
      break;
   }
   if (checkSemi) {
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   }
   return ast_builder_Builder_actOnVarDeclStmt(p->builder, name, loc, &ref, assignLoc, initValue, has_local, has_init_call);
}

static void c2_parser_Parser_consumeSemicolon(c2_parser_Parser* p, _Bool need_semi)
{
   if (need_semi) {
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   } else {
      if (((p->tok.kind == token_Kind_Semicolon) && (p->tok.loc == p->prev_loc))) {
         diagnostics_Diags_error(p->diags, p->tok.loc, "semicolon is not accepted after initializer");
         c2_parser_Parser_consumeToken(p);
      }
   }
}

static ast_Stmt* c2_parser_Parser_parseExprStmt(c2_parser_Parser* p)
{
   ast_Expr* e = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_Expr_asStmt(e);
}

static ast_Stmt* c2_parser_Parser_parseLabelStmt(c2_parser_Parser* p)
{
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Colon);
   ast_Stmt* stmt = NULL;
   switch (p->tok.kind) {
   case token_Kind_RBrace:
      fallthrough;
   case token_Kind_KW_case:
      fallthrough;
   case token_Kind_KW_default:
      fallthrough;
   case token_Kind_KW_fallthrough:
      break;
   default:
      stmt = c2_parser_Parser_parseStmt(p);
      break;
   }
   return ast_builder_Builder_actOnLabelStmt(p->builder, name, loc, stmt);
}

static ast_Stmt* c2_parser_Parser_parseGotoStmt(c2_parser_Parser* p)
{
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnGotoStmt(p->builder, name, loc);
}

static _Bool c2_parser_Parser_isDeclaration(c2_parser_Parser* p)
{
   const token_Kind kind = p->tok.kind;
   if ((kind == token_Kind_Identifier)) return c2_parser_Parser_isTypeSpec(p);

   if (((kind >= token_Kind_KW_bool) && (kind <= token_Kind_KW_void))) return true;

   if ((kind == token_Kind_KW_local)) return true;

   if (((kind == token_Kind_KW_const) || (kind == token_Kind_KW_volatile))) return true;

   return false;
}

static ast_Stmt* c2_parser_Parser_parseSwitchStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   if (c2_parser_Parser_isDeclaration(p)) {
      c2_parser_Parser_error(p, "declarations inside a switch condition are not allowed");
   }
   ast_Expr* cond = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   case_list_List cases; case_list_List_init(&cases);
   _Bool has_default = false;
   while ((p->tok.kind != token_Kind_RBrace)) {
      ast_SwitchCase* c = NULL;
      switch (p->tok.kind) {
      case token_Kind_KW_case:
         c = c2_parser_Parser_parseCase(p, false);
         break;
      case token_Kind_KW_default:
         has_default = true;
         c = c2_parser_Parser_parseCase(p, true);
         break;
      default:
         c2_parser_Parser_error(p, "expected 'case' or 'default' keyword");
         break;
      }
      case_list_List_add(&cases, c);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_Stmt* s = ast_builder_Builder_actOnSwitchStmt(p->builder, loc, cond, case_list_List_getData(&cases), case_list_List_size(&cases), has_default);
   case_list_List_free(&cases);
   return s;
}

static void c2_parser_Parser_parseCaseCondition(c2_parser_Parser* p, expr_list_List* list)
{
   for (;;) {
      ast_Expr* e = c2_parser_Parser_parseExpr(p);
      if ((p->tok.kind == token_Kind_Ellipsis)) {
         src_loc_SrcLoc loc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* e1 = c2_parser_Parser_parseExpr(p);
         e = ast_builder_Builder_actOnRange(p->builder, loc, e, e1);
      }
      expr_list_List_add(list, e);
      if ((p->tok.kind == token_Kind_Colon)) break;

      c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   }
}

static ast_SwitchCase* c2_parser_Parser_parseCase(c2_parser_Parser* p, _Bool is_default)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   expr_list_List conds; expr_list_List_init(&conds);
   if (!is_default) {
      c2_parser_Parser_parseCaseCondition(p, &conds);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Colon);
   stmt_list_List stmts; stmt_list_List_init(&stmts);
   _Bool more = true;
   while (more) {
      switch (p->tok.kind) {
      case token_Kind_RBrace:
         fallthrough;
      case token_Kind_KW_case:
         fallthrough;
      case token_Kind_KW_default:
         more = false;
         break;
      default:
         stmt_list_List_add(&stmts, c2_parser_Parser_parseStmt(p));
         break;
      }
   }
   ast_SwitchCase* s = ast_builder_Builder_actOnCase(p->builder, loc, is_default, expr_list_List_getData(&conds), expr_list_List_size(&conds), stmt_list_List_getData(&stmts), stmt_list_List_size(&stmts));
   expr_list_List_free(&conds);
   stmt_list_List_free(&stmts);
   return s;
}

static void c2_parser_Parser_parseTypeDecl(c2_parser_Parser* p, _Bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t type_name = p->tok.name_idx;
   src_loc_SrcLoc type_loc = p->tok.loc;
   const char* name = string_pool_Pool_idx2str(p->pool, type_name);
   if ((!isupper(name[0]) && !p->is_interface)) c2_parser_Parser_error(p, "a type name must start with an upper case character");
   c2_parser_Parser_consumeToken(p);
   switch (p->tok.kind) {
   case token_Kind_KW_fn:
      c2_parser_Parser_parseFunctionType(p, type_name, type_loc, is_public);
      break;
   case token_Kind_KW_struct:
      c2_parser_Parser_parseStructType(p, true, type_name, type_loc, is_public);
      break;
   case token_Kind_KW_union:
      c2_parser_Parser_parseStructType(p, false, type_name, type_loc, is_public);
      break;
   case token_Kind_KW_enum:
      c2_parser_Parser_parseEnumType(p, type_name, type_loc, is_public);
      break;
   default:
      c2_parser_Parser_parseAliasType(p, type_name, type_loc, is_public);
      break;
   }
}

static void c2_parser_Parser_parseFunctionType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, _Bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   ast_TypeRefHolder rtype; ast_TypeRefHolder_init(&rtype);
   c2_parser_Parser_parseSingleTypeSpecifier(p, &rtype, true);
   ast_DeclList params; ast_DeclList_init(&params);
   _Bool is_variadic = c2_parser_Parser_parseFunctionParams(p, &params, is_public);
   ast_Decl* f = ast_builder_Builder_actOnFunctionTypeDecl(p->builder, name, loc, is_public, &rtype, ((ast_VarDecl**)(ast_DeclList_getDecls(&params))), ast_DeclList_size(&params), is_variadic);
   c2_parser_Parser_parseOptionalAttributes(p);
   ast_DeclList_free(&params);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_builder_Builder_applyAttributes(p->builder, f);
}

static void c2_parser_Parser_parseStructType(c2_parser_Parser* p, _Bool is_struct, uint32_t name, src_loc_SrcLoc loc, _Bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_parseOptionalAttributes(p);
   ast_DeclList members; ast_DeclList_init(&members);
   c2_parser_Parser_parseStructBlock(p, &members, is_public);
   ast_StructTypeDecl* d = ast_builder_Builder_actOnStructType(p->builder, name, loc, is_public, is_struct, true, ast_DeclList_getDecls(&members), ast_DeclList_size(&members));
   ast_DeclList_free(&members);
   ast_builder_Builder_applyAttributes(p->builder, ((ast_Decl*)(d)));
}

static void c2_parser_Parser_parseStructBlock(c2_parser_Parser* p, ast_DeclList* members, _Bool is_public)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   while (1) {
      if ((p->tok.kind == token_Kind_RBrace)) break;

      if (((p->tok.kind == token_Kind_KW_union) || (p->tok.kind == token_Kind_KW_struct))) {
         _Bool is_struct = (p->tok.kind == token_Kind_KW_struct);
         c2_parser_Parser_consumeToken(p);
         uint32_t name = 0;
         src_loc_SrcLoc loc = 0;
         if ((p->tok.kind == token_Kind_Identifier)) {
            name = p->tok.name_idx;
            loc = p->tok.loc;
            if (!c2_parser_checkName(string_pool_Pool_idx2str(p->pool, name), p->is_interface)) {
               c2_parser_Parser_error(p, "a struct/union member name must start with a lower case character");
            }
            c2_parser_Parser_consumeToken(p);
         }
         ast_DeclList sub_members; ast_DeclList_init(&sub_members);
         c2_parser_Parser_parseStructBlock(p, &sub_members, is_public);
         ast_StructTypeDecl* member = ast_builder_Builder_actOnStructType(p->builder, name, loc, is_public, is_struct, false, ast_DeclList_getDecls(&sub_members), ast_DeclList_size(&sub_members));
         ast_DeclList_free(&sub_members);
         ast_DeclList_add(members, ast_StructTypeDecl_asDecl(member));
      } else {
         ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
         c2_parser_Parser_parseTypeSpecifier(p, &ref, true, true);
         uint32_t name = 0;
         src_loc_SrcLoc loc;
         if ((p->tok.kind == token_Kind_Colon)) {
            loc = p->tok.loc;
         } else {
            c2_parser_Parser_expectIdentifier(p);
            name = p->tok.name_idx;
            loc = p->tok.loc;
            if (!c2_parser_checkName(string_pool_Pool_idx2str(p->pool, name), p->is_interface)) {
               c2_parser_Parser_error(p, "a struct/union member name must start with a lower case character");
            }
            c2_parser_Parser_consumeToken(p);
         }
         ast_Expr* bitfield = NULL;
         if ((p->tok.kind == token_Kind_Colon)) {
            c2_parser_Parser_consumeToken(p);
            bitfield = c2_parser_Parser_parseExpr(p);
         }
         ast_VarDecl* member = ast_builder_Builder_actOnStructMember(p->builder, name, loc, is_public, &ref, bitfield);
         ast_DeclList_add(members, ast_VarDecl_asDecl(member));
         c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
}

static void c2_parser_Parser_parseEnumType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, _Bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   switch (p->tok.kind) {
   case token_Kind_KW_char:
      fallthrough;
   case token_Kind_KW_f32:
      fallthrough;
   case token_Kind_KW_f64:
      c2_parser_Parser_error(p, "enum type must be an integer");
      break;
   case token_Kind_KW_i8:
      fallthrough;
   case token_Kind_KW_i16:
      fallthrough;
   case token_Kind_KW_i32:
      fallthrough;
   case token_Kind_KW_i64:
      fallthrough;
   case token_Kind_KW_isize:
      break;
   case token_Kind_KW_reg8:
      fallthrough;
   case token_Kind_KW_reg16:
      fallthrough;
   case token_Kind_KW_reg32:
      fallthrough;
   case token_Kind_KW_reg64:
      c2_parser_Parser_error(p, "enum type must be an integer");
      break;
   case token_Kind_KW_u8:
      fallthrough;
   case token_Kind_KW_u16:
      fallthrough;
   case token_Kind_KW_u32:
      fallthrough;
   case token_Kind_KW_u64:
      fallthrough;
   case token_Kind_KW_usize:
      break;
   case token_Kind_KW_void:
      c2_parser_Parser_error(p, "enum type must be an integer");
      break;
   default:
      c2_parser_Parser_error(p, "expected enum type specifier");
      break;
   }
   ast_QualType implType = ast_builder_Builder_actOnBuiltinType(p->builder, c2_parser_tokKindToBuiltinKind(p->tok.kind));
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_parseOptionalAttributes(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   _Bool is_incr = false;
   ast_DeclList constants; ast_DeclList_init(&constants);
   if ((p->tok.kind == token_Kind_Plus)) {
      is_incr = true;
      c2_parser_Parser_consumeToken(p);
   } else {
      while ((p->tok.kind == token_Kind_Identifier)) {
         uint32_t const_name = p->tok.name_idx;
         const char* name_str = string_pool_Pool_idx2str(p->pool, const_name);
         if (islower(name_str[0])) {
            c2_parser_Parser_error(p, "an enum constant name must start with an upper case character");
         }
         src_loc_SrcLoc const_loc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* init_expr = NULL;
         if ((p->tok.kind == token_Kind_Equal)) {
            c2_parser_Parser_consumeToken(p);
            init_expr = c2_parser_Parser_parseExpr(p);
         }
         ast_EnumConstantDecl* constant = ast_builder_Builder_actOnEnumConstant(p->builder, const_name, const_loc, is_public, init_expr);
         ast_DeclList_add(&constants, ast_EnumConstantDecl_asDecl(constant));
         if ((p->tok.kind != token_Kind_Comma)) break;

         c2_parser_Parser_consumeToken(p);
      }
      if ((ast_DeclList_size(&constants) == 0)) {
         c2_parser_Parser_error(p, "enum without constants");
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_Decl* d = ast_builder_Builder_actOnEnumType(p->builder, name, loc, is_public, is_incr, implType, ((ast_EnumConstantDecl**)(ast_DeclList_getDecls(&constants))), ast_DeclList_size(&constants));
   ast_DeclList_free(&constants);
   ast_builder_Builder_applyAttributes(p->builder, d);
}

static void c2_parser_Parser_parseAliasType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, _Bool is_public)
{
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref, true, true);
   ast_Decl* d = ast_builder_Builder_actOnAliasType(p->builder, name, loc, is_public, &ref);
   c2_parser_Parser_parseOptionalAttributes(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_builder_Builder_applyAttributes(p->builder, d);
}


// --- module module_analyser ---
typedef struct module_analyser_Analyser_ module_analyser_Analyser;
typedef struct module_analyser_StackLayer_ module_analyser_StackLayer;
typedef struct module_analyser_MainMarker_ module_analyser_MainMarker;
typedef struct module_analyser_FormatAnalyser_ module_analyser_FormatAnalyser;
typedef struct module_analyser_FieldInit_ module_analyser_FieldInit;
typedef struct module_analyser_StructFieldInitChecker_ module_analyser_StructFieldInitChecker;

struct module_analyser_StackLayer_ {
   ast_Decl* decl;
   scope_Scope* scope;
   ast_FunctionDecl* function;
   _Bool usedPublic;
};

#define module_analyser_MaxDepth 8
struct module_analyser_Analyser_ {
   diagnostics_Diags* diags;
   conversion_checker_Checker checker;
   ast_context_Context* context;
   string_pool_Pool* astPool;
   ast_builder_Builder* builder;
   module_list_List* allmodules;
   const warning_flags_Flags* warnings;
   ast_Module* mod;
   _Bool usedPublic;
   uint32_t prefix_cache_name;
   uint32_t prefix_cache_idx;
   name_vector_NameVector prefixes;
   struct_func_list_List* type_fn_decls;
   incr_array_list_List* incr_values;
   label_vector_LabelVector labels;
   module_analyser_StackLayer checkStack[8];
   uint32_t checkIndex;
   scope_Scope* scope;
   ast_FunctionDecl* curFunction;
   _Bool has_error;
   uint32_t check_idx;
   init_checker_Checker init_checkers[4];
   uint32_t min_idx;
   uint32_t max_idx;
};

struct module_analyser_MainMarker_ {
   uint32_t name_idx;
   ast_Decl* main;
};

#define module_analyser_LHS 0x1
#define module_analyser_RHS 0x2
static module_analyser_Analyser* module_analyser_create(diagnostics_Diags* diags, ast_context_Context* context, string_pool_Pool* astPool, ast_builder_Builder* builder, module_list_List* allmodules, const warning_flags_Flags* warnings);
static void module_analyser_Analyser_free(module_analyser_Analyser* ma);
static void module_analyser_Analyser_check(module_analyser_Analyser* ma, ast_Module* mod);
static init_checker_Checker* module_analyser_Analyser_getInitChecker(module_analyser_Analyser* ma);
static void module_analyser_Analyser_putInitChecker(module_analyser_Analyser* ma, init_checker_Checker* c);
static void module_analyser_Analyser_collectTypeFunctions(module_analyser_Analyser* ma);
static void module_analyser_Analyser_handleArrayValue(void* arg, ast_ArrayValue* avd);
static void module_analyser_Analyser_collectIncrementalArrays(module_analyser_Analyser* ma);
static void module_analyser_Analyser_handleIncrEntry(module_analyser_Analyser* ma, incr_array_list_Info* entry);
static void module_analyser_Analyser_handleImport(void* arg, ast_ImportDecl* id);
static void module_analyser_Analyser_setMod(module_analyser_Analyser* ma, ast_Module* mod);
__attribute__((__format__(printf, 3, 4))) 
static void module_analyser_Analyser_note(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...);
__attribute__((__format__(printf, 3, 4))) 
static void module_analyser_Analyser_warn(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...);
__attribute__((__format__(printf, 3, 4))) 
static void module_analyser_Analyser_error(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...);
__attribute__((__format__(printf, 4, 5))) 
static void module_analyser_Analyser_errorRange(module_analyser_Analyser* ma, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...);
static void module_analyser_Analyser_createGlobalScope(void* arg, ast_AST* a);
static void module_analyser_Analyser_deleteScope(void* _arg0, ast_AST* a);
static void module_analyser_Analyser_handleStructFunc(void* arg, ast_FunctionDecl* fd);
static void module_analyser_Analyser_analyseFunctionProto(void* arg, ast_FunctionDecl* d);
static void module_analyser_Analyser_analyseFunctionBodies(void* arg, ast_FunctionDecl* d);
static _Bool module_analyser_Analyser_analyseGlobalDecl(module_analyser_Analyser* ma, ast_Decl* d);
static void module_analyser_Analyser_handleTypeDecl(void* arg, ast_Decl* d);
static void module_analyser_Analyser_handleStaticAssert(void* arg, ast_StaticAssert* d);
static void module_analyser_Analyser_handleVarDecl(void* arg, ast_VarDecl* v);
static void module_analyser_Analyser_checkName(module_analyser_Analyser* ma, ast_Decl* d, _Bool is_constant);
static void module_analyser_Analyser_analyseGlobalVarDecl(module_analyser_Analyser* ma, ast_VarDecl* v);
static void module_analyser_Analyser_checkVarDeclAttributes(module_analyser_Analyser* ma, ast_VarDecl* v);
static _Bool module_analyser_Analyser_pushCheck(module_analyser_Analyser* ma, ast_Decl* d, scope_Scope* s, ast_FunctionDecl* fd);
static void module_analyser_Analyser_popCheck(module_analyser_Analyser* ma);
static _Bool module_analyser_Analyser_globalScope(const module_analyser_Analyser* ma);
static void module_analyser_findMainFunction(void* arg, ast_FunctionDecl* fd);
static ast_Decl* module_analyser_Analyser_findMain(module_analyser_Analyser* ma, ast_Module* top, uint32_t name_idx);
static const uint32_t module_analyser_Binop_lhs[29] = {
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_LHS,
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS),
   (module_analyser_LHS | module_analyser_RHS)
};

static const uint8_t module_analyser_BinOpConvAddSubAss[8][8] = {
   {
   2,
   1,
   0,
   1,
   3,
   0,
   0,
   0
},
   {
   4,
   1,
   0,
   1,
   4,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   1,
   1,
   1,
   0,
   0
},
   {
   5,
   1,
   0,
   1,
   6,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   1,
   0,
   0,
   0,
   0
}
};

static const uint8_t module_analyser_BinOpConvAdd[8][8] = {
   {
   2,
   3,
   0,
   1,
   5,
   0,
   0,
   0
},
   {
   4,
   1,
   0,
   1,
   4,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   1,
   1,
   1,
   0,
   0
},
   {
   6,
   3,
   0,
   1,
   7,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   1,
   0,
   0,
   0,
   0
}
};

static const uint8_t module_analyser_BinOpConvSub[8][8] = {
   {
   2,
   1,
   0,
   1,
   2,
   0,
   0,
   0
},
   {
   4,
   5,
   0,
   1,
   4,
   6,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   1,
   1,
   1,
   0,
   0
},
   {
   6,
   1,
   0,
   1,
   7,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   1,
   0,
   0,
   0,
   0
}
};

static const uint8_t module_analyser_BinOpConvComparision[8][8] = {
   {
   2,
   1,
   0,
   1,
   4,
   0,
   0,
   0
},
   {
   1,
   3,
   0,
   1,
   1,
   7,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   1,
   1,
   1,
   0,
   0
},
   {
   5,
   1,
   0,
   1,
   6,
   1,
   0,
   0
},
   {
   1,
   8,
   1,
   1,
   1,
   9,
   0,
   0
}
};

static _Bool module_analyser_validBinOpKind(ast_QualType t);
static ast_QualType module_analyser_Analyser_checkBinopIntArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopLogical(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopAddSubAssign(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopAddArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopSubArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopComparison(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkPointerFuncComparison(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, ast_QualType lcanon, ast_QualType rcanon);
static ast_QualType module_analyser_Analyser_analyseBinaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static _Bool module_analyser_Analyser_checkShiftArgs(module_analyser_Analyser* ma, ast_Expr* lhs, ast_Expr* rhs);
static _Bool module_analyser_Analyser_checkZero(module_analyser_Analyser* ma, ast_Expr* e, const char* operation);
static _Bool module_analyser_Analyser_checkFloat(module_analyser_Analyser* ma, ast_Expr* lhs, ast_Expr* rhs, const char* operation);
static ast_QualType module_analyser_Analyser_analyseBuiltin(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static ast_QualType module_analyser_Analyser_analyseSizeof(module_analyser_Analyser* ma, ast_BuiltinExpr* e);
static ast_QualType module_analyser_Analyser_analyseElemsof(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_QualType module_analyser_Analyser_analyseEnumMinMax(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_QualType module_analyser_Analyser_analyseOffsetOf(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_QualType module_analyser_Analyser_analyseToContainer(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_Decl* module_analyser_Analyser_findMemberOffset(module_analyser_Analyser* ma, ast_BuiltinExpr* b, ast_StructTypeDecl* std, ast_Expr* member);
static ast_Decl* module_analyser_Analyser_findStructMemberOffset(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc, uint32_t* base);
struct module_analyser_FormatAnalyser_ {
   module_analyser_Analyser* ma;
   const char* format;
   uint32_t num_args;
   uint32_t idx;
   src_loc_SrcLoc loc;
   _Bool change_format;
   ast_Expr** args;
};

static const char module_analyser_DiagTooManyArgs[60] = "too many arguments to %sfunction call, expected %d, have %d";

static const char module_analyser_DiagTooFewArgs[59] = "too few arguments to %sfunction call, expected %d, have %d";

static const char module_analyser_NoteDeclaredHere[21] = "'%s' is defined here";

static ast_QualType module_analyser_Analyser_analyseCallExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static _Bool module_analyser_on_format_specifier(void* context, printf_utils_Specifier specifier, uint32_t offset, int32_t stars, char c);
static void module_analyser_Analyser_checkPrintArgs(module_analyser_Analyser* ma, ast_Expr* format, uint32_t num_args, ast_Expr** args, _Bool* change_format);
static void module_analyser_create_template_name(char* name, const char* orig, uint16_t idx);
static void module_analyser_Analyser_opaque_callback(void* arg, src_loc_SrcLoc loc, ast_Decl* d);
static ast_FunctionDecl* module_analyser_Analyser_instantiateTemplateFunction(module_analyser_Analyser* ma, ast_CallExpr* call, ast_FunctionDecl* fd);
static ast_QualType module_analyser_Analyser_analysePureCallExpr(module_analyser_Analyser* ma, ast_Expr* e);
static const uint8_t module_analyser_CondOpTable[8][8] = {
   {
   2,
   1,
   0,
   1,
   3,
   0,
   0,
   0
},
   {
   1,
   4,
   0,
   1,
   1,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   5,
   1,
   1,
   0,
   0
},
   {
   6,
   1,
   0,
   1,
   7,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   1,
   0,
   8,
   0,
   0
}
};

static ast_QualType module_analyser_Analyser_analyseExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, _Bool need_rvalue, uint32_t side);
static ast_QualType module_analyser_Analyser_analyseExprInner(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static const char* module_analyser_type2str(ast_QualType q);
static ast_Decl* module_analyser_Analyser_analyseIdentifier(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static ast_IdentifierKind module_analyser_Analyser_setExprFlags(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_Decl* d);
static ast_QualType module_analyser_Analyser_analyseConditionalOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static _Bool module_analyser_Analyser_checkAssignment(module_analyser_Analyser* ma, ast_Expr* assignee, ast_QualType tleft, const char* msg, src_loc_SrcLoc loc);
static ast_QualType module_analyser_usualUnaryConversions(ast_Expr* e);
static ast_QualType module_analyser_Analyser_analyseExplicitCast(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static ast_QualType module_analyser_Analyser_analyseArraySubscriptExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static ast_QualType module_analyser_Analyser_analyseBitOffsetExpr(module_analyser_Analyser* ma, ast_QualType ltype, ast_Expr* base, ast_Expr* e);
static _Bool module_analyser_Analyser_analyseBitOffsetIndex(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType baseType, ast_Value* result);
static void module_analyser_Analyser_memberError(module_analyser_Analyser* ma, uint32_t name_idx, src_loc_SrcLoc loc, ast_StructTypeDecl* s);
static ast_Decl* module_analyser_Analyser_findStructMember(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc, uint32_t* offset, _Bool allow_funcs);
static ast_QualType module_analyser_getPointerFromArray(ast_builder_Builder* builder, ast_QualType q);
static void module_analyser_Analyser_analyseFunction(module_analyser_Analyser* ma, ast_FunctionDecl* fd);
static void module_analyser_Analyser_analyseFunctionBody(module_analyser_Analyser* ma, ast_FunctionDecl* fd, scope_Scope* s);
static void module_analyser_Analyser_checkPrintfFormat(module_analyser_Analyser* ma, ast_VarDecl* v, ast_QualType qt, uint32_t idx, ast_FunctionDecl* fd);
static _Bool module_analyser_Analyser_analyseInitExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType, src_loc_SrcLoc assignLoc);
static _Bool module_analyser_Analyser_checkEnumArg(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType);
static _Bool module_analyser_Analyser_analyseInitListExpr(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType);
static _Bool module_analyser_Analyser_analyseArrayDesignatedInit(module_analyser_Analyser* ma, ast_Expr* e, ast_QualType expectedType);
static _Bool module_analyser_Analyser_analyseInitListArray(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType);
static _Bool module_analyser_Analyser_checkArrayDesignators(module_analyser_Analyser* ma, ast_InitListExpr* ile, int32_t* size, init_checker_Checker* checker);
static _Bool module_analyser_Analyser_analyseStructFieldInit(module_analyser_Analyser* ma, ast_StructTypeDecl* std, ast_InitListExpr* ile, ast_QualType expectedType);
static _Bool module_analyser_Analyser_analyseInitListStruct(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType);
static const char module_analyser_DiagStaticThoughVar[52] = "cannot access static type-function through variable";

static ast_QualType module_analyser_Analyser_analyseMemberExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static ast_Decl* module_analyser_Analyser_analyseStructMemberAccess(module_analyser_Analyser* ma, ast_StructTypeDecl* std, uint32_t name_idx, src_loc_SrcLoc loc, ast_ValType valtype, uint32_t side, ast_CallKind* ck);
static ast_TypeKind module_analyser_Analyser_analyseBaseType(module_analyser_Analyser* ma, ast_QualType baseType);
static ast_ValType module_analyser_decl2valtype(const ast_Decl* d);
static _Bool module_analyser_hasReturn(const ast_Stmt* s);
static void module_analyser_Analyser_analyseStmt(module_analyser_Analyser* ma, ast_Stmt* s, _Bool checkEffect);
static void module_analyser_Analyser_analyseBreakStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseContinueStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseFallthroughStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseLabelStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseGotoStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseCompoundStmt(module_analyser_Analyser* ma, ast_CompoundStmt* c);
static ast_QualType module_analyser_Analyser_analyseCondition(module_analyser_Analyser* ma, ast_Stmt** s_ptr, _Bool check_assign);
static void module_analyser_Analyser_analyseIfStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseForStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseWhileStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static ast_QualType module_analyser_Analyser_analyseDeclStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseAsmStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseAssertStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseReturnStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_checkReturnAddrOfLocal(module_analyser_Analyser* ma, ast_Expr* arg);
static void module_analyser_Analyser_analyseStructType(module_analyser_Analyser* ma, ast_StructTypeDecl* d);
static void module_analyser_Analyser_analyseStructMembers(module_analyser_Analyser* ma, ast_StructTypeDecl* d);
static void module_analyser_Analyser_analyseStructMember(module_analyser_Analyser* ma, ast_VarDecl* v);
static void module_analyser_Analyser_analyseStructNames(module_analyser_Analyser* ma, ast_StructTypeDecl* d, name_vector_NameVector* names, name_vector_NameVector* locs);
static void module_analyser_Analyser_analyseSwitchStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static _Bool module_analyser_Analyser_analyseCase(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, _Bool is_string);
static _Bool module_analyser_Analyser_analyseCaseCondition(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, _Bool is_string);
static _Bool module_analyser_Analyser_analyseCaseExpr(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, _Bool is_string, src_loc_SrcLoc loc, ast_Expr* cond, uint32_t* indexp, uint32_t* name_idxp);
static _Bool module_analyser_Analyser_checkEnumConstantCase(module_analyser_Analyser* ma, ast_IdentifierExpr* id, init_checker_Checker* checker, ast_EnumTypeDecl* etd, src_loc_SrcLoc loc, uint32_t* ip, uint32_t* name_idxp);
static _Bool module_analyser_isTerminatingStmt(const ast_Stmt* s, _Bool is_default);
static void module_analyser_Analyser_analyseFunctionType(module_analyser_Analyser* ma, ast_Decl* d);
static void module_analyser_Analyser_analyseAliasType(module_analyser_Analyser* ma, ast_AliasTypeDecl* a);
static void module_analyser_Analyser_analyseEnumType(module_analyser_Analyser* ma, ast_EnumTypeDecl* d);
static ast_QualType module_analyser_Analyser_analyseUserTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref);
static ast_QualType module_analyser_Analyser_analyseTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref);
static ast_QualType module_analyser_Analyser_analyseIncrTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref, uint32_t size);
static _Bool module_analyser_Analyser_checkOpaque(module_analyser_Analyser* ma, const ast_StructTypeDecl* std, src_loc_SrcLoc loc);
static ast_VarDecl* module_analyser_getVarDecl(const ast_Expr* e);
static ast_QualType module_analyser_Analyser_analyseUnaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static _Bool module_analyser_Analyser_checkIncrDecr(module_analyser_Analyser* ma, ast_Expr* inner, ast_QualType t, _Bool is_incr, src_loc_SrcLoc loc);
static _Bool module_analyser_Analyser_getIdentifierKind(module_analyser_Analyser* ma, ast_Expr* e);
static ast_IdentifierKind module_analyser_getInnerExprAddressOf(ast_Expr* e);
static ast_QualType module_analyser_getMinusType(ast_QualType qt);
struct module_analyser_FieldInit_ {
   uint32_t offset;
   src_loc_SrcLoc loc;
};

struct module_analyser_StructFieldInitChecker_ {
   module_analyser_FieldInit* inits;
   uint32_t num_inits;
   uint32_t max_inits;
};

static void module_analyser_StructFieldInitChecker_init(module_analyser_StructFieldInitChecker* c, uint32_t max);
static void module_analyser_StructFieldInitChecker_resize(module_analyser_StructFieldInitChecker* c, uint32_t max);
static src_loc_SrcLoc module_analyser_StructFieldInitChecker_add(module_analyser_StructFieldInitChecker* c, uint32_t offset, src_loc_SrcLoc loc);
static src_loc_SrcLoc module_analyser_StructFieldInitChecker_find(const module_analyser_StructFieldInitChecker* c, uint32_t offset);
static void module_analyser_StructFieldInitChecker_free(module_analyser_StructFieldInitChecker* c);

static module_analyser_Analyser* module_analyser_create(diagnostics_Diags* diags, ast_context_Context* context, string_pool_Pool* astPool, ast_builder_Builder* builder, module_list_List* allmodules, const warning_flags_Flags* warnings)
{
   module_analyser_Analyser* ma = calloc(1, 560);
   ma->diags = diags;
   conversion_checker_Checker_init(&ma->checker, diags, builder);
   ma->context = context;
   ma->astPool = astPool;
   ma->builder = builder;
   ma->allmodules = allmodules;
   ma->warnings = warnings;
   ma->min_idx = string_pool_Pool_addStr(astPool, "min", true);
   ma->max_idx = string_pool_Pool_addStr(astPool, "max", true);
   return ma;
}

static void module_analyser_Analyser_free(module_analyser_Analyser* ma)
{
   for (uint32_t i = 0; (i < 4); i++) {
      init_checker_Checker_free(&ma->init_checkers[i]);
   }
   name_vector_NameVector_free(&ma->prefixes);
   label_vector_LabelVector_free(&ma->labels);
   free(ma);
}

static void module_analyser_Analyser_check(module_analyser_Analyser* ma, ast_Module* mod)
{
   ma->mod = mod;
   ma->prefix_cache_name = 0;
   ma->prefix_cache_idx = 0;
   name_vector_NameVector_clear(&ma->prefixes);
   label_vector_LabelVector_reset(&ma->labels);
   ma->checkIndex = 0;
   ma->scope = NULL;
   ma->curFunction = NULL;
   ma->has_error = false;
   ma->usedPublic = false;
   ast_Module_visitASTs(mod, module_analyser_Analyser_createGlobalScope, ma);
   if (diagnostics_Diags_hasErrors(ma->diags)) return;

   module_analyser_Analyser_collectTypeFunctions(ma);
   if (ma->has_error) return;

   module_analyser_Analyser_collectIncrementalArrays(ma);
   if (ma->has_error) return;

   ast_Module_visitTypeDecls(mod, module_analyser_Analyser_handleTypeDecl, ma);
   if (ma->has_error) return;

   ast_Module_visitStaticAsserts(mod, module_analyser_Analyser_handleStaticAssert, ma);
   if (ma->has_error) return;

   ast_Module_visitFunctions(mod, module_analyser_Analyser_analyseFunctionProto, ma);
   if (ma->has_error) return;

   ast_Module_visitVarDecls(mod, module_analyser_Analyser_handleVarDecl, ma);
   if (ma->has_error) return;

   ast_Module_visitFunctions(mod, module_analyser_Analyser_analyseFunctionBodies, ma);
   if (ma->has_error) return;

   if ((!ast_Module_isExternal(mod) && ast_Module_isExported(mod))) {
      ast_Module_visitImports(mod, module_analyser_Analyser_handleImport, ma);
   }
   ast_Module_visitASTs(mod, module_analyser_Analyser_deleteScope, ma);
}

static init_checker_Checker* module_analyser_Analyser_getInitChecker(module_analyser_Analyser* ma)
{
   if ((ma->check_idx >= 4)) {
      ma->check_idx++;
      return calloc(1, 24);
   } else {
      init_checker_Checker* c = &ma->init_checkers[ma->check_idx++];
      init_checker_Checker_clear(c);
      return c;
   }
}

static void module_analyser_Analyser_putInitChecker(module_analyser_Analyser* ma, init_checker_Checker* c)
{
   ((ma->check_idx > 0)) || c2_assert("analyser/module_analyser.c2", 172, "module_analyser.Analyser.putInitChecker", "ma.check_idx > 0");
   ma->check_idx--;
   if ((ma->check_idx >= 4)) {
      init_checker_Checker_free(c);
      free(c);
   }
}

static void module_analyser_Analyser_collectTypeFunctions(module_analyser_Analyser* ma)
{
   struct_func_list_List type_fn_decls = { };
   ma->type_fn_decls = &type_fn_decls;
   ast_Module_visitTypeFunctions(ma->mod, module_analyser_Analyser_handleStructFunc, ma);
   if (ma->has_error) return;

   for (uint32_t i = 0; (i < type_fn_decls.count); i++) {
      const struct_func_list_Info* info = &type_fn_decls.data[i];
      if (ast_Decl_isStructType(info->decl)) {
         ast_StructTypeDecl* fd = ((ast_StructTypeDecl*)(info->decl));
         ast_StructTypeDecl_setStructFunctions(fd, ma->context, ast_FunctionDeclList_getDecls(&info->functions), ast_FunctionDeclList_size(&info->functions));
      } else {
         ast_EnumTypeDecl* etd = ((ast_EnumTypeDecl*)(info->decl));
         ast_EnumTypeDecl_setEnumFunctions(etd, ma->context, ast_FunctionDeclList_getDecls(&info->functions), ast_FunctionDeclList_size(&info->functions));
      }
   }
   name_vector_NameVector_free(&ma->prefixes);
   struct_func_list_List_free(&type_fn_decls);
   ma->type_fn_decls = NULL;
}

static void module_analyser_Analyser_handleArrayValue(void* arg, ast_ArrayValue* avd)
{
   module_analyser_Analyser* ma = arg;
   incr_array_list_List_add(ma->incr_values, ast_ArrayValue_getNameIdx(avd), ast_ArrayValue_getLoc(avd), ast_ArrayValue_getValue(avd));
}

static void module_analyser_Analyser_collectIncrementalArrays(module_analyser_Analyser* ma)
{
   incr_array_list_List ialist = { };
   ma->incr_values = &ialist;
   ast_Module_visitArrayValues(ma->mod, module_analyser_Analyser_handleArrayValue, ma);
   for (uint32_t i = 0; (i < ialist.count); i++) {
      module_analyser_Analyser_handleIncrEntry(ma, &ialist.entries[i]);
   }
   incr_array_list_List_free(&ialist);
   ma->incr_values = NULL;
}

static void module_analyser_Analyser_handleIncrEntry(module_analyser_Analyser* ma, incr_array_list_Info* entry)
{
   uint32_t name = entry->name;
   ast_Decl* d = ast_Module_findSymbol(ma->mod, name);
   if (!d) {
      module_analyser_Analyser_error(ma, entry->loc, "module '%s' has no symbol '%s'", ast_Module_getName(ma->mod), ast_idx2name(name));
      return;
   }
   if (ast_Decl_isVariable(d)) {
      ast_VarDecl* vd = ((ast_VarDecl*)(d));
      ast_TypeRef* ref = ast_VarDecl_getTypeRef(vd);
      if (!ast_TypeRef_isIncrArray(ref)) {
         module_analyser_Analyser_error(ma, entry->loc, "'%s' is not an incremental array", ast_idx2name(name));
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "'%s' is defined here", ast_idx2name(name));
         return;
      }
      uint32_t num_values = ast_ExprList_size(&entry->values);
      ast_Expr** values = ast_ExprList_getExprs(&entry->values);
      ast_Expr* init_expr = ast_builder_Builder_actOnInitList(ma->builder, 0, 0, values, num_values);
      ast_VarDecl_setInit(vd, init_expr);
   } else if (ast_Decl_isEnum(d)) {
      ast_EnumTypeDecl* etd = ((ast_EnumTypeDecl*)(d));
      if (!ast_EnumTypeDecl_isIncremental(etd)) {
         module_analyser_Analyser_error(ma, entry->loc, "'%s' is not an incremental enum", ast_idx2name(name));
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "'%s' is defined here", ast_idx2name(name));
         return;
      }
      uint32_t num_values = ast_ExprList_size(&entry->values);
      ast_Expr** values = ast_ExprList_getExprs(&entry->values);
      for (uint32_t j = 0; (j < num_values); j++) {
         ast_Expr* e = values[j];
         if (!ast_Expr_isIdentifier(e)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "expected identifier");
            return;
         }
      }
      ast_EnumTypeDecl_setIncrConstants(etd, ma->context, ((ast_IdentifierExpr**)(values)), num_values);
   } else {
      module_analyser_Analyser_error(ma, entry->loc, "'%s' is not an incremental array/enum", ast_idx2name(name));
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "'%s' is defined here", ast_idx2name(name));
   }

}

static void module_analyser_Analyser_handleImport(void* arg, ast_ImportDecl* id)
{
   module_analyser_Analyser* ma = arg;
   ast_Decl* d = ((ast_Decl*)(id));
   if (!ast_Decl_isUsedPublic(d)) return;

   ast_Module* dest = ast_ImportDecl_getDest(id);
   if ((ast_Module_isExternal(dest) || ast_Module_isInternal(dest))) return;

   if (!ast_Module_isExported(dest)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "exported module '%s' publicly uses non-exported module '%s'", ast_Module_getName(ma->mod), ast_Module_getName(dest));
   }
}

static void module_analyser_Analyser_setMod(module_analyser_Analyser* ma, ast_Module* mod)
{
   ma->mod = mod;
}

__attribute__((__format__(printf, 3, 4))) 
static void module_analyser_Analyser_note(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_note2(ma->diags, loc, format, args);
   va_end(args);
}

__attribute__((__format__(printf, 3, 4))) 
static void module_analyser_Analyser_warn(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_warn2(ma->diags, loc, format, args);
   va_end(args);
}

__attribute__((__format__(printf, 3, 4))) 
static void module_analyser_Analyser_error(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_error2(ma->diags, loc, format, args);
   va_end(args);
   ma->has_error = true;
}

__attribute__((__format__(printf, 4, 5))) 
static void module_analyser_Analyser_errorRange(module_analyser_Analyser* ma, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_errorRange2(ma->diags, loc, range, format, args);
   va_end(args);
   ma->has_error = true;
}

static void module_analyser_Analyser_createGlobalScope(void* arg, ast_AST* a)
{
   module_analyser_Analyser* ma = arg;
   scope_Scope* s = scope_create(ma->allmodules, ma->diags, ast_AST_getImports(a), ma->mod, ast_Module_getSymbols(ma->mod), !ma->warnings->no_unused_variable);
   ast_AST_setPtr(a, s);
}

static void module_analyser_Analyser_deleteScope(void* _arg0, ast_AST* a)
{
   scope_Scope* s = ast_AST_getPtr(a);
   ast_AST_setPtr(a, NULL);
   scope_Scope_free(s);
}

static void module_analyser_Analyser_handleStructFunc(void* arg, ast_FunctionDecl* fd)
{
   module_analyser_Analyser* ma = arg;
   ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
   ast_Decl* d = ((ast_Decl*)(fd));
   (prefix) || c2_assert("analyser/module_analyser.c2", 347, "module_analyser.Analyser.handleStructFunc", "prefix");
   uint32_t prefix_name_idx = prefix->name_idx;
   (ma->type_fn_decls) || c2_assert("analyser/module_analyser.c2", 350, "module_analyser.Analyser.handleStructFunc", "ma.type_fn_decls");
   uint32_t index = 0;
   if ((prefix_name_idx == ma->prefix_cache_name)) {
      index = ma->prefix_cache_idx;
   } else {
      _Bool found = false;
      found = name_vector_NameVector_find(&ma->prefixes, prefix_name_idx, &index);
      if (!found) {
         const char* msg = "a type-function type must be a struct/union/enum";
         ast_Decl* decl = ast_Module_findType(ma->mod, prefix_name_idx);
         if (!decl) {
            decl = ast_Module_findSymbol(ma->mod, prefix_name_idx);
            if (decl) {
               module_analyser_Analyser_error(ma, prefix->loc, "%s", msg);
            } else {
               module_analyser_Analyser_error(ma, prefix->loc, "module '%s' has no symbol '%s'", ast_Module_getName(ma->mod), ast_Ref_getName(prefix));
            }
            return;
         }
         if ((!ast_Decl_isStructType(decl) && !ast_Decl_isEnum(decl))) {
            module_analyser_Analyser_error(ma, prefix->loc, "%s", msg);
            return;
         }
         if ((ast_Decl_isPublic(d) && !ast_Decl_isPublic(decl))) {
            module_analyser_Analyser_error(ma, prefix->loc, "public type-functions need a public type");
            return;
         }
         index = name_vector_NameVector_add(&ma->prefixes, prefix_name_idx);
         struct_func_list_List_addDecl(ma->type_fn_decls, decl);
      }
      ma->prefix_cache_name = prefix_name_idx;
      ma->prefix_cache_idx = index;
   }
   ast_FunctionDecl* other = struct_func_list_List_findFunc(ma->type_fn_decls, index, ast_Decl_getNameIdx(d));
   if (other) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "redefinition of '%s'", ast_Decl_getFullName(d));
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(other)), "previous definition is here");
      return;
   }
   prefix->decl = struct_func_list_List_getDecl(ma->type_fn_decls, index);
   if (ast_Decl_isStructType(prefix->decl)) {
      ast_StructTypeDecl* std = ((ast_StructTypeDecl*)(prefix->decl));
      ast_Decl* match = ast_StructTypeDecl_findMember(std, ast_Decl_getNameIdx(d), NULL);
      if (match) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(match), "member '%s' conflicts with type-function '%s'", ast_Decl_getName(match), ast_Decl_getFullName(d));
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "previous declaration is here");
         return;
      }
   }
   struct_func_list_List_addFunc(ma->type_fn_decls, index, fd);
}

static void module_analyser_Analyser_analyseFunctionProto(void* arg, ast_FunctionDecl* d)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseGlobalDecl(ma, ((ast_Decl*)(d)));
}

static void module_analyser_Analyser_analyseFunctionBodies(void* arg, ast_FunctionDecl* d)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseFunctionBody(ma, d, ast_AST_getPtr(ast_Decl_getAST(ast_FunctionDecl_asDecl(d))));
}

static _Bool module_analyser_Analyser_analyseGlobalDecl(module_analyser_Analyser* ma, ast_Decl* d)
{
   if (ast_Decl_isChecked(d)) return true;

   if ((ast_Decl_isCheckInProgress(d) && ast_Decl_isEnum(d))) {
      module_analyser_StackLayer* top = &ma->checkStack[(ma->checkIndex - 1)];
      if ((top->decl == d)) return true;

   }
   if (!module_analyser_Analyser_pushCheck(ma, d, ast_AST_getPtr(ast_Decl_getAST(d)), NULL)) return false;

   if ((ast_Decl_isExported(d) && !ast_Decl_isPublic(d))) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "attribute 'export' can only be applied to public declarations");
      return false;
   }
   _Bool saved = ma->has_error;
   ma->has_error = false;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      module_analyser_Analyser_analyseFunction(ma, ((ast_FunctionDecl*)(d)));
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      module_analyser_Analyser_analyseStructType(ma, ((ast_StructTypeDecl*)(d)));
      break;
   case ast_DeclKind_EnumType:
      module_analyser_Analyser_analyseEnumType(ma, ((ast_EnumTypeDecl*)(d)));
      break;
   case ast_DeclKind_EnumConstant:
      (0) || c2_assert("analyser/module_analyser.c2", 455, "module_analyser.Analyser.analyseGlobalDecl", "0");
      break;
   case ast_DeclKind_FunctionType:
      module_analyser_Analyser_analyseFunctionType(ma, d);
      break;
   case ast_DeclKind_AliasType:
      module_analyser_Analyser_analyseAliasType(ma, ((ast_AliasTypeDecl*)(d)));
      break;
   case ast_DeclKind_Variable:
      module_analyser_Analyser_analyseGlobalVarDecl(ma, ((ast_VarDecl*)(d)));
      break;
   }
   ast_Decl_setChecked(d);
   module_analyser_Analyser_popCheck(ma);
   _Bool ok = !ma->has_error;
   ma->has_error |= saved;
   return ok;
}

static void module_analyser_Analyser_handleTypeDecl(void* arg, ast_Decl* d)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseGlobalDecl(ma, d);
}

static void module_analyser_Analyser_handleStaticAssert(void* arg, ast_StaticAssert* d)
{
   module_analyser_Analyser* ma = arg;
   ast_StaticAssert* sa = ((ast_StaticAssert*)(d));
   ast_Expr* lhs = ast_StaticAssert_getLhs(sa);
   ast_Expr* rhs = ast_StaticAssert_getRhs(sa);
   if (!module_analyser_Analyser_pushCheck(ma, NULL, ast_AST_getPtr(ast_StaticAssert_getAST(d)), NULL)) return;

   ast_QualType t1 = module_analyser_Analyser_analyseExpr(ma, &lhs, false, module_analyser_RHS);
   ast_QualType t2 = module_analyser_Analyser_analyseExpr(ma, &rhs, false, module_analyser_RHS);
   module_analyser_Analyser_popCheck(ma);
   if ((ast_QualType_isInvalid(&t1) || ast_QualType_isInvalid(&t2))) return;

   _Bool error = false;
   if (!ast_Expr_isCtv(lhs)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(lhs), ast_Expr_getRange(lhs), "static_assert element is not a compile-time value");
      error = true;
   }
   if (!ast_Expr_isCtv(rhs)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(rhs), ast_Expr_getRange(rhs), "static_assert element is not a compile-time value");
      error = true;
   }
   if (error) return;

   ast_Value val1 = ctv_analyser_get_value(lhs);
   ast_Value val2 = ctv_analyser_get_value(rhs);
   if (!ast_Value_is_equal(&val1, &val2)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getStartLoc(rhs), ast_Expr_getRange(rhs), "static_assert failed, expected %s, got %s", ast_Value_str(&val1), ast_Value_str(&val2));
   }
}

static void module_analyser_Analyser_handleVarDecl(void* arg, ast_VarDecl* v)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseGlobalDecl(ma, ast_VarDecl_asDecl(v));
}

static void module_analyser_Analyser_checkName(module_analyser_Analyser* ma, ast_Decl* d, _Bool is_constant)
{
   const char* name = ast_Decl_getName(d);
   if (is_constant) {
      if (islower(name[0])) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "a global constant name must start with an upper case character");
      }
   } else {
      if (isupper(name[0])) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "a variable name must start with a lower case character");
      }
   }
}

static void module_analyser_Analyser_analyseGlobalVarDecl(module_analyser_Analyser* ma, ast_VarDecl* v)
{
   ast_Decl* d = ((ast_Decl*)(v));
   ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
   ast_Expr* init_expr = ast_VarDecl_getInit(v);
   ast_QualType res;
   if (ast_TypeRef_isIncrArray(ref)) {
      uint32_t size = 0;
      if (init_expr) {
         ast_InitListExpr* ile = ((ast_InitListExpr*)(init_expr));
         size = ast_InitListExpr_getNumValues(ile);
      }
      res = module_analyser_Analyser_analyseIncrTypeRef(ma, ref, size);
   } else {
      res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   }
   if (ast_QualType_isInvalid(&res)) return;

   ast_QualType canon = ast_QualType_getCanonicalType(&res);
   if (ast_QualType_isVoid(&canon)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "%s has invalid type 'void'", ast_QualType_isConst(&res) ? "constant" : "variable");
      return;
   }
   if ((ast_QualType_isArray(&canon) && !ast_TypeRef_isIncrArray(ref))) {
      const ast_ArrayType* at = ast_QualType_getArrayType(&canon);
      if (ast_ArrayType_hasSize(at)) {
         if ((ast_ArrayType_getSize(at) == 0)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "only struct members may have array size zero");
            return;
         }
      } else {
         if (!init_expr) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "array-type variable '%s' needs an explicit size or an initializer", ast_Decl_getFullName(d));
            return;
         }
      }
   }
   ast_Decl_setType(d, res);
   module_analyser_Analyser_checkName(ma, d, ast_QualType_isConstant(&res));
   if (ast_Decl_isPublic(d)) ast_setTypePublicUsed(res);
   if (init_expr) {
      if (!ast_QualType_isConstant(&res)) {
         ma->checkStack[(ma->checkIndex - 1)].usedPublic = false;
         ma->usedPublic = false;
      }
      module_analyser_Analyser_analyseInitExpr(ma, ast_VarDecl_getInit2(v), res, ast_VarDecl_getAssignLoc(v));
   } else {
      if (ast_QualType_isConstant(&res)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "constant variable '%s' must be initialized", ast_Decl_getFullName(d));
      }
   }
   module_analyser_Analyser_checkVarDeclAttributes(ma, v);
}

static void module_analyser_Analyser_checkVarDeclAttributes(module_analyser_Analyser* ma, ast_VarDecl* v)
{
   ast_Decl* d = ((ast_Decl*)(v));
   ast_QualType qt = ast_Decl_getType(d);
   if ((ast_QualType_isConst(&qt) && ast_QualType_isBuiltin(&qt))) {
      if (ast_VarDecl_hasAttrWeak(v)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "attribute 'weak' cannot be applied to constants");
      }
      if (!ast_Decl_hasAttr(d)) return;

      const ast_AST* a = ast_Decl_getAST(d);
      const attr_Value* section = ast_AST_getAttr(a, d, attr_AttrKind_Section);
      if (section) {
         module_analyser_Analyser_error(ma, section->loc, "attribute 'section' cannot be applied to constants");
      }
      const attr_Value* aligned = ast_AST_getAttr(a, d, attr_AttrKind_Aligned);
      if (aligned) {
         module_analyser_Analyser_error(ma, aligned->loc, "attribute 'aligned' cannot be applied to constants");
      }
   }
}

static _Bool module_analyser_Analyser_pushCheck(module_analyser_Analyser* ma, ast_Decl* d, scope_Scope* s, ast_FunctionDecl* fd)
{
   if (d) {
      for (uint32_t i = 0; (i < ma->checkIndex); i++) {
         if ((ma->checkStack[i].decl == d)) {
            for (uint32_t j = i; (j < ma->checkIndex); j++) {
               const ast_Decl* other = ma->checkStack[j].decl;
               if (other) {
                  module_analyser_Analyser_error(ma, ast_Decl_getLoc(other), "circular declaration dependency '%s'", ast_Decl_getName(other));
               }
            }
            return false;
         }
      }
   }
   ma->scope = s;
   ((ma->checkIndex <= module_analyser_MaxDepth)) || c2_assert("analyser/module_analyser.c2", 635, "module_analyser.Analyser.pushCheck", "ma.checkIndex <= MaxDepth");
   module_analyser_StackLayer* top = &ma->checkStack[ma->checkIndex];
   top->decl = d;
   top->scope = s;
   top->function = fd;
   top->usedPublic = (d && ast_Decl_isPublic(d));
   if (fd) ma->curFunction = fd;
   ma->usedPublic = top->usedPublic;
   ma->checkIndex++;
   if ((d && !ast_Decl_isChecked(d))) ast_Decl_setCheckInProgress(d);
   return true;
}

static void module_analyser_Analyser_popCheck(module_analyser_Analyser* ma)
{
   ((ma->checkIndex > 0)) || c2_assert("analyser/module_analyser.c2", 651, "module_analyser.Analyser.popCheck", "ma.checkIndex > 0");
   ma->checkIndex--;
   if ((ma->checkIndex > 0)) {
      module_analyser_StackLayer* top = &ma->checkStack[(ma->checkIndex - 1)];
      ma->scope = top->scope;
      ma->curFunction = top->function;
      ma->usedPublic = top->usedPublic;
   } else {
      ma->scope = NULL;
      ma->curFunction = NULL;
   }
}

static _Bool module_analyser_Analyser_globalScope(const module_analyser_Analyser* ma)
{
   return (ma->curFunction == NULL);
}

static void module_analyser_findMainFunction(void* arg, ast_FunctionDecl* fd)
{
   module_analyser_MainMarker* m = (arg);
   ast_Decl* d = ((ast_Decl*)(fd));
   if ((ast_Decl_getNameIdx(d) == m->name_idx)) {
      if (m->main) {
         return;
      }
      m->main = d;
   }
}

static ast_Decl* module_analyser_Analyser_findMain(module_analyser_Analyser* ma, ast_Module* top, uint32_t name_idx)
{
   ast_Module_setUsed(top);
   module_analyser_MainMarker marker = { name_idx, NULL };
   ast_Module_visitFunctions(top, module_analyser_findMainFunction, &marker);
   if (marker.main) {
      ast_Decl_setUsed(marker.main);
      ast_Decl_setUsedPublic(marker.main);
      ast_Decl_setAttrExport(marker.main);
   }
   return marker.main;
}

static _Bool module_analyser_validBinOpKind(ast_QualType t)
{
   t = ast_QualType_getCanonicalType(&t);
   switch (ast_QualType_getKind(&t)) {
   case ast_TypeKind_Builtin:
      return true;
   case ast_TypeKind_Pointer:
      return true;
   case ast_TypeKind_Array:
      break;
   case ast_TypeKind_Struct:
      return true;
   case ast_TypeKind_Enum:
      return true;
   case ast_TypeKind_Function:
      return true;
   case ast_TypeKind_Alias:
      (0) || c2_assert("analyser/module_analyser_binop.c2", 39, "module_analyser.validBinOpKind", "0");
      break;
   case ast_TypeKind_Module:
      break;
   }
   return false;
}

static ast_QualType module_analyser_Analyser_checkBinopIntArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(&lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(&rhs);
   (ast_QualType_isValid(&lcanon)) || c2_assert("analyser/module_analyser_binop.c2", 129, "module_analyser.Analyser.checkBinopIntArgs", "lcanon.isValid()");
   (ast_QualType_isValid(&rcanon)) || c2_assert("analyser/module_analyser_binop.c2", 130, "module_analyser.Analyser.checkBinopIntArgs", "rcanon.isValid()");
   if (ast_QualType_isEnum(&lcanon)) {
      ast_EnumType* et = ast_QualType_getEnum(&lcanon);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      lcanon = ast_EnumTypeDecl_getImplType(etd);
   }
   if (ast_QualType_isEnum(&rcanon)) {
      ast_EnumType* et = ast_QualType_getEnum(&rcanon);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      rcanon = ast_EnumTypeDecl_getImplType(etd);
   }
   ast_BuiltinType* bl = ast_QualType_getBuiltinTypeOrNil(&lcanon);
   ast_BuiltinType* br = ast_QualType_getBuiltinTypeOrNil(&rcanon);
   if ((((!bl || !br) || ast_QualType_isVoid(&lcanon)) || ast_QualType_isVoid(&lcanon))) {
      ast_Expr* e = ((ast_Expr*)(b));
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   }
   ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(&optype);
   if ((bl != bi)) {
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
   }
   if ((br != bi)) {
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
   }
   return optype;
}

static ast_QualType module_analyser_Analyser_checkBinopLogical(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   _Bool ok = conversion_checker_Checker_check(&ma->checker, ast_builtins[ast_BuiltinKind_Bool], lhs, ast_BinaryOperator_getLHS2(b), ast_Expr_getLoc(ast_BinaryOperator_getLHS(b)));
   ok &= conversion_checker_Checker_check(&ma->checker, ast_builtins[ast_BuiltinKind_Bool], rhs, ast_BinaryOperator_getRHS2(b), ast_Expr_getLoc(ast_BinaryOperator_getRHS(b)));
   if (ok) return ast_builtins[ast_BuiltinKind_Bool];

   ast_Expr* e = ((ast_Expr*)(b));
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopAddSubAssign(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(&lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(&rhs);
   (ast_QualType_isValid(&lcanon)) || c2_assert("analyser/module_analyser_binop.c2", 199, "module_analyser.Analyser.checkBinopAddSubAssign", "lcanon.isValid()");
   (ast_QualType_isValid(&rcanon)) || c2_assert("analyser/module_analyser_binop.c2", 200, "module_analyser.Analyser.checkBinopAddSubAssign", "rcanon.isValid()");
   uint8_t res = module_analyser_BinOpConvAddSubAss[ast_QualType_getKind(&lcanon)][ast_QualType_getKind(&rcanon)];
   switch (res) {
   case 0:
      break;
   case 1: {
      ast_Expr* e = ((ast_Expr*)(b));
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   }
   case 2:
      return lhs;
   case 3:
      return lhs;
   case 4:
      return lhs;
   case 5:
      return lhs;
   case 6:
      return lhs;
   }
   (0) || c2_assert("analyser/module_analyser_binop.c2", 225, "module_analyser.Analyser.checkBinopAddSubAssign", "0");
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopAddArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(&lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(&rhs);
   (ast_QualType_isValid(&lcanon)) || c2_assert("analyser/module_analyser_binop.c2", 259, "module_analyser.Analyser.checkBinopAddArgs", "lcanon.isValid()");
   (ast_QualType_isValid(&rcanon)) || c2_assert("analyser/module_analyser_binop.c2", 260, "module_analyser.Analyser.checkBinopAddArgs", "rcanon.isValid()");
   uint8_t res = module_analyser_BinOpConvAdd[ast_QualType_getKind(&lcanon)][ast_QualType_getKind(&rcanon)];
   switch (res) {
   case 0:
      break;
   case 1: {
      ast_Expr* e = ((ast_Expr*)(b));
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   }
   case 2: {
      ast_BuiltinType* bl = ast_QualType_getBuiltin(&lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(&rcanon);
      ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&optype);
      if ((bl != bi)) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
      }
      if ((br != bi)) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
      }
      return optype;
   }
   case 3:
      return rhs;
   case 4:
      return lhs;
   case 5:
      return rhs;
   case 6:
      return lhs;
   case 7:
      return ast_builtins[ast_BuiltinKind_UInt32];
   }
   (0) || c2_assert("analyser/module_analyser_binop.c2", 299, "module_analyser.Analyser.checkBinopAddArgs", "0");
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopSubArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(&lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(&rhs);
   (ast_QualType_isValid(&lcanon)) || c2_assert("analyser/module_analyser_binop.c2", 330, "module_analyser.Analyser.checkBinopSubArgs", "lcanon.isValid()");
   (ast_QualType_isValid(&rcanon)) || c2_assert("analyser/module_analyser_binop.c2", 331, "module_analyser.Analyser.checkBinopSubArgs", "rcanon.isValid()");
   uint8_t res = module_analyser_BinOpConvSub[ast_QualType_getKind(&lcanon)][ast_QualType_getKind(&rcanon)];
   switch (res) {
   case 0:
      break;
   case 1: {
      ast_Expr* e = ((ast_Expr*)(b));
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   }
   case 2: {
      ast_BuiltinType* bl = ast_QualType_getBuiltin(&lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(&rcanon);
      return conversion_checker_usual_arithmetic_conversion(bl, br);
   }
   case 3: {
      ast_BuiltinType* bl = ast_QualType_getBuiltin(&lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(&rcanon);
      return conversion_checker_usual_arithmetic_conversion(bl, br);
   }
   case 4:
      return lhs;
   case 5: {
      ast_PointerType* pt1 = ast_QualType_getPointerType(&lcanon);
      ast_PointerType* pt2 = ast_QualType_getPointerType(&rcanon);
      ast_QualType t1 = ast_PointerType_getInner(pt1);
      ast_QualType t2 = ast_PointerType_getInner(pt2);
      if ((((ast_QualType_getTypeOrNil(&t1) != ast_QualType_getTypeOrNil(&t2)) || ast_QualType_isVoid(&t1)) || ast_QualType_isVoid(&t2))) {
         ast_Expr* e = ((ast_Expr*)(b));
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
         return ast_QualType_Invalid;
      }
      return ast_builtins[ast_BuiltinKind_ISize];
   }
   case 6:
      return lhs;
   case 7:
      return ast_builtins[ast_BuiltinKind_Int32];
   }
   ast_Expr* e = ((ast_Expr*)(b));
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopComparison(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(&lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(&rhs);
   ast_Expr* e = ((ast_Expr*)(b));
   (ast_QualType_isValid(&lcanon)) || c2_assert("analyser/module_analyser_binop.c2", 407, "module_analyser.Analyser.checkBinopComparison", "lcanon.isValid()");
   (ast_QualType_isValid(&rcanon)) || c2_assert("analyser/module_analyser_binop.c2", 408, "module_analyser.Analyser.checkBinopComparison", "rcanon.isValid()");
   uint8_t res = module_analyser_BinOpConvComparision[ast_QualType_getKind(&lcanon)][ast_QualType_getKind(&rcanon)];
   switch (res) {
   case 0:
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   case 1:
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   case 2:
      return ast_builtins[ast_BuiltinKind_Bool];
   case 3:
      return ast_builtins[ast_BuiltinKind_Bool];
   case 4:
      return ast_builtins[ast_BuiltinKind_Bool];
   case 5:
      return ast_builtins[ast_BuiltinKind_Bool];
   case 6:
      if ((ast_QualType_getTypeOrNil(&lcanon) != ast_QualType_getTypeOrNil(&rcanon))) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "comparing enums of different types ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
         return ast_QualType_Invalid;
      }
      return ast_builtins[ast_BuiltinKind_Bool];
   case 7:
      return module_analyser_Analyser_checkPointerFuncComparison(ma, b, lhs, rhs, lcanon, rcanon);
   case 8:
      return module_analyser_Analyser_checkPointerFuncComparison(ma, b, lhs, rhs, rcanon, lcanon);
   case 9:
      if (((ast_BinaryOperator_getOpcode(b) != ast_BinaryOpcode_Equal) && (ast_BinaryOperator_getOpcode(b) != ast_BinaryOpcode_NotEqual))) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "comparing functions may only be done with '!=' or '=='");
         return ast_QualType_Invalid;
      }
      return ast_builtins[ast_BuiltinKind_Bool];
   }
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "TODO BINOP %u", res);
   (0) || c2_assert("analyser/module_analyser_binop.c2", 451, "module_analyser.Analyser.checkBinopComparison", "0");
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkPointerFuncComparison(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, ast_QualType lcanon, ast_QualType rcanon)
{
   (ast_QualType_isPointer(&lcanon)) || c2_assert("analyser/module_analyser_binop.c2", 459, "module_analyser.Analyser.checkPointerFuncComparison", "lcanon.isPointer()");
   ast_PointerType* pt = ast_QualType_getPointerType(&lcanon);
   ast_QualType inner = ast_PointerType_getInner(pt);
   ast_Expr* e = ((ast_Expr*)(b));
   if (!ast_QualType_isVoid(&inner)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   }
   (ast_QualType_isFunction(&rcanon)) || c2_assert("analyser/module_analyser_binop.c2", 469, "module_analyser.Analyser.checkPointerFuncComparison", "rcanon.isFunction()");
   ast_FunctionType* ft = ast_QualType_getFunctionType(&rcanon);
   ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   if ((ast_FunctionDecl_isType(fd) || ast_FunctionDecl_hasAttrWeak(fd))) return ast_builtins[ast_BuiltinKind_Bool];

   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "comparison of function '%s' will always be true", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseBinaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ast_BinaryOpcode opcode = ast_BinaryOperator_getOpcode(b);
   _Bool need_lhs_rvalue = true;
   if ((opcode >= ast_BinaryOpcode_Assign)) need_lhs_rvalue = false;
   ast_QualType ltype = module_analyser_Analyser_analyseExpr(ma, ast_BinaryOperator_getLHS2(b), need_lhs_rvalue, module_analyser_Binop_lhs[opcode]);
   if (ast_QualType_isInvalid(&ltype)) return ast_QualType_Invalid;

   if (!need_lhs_rvalue) {
      if (!module_analyser_Analyser_checkAssignment(ma, ast_BinaryOperator_getLHS(b), ltype, "left operand of assignment", ast_Expr_getLoc(e))) {
         return ast_QualType_Invalid;
      }
   }
   ast_QualType rtype;
   if (ast_BinaryOpcode_isComparison(opcode)) {
      if (module_analyser_Analyser_checkEnumArg(ma, ast_BinaryOperator_getRHS2(b), ltype)) return ast_builtins[ast_BuiltinKind_Bool];

   }
   if ((opcode == ast_BinaryOpcode_Assign)) {
      if (!module_analyser_Analyser_analyseInitExpr(ma, ast_BinaryOperator_getRHS2(b), ltype, ast_Expr_getLoc(e))) return ast_QualType_Invalid;

      rtype = ast_Expr_getType(ast_BinaryOperator_getRHS(b));
   } else {
      rtype = module_analyser_Analyser_analyseExpr(ma, ast_BinaryOperator_getRHS2(b), true, module_analyser_RHS);
   }
   if (ast_QualType_isInvalid(&rtype)) return ast_QualType_Invalid;

   ast_Expr* lhs = ast_BinaryOperator_getLHS(b);
   ast_Expr* rhs = ast_BinaryOperator_getRHS(b);
   if ((!module_analyser_validBinOpKind(ltype) || ast_QualType_isVoid(&ltype))) {
      ast_QualType tl = ast_Expr_getType(lhs);
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(lhs), "invalid operand to binary expression '%s'", ast_QualType_diagName(&tl));
      return ast_QualType_Invalid;
   }
   if ((!module_analyser_validBinOpKind(rtype) || ast_QualType_isVoid(&rtype))) {
      ast_QualType tr = ast_Expr_getType(rhs);
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(rhs), "invalid operand to binary expression '%s'", ast_QualType_diagName(&tr));
      return ast_QualType_Invalid;
   }
   ast_QualType result = ast_QualType_Invalid;
   switch (opcode) {
   case ast_BinaryOpcode_Multiply:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Divide:
      if (!module_analyser_Analyser_checkZero(ma, rhs, "division")) return ast_QualType_Invalid;

      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Remainder:
      if (!module_analyser_Analyser_checkZero(ma, rhs, "remainder")) return ast_QualType_Invalid;

      if (!module_analyser_Analyser_checkFloat(ma, lhs, rhs, "remainder")) return ast_QualType_Invalid;

      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Add:
      result = module_analyser_Analyser_checkBinopAddArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Subtract:
      result = module_analyser_Analyser_checkBinopSubArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_ShiftLeft:
      fallthrough;
   case ast_BinaryOpcode_ShiftRight:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      if (!module_analyser_Analyser_checkShiftArgs(ma, ast_BinaryOperator_getLHS(b), ast_BinaryOperator_getRHS(b))) return ast_QualType_Invalid;

      break;
   case ast_BinaryOpcode_LessThan:
      fallthrough;
   case ast_BinaryOpcode_GreaterThan:
      fallthrough;
   case ast_BinaryOpcode_LessEqual:
      fallthrough;
   case ast_BinaryOpcode_GreaterEqual:
      result = module_analyser_Analyser_checkBinopComparison(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Equal:
      fallthrough;
   case ast_BinaryOpcode_NotEqual:
      result = module_analyser_Analyser_checkBinopComparison(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_And:
      fallthrough;
   case ast_BinaryOpcode_Xor:
      fallthrough;
   case ast_BinaryOpcode_Or:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_LAnd:
      fallthrough;
   case ast_BinaryOpcode_LOr:
      result = module_analyser_Analyser_checkBinopLogical(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Assign:
      result = ltype;
      break;
   case ast_BinaryOpcode_MulAssign:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_DivAssign:
      if (!module_analyser_Analyser_checkZero(ma, rhs, "division")) return ast_QualType_Invalid;

      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_RemAssign:
      if (!module_analyser_Analyser_checkZero(ma, rhs, "remainder")) return ast_QualType_Invalid;

      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_AddAssign:
      fallthrough;
   case ast_BinaryOpcode_SubAssign:
      result = module_analyser_Analyser_checkBinopAddSubAssign(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_ShlAssign:
      fallthrough;
   case ast_BinaryOpcode_ShrAssign:
      if (!module_analyser_Analyser_checkShiftArgs(ma, lhs, rhs)) return ast_QualType_Invalid;

      fallthrough;
   case ast_BinaryOpcode_AndAssign:
      fallthrough;
   case ast_BinaryOpcode_XorAssign:
      fallthrough;
   case ast_BinaryOpcode_OrAssign:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype);
      break;
   }
   ast_Expr_combineConstantFlags(e, lhs, rhs);
   return result;
}

static _Bool module_analyser_Analyser_checkShiftArgs(module_analyser_Analyser* ma, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_QualType qt = ast_Expr_getType(lhs);
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   if (!ast_QualType_isBuiltin(&canon)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(lhs), "cannot shift .. TODO");
      return false;
   }
   ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(&canon);
   uint32_t width = ast_BuiltinType_getWidth(bi);
   width += ast_BuiltinType_isSigned(bi);
   if (ast_Expr_isCtv(lhs)) {
      ast_Value val = ctv_analyser_get_value(lhs);
      if (ast_Value_isNegative(&val)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(lhs), "shifting a negative signed value is undefined");
         return false;
      }
   }
   if (ast_Expr_isCtv(rhs)) {
      ast_Value val = ctv_analyser_get_value(rhs);
      if (ast_Value_isNegative(&val)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(rhs), "shift count is negative");
         return false;
      }
      if ((ast_Value_as_u64(&val) >= width)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(rhs), "shift count >= width of type");
         return false;
      }
   }
   return true;
}

static _Bool module_analyser_Analyser_checkZero(module_analyser_Analyser* ma, ast_Expr* e, const char* operation)
{
   if (!ast_Expr_isCtv(e)) return true;

   ast_Value val = ctv_analyser_get_value(e);
   if (ast_Value_isDecimal(&val)) {
      if (ast_Value_isZero(&val)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "%s by zero is undefined", operation);
         return false;
      }
   }
   return true;
}

static _Bool module_analyser_Analyser_checkFloat(module_analyser_Analyser* ma, ast_Expr* lhs, ast_Expr* rhs, const char* operation)
{
   ast_QualType t1 = ast_Expr_getType(lhs);
   if (ast_QualType_isFloat(&t1)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(lhs), "invalid operand for binary operation %s", operation);
      return false;
   }
   ast_QualType t2 = ast_Expr_getType(rhs);
   if (ast_QualType_isFloat(&t2)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(rhs), "invalid operand for binary operation %s", operation);
      return false;
   }
   return true;
}

static ast_QualType module_analyser_Analyser_analyseBuiltin(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_BuiltinExpr* b = ((ast_BuiltinExpr*)(e));
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof:
      return module_analyser_Analyser_analyseSizeof(ma, b);
   case ast_BuiltinExprKind_Elemsof:
      return module_analyser_Analyser_analyseElemsof(ma, b);
   case ast_BuiltinExprKind_EnumMin:
      fallthrough;
   case ast_BuiltinExprKind_EnumMax:
      return module_analyser_Analyser_analyseEnumMinMax(ma, b);
   case ast_BuiltinExprKind_OffsetOf:
      return module_analyser_Analyser_analyseOffsetOf(ma, b);
   case ast_BuiltinExprKind_ToContainer:
      return module_analyser_Analyser_analyseToContainer(ma, b);
   }
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseSizeof(module_analyser_Analyser* ma, ast_BuiltinExpr* e)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(e);
   (inner) || c2_assert("analyser/module_analyser_builtin.c2", 45, "module_analyser.Analyser.analyseSizeof", "inner");
   _Bool savedPublic = ma->usedPublic;
   ma->usedPublic = false;
   ast_QualType qt;
   if (ast_Expr_isType(inner)) {
      ast_TypeExpr* te = ((ast_TypeExpr*)(inner));
      ast_TypeRef* ref = ast_TypeExpr_getTypeRef(te);
      qt = module_analyser_Analyser_analyseTypeRef(ma, ref);
      ast_Expr_setType(inner, qt);
   } else {
      qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, 0);
      if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

      if (ast_QualType_isStruct(&qt)) {
         ast_StructType* st = ast_QualType_getStructType(&qt);
         const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
         if (ast_StructTypeDecl_isOpaque(std)) {
            const ast_Decl* d = ((ast_Decl*)(std));
            _Bool is_external = (ma->mod != ast_Decl_getModule(d));
            if ((ma->curFunction && (ast_FunctionDecl_getInstanceModule(ma->curFunction) == ast_Decl_getModule(d)))) {
               is_external = false;
            }
            if (is_external) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "opaque type '%s' used by value", ast_QualType_diagName(&qt));
            }
         }
      }
   }
   ma->usedPublic = savedPublic;
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   size_analyser_TypeSize info = size_analyser_sizeOfType(qt);
   ast_BuiltinExpr_setUValue(e, info.size);
   return ast_builtins[ast_BuiltinKind_UInt32];
}

static ast_QualType module_analyser_Analyser_analyseElemsof(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   _Bool savedPublic = ma->usedPublic;
   ma->usedPublic = false;
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   ma->usedPublic = savedPublic;
   if (ast_QualType_isInvalid(&qt)) return qt;

   const ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(&qt);
   if (at) {
      ast_BuiltinExpr_setUValue(b, ast_ArrayType_getSize(at));
      return ast_builtins[ast_BuiltinKind_UInt32];
   }
   const ast_EnumType* et = ast_QualType_getEnumTypeOrNil(&qt);
   if (et) {
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_BuiltinExpr_setUValue(b, ast_EnumTypeDecl_getNumConstants(etd));
      return ast_builtins[ast_BuiltinKind_UInt32];
   }
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "elemsof can only be used on arrays/enums");
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseEnumMinMax(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   ast_EnumType* et = ast_QualType_getEnumTypeOrNil(&qt);
   if (!et) {
      const char* kind = ((ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_EnumMin)) ? "enum_min" : "enum_max";
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "%s can only be used on enum types", kind);
      return ast_QualType_Invalid;
   }
   ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
   uint32_t num = ast_EnumTypeDecl_getNumConstants(etd);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
   uint32_t index = 0;
   if ((ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_EnumMax)) index = (num - 1);
   ast_BuiltinExpr_setValue(b, ast_EnumConstantDecl_getValue(constants[index]));
   return ast_EnumTypeDecl_getImplType(etd);
}

static ast_QualType module_analyser_Analyser_analyseOffsetOf(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* e = ((ast_Expr*)(b));
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   ast_Expr_setType(e, ast_builtins[ast_BuiltinKind_UInt32]);
   ast_StructType* st = ast_QualType_getStructTypeOrNil(&qt);
   if (!st) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "offsetof can only be used on struct types");
      return ast_QualType_Invalid;
   }
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   if (!module_analyser_Analyser_checkOpaque(ma, std, ast_Expr_getLoc(inner))) return ast_QualType_Invalid;

   ast_Expr* member = ast_BuiltinExpr_getOffsetOfMember(b);
   ast_Decl* d = module_analyser_Analyser_findMemberOffset(ma, b, std, member);
   if (!d) return ast_QualType_Invalid;

   return ast_Expr_getType(e);
}

static ast_QualType module_analyser_Analyser_analyseToContainer(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   ast_StructType* st = ast_QualType_getStructTypeOrNil(&qt);
   if (!st) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "to_container can only be used on struct types");
      return ast_QualType_Invalid;
   }
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   if (!module_analyser_Analyser_checkOpaque(ma, std, ast_Expr_getLoc(inner))) return ast_QualType_Invalid;

   ast_Expr* member = ast_BuiltinExpr_getToContainerMember(b);
   ast_Decl* d = module_analyser_Analyser_findMemberOffset(ma, b, std, member);
   if (!d) return ast_QualType_Invalid;

   ast_QualType qmem = ast_Decl_getType(d);
   qmem = ast_builder_Builder_actOnPointerType(ma->builder, qmem);
   ast_QualType qptr = module_analyser_Analyser_analyseExpr(ma, ast_BuiltinExpr_getToContainerPointer2(b), false, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qptr)) return ast_QualType_Invalid;

   ast_Expr* eptr = ast_BuiltinExpr_getToContainerPointer(b);
   if (!conversion_checker_Checker_check(&ma->checker, qptr, qmem, ast_BuiltinExpr_getToContainerPointer2(b), ast_Expr_getLoc(eptr))) {
      return ast_QualType_Invalid;
   }
   if (ast_QualType_isConstPtr(&qptr)) ast_QualType_setConst(&qt);
   return ast_builder_Builder_actOnPointerType(ma->builder, qt);
}

static ast_Decl* module_analyser_Analyser_findMemberOffset(module_analyser_Analyser* ma, ast_BuiltinExpr* b, ast_StructTypeDecl* std, ast_Expr* member)
{
   uint32_t base_offset = 0;
   ast_Decl* d = NULL;
   if (ast_Expr_isIdentifier(member)) {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(member));
      uint32_t name_idx = ast_IdentifierExpr_getNameIdx(i);
      d = module_analyser_Analyser_findStructMemberOffset(ma, std, name_idx, ast_Expr_getLoc(member), &base_offset);
      if (!d) return NULL;

      ast_IdentifierExpr_setDecl(i, d);
      ast_Decl_setUsed(d);
      ast_Expr_setLValue(member);
      ast_IdentifierExpr_setKind(i, ast_IdentifierKind_StructMember);
   } else {
      (ast_Expr_isMember(member)) || c2_assert("analyser/module_analyser_builtin.c2", 211, "module_analyser.Analyser.findMemberOffset", "member.isMember()");
      ast_MemberExpr* m = ((ast_MemberExpr*)(member));
      for (uint32_t i = 0; (i < ast_MemberExpr_getNumRefs(m)); i++) {
         uint32_t name_idx = ast_MemberExpr_getNameIdx(m, i);
         src_loc_SrcLoc loc = ast_MemberExpr_getLoc(m, i);
         d = module_analyser_Analyser_findStructMemberOffset(ma, std, name_idx, loc, &base_offset);
         if (!d) return NULL;

         if (ast_Decl_isStructType(d)) std = ((ast_StructTypeDecl*)(d));
         ast_Decl_setUsed(d);
         ast_MemberExpr_setDecl(m, d, i);
      }
      ast_MemberExpr_setKind(m, ast_IdentifierKind_StructMember);
   }
   ast_Expr_setType(member, ast_Decl_getType(d));
   ast_BuiltinExpr_setUValue(b, base_offset);
   return d;
}

static ast_Decl* module_analyser_Analyser_findStructMemberOffset(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc, uint32_t* base)
{
   ast_Decl* d = ast_StructTypeDecl_findMember(s, name_idx, base);
   if (!d) module_analyser_Analyser_memberError(ma, name_idx, loc, s);
   return d;
}

static ast_QualType module_analyser_Analyser_analyseCallExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_CallExpr* call = ((ast_CallExpr*)(e));
   ast_Expr** func = ast_CallExpr_getFunc2(call);
   ast_Expr* origFn = ast_CallExpr_getFunc(call);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, func, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   if (ast_Expr_isNValue(origFn)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(origFn), ast_Expr_getRange(origFn), "called object is not a function of function pointer");
      return ast_QualType_Invalid;
   }
   ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(&qt);
   if (!ft) {
      ast_Expr* fn2 = ast_CallExpr_getFunc(call);
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(fn2), ast_Expr_getRange(fn2), "called object type %s is not a function or function pointer", ast_QualType_diagName(&qt));
      return ast_QualType_Invalid;
   }
   ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   ast_Decl_setUsed(ast_FunctionDecl_asDecl(fd));
   if (ast_FunctionDecl_hasAttrNoReturn(fd)) ast_CallExpr_setNoreturn(call);
   if (ast_FunctionDecl_isTemplate(fd)) {
      if (!ast_CallExpr_getTemplateArg(call)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "function %s requires a template argument", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
      fd = module_analyser_Analyser_instantiateTemplateFunction(ma, call, fd);
      if (!fd) return ast_QualType_Invalid;

   } else {
      if (ast_CallExpr_getTemplateArg(call)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "function %s is not a template function", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
   }
   uint32_t func_num_args = ast_FunctionDecl_getNumParams(fd);
   uint32_t call_num_args = ast_CallExpr_getNumArgs(call);
   _Bool isTypeFuncCall = false;
   src_loc_SrcLoc loc = ast_Expr_getLoc(e);
   ast_QualType baseType;
   ast_MemberExpr* m = NULL;
   if (ast_Expr_isMember(origFn)) {
      m = ((ast_MemberExpr*)(origFn));
      ast_Decl* fdd = ((ast_Decl*)(fd));
      switch (ast_FunctionDecl_getCallKind(fd)) {
      case ast_CallKind_Invalid:
         (0) || c2_assert("analyser/module_analyser_call.c2", 90, "module_analyser.Analyser.analyseCallExpr", "0");
         break;
      case ast_CallKind_Normal:
         break;
      case ast_CallKind_TypeFunc:
         if (!ast_MemberExpr_isStaticTypeFunc(m)) {
            isTypeFuncCall = true;
            ast_CallExpr_setCallsTypeFunc(call);
            baseType = ast_MemberExpr_getBaseType(m);
            loc = ast_MemberExpr_getLastLoc(m);
         }
         break;
      case ast_CallKind_StaticTypeFunc:
         if (!ast_MemberExpr_isStaticTypeFunc(m)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "'%s' is a static type-function; use '%s()'", ast_Decl_getFullName(fdd), ast_Decl_getFullName(fdd));
            module_analyser_Analyser_note(ma, ast_Decl_getLoc(fdd), "'%s' is defined here", ast_Decl_getFullName(fdd));
            return ast_QualType_Invalid;
         }
         ast_CallExpr_setCallsStaticTypeFunc(call);
         break;
      }
   }
   uint32_t num_auto_args = ast_FunctionDecl_getNumAutoArgs(fd);
   if (num_auto_args) ast_CallExpr_setHasAutoArgs(call);
   ast_VarDecl** func_args = ast_FunctionDecl_getParams(fd);
   ast_Expr** call_args = ast_CallExpr_getArgs(call);
   uint32_t func_arg_index = 0;
   uint32_t call_arg_index = 0;
   if (isTypeFuncCall) {
      ((ast_FunctionDecl_getNumParams(fd) >= 1)) || c2_assert("analyser/module_analyser_call.c2", 124, "module_analyser.Analyser.analyseCallExpr", "fd.getNumParams() >= 1");
      (m) || c2_assert("analyser/module_analyser_call.c2", 125, "module_analyser.Analyser.analyseCallExpr", "m");
      ast_VarDecl* arg0 = func_args[0];
      ast_QualType expectedType = ast_Decl_getType(ast_VarDecl_asDecl(arg0));
      if (ast_QualType_isPointer(&expectedType)) {
         if (!ast_QualType_isPointer(&baseType)) {
            baseType = ast_builder_Builder_actOnPointerType(ma->builder, baseType);
            ast_MemberExpr_setConversion(m, ast_MemberConversion_Addr);
         }
      } else {
         if (ast_QualType_isPointer(&baseType)) {
            baseType = ast_QualType_getPointerBaseType(&baseType);
            ast_MemberExpr_setConversion(m, ast_MemberConversion_Deref);
         }
      }
      _Bool ok = conversion_checker_Checker_check(&ma->checker, expectedType, baseType, e_ptr, loc);
      if (!ok) return ast_QualType_Invalid;

      func_arg_index++;
   }
   _Bool has_printf_format = false;
   uint32_t printf_call_idx = 0;
   while (1) {
      if ((func_arg_index >= func_num_args)) break;

      if ((call_arg_index >= call_num_args)) break;

      ast_VarDecl* vd = func_args[func_arg_index];
      if (ast_VarDecl_hasAutoAttr(vd)) {
         func_arg_index++;
         continue;
      }
      if (!module_analyser_Analyser_analyseInitExpr(ma, &call_args[call_arg_index], ast_Decl_getType(ast_VarDecl_asDecl(vd)), ast_Expr_getLoc(call_args[call_arg_index]))) return ast_QualType_Invalid;

      if (ast_VarDecl_hasPrintfFormat(vd)) {
         has_printf_format = true;
         printf_call_idx = call_arg_index;
      }
      func_arg_index++;
      call_arg_index++;
   }
   uint32_t expected_args = ((func_num_args - num_auto_args) - isTypeFuncCall);
   if ((call_num_args < expected_args)) {
      module_analyser_Analyser_error(ma, (ast_CallExpr_getEndLoc(call) - 1), "too few arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), expected_args, call_num_args);
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      return ast_QualType_Invalid;
   }
   if (((call_arg_index != call_num_args) || ast_FunctionDecl_isVariadic(fd))) {
      if (!ast_FunctionDecl_isVariadic(fd)) {
         ast_Expr* call_arg = call_args[call_arg_index];
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(call_arg), "too many arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), expected_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
      while ((call_arg_index != call_num_args)) {
         ast_QualType callType = module_analyser_Analyser_analyseExpr(ma, &call_args[call_arg_index], true, module_analyser_RHS);
         if (ast_QualType_isInvalid(&callType)) return ast_QualType_Invalid;

         if (ast_QualType_isVoid(&callType)) {
            ast_Expr* call_arg = call_args[call_arg_index];
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(call_arg), "passing 'void' as variadic argument is invalid");
            return ast_QualType_Invalid;
         }
         call_arg_index++;
      }
      if (has_printf_format) {
         uint32_t num_args = ((call_num_args - printf_call_idx) - 1);
         _Bool change_format = false;
         module_analyser_Analyser_checkPrintArgs(ma, call_args[printf_call_idx], num_args, &call_args[(printf_call_idx + 1)], &change_format);
         ast_CallExpr_setPrintfFormat(call, printf_call_idx, change_format);
      }
   }
   return ast_FunctionDecl_getRType(fd);
}

static _Bool module_analyser_on_format_specifier(void* context, printf_utils_Specifier specifier, uint32_t offset, int32_t stars, char c)
{
   module_analyser_FormatAnalyser* fa = context;
   module_analyser_Analyser* ma = fa->ma;
   ast_Expr** args = fa->args;
   if ((c == '\0')) {
      module_analyser_Analyser_error(ma, (fa->loc + offset), "missing conversion specifier at end of format string");
      return false;
   }
   if (((fa->idx + stars) >= fa->num_args)) {
      module_analyser_Analyser_error(ma, (fa->loc + offset), "too many format specifiers or not enough arguments");
      return false;
   }
   for (int32_t i = 0; (i < stars); i++) {
      ast_Expr* arg = args[fa->idx];
      ast_QualType qt = ast_Expr_getType(arg);
      qt = ast_QualType_getCanonicalType(&qt);
      if (!ast_QualType_promotesToInt32(&qt)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(arg), "argument for '*' width/precision specifier must be an i32");
      }
      fa->idx++;
   }
   ast_Expr* arg = args[fa->idx];
   ast_QualType qt = ast_Expr_getType(arg);
   qt = ast_QualType_getCanonicalType(&qt);
   switch (specifier) {
   case printf_utils_Specifier_Other:
      break;
   case printf_utils_Specifier_String:
      if (!ast_QualType_isCharPointer(&qt)) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%s' expects a string argument");
      }
      break;
   case printf_utils_Specifier_Char:
      if (((!ast_QualType_isChar(&qt) && !ast_QualType_isInt8(&qt)) && !ast_QualType_isUInt8(&qt))) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%c' expects a character argument");
      }
      break;
   case printf_utils_Specifier_Integer: {
      fa->change_format = true;
      if (ast_QualType_isEnum(&qt)) {
         ast_EnumType* et = ast_QualType_getEnumType(&qt);
         qt = ast_EnumType_getImplType(et);
      }
      ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(&qt);
      if ((!bi || !ast_BuiltinType_isIntegerOrBool(bi))) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%%c' expects an integer argument", c);
      }
      break;
   }
   case printf_utils_Specifier_FloatingPoint: {
      fa->change_format = true;
      ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(&qt);
      if ((!bi || !ast_BuiltinType_isFloatingPoint(bi))) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%%c' expects a floating-point argument", c);
      }
      break;
   }
   case printf_utils_Specifier_Pointer:
      if ((!ast_QualType_isPointer(&qt) && !ast_QualType_isFunction(&qt))) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%p' expects a pointer argument");
      }
      break;
   case printf_utils_Specifier_Invalid:
      switch (c) {
      case 'h':
         fallthrough;
      case 'j':
         fallthrough;
      case 'l':
         fallthrough;
      case 't':
         fallthrough;
      case 'w':
         fallthrough;
      case 'z':
         fallthrough;
      case 'L':
         module_analyser_Analyser_error(ma, (fa->loc + offset), "format length modifier '%c' should be omitted", c);
         break;
      case 'i':
         fallthrough;
      case 'u':
         module_analyser_Analyser_error(ma, (fa->loc + offset), "invalid format specifier '%%%c', should use '%%d'", c);
         break;
      default:
         module_analyser_Analyser_error(ma, (fa->loc + offset), "invalid format specifier '%%%c'", c);
         break;
      }
      return false;
   }
   fa->idx++;
   return true;
}

static void module_analyser_Analyser_checkPrintArgs(module_analyser_Analyser* ma, ast_Expr* format, uint32_t num_args, ast_Expr** args, _Bool* change_format)
{
   if (!ast_Expr_isImplicitCast(format)) goto not_constant;

   ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(format));
   if (!ast_ImplicitCastExpr_isArrayToPointerDecay(ic)) goto not_constant;

   format = ast_ImplicitCastExpr_getInner(ic);
   src_loc_SrcLoc format_loc;
   const char* format_text = printf_utils_get_format(format, &format_loc);
   if (!format_text) goto not_constant;

   module_analyser_FormatAnalyser fa = {
   ma,
   format_text,
   num_args,
   0,
   format_loc,
   false,
   args
};
   if (!printf_utils_parseFormat(format_text, module_analyser_on_format_specifier, &fa)) {
      return;
   }
   *change_format = fa.change_format;
   if ((fa.idx < num_args)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(args[fa.idx]), "too many arguments for format");
      return;
   }
   return;
   not_constant:
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(format), "format argument is not a constant string");
   return;
}

static void module_analyser_create_template_name(char* name, const char* orig, uint16_t idx)
{
   sprintf(name, "%s_%u_", orig, idx);
}

static void module_analyser_Analyser_opaque_callback(void* arg, src_loc_SrcLoc loc, ast_Decl* d)
{
   module_analyser_Analyser* ma = arg;
   ast_QualType qt = ast_Decl_getType(d);
   module_analyser_Analyser_error(ma, loc, " using opaque type '%s'", ast_QualType_diagName(&qt));
}

static ast_FunctionDecl* module_analyser_Analyser_instantiateTemplateFunction(module_analyser_Analyser* ma, ast_CallExpr* call, ast_FunctionDecl* fd)
{
   ast_TypeRef* template_arg = ast_CallExpr_getTemplateArg(call);
   ast_QualType templateType = module_analyser_Analyser_analyseTypeRef(ma, template_arg);
   if (ast_QualType_isInvalid(&templateType)) return NULL;

   ast_FunctionDecl* instance = ast_Module_findInstance(ma->mod, fd, templateType);
   if (!instance) {
      _Bool used_opaque = false;
      ast_StructType* st = ast_QualType_getStructTypeOrNil(&templateType);
      if (st) {
         ast_StructTypeDecl* std = ast_StructType_getDecl(st);
         ast_Decl* d = ((ast_Decl*)(std));
         used_opaque = ((ast_StructTypeDecl_isOpaque(std) && (ast_Decl_getModule(d) != ma->mod)));
      }
      ast_Instantiator inst = {
   .c = ma->context,
   .ref = template_arg,
   .template_name = ast_FunctionDecl_getTemplateNameIdx(fd),
   .instance_ast_idx = ast_CallExpr_getInstanceASTIdx(call),
   .used_opaque = used_opaque,
   .arg = ma,
   .on_error = module_analyser_Analyser_opaque_callback
};
      instance = ast_FunctionDecl_instantiate(fd, &inst);
      ast_Decl* d = ((ast_Decl*)(instance));
      module_analyser_Analyser_analyseFunction(ma, instance);
      if (ma->has_error) return NULL;

      ast_Decl_setChecked(d);
      ast_Module* template_mod = ast_Decl_getModule(ast_FunctionDecl_asDecl(fd));
      module_analyser_Analyser* analyser = module_analyser_create(ma->diags, ma->context, ma->astPool, ma->builder, ma->allmodules, ma->warnings);
      module_analyser_Analyser_setMod(analyser, template_mod);
      scope_Scope* tmpScope = scope_create(ma->allmodules, ma->diags, ast_AST_getImports(ast_Decl_getAST(d)), template_mod, ast_Module_getSymbols(template_mod), !ma->warnings->no_unused_variable);
      module_analyser_Analyser_analyseFunctionBody(analyser, instance, tmpScope);
      scope_Scope_free(tmpScope);
      module_analyser_Analyser_free(analyser);
      if (ma->has_error) return NULL;

      uint16_t instance_idx = ast_Module_addInstance(ma->mod, fd, templateType, instance);
      ast_FunctionDecl_setTemplateInstanceIdx(instance, instance_idx);
      char name[64];
      module_analyser_create_template_name(name, ast_Decl_getName(d), instance_idx);
      ast_FunctionDecl_setInstanceName(instance, string_pool_Pool_addStr(ma->astPool, name, true));
   }
   ast_CallExpr_setTemplateIdx(call, ast_FunctionDecl_getTemplateInstanceIdx(instance));
   return instance;
}

static ast_QualType module_analyser_Analyser_analysePureCallExpr(module_analyser_Analyser* ma, ast_Expr* e)
{
   ast_CallExpr* call = ((ast_CallExpr*)(e));
   ast_Expr** func = ast_CallExpr_getFunc2(call);
   ast_Expr* origFn = ast_CallExpr_getFunc(call);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, func, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   if (ast_Expr_isNValue(origFn)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(origFn), ast_Expr_getRange(origFn), "called object is not a function of function pointer");
      return ast_QualType_Invalid;
   }
   ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(&qt);
   if (!ft) {
      ast_Expr* fn2 = ast_CallExpr_getFunc(call);
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(fn2), ast_Expr_getRange(fn2), "called object type %s is not a function or function pointer", ast_QualType_diagName(&qt));
      return ast_QualType_Invalid;
   }
   ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   ast_Decl_setUsed(ast_FunctionDecl_asDecl(fd));
   if (!ast_FunctionDecl_hasAttrPure(fd)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "only pure functions can be called in global initializers");
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      return ast_QualType_Invalid;
   }
   uint32_t func_num_args = ast_FunctionDecl_getNumParams(fd);
   uint32_t call_num_args = ast_CallExpr_getNumArgs(call);
   ast_Expr** call_args = ast_CallExpr_getArgs(call);
   if ((func_num_args != call_num_args)) {
      if ((call_num_args > func_num_args)) {
         src_loc_SrcLoc loc = func_num_args ? ast_Expr_getEndLoc(call_args[(func_num_args - 1)]) : (ast_CallExpr_getEndLoc(call) - 1);
         module_analyser_Analyser_error(ma, loc, "too many arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), func_num_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      } else {
         module_analyser_Analyser_error(ma, (ast_CallExpr_getEndLoc(call) - 1), "too few arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), func_num_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      }
      return ast_QualType_Invalid;
   }
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, _Bool need_rvalue, uint32_t side)
{
   (e_ptr) || c2_assert("analyser/module_analyser_expr.c2", 25, "module_analyser.Analyser.analyseExpr", "e_ptr");
   ast_QualType result = module_analyser_Analyser_analyseExprInner(ma, e_ptr, side);
   if (ast_QualType_isInvalid(&result)) return result;

   ast_Expr* e = *e_ptr;
   ast_Expr_setType(e, result);
   if (need_rvalue) {
      if (ast_Expr_isLValue(e)) {
         ast_QualType canon = ast_QualType_getCanonicalType(&result);
         (ast_QualType_isValid(&canon)) || c2_assert("analyser/module_analyser_expr.c2", 35, "module_analyser.Analyser.analyseExpr", "canon.isValid()");
         if (ast_QualType_isArray(&canon)) {
            result = module_analyser_getPointerFromArray(ma->builder, canon);
            ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_ArrayToPointerDecay, e_ptr, result);
         } else {
            ast_QualType_unsetConst(&result);
            ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_LValueToRValue, e_ptr, result);
         }
      } else if (ast_Expr_isNValue(e)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "lvalue/rvalue required");
         return ast_QualType_Invalid;
      }

   }
   return result;
}

static ast_QualType module_analyser_Analyser_analyseExprInner(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      return ast_Expr_getType(e);
   case ast_ExprKind_FloatLiteral:
      return ast_Expr_getType(e);
   case ast_ExprKind_BooleanLiteral:
      return ast_builtins[ast_BuiltinKind_Bool];
   case ast_ExprKind_CharLiteral:
      return ast_builtins[ast_BuiltinKind_UInt8];
   case ast_ExprKind_StringLiteral:
      return ast_Expr_getType(e);
   case ast_ExprKind_Nil:
      return ast_getVoidPtr();
   case ast_ExprKind_Identifier: {
      ast_Decl* d = module_analyser_Analyser_analyseIdentifier(ma, e_ptr, side);
      if (!d) break;

      return ast_Decl_getType(d);
   }
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      return module_analyser_Analyser_analyseCallExpr(ma, e_ptr);
   case ast_ExprKind_InitList:
      ast_Expr_dump((*e_ptr));
      (0) || c2_assert("analyser/module_analyser_expr.c2", 80, "module_analyser.Analyser.analyseExprInner", "0");
      break;
   case ast_ExprKind_FieldDesignatedInit:
      ast_Expr_dump((*e_ptr));
      (0) || c2_assert("analyser/module_analyser_expr.c2", 84, "module_analyser.Analyser.analyseExprInner", "0");
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      ast_Expr_dump((*e_ptr));
      (0) || c2_assert("analyser/module_analyser_expr.c2", 88, "module_analyser.Analyser.analyseExprInner", "0");
      break;
   case ast_ExprKind_BinaryOperator:
      return module_analyser_Analyser_analyseBinaryOperator(ma, e_ptr);
   case ast_ExprKind_UnaryOperator:
      return module_analyser_Analyser_analyseUnaryOperator(ma, e_ptr, side);
   case ast_ExprKind_ConditionalOperator:
      return module_analyser_Analyser_analyseConditionalOperator(ma, e_ptr);
   case ast_ExprKind_Builtin:
      return module_analyser_Analyser_analyseBuiltin(ma, e_ptr);
   case ast_ExprKind_ArraySubscript:
      return module_analyser_Analyser_analyseArraySubscriptExpr(ma, e_ptr, side);
   case ast_ExprKind_Member:
      return module_analyser_Analyser_analyseMemberExpr(ma, e_ptr, side);
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_ParenExpr_getInner2(p), false, side);
      ast_Expr* inner = ast_ParenExpr_getInner(p);
      ast_Expr_copyConstantFlags(e, inner);
      ast_Expr_copyValType(e, inner);
      return qt;
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast:
      return module_analyser_Analyser_analyseExplicitCast(ma, e_ptr);
   case ast_ExprKind_ImplicitCast:
      break;
   case ast_ExprKind_Range:
      ast_Expr_dump((*e_ptr));
      (0) || c2_assert("analyser/module_analyser_expr.c2", 117, "module_analyser.Analyser.analyseExprInner", "0");
      break;
   }
   return ast_QualType_Invalid;
}

static const char* module_analyser_type2str(ast_QualType q)
{
   if (ast_QualType_isFunction(&q)) return "function";

   if (ast_QualType_isConst(&q)) return "constant";

   return "variable";
}

static ast_Decl* module_analyser_Analyser_analyseIdentifier(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
   ast_Decl* d = scope_Scope_find(ma->scope, ast_IdentifierExpr_getNameIdx(i), ast_Expr_getLoc(e), ma->usedPublic);
   if (!d) {
      ma->has_error = true;
      return NULL;
   }
   if (!ast_Decl_isChecked(d)) {
      if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) {
         return NULL;
      }
   }
   ast_QualType qt = ast_Decl_getType(d);
   if (ast_QualType_isInvalid(&qt)) return NULL;

   ast_Expr_setType(e, qt);
   ast_IdentifierExpr_setDecl(i, d);
   if (((side & module_analyser_RHS) || (side == 0))) ast_Decl_setUsed(d);
   else {
      if (ast_Decl_isVarDecl(d)) {
         ast_VarDecl* vd = ((ast_VarDecl*)(d));
         if (ast_VarDecl_isParameter(vd)) ast_Decl_setUsed(d);
      }
   }
   ast_IdentifierKind kind = module_analyser_Analyser_setExprFlags(ma, e_ptr, d);
   ast_IdentifierExpr_setKind(i, kind);
   if (((ma->usedPublic && !ast_Decl_isPublic(d)) && ast_Decl_isGlobal(d))) {
      const char* kind_str = module_analyser_type2str(qt);
      if (scope_Scope_inFunction(ma->scope)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "public inline function using non-public %s '%s'", kind_str, ast_Decl_getFullName(d));
      } else {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "public declaration using non-public %s '%s'", kind_str, ast_Decl_getFullName(d));
      }
      return NULL;
   }
   return d;
}

static ast_IdentifierKind module_analyser_Analyser_setExprFlags(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_Decl* d)
{
   ast_Expr* e = *e_ptr;
   ast_IdentifierKind kind = ast_IdentifierKind_Unresolved;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      ast_Expr_setCtc(e);
      ast_Expr_setRValue(e);
      kind = ast_IdentifierKind_Function;
      break;
   case ast_DeclKind_Import:
      ast_Expr_setCtc(e);
      kind = ast_IdentifierKind_Module;
      break;
   case ast_DeclKind_StructType:
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_EnumType:
      ast_Expr_setCtc(e);
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_EnumConstant:
      ast_Expr_setCtc(e);
      ast_Expr_setCtv(e);
      ast_Expr_setRValue(e);
      kind = ast_IdentifierKind_EnumConstant;
      break;
   case ast_DeclKind_FunctionType:
      ast_Expr_setCtc(e);
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_AliasType:
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_Variable: {
      ast_VarDecl* vd = ((ast_VarDecl*)(d));
      ast_QualType t = ast_Decl_getType(ast_VarDecl_asDecl(vd));
      if ((ast_VarDecl_isGlobal(vd) || ast_VarDecl_hasLocalQualifier(vd))) ast_Expr_setCtc(e);
      ast_Expr_setLValue(e);
      const ast_Expr* init_ = ast_VarDecl_getInit(vd);
      if (((init_ && ast_QualType_isConst(&t)) && ast_Expr_isCtv(init_))) ast_Expr_setCtv(e);
      switch (ast_VarDecl_getKind(vd)) {
      case ast_VarDeclKind_GlobalVar:
         fallthrough;
      case ast_VarDeclKind_LocalVar:
         fallthrough;
      case ast_VarDeclKind_FunctionParam:
         kind = ast_IdentifierKind_Var;
         break;
      case ast_VarDeclKind_StructMember:
         kind = ast_IdentifierKind_StructMember;
         break;
      }
      break;
   }
   }
   return kind;
}

static ast_QualType module_analyser_Analyser_analyseConditionalOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_ConditionalOperator* cond = ((ast_ConditionalOperator*)(e));
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_ConditionalOperator_getCond2(cond), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return ast_QualType_Invalid;

   conversion_checker_Checker_check(&ma->checker, ast_builtins[ast_BuiltinKind_Bool], qt, ast_ConditionalOperator_getCond2(cond), ast_Expr_getLoc(ast_ConditionalOperator_getCond(cond)));
   ast_QualType lhs = module_analyser_Analyser_analyseExpr(ma, ast_ConditionalOperator_getLHS2(cond), true, module_analyser_RHS);
   ast_QualType rhs = module_analyser_Analyser_analyseExpr(ma, ast_ConditionalOperator_getRHS2(cond), true, module_analyser_RHS);
   if ((ast_QualType_isInvalid(&lhs) || ast_QualType_isInvalid(&rhs))) return ast_QualType_Invalid;

   ast_QualType lcanon = ast_QualType_getCanonicalType(&lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(&rhs);
   (ast_QualType_isValid(&lcanon)) || c2_assert("analyser/module_analyser_expr.c2", 268, "module_analyser.Analyser.analyseConditionalOperator", "lcanon.isValid()");
   (ast_QualType_isValid(&rcanon)) || c2_assert("analyser/module_analyser_expr.c2", 269, "module_analyser.Analyser.analyseConditionalOperator", "rcanon.isValid()");
   if (ast_Expr_isCtv(ast_ConditionalOperator_getCond(cond))) ast_Expr_combineConstantFlags(e, ast_ConditionalOperator_getLHS(cond), ast_ConditionalOperator_getRHS(cond));
   uint8_t res = module_analyser_CondOpTable[ast_QualType_getKind(&lcanon)][ast_QualType_getKind(&rcanon)];
   switch (res) {
   case 0:
      break;
   case 1:
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to ternary operator (%s and %s)", ast_QualType_diagName(&lhs), ast_QualType_diagName(&rhs));
      return ast_QualType_Invalid;
   case 2:
      return conversion_checker_get_common_arithmetic_type(lcanon, rcanon);
   case 3:
      return lhs;
   case 4:
      return lhs;
   case 5: {
      _Bool ok = conversion_checker_Checker_check(&ma->checker, lhs, rhs, e_ptr, ast_Expr_getLoc(e));
      if (!ok) return ast_QualType_Invalid;

      return lhs;
   }
   case 6:
      return rhs;
   case 7: {
      _Bool ok = conversion_checker_Checker_check(&ma->checker, lhs, rhs, e_ptr, ast_Expr_getLoc(e));
      if (!ok) return ast_QualType_Invalid;

      return lhs;
   }
   case 8:
      return lhs;
   }
   ast_Expr_dump(e);
   (0) || c2_assert("analyser/module_analyser_expr.c2", 304, "module_analyser.Analyser.analyseConditionalOperator", "0");
   return ast_QualType_Invalid;
}

static _Bool module_analyser_Analyser_checkAssignment(module_analyser_Analyser* ma, ast_Expr* assignee, ast_QualType tleft, const char* msg, src_loc_SrcLoc loc)
{
   if (ast_QualType_isConst(&tleft)) {
      if (ast_Expr_isIdentifier(assignee)) {
         ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(assignee));
         module_analyser_Analyser_error(ma, loc, "cannot assign to read-only variable '%s'", ast_Decl_getFullName(ast_IdentifierExpr_getDecl(i)));
         return false;
      }
      if (ast_Expr_isMember(assignee)) {
         ast_MemberExpr* m = ((ast_MemberExpr*)(assignee));
         switch (ast_MemberExpr_getKind(m)) {
         case ast_IdentifierKind_Unresolved:
            (0) || c2_assert("analyser/module_analyser_expr.c2", 320, "module_analyser.Analyser.checkAssignment", "0");
            break;
         case ast_IdentifierKind_Module:
            (0) || c2_assert("analyser/module_analyser_expr.c2", 323, "module_analyser.Analyser.checkAssignment", "0");
            break;
         case ast_IdentifierKind_Function:
            break;
         case ast_IdentifierKind_Type:
            break;
         case ast_IdentifierKind_Var:
            module_analyser_Analyser_error(ma, loc, "cannot assign to read-only variable '%s'", ast_MemberExpr_getLastMemberName(m));
            return false;
         case ast_IdentifierKind_EnumConstant:
            break;
         case ast_IdentifierKind_StructMember:
            module_analyser_Analyser_error(ma, loc, "assignment of member '%s' in read-only object", ast_MemberExpr_getLastMemberName(m));
            return false;
         case ast_IdentifierKind_Label:
            break;
         }
      }
      module_analyser_Analyser_error(ma, loc, "cannot assign to variable with const-qualified type '%s'", ast_QualType_diagName(&tleft));
      return false;
   }
   if (!ast_Expr_isLValue(assignee)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(assignee), ast_Expr_getRange(assignee), "lvalue required as %s", msg);
      return false;
   }
   if (ast_QualType_isArray(&tleft)) {
      module_analyser_Analyser_error(ma, loc, "array type '%s' is not assignable", ast_QualType_diagName(&tleft));
      return false;
   }
   return true;
}

static ast_QualType module_analyser_usualUnaryConversions(ast_Expr* e)
{
   ast_QualType qt = ast_Expr_getType(e);
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   if (ast_QualType_isBuiltin(&canon)) {
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&canon);
      if (ast_BuiltinType_isPromotableIntegerType(bi)) return ast_builtins[ast_BuiltinKind_Int32];

   } else if (ast_QualType_isPointer(&canon)) {
      return ast_builtins[ast_BuiltinKind_UInt64];
   }

   return qt;
}

static ast_QualType module_analyser_Analyser_analyseExplicitCast(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_ExplicitCastExpr* c = ((ast_ExplicitCastExpr*)(e));
   ast_TypeRef* ref = ast_ExplicitCastExpr_getTypeRef(c);
   ast_QualType destType = module_analyser_Analyser_analyseTypeRef(ma, ref);
   ast_QualType srcType = module_analyser_Analyser_analyseExpr(ma, ast_ExplicitCastExpr_getInner2(c), true, module_analyser_RHS);
   if ((ast_QualType_isInvalid(&srcType) || ast_QualType_isInvalid(&destType))) return ast_QualType_Invalid;

   ast_Expr* inner = ast_ExplicitCastExpr_getInner(c);
   ast_Expr_copyConstantFlags(e, inner);
   ast_Expr_copyValType(e, inner);
   ast_ExplicitCastExpr_setDestType(c, destType);
   if (!ast_QualType_isScalar(&destType)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "used type '%s' where arithmetic or pointer type is required", ast_QualType_diagName(&destType));
      return ast_QualType_Invalid;
   }
   if (!conversion_checker_Checker_checkCast(&ma->checker, destType, srcType, ast_TypeRef_getLoc(ref), ast_Expr_getLoc(inner))) return ast_QualType_Invalid;

   return destType;
}

static ast_QualType module_analyser_Analyser_analyseArraySubscriptExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_ArraySubscriptExpr* sub = ((ast_ArraySubscriptExpr*)(e));
   ast_Expr* orig = ast_ArraySubscriptExpr_getBase(sub);
   ast_QualType q = module_analyser_Analyser_analyseExpr(ma, ast_ArraySubscriptExpr_getBase2(sub), true, (side | module_analyser_RHS));
   if (ast_QualType_isInvalid(&q)) return q;

   ast_Expr* index = ast_ArraySubscriptExpr_getIndex(sub);
   if (ast_Expr_isBitOffset(index)) {
      if ((side & module_analyser_LHS)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "bitoffset cannot be used as left hand side expression");
         return ast_QualType_Invalid;
      }
      ast_Expr* base = ast_ArraySubscriptExpr_getBase(sub);
      q = module_analyser_Analyser_analyseBitOffsetExpr(ma, q, base, index);
      ast_Expr_combineConstantFlags(e, base, index);
      return q;
   }
   q = ast_QualType_getCanonicalType(&q);
   if (!ast_QualType_isPointer(&q)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "subscripted value is not an array or pointer");
      return ast_QualType_Invalid;
   }
   ast_QualType qidx = module_analyser_Analyser_analyseExpr(ma, ast_ArraySubscriptExpr_getIndex2(sub), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qidx)) return qidx;

   ast_QualType canon = ast_QualType_getCanonicalType(&qidx);
   if ((!ast_QualType_isInteger(&canon) && !ast_QualType_isEnum(&canon))) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(ast_ArraySubscriptExpr_getIndex(sub)), "array subscript is not an integer");
      return ast_QualType_Invalid;
   }
   index = ast_ArraySubscriptExpr_getIndex(sub);
   if (ast_Expr_isCtv(index)) {
      ast_QualType q2 = ast_Expr_getType(orig);
      ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(&q2);
      if (at) {
         uint32_t size = ast_ArrayType_getSize(at);
         if ((size != 0)) {
            ast_Value val = ctv_analyser_get_value(index);
            uint64_t idx = ast_Value_as_u64(&val);
            if ((idx >= size)) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(index), "array out-of-bounds access [%lu] in array of [%u]", idx, size);
               return ast_QualType_Invalid;
            }
         }
      }
   }
   ast_PointerType* pt = ast_QualType_getPointerType(&q);
   return ast_PointerType_getInner(pt);
}

static ast_QualType module_analyser_Analyser_analyseBitOffsetExpr(module_analyser_Analyser* ma, ast_QualType ltype, ast_Expr* base, ast_Expr* e)
{
   ast_BitOffsetExpr* bo = ((ast_BitOffsetExpr*)(e));
   ast_QualType canon = ast_QualType_getCanonicalType(&ltype);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(&canon);
   if ((!ast_QualType_isBuiltin(&canon) || !ast_BuiltinType_isUnsigned(bi))) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(base), "bitoffsets are only allowed on unsigned integer type");
      return ast_QualType_Invalid;
   }
   ast_Value lval;
   ast_Value rval;
   _Bool lvalid = module_analyser_Analyser_analyseBitOffsetIndex(ma, ast_BitOffsetExpr_getLHS2(bo), canon, &lval);
   _Bool rvalid = module_analyser_Analyser_analyseBitOffsetIndex(ma, ast_BitOffsetExpr_getRHS2(bo), canon, &rval);
   if ((lvalid && rvalid)) {
      if (!ast_Value_is_less(&rval, &lval)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "left bitoffset index is smaller than right index");
         return ast_QualType_Invalid;
      }
      ast_Value width = ast_Value_minus(&lval, &rval);
      uint64_t w = (ast_Value_as_u64(&width) + 1);
      if ((w <= 8)) {
         ltype = ast_builtins[ast_BuiltinKind_UInt8];
      } else if ((w <= 16)) {
         ltype = ast_builtins[ast_BuiltinKind_UInt16];
      } else if ((w <= 32)) {
         ltype = ast_builtins[ast_BuiltinKind_UInt32];
      } else {
         ltype = ast_builtins[ast_BuiltinKind_UInt64];
      }


      ast_BitOffsetExpr_setWidth(bo, ((uint8_t)(w)));
      ast_Expr_setType(e, ltype);
   }
   ast_Expr_combineConstantFlags(e, ast_BitOffsetExpr_getLHS(bo), ast_BitOffsetExpr_getRHS(bo));
   return ltype;
}

static _Bool module_analyser_Analyser_analyseBitOffsetIndex(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType baseType, ast_Value* result)
{
   ast_BuiltinType* base_bi = ast_QualType_getBuiltin(&baseType);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, e_ptr, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return false;

   ast_Expr* e = *e_ptr;
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(&canon);
   if ((!ast_QualType_isBuiltin(&canon) || !ast_BuiltinType_isInteger(bi))) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "index of bitoffset has non-integer type '%s'", ast_QualType_diagName(&qt));
      return false;
   }
   if (!ast_Expr_isCtv(e)) return false;

   ast_Value val = ctv_analyser_get_value(e);
   if (ast_Value_isNegative(&val)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "bitoffset index value '%s' is negative", ast_Value_str(&val));
      return false;
   }
   if (ast_Value_isFloat(&val)) {
      return false;
   }
   if ((ast_Value_as_u64(&val) >= ast_BuiltinType_getWidth(base_bi))) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "bitoffset index value '%s' too large for type '%s'", ast_Value_str(&val), ast_QualType_diagName(&baseType));
      return false;
   }
   *result = val;
   return true;
}

static void module_analyser_Analyser_memberError(module_analyser_Analyser* ma, uint32_t name_idx, src_loc_SrcLoc loc, ast_StructTypeDecl* s)
{
   module_analyser_Analyser_error(ma, loc, "no member named '%s' in %s '%s'", ast_idx2name(name_idx), ast_StructTypeDecl_isStruct(s) ? "struct" : "union", ast_Decl_getFullName(ast_StructTypeDecl_asDecl(s)));
}

static ast_Decl* module_analyser_Analyser_findStructMember(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc, uint32_t* offset, _Bool allow_funcs)
{
   ast_Decl* d = ast_StructTypeDecl_findAny(s, name_idx, offset);
   if ((!d || ((!allow_funcs && ast_Decl_isFunction(d))))) {
      module_analyser_Analyser_memberError(ma, name_idx, loc, s);
      return NULL;
   }
   return d;
}

static ast_QualType module_analyser_getPointerFromArray(ast_builder_Builder* builder, ast_QualType q)
{
   const ast_ArrayType* a = ((ast_ArrayType*)(ast_QualType_getTypeOrNil(&q)));
   ast_QualType elem = ast_ArrayType_getElemType(a);
   if (ast_QualType_isConst(&q)) ast_QualType_setConst(&elem);
   ast_QualType res = ast_builder_Builder_actOnPointerType(builder, elem);
   return res;
}

static void module_analyser_Analyser_analyseFunction(module_analyser_Analyser* ma, ast_FunctionDecl* fd)
{
   if (ast_FunctionDecl_isTemplate(fd)) {
      scope_Scope_checkGlobalSymbol(ma->scope, ast_FunctionDecl_getTemplateNameIdx(fd), ast_FunctionDecl_getTemplateLoc(fd));
      ast_TypeRef* rtype = ast_FunctionDecl_getReturnTypeRef(fd);
      if (ast_TypeRef_getNumArrays(rtype)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions are not allowed to return array types");
      }
      uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
      ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
      for (uint32_t i = 0; (i < num_params); i++) {
         ast_VarDecl* v = params[i];
         ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
         if (ast_TypeRef_getNumArrays(ref)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array types are not allowed here");
         }
      }
      return;
   }
   ast_TypeRef* rtype = ast_FunctionDecl_getReturnTypeRef(fd);
   ast_QualType qt = module_analyser_Analyser_analyseTypeRef(ma, rtype);
   if (ast_QualType_isInvalid(&qt)) return;

   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   if (ast_QualType_isArray(&canon)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions are not allowed to return array types");
   }
   if ((ast_QualType_isConst(&canon) && !ast_QualType_isPointer(&canon))) {
      module_analyser_Analyser_warn(ma, ast_TypeRef_getLoc(rtype), "'const' type qualifier on return type has no effect");
   }
   _Bool is_public = ast_Decl_isPublic(ast_FunctionDecl_asDecl(fd));
   if (is_public) ast_setTypePublicUsed(qt);
   ast_FunctionDecl_setRType(fd, qt);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   uint32_t auto_arg_count = 0;
   uint32_t first_auto_arg = 0;
   for (uint32_t i = 0; (i < num_params); i++) {
      ast_VarDecl* v = params[i];
      ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
      ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
      if (ast_QualType_isInvalid(&res)) continue;

      canon = ast_QualType_getCanonicalType(&res);
      if (ast_QualType_isArray(&canon)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array types are not allowed here");
         continue;
      }
      if (ast_QualType_isVoid(&canon)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "parameter has invalid type 'void'");
         continue;
      }
      if (is_public) ast_setTypePublicUsed(res);
      if (ast_VarDecl_hasAutoAttr(v)) {
         if ((auto_arg_count == 0)) first_auto_arg = i;
         auto_arg_count++;
         if ((ast_VarDecl_hasAttrAutoFile(v) && !ast_TypeRef_isConstCharPtr(ref))) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "attribute 'auto_file' requires a parameter of type 'const char*'");
         }
         if ((ast_VarDecl_hasAttrAutoLine(v) && !ast_TypeRef_isU32(ref))) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "attribute 'auto_line' requires a parameter of type 'u32'");
         }
      }
      if (ast_VarDecl_hasPrintfFormat(v)) {
         module_analyser_Analyser_checkPrintfFormat(ma, v, res, i, fd);
         ast_FunctionDecl_setAttrPrintf(fd, ((uint8_t)((i + 1))));
      }
      ast_Decl* d = ((ast_Decl*)(v));
      ast_Decl_setType(d, res);
      ast_Decl_setChecked(d);
   }
   _Bool is_typefn = false;
   if ((num_params && ast_FunctionDecl_hasPrefix(fd))) {
      const ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
      const ast_Decl* pd = prefix->decl;
      (pd) || c2_assert("analyser/module_analyser_function.c2", 121, "module_analyser.Analyser.analyseFunction", "pd");
      ast_QualType prefixType = ast_Decl_getType(pd);
      _Bool is_non_static = true;
      ast_TypeRef* ref = ast_VarDecl_getTypeRef(params[0]);
      const ast_Ref* param_ref = ast_TypeRef_getUser(ref);
      if (ast_Decl_isStructType(pd)) {
         is_non_static = ast_TypeRef_isPointerTo(ref, ast_QualType_getIndex(&prefixType));
      } else {
         is_non_static = ((((param_ref && (param_ref->decl == prefix->decl))) || ast_TypeRef_isPointerTo(ref, ast_QualType_getIndex(&prefixType))));
      }
      if (is_non_static) {
         ast_FunctionDecl_setCallKind(fd, ast_CallKind_TypeFunc);
         is_typefn = true;
      }
   }
   if (auto_arg_count) {
      ast_FunctionDecl_setNumAutoArgs(fd, auto_arg_count);
      _Bool seen_normal_arg = false;
      uint32_t start = 0;
      if (is_typefn) start = 1;
      for (uint32_t i = start; (i < num_params); i++) {
         ast_VarDecl* v = params[i];
         if (ast_VarDecl_hasAutoAttr(v)) {
            if (seen_normal_arg) {
               module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(v)), "auto-arguments must come before normal arguments");
            }
         } else {
            seen_normal_arg = true;
         }
      }
   }
   if ((ast_FunctionDecl_hasAttrConstructor(fd) || ast_FunctionDecl_hasAttrDestructor(fd))) {
      if (!ast_TypeRef_isVoid(rtype)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions marked with '%s' cannot return a value", ast_FunctionDecl_hasAttrConstructor(fd) ? "constructor" : "destructor");
      }
      if ((num_params || ast_FunctionDecl_isVariadic(fd))) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions marked with '%s' cannot have arguments", ast_FunctionDecl_hasAttrConstructor(fd) ? "constructor" : "destructor");
      }
   }
   if (ast_FunctionDecl_hasAttrPure(fd)) {
      if ((num_params == 0)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), "pure functions must have arguments");
         return;
      }
      if (ast_FunctionDecl_isVariadic(fd)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), "pure functions cannot be variadic");
         return;
      }
      if (!ast_FunctionDecl_hasReturn(fd)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "pure functions must return a value");
         return;
      }
      if (auto_arg_count) {
         ast_VarDecl* v = params[first_auto_arg];
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(v)), "pure functions cannot have auto-arguments");
         return;
      }
   }
}

static void module_analyser_Analyser_analyseFunctionBody(module_analyser_Analyser* ma, ast_FunctionDecl* fd, scope_Scope* s)
{
   if (ast_FunctionDecl_isTemplate(fd)) return;

   ast_CompoundStmt* body = ast_FunctionDecl_getBody(fd);
   if (!body) return;

   ast_Decl* d = ((ast_Decl*)(fd));
   module_analyser_Analyser_pushCheck(ma, d, s, fd);
   ma->checkStack[0].usedPublic = false;
   ma->usedPublic = ast_FunctionDecl_isInline(fd);
   scope_Scope_reset(ma->scope);
   scope_Scope_enter(ma->scope, (scope_Function | scope_Decl));
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; (i < num_params); i++) {
      ast_Decl* p = ((ast_Decl*)(params[i]));
      if (ast_Decl_getNameIdx(p)) {
         _Bool error = scope_Scope_add(ma->scope, p);
         if (error) return;

      }
   }
   ma->has_error = false;
   label_vector_LabelVector_reset(&ma->labels);
   module_analyser_Analyser_analyseCompoundStmt(ma, body);
   ast_QualType rtype = ast_FunctionDecl_getRType(fd);
   if (!ast_QualType_isVoid(&rtype)) {
      if (!module_analyser_hasReturn(((ast_Stmt*)(body)))) {
         module_analyser_Analyser_error(ma, (ast_CompoundStmt_getEndLoc(body) - 1), "control reaches end of non-void function");
      }
   }
   if ((!ma->warnings->no_unused_parameter && !ast_FunctionDecl_hasAttrUnusedParams(fd))) {
      for (uint32_t i = 0; (i < num_params); i++) {
         ast_Decl* p = ((ast_Decl*)(params[i]));
         if ((!ast_Decl_isUsed(p) && ast_Decl_getNameIdx(p))) {
            module_analyser_Analyser_warn(ma, ast_Decl_getLoc(p), "unused parameter '%s'", ast_Decl_getName(p));
         }
      }
   }
   scope_Scope_exit(ma->scope, ma->has_error);
   uint32_t num_labels = label_vector_LabelVector_getCount(&ma->labels);
   const label_vector_Label* labels = label_vector_LabelVector_getLabels(&ma->labels);
   for (uint32_t i = 0; (i < num_labels); i++) {
      const label_vector_Label* l = &labels[i];
      if (l->is_label) {
         if ((!l->used && !ma->warnings->no_unused_label)) {
            module_analyser_Analyser_warn(ma, l->loc, "unused label '%s'", ast_idx2name(l->name_idx));
         }
      } else {
         module_analyser_Analyser_error(ma, l->loc, "use of undeclared label '%s'", ast_idx2name(l->name_idx));
      }
   }
   module_analyser_Analyser_popCheck(ma);
}

static void module_analyser_Analyser_checkPrintfFormat(module_analyser_Analyser* ma, ast_VarDecl* v, ast_QualType qt, uint32_t idx, ast_FunctionDecl* fd)
{
   ast_Decl* d = ((ast_Decl*)(v));
   if (!ast_QualType_isCharPointer(&qt)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "printf_format parameter must have type 'const char*'");
      return;
   }
   if (ast_VarDecl_hasAutoAttr(v)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "printf_format parameter cannot be an auto-argument");
      return;
   }
   if (!ast_FunctionDecl_isVariadic(fd)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "printf_format functions must have a variable number of arguments");
      return;
   }
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   if ((idx != (num_params - 1))) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "printf_format parameter must be the last parameter)");
      return;
   }
}

static _Bool module_analyser_Analyser_analyseInitExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType, src_loc_SrcLoc assignLoc)
{
   ast_Expr* e = *e_ptr;
   if (ast_Expr_isInitList(e)) {
      return module_analyser_Analyser_analyseInitListExpr(ma, ((ast_InitListExpr*)(e)), expectedType);
   }
   if (ast_Expr_isStringLiteral(e)) {
      ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(&expectedType);
      if (at) {
         ast_QualType elem = ast_ArrayType_getElemType(at);
         if ((((ast_QualType_getTypeOrNil(&elem) != ast_QualType_getTypeOrNil(&ast_builtins[ast_BuiltinKind_Char])) && (ast_QualType_getTypeOrNil(&elem) != ast_QualType_getTypeOrNil(&ast_builtins[ast_BuiltinKind_Int8]))) && (ast_QualType_getTypeOrNil(&elem) != ast_QualType_getTypeOrNil(&ast_builtins[ast_BuiltinKind_UInt8])))) {
            module_analyser_Analyser_errorRange(ma, assignLoc, ast_Expr_getRange(e), "cannot initialize array of '%s' with a string literal", ast_QualType_diagName(&elem));
            return false;
         }
         ast_QualType st = ast_Expr_getType(e);
         ast_ArrayType* at2 = ast_QualType_getArrayType(&st);
         uint32_t rhs_len = ast_ArrayType_getSize(at2);
         if (ast_ArrayType_hasSize(at)) {
            uint32_t lhs_len = ast_ArrayType_getSize(at);
            if ((rhs_len > lhs_len)) {
               module_analyser_Analyser_errorRange(ma, assignLoc, ast_Expr_getRange(e), "initializer-string for char array is too long");
               return false;
            }
         } else {
            ast_ArrayType_setSize(at, rhs_len);
         }
         ast_Expr_setRValue(e);
      } else {
         ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, e_ptr, true, module_analyser_RHS);
         e = *e_ptr;
         if (!conversion_checker_Checker_check(&ma->checker, expectedType, ast_Expr_getType(e), e_ptr, assignLoc)) return false;

      }
      return true;
   }
   if (ast_QualType_isArray(&expectedType)) {
      module_analyser_Analyser_error(ma, assignLoc, "array initializer must be an initializer list");
      return false;
   }
   if ((ast_Expr_isCall(e) && module_analyser_Analyser_globalScope(ma))) {
      ast_QualType qt = module_analyser_Analyser_analysePureCallExpr(ma, e);
      return true;
   }
   if (module_analyser_Analyser_checkEnumArg(ma, e_ptr, expectedType)) return true;

   ast_QualType res = module_analyser_Analyser_analyseExpr(ma, e_ptr, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&res)) return false;

   e = *e_ptr;
   if (((ast_Expr_isCtv(e) && ast_QualType_isBuiltin(&expectedType)) && !ast_QualType_isPointer(&res))) {
      if (ast_QualType_isBool(&expectedType)) return true;

      if (!ctv_analyser_check(ma->diags, expectedType, e)) return false;

      ast_Expr_setType(e, expectedType);
      return true;
   }
   if (!conversion_checker_Checker_check(&ma->checker, expectedType, res, e_ptr, assignLoc)) return false;

   if ((!ma->curFunction && !ast_Expr_isCtv(e))) {
      if (!ast_Expr_isCtc(e)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time constant");
         return false;
      }
      if (ast_QualType_needsCtvInit(&expectedType)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time value");
         return false;
      }
   }
   return true;
}

static _Bool module_analyser_Analyser_checkEnumArg(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType)
{
   ast_Expr* e = *e_ptr;
   if ((ast_Expr_isIdentifier(e) && ast_QualType_isEnum(&expectedType))) {
      ast_EnumType* et = ast_QualType_getEnum(&expectedType);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_IdentifierExpr* ie = ((ast_IdentifierExpr*)(e));
      ast_EnumConstantDecl* ecd = ast_EnumTypeDecl_findConstant(etd, ast_IdentifierExpr_getNameIdx(ie));
      if (ecd) {
         ast_Decl* d = ((ast_Decl*)(ecd));
         ast_Decl_setUsed(d);
         ast_Expr_setType(e, expectedType);
         ast_IdentifierExpr_setDecl(ie, d);
         ast_IdentifierKind kind = module_analyser_Analyser_setExprFlags(ma, e_ptr, d);
         ast_IdentifierExpr_setKind(ie, kind);
         return true;
      }
   }
   return false;
}

static _Bool module_analyser_Analyser_analyseInitListExpr(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(&expectedType);
   if (ast_Type_isArrayType(t)) {
      ast_InitListExpr_setIsArray(ile);
      return module_analyser_Analyser_analyseInitListArray(ma, ile, expectedType);
   }
   if (ast_Type_isStructType(t)) {
      return module_analyser_Analyser_analyseInitListStruct(ma, ile, expectedType);
   }
   ast_Expr* e = ((ast_Expr*)(ile));
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot initialize variable of type '%s' with initializer list", ast_QualType_diagName(&expectedType));
   return false;
}

static _Bool module_analyser_Analyser_analyseArrayDesignatedInit(module_analyser_Analyser* ma, ast_Expr* e, ast_QualType expectedType)
{
   ast_ArrayDesignatedInitExpr* ad = ((ast_ArrayDesignatedInitExpr*)(e));
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_ArrayDesignatedInitExpr_getDesignator2(ad), false, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return false;

   ast_Expr* de = ast_ArrayDesignatedInitExpr_getDesignator(ad);
   if (!ast_Expr_isCtv(de)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(de), ast_Expr_getRange(de), "array index is not a compile-time value");
      return false;
   }
   ast_Expr* val = ast_ArrayDesignatedInitExpr_getInit(ad);
   if (ast_Expr_isInitList(val)) {
      return module_analyser_Analyser_analyseInitListExpr(ma, ((ast_InitListExpr*)(val)), expectedType);
   }
   _Bool ok = module_analyser_Analyser_analyseInitExpr(ma, ast_ArrayDesignatedInitExpr_getInit2(ad), expectedType, ast_Expr_getLoc(val));
   if (!ok) return false;

   if (!ma->curFunction) {
      if (!ast_Expr_isCtc(val)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(val), ast_Expr_getRange(val), "initializer element is not a compile-time constant");
         return false;
      }
      if ((!ast_Expr_isCtv(val) && ast_QualType_needsCtvInit(&expectedType))) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(val), ast_Expr_getRange(val), "initializer element is not a compile-time value");
         return false;
      }
   }
   val = ast_ArrayDesignatedInitExpr_getInit(ad);
   ast_Expr_copyConstantFlags(e, val);
   ast_Expr_setType(e, expectedType);
   return true;
}

static _Bool module_analyser_Analyser_analyseInitListArray(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType)
{
   ast_Expr* e = ((ast_Expr*)(ile));
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   ast_QualType_clearQuals(&expectedType);
   ast_ArrayType* at = ast_QualType_getArrayType(&expectedType);
   ast_QualType et = ast_ArrayType_getElemType(at);
   ast_QualType_clearQuals(&et);
   _Bool ok = true;
   _Bool ctc = true;
   _Bool have_designators = false;
   uint32_t current_index = 0;
   for (uint32_t i = 0; (i < numValues); i++) {
      ast_Expr* value = values[i];
      if (ast_Expr_isFieldDesignatedInit(value)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(value), ast_Expr_getRange(value), "field designator cannot initialize an array");
         ok = false;
         continue;
      }
      if (ast_Expr_isArrayDesignatedInit(value)) {
         ok &= module_analyser_Analyser_analyseArrayDesignatedInit(ma, value, et);
         have_designators = true;
         continue;
      }
      ok &= module_analyser_Analyser_analyseInitExpr(ma, &values[i], et, ast_Expr_getLoc(values[i]));
      ctc &= ast_Expr_isCtc(values[i]);
   }
   current_index = numValues;
   if (ctc) ast_Expr_setCtc(e);
   if (!ok) return false;

   if (have_designators) {
      ast_InitListExpr_setHasDesignators(ile);
      int32_t array_size = -1;
      if (ast_ArrayType_hasSize(at)) array_size = ((int32_t)(ast_ArrayType_getSize(at)));
      init_checker_Checker* checker = module_analyser_Analyser_getInitChecker(ma);
      ok = module_analyser_Analyser_checkArrayDesignators(ma, ile, &array_size, checker);
      module_analyser_Analyser_putInitChecker(ma, checker);
      if (!ast_ArrayType_hasSize(at)) ast_ArrayType_setSize(at, ((uint32_t)(array_size)));
   } else {
      if (ast_ArrayType_hasSize(at)) {
         uint32_t arraySize = ast_ArrayType_getSize(at);
         if ((current_index > arraySize)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(values[arraySize]), "excess elements in array initializer");
            return false;
         }
      } else {
         ast_ArrayType_setSize(at, numValues);
      }
   }
   ast_Expr_setType(e, expectedType);
   return ok;
}

static _Bool module_analyser_Analyser_checkArrayDesignators(module_analyser_Analyser* ma, ast_InitListExpr* ile, int32_t* size, init_checker_Checker* checker)
{
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   int32_t max_index = 0;
   int32_t current_index = -1;
   for (uint32_t i = 0; (i < numValues); i++) {
      src_loc_SrcLoc loc;
      ast_Expr* value = values[i];
      if (ast_Expr_isArrayDesignatedInit(value)) {
         ast_ArrayDesignatedInitExpr* ad = ((ast_ArrayDesignatedInitExpr*)(value));
         ast_Expr* desig = ast_ArrayDesignatedInitExpr_getDesignator(ad);
         loc = ast_Expr_getLoc(desig);
         ast_Value idx = ctv_analyser_get_value(desig);
         if (ast_Value_isNegative(&idx)) {
            module_analyser_Analyser_error(ma, loc, "array designator value '%s' is negative", ast_Value_str(&idx));
            return false;
         }
         if (((*size != -1) && (((*size <= 0) || !ast_Value_checkRange(&idx, 0, ((uint64_t)((*size - 1)))))))) {
            module_analyser_Analyser_error(ma, loc, "array designator index (%s) exceeds array bounds (%d)", ast_Value_str(&idx), *size);
            return false;
         }
         current_index = ast_Value_as_i32(&idx);
      } else {
         loc = ast_Expr_getLoc(value);
         current_index++;
      }
      if (((*size != -1) && (current_index >= *size))) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "excess elements in array initializer");
         return false;
      }
      src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, ((uint32_t)(current_index)));
      if (duplicate) {
         module_analyser_Analyser_error(ma, loc, "duplicate initialization of array index");
         module_analyser_Analyser_note(ma, duplicate, "previous initialization is here");
      } else {
         init_checker_Checker_add(checker, ((uint32_t)(current_index)), loc);
      }
      if ((current_index > max_index)) max_index = current_index;
   }
   if ((*size == -1)) *size = (max_index + 1);
   return true;
}

static _Bool module_analyser_Analyser_analyseStructFieldInit(module_analyser_Analyser* ma, ast_StructTypeDecl* std, ast_InitListExpr* ile, ast_QualType expectedType)
{
   ast_InitListExpr_setHasDesignators(ile);
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   const uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   module_analyser_StructFieldInitChecker checker; module_analyser_StructFieldInitChecker_init(&checker, num_members);
   for (uint32_t i = 0; (i < numValues); i++) {
      ast_Expr* value = values[i];
      if (ast_Expr_isArrayDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "array designator cannot initialize non-array type '%s'", ast_QualType_diagName(&expectedType));
         goto out;
      }
      if (!ast_Expr_isFieldDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "mixing field designators with non-field designators");
         goto out;
      }
      ast_FieldDesignatedInitExpr* fdi = ((ast_FieldDesignatedInitExpr*)(value));
      uint32_t field_name = ast_FieldDesignatedInitExpr_getField(fdi);
      uint32_t offset = 0;
      ast_Decl* member = module_analyser_Analyser_findStructMember(ma, std, field_name, ast_Expr_getLoc(value), &offset, false);
      if (!member) goto out;

      ast_FieldDesignatedInitExpr_setMemberOffset(fdi, offset);
      ast_FieldDesignatedInitExpr_setDecl(fdi, member);
      ast_Decl_setUsed(member);
      src_loc_SrcLoc prev = module_analyser_StructFieldInitChecker_add(&checker, offset, ast_Expr_getLoc(value));
      if (prev) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "duplicate initialization of field '%s'", ast_FieldDesignatedInitExpr_getFieldName(fdi));
         module_analyser_Analyser_note(ma, prev, "previous initialization is here");
         goto out;
      }
      _Bool ok = module_analyser_Analyser_analyseInitExpr(ma, ast_FieldDesignatedInitExpr_getInit2(fdi), ast_Decl_getType(member), ast_Expr_getLoc(ast_FieldDesignatedInitExpr_getInit(fdi)));
      if (!ok) goto out;

      ast_Expr_setType(value, ast_Expr_getType(ast_FieldDesignatedInitExpr_getInit(fdi)));
   }
   ast_QualType_clearQuals(&expectedType);
   ast_Expr* e = ((ast_Expr*)(ile));
   ast_Expr_setType(e, expectedType);
   module_analyser_StructFieldInitChecker_free(&checker);
   return true;
   out:
   module_analyser_StructFieldInitChecker_free(&checker);
   return false;
}

static _Bool module_analyser_Analyser_analyseInitListStruct(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType)
{
   ast_Expr* e = ((ast_Expr*)(ile));
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   ast_StructType* st = ast_QualType_getStructType(&expectedType);
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   if ((numValues == 0)) {
      ast_Expr_setType(e, expectedType);
      return true;
   }
   const _Bool haveDesignators = (ast_Expr_isFieldDesignatedInit(values[0]));
   if ((!haveDesignators && ast_StructTypeDecl_isUnion(std))) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(values[0]), "union member initializer needs field designator");
      return false;
   }
   if (haveDesignators) {
      return module_analyser_Analyser_analyseStructFieldInit(ma, std, ile, expectedType);
   }
   const uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   for (uint32_t i = 0; (i < numValues); i++) {
      ast_Expr* value = values[i];
      if ((i >= num_members)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "excess initializer elements in struct");
         return false;
      }
      if (ast_Expr_isArrayDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "array designator cannot initialize non-array type '%s'", ast_QualType_diagName(&expectedType));
         return false;
      }
      if (ast_Expr_isFieldDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "mixing field designators with non-field designators");
         return false;
      }
      ast_Decl_setUsed(members[i]);
      _Bool ok = module_analyser_Analyser_analyseInitExpr(ma, &values[i], ast_Decl_getType(members[i]), ast_Expr_getLoc(values[i]));
      if (!ok) return false;

   }
   ast_QualType_clearQuals(&expectedType);
   ast_Expr_setType(e, expectedType);
   return true;
}

static ast_QualType module_analyser_Analyser_analyseMemberExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_MemberExpr* m = ((ast_MemberExpr*)(e));
   src_loc_SrcLoc baseLoc = 0;
   ast_ValType valtype = ast_ValType_NValue;
   ast_QualType baseType = ast_QualType_Invalid;
   ast_CallKind ck = ast_CallKind_Invalid;
   if (ast_MemberExpr_hasExpr(m)) {
      ast_Expr* exprBase = ast_MemberExpr_getExprBase(m);
      baseType = module_analyser_Analyser_analyseExpr(ma, &exprBase, false, side);
      if (ast_QualType_isInvalid(&baseType)) return ast_QualType_Invalid;

      valtype = ast_Expr_getValType(exprBase);
   }
   ast_Decl* d = NULL;
   uint32_t refcount = ast_MemberExpr_getNumRefs(m);
   for (uint32_t i = 0; (i < refcount); i++) {
      uint32_t name_idx = ast_MemberExpr_getNameIdx(m, i);
      src_loc_SrcLoc loc = ast_MemberExpr_getLoc(m, i);
      if (ast_QualType_isInvalid(&baseType)) {
         d = scope_Scope_find(ma->scope, name_idx, loc, ma->usedPublic);
         if (!d) {
            ma->has_error = true;
            return ast_QualType_Invalid;
         }
         if (!ast_Decl_isChecked(d)) {
            if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) return ast_QualType_Invalid;

         }
         baseType = ast_Decl_getType(d);
         valtype = module_analyser_decl2valtype(d);
      } else {
         ast_QualType canon = ast_QualType_getCanonicalType(&baseType);
         ast_TypeKind kind = module_analyser_Analyser_analyseBaseType(ma, canon);
         _Bool is_ptr = ast_QualType_isPointer(&canon);
         _Bool inner_const = false;
         const ast_Type* t = ast_QualType_getTypeOrNil(&canon);
         if (is_ptr) {
            ast_PointerType* pt = ((ast_PointerType*)(t));
            ast_QualType inner = ast_PointerType_getInner(pt);
            inner_const = ast_QualType_isConst(&inner);
            t = ast_QualType_getTypeOrNil(&inner);
         }
         switch (kind) {
         case ast_TypeKind_Struct: {
            ast_StructType* st = ((ast_StructType*)(t));
            ast_StructTypeDecl* std = ast_StructType_getDecl(st);
            d = module_analyser_Analyser_analyseStructMemberAccess(ma, std, name_idx, loc, valtype, side, &ck);
            if (!d) return ast_QualType_Invalid;

            _Bool is_const = ast_QualType_isConst(&baseType);
            baseType = ast_Decl_getType(d);
            if (is_ptr) is_const = inner_const;
            if ((is_ptr && (ck != ast_CallKind_Invalid))) is_const = false;
            ast_MemberExpr_setConstBase(m, is_const);
            if ((is_const && (ck == ast_CallKind_Invalid))) ast_QualType_setConst(&baseType);
            break;
         }
         case ast_TypeKind_Enum: {
            ast_EnumType* et = ((ast_EnumType*)(t));
            ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
            const char* last = ast_MemberExpr_getLastMemberName(m);
            if (((isupper(last[0]) || (name_idx == ma->min_idx)) || (name_idx == ma->max_idx))) {
               if ((valtype != ast_ValType_NValue)) {
                  module_analyser_Analyser_error(ma, baseLoc, "invalid member reference base (enum constant/variable)");
                  return ast_QualType_Invalid;
               }
               ast_EnumConstantDecl* ecd;
               if ((name_idx == ma->min_idx)) {
                  ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
                  ecd = constants[0];
               } else if ((name_idx == ma->max_idx)) {
                  ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
                  ecd = constants[(ast_EnumTypeDecl_getNumConstants(etd) - 1)];
               } else {
                  ecd = ast_EnumTypeDecl_findConstant(etd, name_idx);
                  if (!ecd) {
                     module_analyser_Analyser_error(ma, loc, "enum '%s' has no constant '%s'", ast_Decl_getFullName(d), ast_MemberExpr_getLastMemberName(m));
                     return ast_QualType_Invalid;
                  }
               }

               d = ((ast_Decl*)(ecd));
               if (!ast_Decl_isChecked(d)) {
                  module_analyser_Analyser_error(ma, loc, "circular definition using enum constant '%s'", ast_Decl_getName(d));
                  return ast_QualType_Invalid;
               }
            } else {
               d = ((ast_Decl*)(etd));
               ast_Decl* ef = ast_EnumTypeDecl_findFunction(etd, name_idx);
               if (!ef) {
                  module_analyser_Analyser_error(ma, loc, "enum '%s' has no function '%s'", ast_Decl_getFullName(d), ast_MemberExpr_getLastMemberName(m));
                  return ast_QualType_Invalid;
               }
               ck = (valtype == ast_ValType_NValue) ? ast_CallKind_StaticTypeFunc : ast_CallKind_TypeFunc;
               d = ef;
               baseType = ast_Decl_getType(ef);
               if (!scope_Scope_checkAccess(ma->scope, d, loc)) return ast_QualType_Invalid;

            }
            valtype = ast_ValType_RValue;
            break;
         }
         case ast_TypeKind_Alias:
            (0) || c2_assert("analyser/module_analyser_member.c2", 159, "module_analyser.Analyser.analyseMemberExpr", "0");
            break;
         case ast_TypeKind_Module: {
            ast_ModuleType* mt = ((ast_ModuleType*)(t));
            d = scope_Scope_findSymbolInModule(ma->scope, ast_ModuleType_getModule(mt), name_idx, loc);
            if (!d) {
               ma->has_error = true;
               return ast_QualType_Invalid;
            }
            if (!ast_Decl_isChecked(d)) {
               if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) return ast_QualType_Invalid;

            }
            baseType = ast_Decl_getType(d);
            valtype = module_analyser_decl2valtype(d);
            break;
         }
         default:
            module_analyser_Analyser_errorRange(ma, loc, ast_MemberExpr_getRange(m, i), "invalid member reference base");
            return ast_QualType_Invalid;
         }
      }
      baseLoc = loc;
      if ((i == (refcount - 1))) {
         if ((side & module_analyser_RHS)) ast_Decl_setUsed(d);
      } else {
         ast_Decl_setUsed(d);
      }
      ast_MemberExpr_setDecl(m, d, i);
   }
   if (((ck == ast_CallKind_Invalid) && ast_Decl_isFunction(d))) ck = ast_CallKind_Normal;
   if ((ck == ast_CallKind_TypeFunc)) ast_MemberExpr_setIsTypeFunc(m);
   if ((ck == ast_CallKind_StaticTypeFunc)) ast_MemberExpr_setIsStaticTypeFunc(m);
   ast_IdentifierKind kind = module_analyser_Analyser_setExprFlags(ma, e_ptr, d);
   ast_MemberExpr_setKind(m, kind);
   ast_Expr_setType(e, baseType);
   if (ast_Expr_isCtv(e)) ast_Expr_setRValue(e);
   return baseType;
}

static ast_Decl* module_analyser_Analyser_analyseStructMemberAccess(module_analyser_Analyser* ma, ast_StructTypeDecl* std, uint32_t name_idx, src_loc_SrcLoc loc, ast_ValType valtype, uint32_t side, ast_CallKind* ck)
{
   *ck = ast_CallKind_Invalid;
   ast_Decl* d = module_analyser_Analyser_findStructMember(ma, std, name_idx, loc, NULL, true);
   if (!d) return NULL;

   if (!ast_Decl_isChecked(d)) {
      if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) return NULL;

   }
   if (ast_Decl_isFunction(d)) {
      ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
      ast_CallKind callkind = ast_FunctionDecl_getCallKind(fd);
      ((callkind != ast_CallKind_Normal)) || c2_assert("analyser/module_analyser_member.c2", 222, "module_analyser.Analyser.analyseStructMemberAccess", "callkind != CallKind.Normal");
      switch (valtype) {
      case ast_ValType_NValue:
         if ((callkind != ast_CallKind_StaticTypeFunc)) {
         }
         *ck = ast_CallKind_StaticTypeFunc;
         break;
      case ast_ValType_RValue:
         if ((callkind == ast_CallKind_StaticTypeFunc)) {
            module_analyser_Analyser_error(ma, loc, module_analyser_DiagStaticThoughVar);
            return NULL;
         }
         ((callkind == ast_CallKind_TypeFunc)) || c2_assert("analyser/module_analyser_member.c2", 238, "module_analyser.Analyser.analyseStructMemberAccess", "callkind == CallKind.TypeFunc");
         *ck = ast_CallKind_TypeFunc;
         break;
      case ast_ValType_LValue:
         if ((callkind == ast_CallKind_StaticTypeFunc)) {
            module_analyser_Analyser_error(ma, loc, module_analyser_DiagStaticThoughVar);
            return NULL;
         }
         ((callkind == ast_CallKind_TypeFunc)) || c2_assert("analyser/module_analyser_member.c2", 246, "module_analyser.Analyser.analyseStructMemberAccess", "callkind == CallKind.TypeFunc");
         *ck = ast_CallKind_TypeFunc;
         break;
      }
      if (!scope_Scope_checkAccess(ma->scope, d, loc)) return NULL;

   } else {
      if (!module_analyser_Analyser_checkOpaque(ma, std, loc)) return NULL;

      if ((side && (valtype == ast_ValType_NValue))) {
         ast_QualType t = ast_Decl_getType(ast_StructTypeDecl_asDecl(std));
         module_analyser_Analyser_error(ma, loc, "member access needs an instantiation of type '%s'", ast_QualType_diagName(&t));
         return NULL;
      }
   }
   return d;
}

static ast_TypeKind module_analyser_Analyser_analyseBaseType(module_analyser_Analyser* ma, ast_QualType baseType)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(&baseType);
   if (ast_Type_isPointerType(t)) {
      ast_PointerType* pt = ((ast_PointerType*)(t));
      baseType = ast_PointerType_getInner(pt);
      t = ast_QualType_getTypeOrNil(&baseType);
   }
   return ast_Type_getKind(t);
}

static ast_ValType module_analyser_decl2valtype(const ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      return ast_ValType_RValue;
   case ast_DeclKind_Import:
      fallthrough;
   case ast_DeclKind_StructType:
      fallthrough;
   case ast_DeclKind_EnumType:
      fallthrough;
   case ast_DeclKind_EnumConstant:
      fallthrough;
   case ast_DeclKind_FunctionType:
      fallthrough;
   case ast_DeclKind_AliasType:
      break;
   case ast_DeclKind_Variable:
      return ast_ValType_LValue;
   }
   return ast_ValType_NValue;
}

static _Bool module_analyser_hasReturn(const ast_Stmt* s)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      return true;
   case ast_StmtKind_If: {
      const ast_IfStmt* i = ((ast_IfStmt*)(s));
      if (!module_analyser_hasReturn(ast_IfStmt_getThen(i))) return false;

      const ast_Stmt* e = ast_IfStmt_getElse(i);
      if ((e && module_analyser_hasReturn(e))) return true;

      break;
   }
   case ast_StmtKind_While:
      break;
   case ast_StmtKind_For:
      break;
   case ast_StmtKind_Switch:
      break;
   case ast_StmtKind_Label: {
      const ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      const ast_Stmt* lss = ast_LabelStmt_getStmt(ls);
      if (!lss) return false;

      return module_analyser_hasReturn(lss);
   }
   case ast_StmtKind_Compound: {
      const ast_CompoundStmt* cs = ((ast_CompoundStmt*)(s));
      const ast_Stmt* last = ast_CompoundStmt_getLastStmt(cs);
      if (!last) return false;

      return module_analyser_hasReturn(last);
   }
   default:
      break;
   }
   return false;
}

static void module_analyser_Analyser_analyseStmt(module_analyser_Analyser* ma, ast_Stmt* s, _Bool checkEffect)
{
   if ((scope_Scope_isUnreachable(ma->scope) && (ast_Stmt_getKind(s) != ast_StmtKind_Label))) {
      module_analyser_Analyser_warn(ma, ast_Stmt_getLoc(s), "unreachable code");
   }
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      module_analyser_Analyser_analyseReturnStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      break;
   case ast_StmtKind_Expr: {
      module_analyser_Analyser_analyseExpr(ma, ((ast_Expr**)(&s)), false, 0);
      ast_Expr* e = ((ast_Expr*)(s));
      if ((checkEffect && !ast_Expr_hasEffect(e))) module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "expression without effect");
      break;
   }
   case ast_StmtKind_If:
      module_analyser_Analyser_analyseIfStmt(ma, s);
      break;
   case ast_StmtKind_While:
      module_analyser_Analyser_analyseWhileStmt(ma, s);
      break;
   case ast_StmtKind_For:
      module_analyser_Analyser_analyseForStmt(ma, s);
      break;
   case ast_StmtKind_Switch:
      module_analyser_Analyser_analyseSwitchStmt(ma, s);
      break;
   case ast_StmtKind_Break:
      module_analyser_Analyser_analyseBreakStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      break;
   case ast_StmtKind_Continue:
      module_analyser_Analyser_analyseContinueStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      break;
   case ast_StmtKind_Fallthrough:
      module_analyser_Analyser_analyseFallthroughStmt(ma, s);
      break;
   case ast_StmtKind_Label:
      scope_Scope_setReachable(ma->scope);
      module_analyser_Analyser_analyseLabelStmt(ma, s);
      break;
   case ast_StmtKind_Goto:
      module_analyser_Analyser_analyseGotoStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      break;
   case ast_StmtKind_Compound:
      scope_Scope_enter(ma->scope, scope_Decl);
      module_analyser_Analyser_analyseCompoundStmt(ma, ((ast_CompoundStmt*)(s)));
      scope_Scope_exit(ma->scope, ma->has_error);
      break;
   case ast_StmtKind_Decl:
      module_analyser_Analyser_analyseDeclStmt(ma, s);
      break;
   case ast_StmtKind_Asm:
      module_analyser_Analyser_analyseAsmStmt(ma, s);
      break;
   case ast_StmtKind_Assert:
      module_analyser_Analyser_analyseAssertStmt(ma, s);
      break;
   }
}

static void module_analyser_Analyser_analyseBreakStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   if (!scope_Scope_allowBreak(ma->scope)) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "'break' statement not in loop or switch statement");
   }
}

static void module_analyser_Analyser_analyseContinueStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   if (!scope_Scope_allowContinue(ma->scope)) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "'continue' statement not in loop statement");
   }
}

static void module_analyser_Analyser_analyseFallthroughStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   if (!scope_Scope_allowFallthrough(ma->scope)) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "'fallthrough' statement cannot be used here");
   }
}

static void module_analyser_Analyser_analyseLabelStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
   uint32_t name = ast_LabelStmt_getNameIdx(ls);
   label_vector_Label* label = label_vector_LabelVector_find(&ma->labels, name);
   if (label) {
      if (label->is_label) {
         module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "redefinition of label '%s'", ast_LabelStmt_getName(ls));
         module_analyser_Analyser_note(ma, label->loc, "previous definition is here");
      } else {
         label->is_label = true;
         label->stmt = ls;
         ast_LabelStmt_setUsed(ls);
      }
   } else {
      label_vector_Label lab = { .name_idx = name, .loc = ast_Stmt_getLoc(s), .is_label = true, .used = false, .stmt = ls };
      label_vector_LabelVector_add(&ma->labels, lab);
   }
   ast_Stmt* lss = ast_LabelStmt_getStmt(ls);
   if (lss) module_analyser_Analyser_analyseStmt(ma, lss, true);
}

static void module_analyser_Analyser_analyseGotoStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_GotoStmt* gs = ((ast_GotoStmt*)(s));
   uint32_t name = ast_GotoStmt_getNameIdx(gs);
   label_vector_Label* label = label_vector_LabelVector_find(&ma->labels, name);
   if (label) {
      label->used = true;
      if (label->stmt) ast_LabelStmt_setUsed(label->stmt);
   } else {
      label_vector_Label lab = { .name_idx = name, .loc = ast_Stmt_getLoc(s), .is_label = false, .used = true, .stmt = NULL };
      label_vector_LabelVector_add(&ma->labels, lab);
   }
}

static void module_analyser_Analyser_analyseCompoundStmt(module_analyser_Analyser* ma, ast_CompoundStmt* c)
{
   uint32_t count = ast_CompoundStmt_getCount(c);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
   for (uint32_t i = 0; (i < count); i++) {
      ast_Stmt* s = stmts[i];
      module_analyser_Analyser_analyseStmt(ma, s, true);
      if (ma->has_error) break;

   }
}

static ast_QualType module_analyser_Analyser_analyseCondition(module_analyser_Analyser* ma, ast_Stmt** s_ptr, _Bool check_assign)
{
   ast_Stmt* s = *s_ptr;
   if (ast_Stmt_isDecl(s)) {
      ast_QualType qt = module_analyser_Analyser_analyseDeclStmt(ma, s);
      if (ast_QualType_isValid(&qt)) {
         ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
         if (!ast_VarDecl_getInit(vd)) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(vd)), "variable declaration in condition must have an initializer");
            return ast_QualType_Invalid;
         }
      }
      return qt;
   }
   (ast_Stmt_isExpr(s)) || c2_assert("analyser/module_analyser_stmt.c2", 203, "module_analyser.Analyser.analyseCondition", "s.isExpr()");
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ((ast_Expr**)(s_ptr)), true, module_analyser_RHS);
   ast_Expr* e = ((ast_Expr*)(*s_ptr));
   if (ast_QualType_isValid(&qt)) conversion_checker_Checker_check(&ma->checker, ast_builtins[ast_BuiltinKind_Bool], qt, ((ast_Expr**)(s_ptr)), ast_Expr_getLoc(e));
   e = ((ast_Expr*)(*s_ptr));
   if ((check_assign && ast_Expr_isAssignment(e))) {
      module_analyser_Analyser_warn(ma, ast_Expr_getLoc(e), "using the result of an assignment as a condition without parentheses");
   }
   return qt;
}

static void module_analyser_Analyser_analyseIfStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_IfStmt* i = ((ast_IfStmt*)(s));
   scope_Scope_enter(ma->scope, scope_Decl);
   module_analyser_Analyser_analyseCondition(ma, ast_IfStmt_getCond2(i), true);
   if (ma->has_error) goto done;

   scope_Scope_enter(ma->scope, scope_Decl);
   module_analyser_Analyser_analyseStmt(ma, ast_IfStmt_getThen(i), true);
   scope_Scope_exit(ma->scope, ma->has_error);
   ast_Stmt* else_ = ast_IfStmt_getElse(i);
   if (else_) {
      scope_Scope_enter(ma->scope, scope_Decl);
      module_analyser_Analyser_analyseStmt(ma, else_, true);
      scope_Scope_exit(ma->scope, ma->has_error);
   }
   done:
   scope_Scope_exit(ma->scope, ma->has_error);
}

static void module_analyser_Analyser_analyseForStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_ForStmt* f = ((ast_ForStmt*)(s));
   scope_Scope_enter(ma->scope, (((scope_Break | scope_Continue) | scope_Decl) | scope_Control));
   ast_Stmt** init = ast_ForStmt_getInit2(f);
   if (init) {
      ast_QualType ct = module_analyser_Analyser_analyseCondition(ma, init, false);
      if (ast_QualType_isInvalid(&ct)) goto done;

   }
   ast_Expr** cond = ast_ForStmt_getCond2(f);
   if (cond) {
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, cond, true, module_analyser_RHS);
      if (ast_QualType_isInvalid(&qt)) goto done;

      conversion_checker_Checker_check(&ma->checker, ast_builtins[ast_BuiltinKind_Bool], qt, cond, ast_Expr_getLoc((*cond)));
   }
   ast_Expr** cont = ast_ForStmt_getCont2(f);
   if (cont) {
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, cont, true, module_analyser_RHS);
      if (ast_QualType_isInvalid(&qt)) goto done;

   }
   module_analyser_Analyser_analyseStmt(ma, ast_ForStmt_getBody(f), true);
   done:
   scope_Scope_exit(ma->scope, ma->has_error);
}

static void module_analyser_Analyser_analyseWhileStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_WhileStmt* w = ((ast_WhileStmt*)(s));
   scope_Scope_enter(ma->scope, scope_Decl);
   module_analyser_Analyser_analyseCondition(ma, ast_WhileStmt_getCond2(w), true);
   if (ma->has_error) goto done;

   scope_Scope_enter(ma->scope, (((scope_Break | scope_Continue) | scope_Decl) | scope_Control));
   module_analyser_Analyser_analyseStmt(ma, ast_WhileStmt_getBody(w), true);
   scope_Scope_exit(ma->scope, ma->has_error);
   done:
   scope_Scope_exit(ma->scope, ma->has_error);
}

static ast_QualType module_analyser_Analyser_analyseDeclStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
   ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
   ast_Decl* d = ((ast_Decl*)(vd));
   ast_TypeRef* ref = ast_VarDecl_getTypeRef(vd);
   if (ast_TypeRef_isIncrArray(ref)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "incremental arrays not allowed in function scope");
      return ast_QualType_Invalid;
   }
   ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   if (ast_QualType_isInvalid(&res)) return ast_QualType_Invalid;

   ast_Decl_setType(d, res);
   if (ast_QualType_isVoid(&res)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "variable has invalid type 'void'");
      return ast_QualType_Invalid;
   }
   module_analyser_Analyser_checkName(ma, d, false);
   ast_Expr** initExpr = ast_VarDecl_getInit2(vd);
   _Bool has_init_call = ast_VarDecl_hasInitCall(vd);
   if ((!has_init_call && initExpr)) {
      module_analyser_Analyser_analyseInitExpr(ma, initExpr, res, ast_VarDecl_getAssignLoc(vd));
      if (ast_VarDecl_hasLocalQualifier(vd)) {
         ast_Expr* e = ast_VarDecl_getInit(vd);
         if (!ast_Expr_isCtc(e)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time constant");
            return ast_QualType_Invalid;
         }
      }
   } else {
      if (ast_QualType_isConstant(&res)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "constant variable '%s' must be initialized", ast_Decl_getName(d));
         return ast_QualType_Invalid;
      }
      const ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(&res);
      if (at) {
         if (ast_ArrayType_hasSize(at)) {
            if ((ast_ArrayType_getSize(at) == 0)) {
               module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "only struct members may have array size zero");
               return ast_QualType_Invalid;
            }
         } else {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "array-type variable '%s' needs an explicit size or an initializer", ast_Decl_getName(d));
            return ast_QualType_Invalid;
         }
      }
   }
   ast_Decl_setChecked(d);
   ma->has_error = (ma->has_error | scope_Scope_add(ma->scope, d));
   if (has_init_call) {
      ast_Expr* e = *initExpr;
      module_analyser_Analyser_analyseExpr(ma, &e, false, 0);
   }
   return res;
}

static void module_analyser_Analyser_analyseAsmStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_AsmStmt* a = ((ast_AsmStmt*)(s));
   uint32_t num_exprs = ast_AsmStmt_getNumExprs(a);
   ast_Expr** exprs = ast_AsmStmt_getExprs(a);
   uint32_t num_outputs = ast_AsmStmt_getNumOutputs(a);
   for (uint32_t i = 0; (i < num_exprs); i++) {
      _Bool need_rvalue;
      uint32_t side;
      if ((i < num_outputs)) {
         need_rvalue = false;
         side = module_analyser_LHS;
      } else {
         need_rvalue = true;
         side = module_analyser_RHS;
      }
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &exprs[i], need_rvalue, side);
      if (ast_QualType_isInvalid(&qt)) return;

   }
}

static void module_analyser_Analyser_analyseAssertStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_AssertStmt* a = ((ast_AssertStmt*)(s));
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_AssertStmt_getInner2(a), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&qt)) return;

   ast_Expr* inner = ast_AssertStmt_getInner(a);
   conversion_checker_Checker_check(&ma->checker, ast_builtins[ast_BuiltinKind_Bool], qt, ast_AssertStmt_getInner2(a), ast_Expr_getLoc(inner));
}

static void module_analyser_Analyser_analyseReturnStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_ReturnStmt* r = ((ast_ReturnStmt*)(s));
   ast_Expr** arg = ast_ReturnStmt_getValue2(r);
   if (ast_FunctionDecl_hasReturn(ma->curFunction)) {
      if (!arg) {
         module_analyser_Analyser_error(ma, (ast_Stmt_getLoc(s) + 6), "non-void function %s should return a value", ast_Decl_getName(ast_FunctionDecl_asDecl(ma->curFunction)));
         return;
      }
   } else {
      if (arg) {
         ast_Expr* e = ast_ReturnStmt_getValue(r);
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "void function %s should not return a value", ast_Decl_getName(ast_FunctionDecl_asDecl(ma->curFunction)));
         return;
      }
   }
   if (arg) {
      if (!module_analyser_Analyser_analyseInitExpr(ma, arg, ast_FunctionDecl_getRType(ma->curFunction), ast_Expr_getLoc((*arg)))) return;

      ast_QualType qt = ast_Expr_getType((*arg));
      if (ast_QualType_isPointer(&qt)) module_analyser_Analyser_checkReturnAddrOfLocal(ma, *arg);
   }
}

static void module_analyser_Analyser_checkReturnAddrOfLocal(module_analyser_Analyser* ma, ast_Expr* arg)
{
   if (!ast_Expr_isUnaryOp(&(*arg))) return;

   ast_UnaryOperator* uo = ((ast_UnaryOperator*)(arg));
   ast_Expr* inner = ast_UnaryOperator_getInner(uo);
   if (!ast_Expr_isIdentifier(inner)) return;

   ast_IdentifierExpr* id = ((ast_IdentifierExpr*)(inner));
   ast_Decl* d = ast_IdentifierExpr_getDecl(id);
   (d) || c2_assert("analyser/module_analyser_stmt.c2", 409, "module_analyser.Analyser.checkReturnAddrOfLocal", "d");
   if (!ast_Decl_isVarDecl(d)) return;

   ast_VarDecl* vd = ((ast_VarDecl*)(d));
   if ((((ast_VarDecl_isLocal(vd) && !ast_VarDecl_hasLocalQualifier(vd))) || ast_VarDecl_isParameter(vd))) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(arg), "function returns address of local variable");
   }
}

static void module_analyser_Analyser_analyseStructType(module_analyser_Analyser* ma, ast_StructTypeDecl* d)
{
   if (ast_StructTypeDecl_isOpaque(d)) {
      ma->checkStack[(ma->checkIndex - 1)].usedPublic = false;
      ma->usedPublic = false;
   }
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(d);
   name_vector_NameVector names; name_vector_NameVector_init(&names, num_members);
   name_vector_NameVector locs; name_vector_NameVector_init(&locs, num_members);
   module_analyser_Analyser_analyseStructNames(ma, d, &names, &locs);
   name_vector_NameVector_free(&names);
   name_vector_NameVector_free(&locs);
   module_analyser_Analyser_analyseStructMembers(ma, d);
   if (((!ma->has_error && (ast_StructTypeDecl_getSize(d) == 0)) && !ast_Module_isExternal(ma->mod))) {
      ast_Decl* dd = ((ast_Decl*)d);
      ast_Decl_dump(dd);
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(dd), "empty structs are only allowed in interface files");
   }
}

static void module_analyser_Analyser_analyseStructMembers(module_analyser_Analyser* ma, ast_StructTypeDecl* d)
{
   uint32_t count = ast_StructTypeDecl_getNumMembers(d);
   ast_Decl** members = ast_StructTypeDecl_getMembers(d);
   _Bool is_packed = ast_StructTypeDecl_isPacked(d);
   for (uint32_t i = 0; (i < count); i++) {
      ast_Decl* member = members[i];
      if (ast_Decl_isVariable(member)) {
         ast_VarDecl* vd = ((ast_VarDecl*)(member));
         ast_Decl_setCheckInProgress(member);
         module_analyser_Analyser_analyseStructMember(ma, vd);
         ast_Expr* bitfield = ast_VarDecl_getBitfield(vd);
         if (bitfield) {
            ast_QualType qt = ast_Decl_getType(member);
            uint32_t type_width = ast_QualType_getBitFieldWidth(&qt);
            if ((type_width == 0)) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field '%s' has invalid type", ast_VarDecl_getName(vd));
               return;
            }
            ast_QualType qt2 = module_analyser_Analyser_analyseExpr(ma, &bitfield, false, module_analyser_RHS);
            if (ast_QualType_isInvalid(&qt2)) return;

            if (!ast_Expr_isCtv(bitfield)) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field size is not a compile-time value");
               return;
            }
            ast_Value value = ctv_analyser_get_value(bitfield);
            if (ast_Value_isZero(&value)) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "zero width for bit-field '%s'", ast_VarDecl_getName(vd));
            }
            uint32_t field_width = ast_Value_as_u32(&value);
            if ((ast_QualType_isEnum(&qt) && (field_width < type_width))) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field '%s' has insufficient bits for enum '%s'", ast_VarDecl_getName(vd), ast_QualType_diagName(&qt));
               return;
            }
            if ((field_width > type_width)) {
               const char* name = ast_VarDecl_getName(vd);
               if (name) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "width of bit-field '%s' (%u bits) exceeds the width of its type (%u bit%s)", name, field_width, type_width, (type_width > 1) ? "s" : "");
               } else {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "width of anonymous bit-field (%u bits) exceeds the width of its type (%u bit%s)", field_width, type_width, (type_width > 1) ? "s" : "");
               }
               return;
            }
         }
         ast_Decl_setChecked(member);
      } else if (ast_Decl_isStructType(member)) {
         ast_StructTypeDecl* sub = ((ast_StructTypeDecl*)(member));
         if (is_packed) ast_StructTypeDecl_setPacked(sub);
         module_analyser_Analyser_analyseStructMembers(ma, sub);
         ast_Decl_setChecked(member);
      }

   }
   size_analyser_TypeSize info = size_analyser_sizeOfStruct(d);
   ast_StructTypeDecl_setSizeAlignment(d, info.size, info.align);
}

static void module_analyser_Analyser_analyseStructMember(module_analyser_Analyser* ma, ast_VarDecl* v)
{
   ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
   if (ast_TypeRef_isIncrArray(ref)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "incremental arrays not allowed in as struct/union member");
      return;
   }
   ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   if (ast_QualType_isInvalid(&res)) return;

   if (ast_QualType_isArray(&res)) {
      ast_ArrayType* at = ast_QualType_getArrayType(&res);
      if (!ast_ArrayType_hasSize(at)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array size must be specified for struct/union members");
         return;
      }
   }
   if (ast_QualType_isVoid(&res)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "member has invalid type 'void'");
      return;
   }
   ast_Decl_setType(ast_VarDecl_asDecl(v), res);
   if (ma->usedPublic) ast_setTypePublicUsed(res);
}

static void module_analyser_Analyser_analyseStructNames(module_analyser_Analyser* ma, ast_StructTypeDecl* d, name_vector_NameVector* names, name_vector_NameVector* locs)
{
   uint32_t count = ast_StructTypeDecl_getNumMembers(d);
   ast_Decl** members = ast_StructTypeDecl_getMembers(d);
   for (uint32_t i = 0; (i < count); i++) {
      ast_Decl* member = members[i];
      uint32_t name_idx = ast_Decl_getNameIdx(member);
      ast_StructTypeDecl* sub = NULL;
      if (ast_Decl_isStructType(member)) sub = ((ast_StructTypeDecl*)(member));
      if ((name_idx == 0)) {
         if (ast_Decl_isStructType(member)) {
            module_analyser_Analyser_analyseStructNames(ma, sub, names, locs);
         }
      } else {
         uint32_t old_index;
         if (name_vector_NameVector_find(names, name_idx, &old_index)) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(member), "duplicate struct/union member '%s'", ast_Decl_getName(member));
            module_analyser_Analyser_note(ma, name_vector_NameVector_get(locs, old_index), "previous declaration is here");
            return;
         }
         name_vector_NameVector_add(names, name_idx);
         name_vector_NameVector_add(locs, ast_Decl_getLoc(member));
         if (ast_Decl_isStructType(member)) {
            name_vector_NameVector sub_names; name_vector_NameVector_init(&sub_names, ast_StructTypeDecl_getNumMembers(sub));
            name_vector_NameVector sub_locs; name_vector_NameVector_init(&sub_locs, ast_StructTypeDecl_getNumMembers(sub));
            module_analyser_Analyser_analyseStructNames(ma, sub, &sub_names, &sub_locs);
            name_vector_NameVector_free(&sub_names);
            name_vector_NameVector_free(&sub_locs);
         }
      }
   }
}

static void module_analyser_Analyser_analyseSwitchStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_SwitchStmt* sw = ((ast_SwitchStmt*)(s));
   scope_Scope_enter(ma->scope, scope_Decl);
   _Bool is_string = false;
   ast_EnumTypeDecl* etd = NULL;
   ast_QualType ct = module_analyser_Analyser_analyseExpr(ma, ast_SwitchStmt_getCond2(sw), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(&ct)) {
      scope_Scope_exit(ma->scope, ma->has_error);
      return;
   }
   _Bool isCharPtr = ast_QualType_isCharPointer(&ct);
   if (isCharPtr) {
      is_string = true;
      ast_SwitchStmt_setString(sw);
   } else {
      ast_EnumType* et = ast_QualType_getEnumTypeOrNil(&ct);
      if (et) etd = ast_EnumType_getDecl(et);
   }
   const uint32_t numCases = ast_SwitchStmt_getNumCases(sw);
   ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
   if ((numCases == 0)) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "switch without cases or default");
      scope_Scope_exit(ma->scope, ma->has_error);
      return;
   }
   ast_SwitchCase* defaultCase = NULL;
   init_checker_Checker* checker = module_analyser_Analyser_getInitChecker(ma);
   _Bool ok = true;
   for (uint32_t i = 0; (i < numCases); i++) {
      ast_SwitchCase* c = cases[i];
      _Bool is_last = (((i + 1) == numCases));
      uint32_t flags = (scope_Decl | scope_Break);
      if (!is_last) flags |= scope_Fallthrough;
      if (ast_SwitchCase_isDefault(c)) {
         if (defaultCase) {
            module_analyser_Analyser_error(ma, ast_SwitchCase_getLoc(c), "multiple default labels");
            ok = false;
         } else if (!is_last) {
            module_analyser_Analyser_error(ma, ast_SwitchCase_getLoc(c), "default case must be last in switch");
            ok = false;
         }

         defaultCase = c;
      }
      scope_Scope_enter(ma->scope, flags);
      ok &= module_analyser_Analyser_analyseCase(ma, c, checker, etd, is_string);
      scope_Scope_exit(ma->scope, ma->has_error);
   }
   scope_Scope_exit(ma->scope, ma->has_error);
   if ((ok && etd)) {
      const uint32_t numConstants = ast_EnumTypeDecl_getNumConstants(etd);
      if (defaultCase) {
         if ((init_checker_Checker_getCount(checker) >= numConstants)) {
            module_analyser_Analyser_error(ma, ast_SwitchCase_getLoc(defaultCase), "default label in switch which covers all enumeration values");
         }
      } else {
         if ((init_checker_Checker_getCount(checker) < numConstants)) {
            string_buffer_Buf* out = string_buffer_create(128, false, 0);
            uint32_t missing = 0;
            ast_EnumConstantDecl** ecd = ast_EnumTypeDecl_getConstants(etd);
            for (uint32_t i = 0; (i < numConstants); i++) {
               ast_Value v = ast_EnumConstantDecl_getValue(ecd[i]);
               if (!init_checker_Checker_find(checker, ast_Value_as_u32(&v))) {
                  if ((missing != 0)) string_buffer_Buf_add(out, ", ");
                  if ((missing >= 3)) {
                     string_buffer_Buf_add(out, "...");
                     break;
                  }
                  missing++;
                  string_buffer_Buf_add(out, ast_Decl_getName(ast_EnumConstantDecl_asDecl(ecd[i])));
               }
            }
            if (missing) {
               module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "unhandled enumeration value%s: %s", (missing > 1) ? "s" : "", string_buffer_Buf_data(out));
            }
            string_buffer_Buf_free(out);
         }
      }
   }
   module_analyser_Analyser_putInitChecker(ma, checker);
}

static _Bool module_analyser_Analyser_analyseCase(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, _Bool is_string)
{
   _Bool is_default = ast_SwitchCase_isDefault(c);
   if (!is_default) {
      if (!module_analyser_Analyser_analyseCaseCondition(ma, c, checker, etd, is_string)) return false;

   }
   const uint32_t count = ast_SwitchCase_getNumStmts(c);
   if ((count == 0)) {
      ast_SwitchCase_setHasFallthrough(c);
      return true;
   }
   _Bool has_decls = false;
   for (uint32_t i = 0; (i < count); i++) {
      ast_Stmt* st = ast_SwitchCase_getStmt(c, i);
      module_analyser_Analyser_analyseStmt(ma, st, true);
      if (ma->has_error) return false;

      if (ast_Stmt_isDecl(st)) has_decls = true;
      if (ast_Stmt_isFallthrough(st)) {
         ast_SwitchCase_setHasFallthrough(c);
         if ((((i + 1) != count))) {
            module_analyser_Analyser_error(ma, ast_Stmt_getLoc(st), "'fallthrough' statement must be last statement in case");
            return false;
         }
      }
   }
   if (has_decls) ast_SwitchCase_setHasDecls(c);
   ast_Stmt* last = ast_SwitchCase_getStmt(c, (count - 1));
   if (module_analyser_isTerminatingStmt(last, is_default)) return true;

   src_loc_SrcLoc loc = ast_Stmt_getLoc(last);
   if (!loc) loc = ast_SwitchCase_getLoc(c);
   if (is_default) {
      module_analyser_Analyser_error(ma, loc, "no terminating statement (break|return|continue|goto|noreturn-func) at end of default case");
   } else {
      module_analyser_Analyser_error(ma, loc, "no terminating statement (break|fallthrough|goto|return|continue|noreturn-func) at end of case");
   }
   return false;
}

static _Bool module_analyser_Analyser_analyseCaseCondition(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, _Bool is_string)
{
   uint32_t num_conds = ast_SwitchCase_getNumConds(c);
   _Bool res = true;
   for (uint32_t i = 0; (i < num_conds); i++) {
      ast_Expr* e = ast_SwitchCase_getCond(c, i);
      src_loc_SrcLoc loc = ast_Expr_getLoc(e);
      if (ast_Expr_isRange(e)) {
         if (is_string) {
            module_analyser_Analyser_error(ma, loc, "case ranges are not allowed for strings");
            res = false;
            continue;
         }
         ast_RangeExpr* re = ((ast_RangeExpr*)(e));
         ast_Expr* lhs = ast_RangeExpr_getLHS(re);
         ast_Expr* rhs = ast_RangeExpr_getRHS(re);
         uint32_t lhs_index = 0;
         uint32_t rhs_index;
         uint32_t lhs_name_idx = 0;
         uint32_t rhs_name_idx = 0;
         res &= module_analyser_Analyser_analyseCaseExpr(ma, c, checker, etd, is_string, 0, lhs, &lhs_index, &lhs_name_idx);
         res &= module_analyser_Analyser_analyseCaseExpr(ma, c, checker, etd, is_string, 0, rhs, &rhs_index, &rhs_name_idx);
         if (res) {
            if (etd) {
               if ((lhs_index > rhs_index)) {
                  module_analyser_Analyser_error(ma, loc, "enum constant '%s' does not come after '%s'", ast_idx2name(rhs_name_idx), ast_idx2name(lhs_name_idx));
                  res = false;
                  continue;
               }
               uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(etd);
               for (uint32_t idx = 0; (idx < num_constants); idx++) {
                  ast_EnumConstantDecl* ecd = ast_EnumTypeDecl_getConstant(etd, idx);
                  ast_Value v = ast_EnumConstantDecl_getValue(ecd);
                  uint32_t index = ast_Value_as_u32(&v);
                  if (((index >= lhs_index) && (index <= rhs_index))) {
                     src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
                     if ((duplicate && res)) {
                        ast_Decl* d = ((ast_Decl*)(ecd));
                        module_analyser_Analyser_error(ma, loc, "duplicate case value '%s'", ast_Decl_getName(d));
                        module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                        res = false;
                     }
                     init_checker_Checker_add(checker, index, loc);
                  }
               }
            } else {
               if ((lhs_index > rhs_index)) {
                  module_analyser_Analyser_error(ma, loc, "case range bounds %u and %u are out of order", lhs_index, rhs_index);
                  res = false;
                  continue;
               }
               src_loc_SrcLoc duplicate = init_checker_Checker_find2(checker, lhs_index, rhs_index);
               if (duplicate) {
                  module_analyser_Analyser_error(ma, loc, "duplicate case value in range");
                  module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                  res = false;
               }
               init_checker_Checker_add2(checker, lhs_index, rhs_index, loc);
            }
         }
      } else {
         uint32_t index;
         uint32_t name_idx;
         res &= module_analyser_Analyser_analyseCaseExpr(ma, c, checker, etd, is_string, loc, e, &index, &name_idx);
      }
   }
   return res;
}

static _Bool module_analyser_Analyser_analyseCaseExpr(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, _Bool is_string, src_loc_SrcLoc loc, ast_Expr* cond, uint32_t* indexp, uint32_t* name_idxp)
{
   uint32_t index = 0;
   if (etd) {
      if (!ast_Expr_isIdentifier(cond)) {
         if (ast_Expr_isMember(cond)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "enum constant may not be prefixed in case statement");
         } else {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "condition is not a constant of enum type '%s'", ast_Decl_getFullName(ast_EnumTypeDecl_asDecl(etd)));
         }
         return false;
      }
      ast_IdentifierExpr* id = ((ast_IdentifierExpr*)(cond));
      if (!module_analyser_Analyser_checkEnumConstantCase(ma, id, checker, etd, loc, &index, name_idxp)) return false;

   } else {
      ast_Expr* orig = cond;
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &cond, true, module_analyser_RHS);
      if (ast_QualType_isInvalid(&qt)) return false;

      ast_Expr_setType(cond, qt);
      if (is_string) {
         if (ast_Expr_isNil(orig)) {
            index = 0;
            *name_idxp = 0;
            if (loc) {
               src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
               if (duplicate) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(cond), ast_Expr_getRange(cond), "duplicate case value nil");
                  module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                  return false;
               }
               init_checker_Checker_add(checker, index, loc);
            }
         } else if (ast_Expr_isStringLiteral(orig)) {
            ast_StringLiteral* lit = ((ast_StringLiteral*)(orig));
            uint32_t len = (ast_StringLiteral_getSize(lit) - 1);
            if ((len > 255)) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "string switch case string is loo long (max 255 bytes)");
               return false;
            }
            if (memchr(ast_StringLiteral_getText(lit), 0, len)) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "case string value has embedded null byte");
               return false;
            }
            index = ast_StringLiteral_getTextIndex(lit);
            *name_idxp = 0;
            if (loc) {
               src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
               if (duplicate) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(cond), ast_Expr_getRange(cond), "duplicate case string");
                  module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                  return false;
               }
               init_checker_Checker_add(checker, index, loc);
            }
         } else {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "string switch case can only have a string literal or nil as condition");
            return false;
         }

      } else {
         if (!ast_Expr_isCtv(cond)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "case condition is not compile-time constant");
            return false;
         }
         ast_Value v = ctv_analyser_get_value(cond);
         index = ast_Value_as_u32(&v);
         *name_idxp = 0;
         if (loc) {
            src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
            if (duplicate) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(cond), ast_Expr_getRange(cond), "duplicate case value %u", index);
               module_analyser_Analyser_note(ma, duplicate, "previous case is here");
               return false;
            }
            init_checker_Checker_add(checker, index, loc);
         }
      }
   }
   *indexp = index;
   return true;
}

static _Bool module_analyser_Analyser_checkEnumConstantCase(module_analyser_Analyser* ma, ast_IdentifierExpr* id, init_checker_Checker* checker, ast_EnumTypeDecl* etd, src_loc_SrcLoc loc, uint32_t* ip, uint32_t* name_idxp)
{
   ast_Expr* e = ((ast_Expr*)(id));
   *name_idxp = ast_IdentifierExpr_getNameIdx(id);
   ast_EnumConstantDecl* ecd = ast_EnumTypeDecl_findConstant(etd, *name_idxp);
   if (!ecd) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "enum '%s' has no constant '%s'", ast_Decl_getFullName(ast_EnumTypeDecl_asDecl(etd)), ast_IdentifierExpr_getName(id));
      return false;
   }
   ast_Decl* d = ((ast_Decl*)(ecd));
   ast_Decl_setUsed(d);
   ast_QualType qt = ast_Decl_getType(d);
   ast_Expr_setType(e, qt);
   ast_Expr_setCtc(e);
   ast_Expr_setCtv(e);
   ast_Expr_setRValue(e);
   ast_IdentifierExpr_setDecl(id, d);
   ast_IdentifierExpr_setKind(id, ast_IdentifierKind_EnumConstant);
   ast_Value v = ast_EnumConstantDecl_getValue(ecd);
   uint32_t index = ast_Value_as_u32(&v);
   *ip = index;
   if (loc) {
      src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
      if (duplicate) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "duplicate case value '%s'", ast_IdentifierExpr_getName(id));
         module_analyser_Analyser_note(ma, duplicate, "previous case is here");
         return false;
      }
      init_checker_Checker_add(checker, index, loc);
   }
   return true;
}

static _Bool module_analyser_isTerminatingStmt(const ast_Stmt* s, _Bool is_default)
{
   if (!s) return false;

   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      return true;
   case ast_StmtKind_Expr: {
      const ast_Expr* e = ((ast_Expr*)(s));
      if (!ast_Expr_isCall(e)) break;

      const ast_CallExpr* c = ((ast_CallExpr*)(e));
      e = ast_CallExpr_getFunc(c);
      ast_QualType qt = ast_Expr_getType(e);
      const ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(&qt);
      (ft) || c2_assert("analyser/module_analyser_switch.c2", 395, "module_analyser.isTerminatingStmt", "ft");
      const ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      if (ast_FunctionDecl_hasAttrNoReturn(fd)) return true;

      break;
   }
   case ast_StmtKind_If: {
      const ast_IfStmt* is = ((ast_IfStmt*)(s));
      return (module_analyser_isTerminatingStmt(ast_IfStmt_getThen(is), is_default) && module_analyser_isTerminatingStmt(ast_IfStmt_getElse(is), is_default));
   }
   case ast_StmtKind_While:
      fallthrough;
   case ast_StmtKind_For:
      break;
   case ast_StmtKind_Switch:
      break;
   case ast_StmtKind_Break:
      return true;
   case ast_StmtKind_Continue:
      return true;
   case ast_StmtKind_Fallthrough:
      return !is_default;
   case ast_StmtKind_Label: {
      const ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      const ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      if (!stmt) return false;

      return module_analyser_isTerminatingStmt(stmt, is_default);
   }
   case ast_StmtKind_Goto:
      return true;
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      return module_analyser_isTerminatingStmt(ast_CompoundStmt_getLastStmt(c), is_default);
   }
   default:
      break;
   }
   return false;
}

static void module_analyser_Analyser_analyseFunctionType(module_analyser_Analyser* ma, ast_Decl* d)
{
   ast_FunctionTypeDecl* ftd = ((ast_FunctionTypeDecl*)(d));
   ast_FunctionDecl* fd = ast_FunctionTypeDecl_getDecl(ftd);
   module_analyser_Analyser_analyseFunction(ma, fd);
}

static void module_analyser_Analyser_analyseAliasType(module_analyser_Analyser* ma, ast_AliasTypeDecl* a)
{
   ast_TypeRef* ref = ast_AliasTypeDecl_getTypeRef(a);
   ast_Decl* d = ((ast_Decl*)(a));
   ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   if (ast_QualType_isInvalid(&res)) return;

   ast_QualType qt = ast_Decl_getType(d);
   ast_Type* at = ast_QualType_getTypeOrNil(&qt);
   ast_QualType canon = ast_QualType_getCanonicalType(&res);
   ast_QualType_copyQuals(&canon, res);
   ast_Type_setCanonicalType(at, canon);
}

static void module_analyser_Analyser_analyseEnumType(module_analyser_Analyser* ma, ast_EnumTypeDecl* d)
{
   uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(d);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(d);
   ast_Value value = { };
   ast_QualType implType = ast_EnumTypeDecl_getImplType(d);
   if ((num_constants == 0)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_EnumTypeDecl_asDecl(d)), "enum without constants");
      return;
   }
   for (uint32_t i = 0; (i < num_constants); i++) {
      ast_EnumConstantDecl* c = constants[i];
      ast_Decl* ecd = ((ast_Decl*)(c));
      ast_Decl_setCheckInProgress(ecd);
      ast_EnumConstantDecl_setIndex(c, i);
      ast_Decl* cd = ((ast_Decl*)(c));
      uint32_t name_idx = ast_Decl_getNameIdx(cd);
      for (uint32_t j = 0; (j < i); j++) {
         const ast_Decl* other = ast_EnumConstantDecl_asDecl(constants[j]);
         if ((ast_Decl_getNameIdx(other) == name_idx)) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(cd), "duplicate enum constant '%s'", ast_idx2name(name_idx));
            module_analyser_Analyser_note(ma, ast_Decl_getLoc(other), "previous definition is here");
            return;
         }
      }
      ast_Expr* initval = ast_EnumConstantDecl_getInit(c);
      if (initval) {
         ast_QualType res = module_analyser_Analyser_analyseExpr(ma, ast_EnumConstantDecl_getInit2(c), true, module_analyser_RHS);
         if (ast_QualType_isInvalid(&res)) return;

         initval = ast_EnumConstantDecl_getInit(c);
         if (!ast_Expr_isCtv(initval)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(initval), ast_Expr_getRange(initval), "initializer is not a compile-time value");
            return;
         }
         ast_Value ctv = ctv_analyser_get_value(initval);
         if (!ctv_analyser_checkRange(ma->diags, implType, &ctv, 0, initval)) return;

         if (((i > 0) && ast_Value_is_less(&ctv, &value))) {
            ast_Value_decr(&value);
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(initval), "enum constants need to increase (value %s, previous %s)", ast_Value_str(&ctv), ast_Value_str(&value));
            return;
         }
         value = ctv;
      } else {
         if (!ctv_analyser_checkRange(ma->diags, implType, &value, ast_Decl_getLoc(cd), NULL)) return;

      }
      ast_EnumConstantDecl_setValue(c, value);
      ast_Decl_setChecked(ecd);
      ast_Value_incr(&value);
   }
}

static ast_QualType module_analyser_Analyser_analyseUserTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref)
{
   (ma->mod) || c2_assert("analyser/module_analyser_type.c2", 100, "module_analyser.Analyser.analyseUserTypeRef", "ma.mod");
   const ast_Ref* user = ast_TypeRef_getUser(ref);
   if (user->decl) return ast_Decl_getType(user->decl);

   const ast_Ref* prefix = ast_TypeRef_getPrefix(ref);
   ast_Decl* d = NULL;
   if (prefix) {
      ast_ImportDecl* i = scope_Scope_findModule(ma->scope, prefix->name_idx, prefix->loc);
      if (!i) {
         ma->has_error = true;
         return ast_QualType_Invalid;
      }
      if (ma->usedPublic) {
         ast_Decl_setUsedPublic(ast_ImportDecl_asDecl(i));
      }
      ast_TypeRef_setPrefix(ref, ((ast_Decl*)(i)));
      ast_Module* mod = ast_ImportDecl_getDest(i);
      d = scope_Scope_findSymbolInModule(ma->scope, mod, user->name_idx, user->loc);
   } else {
      d = scope_Scope_findType(ma->scope, user->name_idx, user->loc, ma->usedPublic);
   }
   if (!d) {
      ma->has_error = true;
      return ast_QualType_Invalid;
   }
   if ((ma->usedPublic && !ast_Decl_isPublic(d))) {
      if (scope_Scope_inFunction(ma->scope)) {
         module_analyser_Analyser_error(ma, user->loc, "public inline function using non-public type '%s'", ast_Decl_getFullName(d));
      } else {
         module_analyser_Analyser_error(ma, user->loc, "public declaration using non-public type '%s'", ast_Decl_getFullName(d));
      }
      return ast_QualType_Invalid;
   }
   ast_TypeRef_setUser(ref, d);
   if (!ast_Decl_isTypeDecl(d)) {
      module_analyser_Analyser_error(ma, user->loc, "'%s' is not a type", ast_TypeRef_diagName(ref));
      return ast_QualType_Invalid;
   }
   _Bool full = ((ast_TypeRef_getNumPointers(ref) == 0));
   ast_DeclCheckState state = ast_Decl_getCheckState(d);
   if ((full && (state == ast_DeclCheckState_InProgress))) {
      module_analyser_Analyser_error(ma, user->loc, "circular declaration");
      return ast_QualType_Invalid;
   }
   if ((full && (state != ast_DeclCheckState_Checked))) {
      module_analyser_Analyser_analyseGlobalDecl(ma, d);
   }
   ast_Decl_setUsed(d);
   _Bool external = ((ma->mod != ast_Decl_getModule(d)));
   if ((external || ma->usedPublic)) ast_Decl_setUsedPublic(d);
   return ast_Decl_getType(d);
}

static ast_QualType module_analyser_Analyser_analyseTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref)
{
   ast_QualType base;
   if (ast_TypeRef_isUser(ref)) {
      base = module_analyser_Analyser_analyseUserTypeRef(ma, ref);
      if (ast_QualType_isInvalid(&base)) return base;

      if (!ast_QualType_hasCanonicalType(&base)) return ast_QualType_Invalid;

   } else {
      ast_BuiltinKind kind = ast_TypeRef_getBuiltinKind(ref);
      base = ast_builder_Builder_actOnBuiltinType(ma->builder, kind);
      (ast_QualType_isValid(&base)) || c2_assert("analyser/module_analyser_type.c2", 176, "module_analyser.Analyser.analyseTypeRef", "base.isValid()");
   }
   if (ast_TypeRef_isConst(ref)) ast_QualType_setConst(&base);
   if (ast_TypeRef_isVolatile(ref)) ast_QualType_setVolatile(&base);
   ast_QualType resolved = base;
   uint32_t num_ptrs = ast_TypeRef_getNumPointers(ref);
   for (uint32_t i = 0; (i < num_ptrs); i++) {
      resolved = ast_builder_Builder_actOnPointerType(ma->builder, resolved);
   }
   if ((ast_TypeRef_isUser(ref) && ast_QualType_isStruct(&resolved))) {
      ast_StructType* st = ast_QualType_getStructType(&resolved);
      const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
      if (ast_StructTypeDecl_isOpaque(std)) {
         const ast_Decl* d = ((ast_Decl*)(std));
         _Bool is_external = (ma->mod != ast_Decl_getModule(d));
         if ((ma->curFunction && (ast_FunctionDecl_getInstanceModule(ma->curFunction) == ast_Decl_getModule(d)))) {
            is_external = false;
         }
         if (is_external) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "opaque type '%s' used by value", ast_QualType_diagName(&resolved));
         } else if (ma->usedPublic) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "public declaration using opaque type '%s' by value", ast_QualType_diagName(&resolved));
         }

      }
   }
   uint32_t num_arrays = ast_TypeRef_getNumArrays(ref);
   for (uint32_t i = num_arrays; (i > 0); i--) {
      ast_Expr* sizeExpr = ast_TypeRef_getArray(ref, (i - 1));
      uint32_t size = 0;
      if (sizeExpr) {
         ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_TypeRef_getArray2(ref, (i - 1)), true, module_analyser_RHS);
         if (ast_QualType_isInvalid(&qt)) return qt;

         sizeExpr = ast_TypeRef_getArray(ref, (i - 1));
         if (!ast_QualType_isInteger(&qt)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array size has non-integer type '%s'", ast_QualType_diagName(&qt));
            return ast_QualType_Invalid;
         }
         if (!ast_Expr_isCtv(sizeExpr)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(sizeExpr), ast_Expr_getRange(sizeExpr), "array size is not a compile-time value");
            return ast_QualType_Invalid;
         }
         ast_Value value = ctv_analyser_get_value(sizeExpr);
         if (ast_Value_isNegative(&value)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(sizeExpr), ast_Expr_getRange(sizeExpr), "array size has negative value '%s'", ast_Value_str(&value));
            return ast_QualType_Invalid;
         }
         size = ast_Value_as_u32(&value);
      }
      if (ast_QualType_isVoid(&resolved)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array element has invalid type 'void'");
         return ast_QualType_Invalid;
      }
      resolved = ast_builder_Builder_actOnArrayType(ma->builder, resolved, (sizeExpr != NULL), size);
   }
   if (ast_TypeRef_isIncrArray(ref)) {
      resolved = ast_builder_Builder_actOnIncrementalArrayType(ma->builder, resolved);
   }
   if (ast_TypeRef_isUser(ref)) ast_TypeRef_setDest(ref, ast_QualType_getIndex(&base));
   return resolved;
}

static ast_QualType module_analyser_Analyser_analyseIncrTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref, uint32_t size)
{
   ast_QualType base;
   if (ast_TypeRef_isUser(ref)) {
      base = module_analyser_Analyser_analyseUserTypeRef(ma, ref);
      if (ast_QualType_isInvalid(&base)) return base;

      (ast_QualType_hasCanonicalType(&base)) || c2_assert("analyser/module_analyser_type.c2", 255, "module_analyser.Analyser.analyseIncrTypeRef", "base.hasCanonicalType()");
   } else {
      ast_BuiltinKind kind = ast_TypeRef_getBuiltinKind(ref);
      base = ast_builder_Builder_actOnBuiltinType(ma->builder, kind);
      (ast_QualType_isValid(&base)) || c2_assert("analyser/module_analyser_type.c2", 259, "module_analyser.Analyser.analyseIncrTypeRef", "base.isValid()");
   }
   if (ast_TypeRef_isConst(ref)) ast_QualType_setConst(&base);
   if (ast_TypeRef_isVolatile(ref)) ast_QualType_setVolatile(&base);
   ast_QualType resolved = base;
   uint32_t num_ptrs = ast_TypeRef_getNumPointers(ref);
   for (uint32_t i = 0; (i < num_ptrs); i++) {
      resolved = ast_builder_Builder_actOnPointerType(ma->builder, resolved);
   }
   if (ast_QualType_isVoid(&resolved)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array element has invalid type 'void'");
      return ast_QualType_Invalid;
   }
   resolved = ast_builder_Builder_actOnArrayType(ma->builder, resolved, true, size);
   if (ast_TypeRef_isUser(ref)) ast_TypeRef_setDest(ref, ast_QualType_getIndex(&base));
   return resolved;
}

static _Bool module_analyser_Analyser_checkOpaque(module_analyser_Analyser* ma, const ast_StructTypeDecl* std, src_loc_SrcLoc loc)
{
   if (ast_StructTypeDecl_isOpaque(std)) {
      ast_Decl* d = ((ast_Decl*)(std));
      ast_Module* other = ast_Decl_getModule(d);
      if ((other != ma->mod)) {
         ast_QualType qt = ast_Decl_getType(d);
         module_analyser_Analyser_error(ma, loc, " cannot dereference opaque struct '%s'", ast_QualType_diagNameBare(&qt));
         return false;
      }
   }
   return true;
}

static ast_VarDecl* module_analyser_getVarDecl(const ast_Expr* e)
{
   ast_Decl* d;
   if (ast_Expr_isIdentifier(e)) {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      d = ast_IdentifierExpr_getDecl(i);
   } else {
      ast_MemberExpr* m = ((ast_MemberExpr*)(e));
      d = ast_MemberExpr_getFullDecl(m);
   }
   if (ast_Decl_isVariable(d)) return ((ast_VarDecl*)(d));

   return NULL;
}

static ast_QualType module_analyser_Analyser_analyseUnaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_UnaryOperator* u = ((ast_UnaryOperator*)(e));
   _Bool need_rvalue = true;
   switch (ast_UnaryOperator_getOpcode(u)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec:
      fallthrough;
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec:
      if (!ma->curFunction) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time constant");
         return ast_QualType_Invalid;
      }
      need_rvalue = false;
      side |= module_analyser_LHS;
      break;
   case ast_UnaryOpcode_AddrOf:
      need_rvalue = false;
      side |= module_analyser_LHS;
      break;
   case ast_UnaryOpcode_Deref:
      fallthrough;
   case ast_UnaryOpcode_Plus:
      fallthrough;
   case ast_UnaryOpcode_Minus:
      fallthrough;
   case ast_UnaryOpcode_Not:
      fallthrough;
   case ast_UnaryOpcode_LNot:
      side |= module_analyser_RHS;
      break;
   }
   ast_QualType t = module_analyser_Analyser_analyseExpr(ma, ast_UnaryOperator_getInner2(u), need_rvalue, side);
   if (ast_QualType_isInvalid(&t)) {
      return ast_QualType_Invalid;
   }
   e = *e_ptr;
   ast_Expr* inner = ast_UnaryOperator_getInner(u);
   if (ast_QualType_isVoid(&t)) goto invalid_type;

   ast_QualType canon = ast_QualType_getCanonicalType(&t);
   switch (ast_UnaryOperator_getOpcode(u)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PreInc:
      if (!module_analyser_Analyser_checkIncrDecr(ma, inner, t, true, ast_Expr_getLoc(e))) return ast_QualType_Invalid;

      break;
   case ast_UnaryOpcode_PostDec:
      fallthrough;
   case ast_UnaryOpcode_PreDec:
      if (!module_analyser_Analyser_checkIncrDecr(ma, inner, t, false, ast_Expr_getLoc(e))) return ast_QualType_Invalid;

      break;
   case ast_UnaryOpcode_AddrOf:
      if (!module_analyser_Analyser_getIdentifierKind(ma, inner)) return ast_QualType_Invalid;

      if ((ast_QualType_isConst(&canon) && ((ast_Expr_isIdentifier(inner) || ast_Expr_isMember(inner))))) {
         ast_VarDecl* vd = module_analyser_getVarDecl(inner);
         if (vd) ast_VarDecl_setAddrUsed(vd);
      }
      t = ast_builder_Builder_actOnPointerType(ma->builder, canon);
      ast_Expr_copyCtcFlags(e, inner);
      if ((ast_Expr_getKind(inner) == ast_ExprKind_ArraySubscript)) {
         ast_ArraySubscriptExpr* e1 = ((ast_ArraySubscriptExpr*)(inner));
         if ((ast_Expr_isCtc(ast_ArraySubscriptExpr_getBase(e1)) && ast_Expr_isCtv(ast_ArraySubscriptExpr_getIndex(e1)))) ast_Expr_setCtc(e);
      } else if ((ast_Expr_getKind(inner) == ast_ExprKind_UnaryOperator)) {
         ast_UnaryOperator* e1 = ((ast_UnaryOperator*)(inner));
         if ((ast_UnaryOperator_getOpcode(e1) == ast_UnaryOpcode_Deref)) ast_Expr_copyCtcFlags(e, ast_UnaryOperator_getInner(e1));
      }

      break;
   case ast_UnaryOpcode_Deref:
      if (ast_QualType_isPointer(&t)) {
         ast_Expr_setLValue(e);
         t = ast_QualType_getCanonicalType(&t);
         const ast_PointerType* p = ast_QualType_getPointerType(&t);
         return ast_PointerType_getInner(p);
      } else {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "indirection requires pointer operand ('%s' invalid)", ast_QualType_diagName(&t));
         return ast_QualType_Invalid;
      }
      break;
   case ast_UnaryOpcode_Minus: {
      ast_QualType lhs = module_analyser_getMinusType(canon);
      if (!ast_QualType_isValid(&lhs)) goto invalid_type;

      ast_Expr_copyConstantFlags(e, inner);
      t = module_analyser_usualUnaryConversions(inner);
      break;
   }
   case ast_UnaryOpcode_Plus:
      if (!ast_QualType_isBuiltin(&canon)) goto invalid_type;

      ast_Expr_copyConstantFlags(e, inner);
      t = module_analyser_usualUnaryConversions(inner);
      break;
   case ast_UnaryOpcode_Not:
      if ((!ast_QualType_isBuiltin(&canon) || ast_QualType_isFloat(&canon))) goto invalid_type;

      ast_Expr_copyConstantFlags(e, inner);
      t = module_analyser_usualUnaryConversions(inner);
      break;
   case ast_UnaryOpcode_LNot:
      ast_Expr_copyConstantFlags(e, inner);
      return ast_builtins[ast_BuiltinKind_Bool];
   }
   return t;
   invalid_type:
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid argument type '%s' to unary expression", ast_QualType_diagName(&t));
   return ast_QualType_Invalid;
}

static _Bool module_analyser_Analyser_checkIncrDecr(module_analyser_Analyser* ma, ast_Expr* inner, ast_QualType t, _Bool is_incr, src_loc_SrcLoc loc)
{
   const char* operand = is_incr ? "increment operand" : "decrement operand";
   if (!module_analyser_Analyser_checkAssignment(ma, inner, t, operand, loc)) return false;

   t = ast_QualType_getCanonicalType(&t);
   if (((!ast_QualType_isBuiltin(&t) && !ast_QualType_isPointer(&t)) && !ast_QualType_isEnum(&t))) {
      module_analyser_Analyser_error(ma, loc, "cannot %s value of type '%s'", is_incr ? "increment" : "decrement", ast_QualType_diagName(&t));
      return false;
   }
   return true;
}

static _Bool module_analyser_Analyser_getIdentifierKind(module_analyser_Analyser* ma, ast_Expr* e)
{
   ast_IdentifierKind kind = module_analyser_getInnerExprAddressOf(e);
   const char* arg = "";
   switch (kind) {
   case ast_IdentifierKind_Unresolved: {
      ast_QualType qt = ast_Expr_getType(e);
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot take the address of an rvalue of type '%s'", ast_QualType_diagName(&qt));
      return false;
   }
   case ast_IdentifierKind_Module:
      arg = "a module";
      break;
   case ast_IdentifierKind_Function:
      arg = "a function";
      break;
   case ast_IdentifierKind_Type:
      arg = "a type";
      break;
   case ast_IdentifierKind_Var:
      return true;
   case ast_IdentifierKind_EnumConstant:
      arg = "an enum constant";
      break;
   case ast_IdentifierKind_StructMember:
      return true;
   case ast_IdentifierKind_Label:
      arg = "a label";
      break;
   }
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot take the address of %s", arg);
   return false;
}

static ast_IdentifierKind module_analyser_getInnerExprAddressOf(ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      fallthrough;
   case ast_ExprKind_StringLiteral:
      fallthrough;
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      return ast_IdentifierExpr_getKind(i);
   }
   case ast_ExprKind_Type:
      fallthrough;
   case ast_ExprKind_Call:
      fallthrough;
   case ast_ExprKind_InitList:
      fallthrough;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      break;
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* e1 = ((ast_UnaryOperator*)(e));
      if ((ast_UnaryOperator_getOpcode(e1) == ast_UnaryOpcode_Deref)) {
         return ast_IdentifierKind_Var;
      }
      break;
   }
   case ast_ExprKind_ConditionalOperator:
      break;
   case ast_ExprKind_Builtin:
      break;
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      if ((ast_Expr_getKind(index) != ast_ExprKind_BitOffset)) return ast_IdentifierKind_Var;

      break;
   }
   case ast_ExprKind_Member: {
      ast_MemberExpr* m = ((ast_MemberExpr*)(e));
      return ast_MemberExpr_getKind(m);
   }
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      return module_analyser_getInnerExprAddressOf(ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      return ast_IdentifierKind_Unresolved;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* c = ((ast_ExplicitCastExpr*)(e));
      return module_analyser_getInnerExprAddressOf(ast_ExplicitCastExpr_getInner(c));
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* c = ((ast_ImplicitCastExpr*)(e));
      return module_analyser_getInnerExprAddressOf(ast_ImplicitCastExpr_getInner(c));
   }
   case ast_ExprKind_Range:
      break;
   }
   return ast_IdentifierKind_Unresolved;
}

static ast_QualType module_analyser_getMinusType(ast_QualType qt)
{
   if (!ast_QualType_isBuiltin(&qt)) return ast_QualType_Invalid;

   ast_BuiltinType* bi = ast_QualType_getBuiltin(&qt);
   switch (ast_BuiltinType_getKind(bi)) {
   case ast_BuiltinKind_Char:
      fallthrough;
   case ast_BuiltinKind_Int8:
      fallthrough;
   case ast_BuiltinKind_Int16:
      fallthrough;
   case ast_BuiltinKind_Bool:
      return ast_builtins[ast_BuiltinKind_Int32];
   case ast_BuiltinKind_Int32:
      fallthrough;
   case ast_BuiltinKind_Int64:
      return qt;
   case ast_BuiltinKind_UInt8:
      fallthrough;
   case ast_BuiltinKind_UInt16:
      fallthrough;
   case ast_BuiltinKind_UInt32:
      return ast_builtins[ast_BuiltinKind_Int32];
   case ast_BuiltinKind_UInt64:
      return ast_builtins[ast_BuiltinKind_Int64];
   case ast_BuiltinKind_Float32:
      fallthrough;
   case ast_BuiltinKind_Float64:
      fallthrough;
   case ast_BuiltinKind_ISize:
      return qt;
   case ast_BuiltinKind_USize:
      return ast_builtins[ast_BuiltinKind_ISize];
   case ast_BuiltinKind_Void:
      break;
   }
   return ast_QualType_Invalid;
}

static void module_analyser_StructFieldInitChecker_init(module_analyser_StructFieldInitChecker* c, uint32_t max)
{
   c->num_inits = 0;
   c->max_inits = max;
   c->inits = NULL;
   module_analyser_StructFieldInitChecker_resize(c, max);
}

static void module_analyser_StructFieldInitChecker_resize(module_analyser_StructFieldInitChecker* c, uint32_t max)
{
   module_analyser_FieldInit* inits = malloc((max * 8));
   c->max_inits = max;
   if (c->num_inits) memcpy(inits, c->inits, (c->num_inits * 8));
   if (c->inits) free(c->inits);
   c->inits = inits;
}

static src_loc_SrcLoc module_analyser_StructFieldInitChecker_add(module_analyser_StructFieldInitChecker* c, uint32_t offset, src_loc_SrcLoc loc)
{
   src_loc_SrcLoc prev = module_analyser_StructFieldInitChecker_find(c, offset);
   if (prev) return prev;

   if ((c->num_inits == c->max_inits)) module_analyser_StructFieldInitChecker_resize(c, (c->max_inits * 2));
   c->inits[c->num_inits].offset = offset;
   c->inits[c->num_inits].loc = loc;
   c->num_inits++;
   return 0;
}

static src_loc_SrcLoc module_analyser_StructFieldInitChecker_find(const module_analyser_StructFieldInitChecker* c, uint32_t offset)
{
   for (uint32_t i = 0; (i < c->num_inits); i++) {
      if ((c->inits[i].offset == offset)) return c->inits[i].loc;

   }
   return 0;
}

static void module_analyser_StructFieldInitChecker_free(module_analyser_StructFieldInitChecker* c)
{
   free(c->inits);
}


// --- module ir_generator ---
typedef struct ir_generator_BasicStructLayouter_ ir_generator_BasicStructLayouter;
typedef struct ir_generator_FieldInit_ ir_generator_FieldInit;
typedef struct ir_generator_FieldStructLayouter_ ir_generator_FieldStructLayouter;
typedef struct ir_generator_JumpScope_ ir_generator_JumpScope;
typedef struct ir_generator_Generator_ ir_generator_Generator;

struct ir_generator_BasicStructLayouter_ {
   ir_generator_Generator* gen;
   ast_StructTypeDecl* std;
   uint32_t cur_idx;
   uint32_t cur_offset;
   const uint32_t* offsets;
   ast_Decl** members;
};

static void ir_generator_BasicStructLayouter_init(ir_generator_BasicStructLayouter* l, ir_generator_Generator* gen, ast_StructTypeDecl* std);
static void ir_generator_BasicStructLayouter_add(ir_generator_BasicStructLayouter* l, uint32_t idx, const ast_Expr* value);
static void ir_generator_BasicStructLayouter_finalize(ir_generator_BasicStructLayouter* l);
struct ir_generator_FieldInit_ {
   uint32_t offset;
   ast_Expr* expr;
};

struct ir_generator_FieldStructLayouter_ {
   ir_generator_Generator* gen;
   uint32_t size;
   ir_generator_FieldInit* inits;
   uint32_t num_inits;
   uint32_t max_inits;
};

static void ir_generator_FieldStructLayouter_init(ir_generator_FieldStructLayouter* l, ir_generator_Generator* gen, ast_StructTypeDecl* std);
static void ir_generator_FieldStructLayouter_resize(ir_generator_FieldStructLayouter* l, uint32_t max);
static void ir_generator_FieldStructLayouter_add(ir_generator_FieldStructLayouter* l, uint32_t offset, ast_Expr* value);
static void ir_generator_FieldStructLayouter_finalize(ir_generator_FieldStructLayouter* l);
struct ir_generator_JumpScope_ {
   uint32_t break_block;
   uint32_t continue_block;
};

struct ir_generator_Generator_ {
   ir_Context* ctx;
   string_pool_Pool* names;
   value_maplist_List labels;
   ir_generator_JumpScope scopes[32];
   uint32_t num_scopes;
   ir_gen_locals_Locals locals;
   ref_list_pool_Pool ref_pool;
   string_buffer_Buf* name_buf;
   _Bool assert_generated;
   _Bool print;
   _Bool enable_asserts;
   uint32_t string_idx;
   uint32_t substruct_idx;
   const char* target;
   const char* output_dir;
   source_mgr_SourceMgr* sm;
   ast_FunctionDecl* cur_function;
};

static const ir_Type ir_generator_Ast_type2ir_type[15] = {
   [ast_BuiltinKind_Char] = ir_Type_I8,
   [ast_BuiltinKind_Int8] = ir_Type_I8,
   [ast_BuiltinKind_Int16] = ir_Type_I16,
   [ast_BuiltinKind_Int32] = ir_Type_I32,
   [ast_BuiltinKind_Int64] = ir_Type_I64,
   [ast_BuiltinKind_UInt8] = ir_Type_U8,
   [ast_BuiltinKind_UInt16] = ir_Type_U16,
   [ast_BuiltinKind_UInt32] = ir_Type_U32,
   [ast_BuiltinKind_UInt64] = ir_Type_U64,
   [ast_BuiltinKind_Float32] = ir_Type_F32,
   [ast_BuiltinKind_Float64] = ir_Type_F64,
   [ast_BuiltinKind_ISize] = ir_Type_I64,
   [ast_BuiltinKind_USize] = ir_Type_U64,
   [ast_BuiltinKind_Bool] = ir_Type_I8,
   [ast_BuiltinKind_Void] = ir_Type_None
};

static void ir_generator_Generator_init(ir_generator_Generator* gen, source_mgr_SourceMgr* sm, const char* target, const char* output_dir, _Bool enable_asserts, _Bool print);
static void ir_generator_Generator_free(ir_generator_Generator* gen);
static void ir_generator_Generator_enterScope(ir_generator_Generator* gen, uint32_t break_block, uint32_t continue_block);
static void ir_generator_Generator_leaveScope(ir_generator_Generator* gen);
static const char* ir_generator_Generator_createLocalName(ir_generator_Generator* gen, const ast_Decl* d);
static const char* ir_generator_Generator_createSymbolName(ir_generator_Generator* gen, const ast_Decl* d);
static ir_SymbolId ir_generator_Generator_createSymbol(ir_generator_Generator* gen, ast_Decl* d);
static const char* ir_generator_Generator_createStringVar(ir_generator_Generator* gen);
static ir_Type ir_generator_builtin2irtype(ast_BuiltinKind k);
static ir_Type ir_generator_Generator_type2irtype(ir_generator_Generator* gen, ast_QualType qt);
static void ir_generator_Generator_emitInit(ir_generator_Generator* gen, const ast_Expr* e, uint32_t size);
static void ir_generator_Generator_emitStructInit(ir_generator_Generator* gen, const ast_Expr* e);
static void ir_generator_on_zero(void* arg, uint32_t size);
static void ir_generator_on_expr(void* arg, const ast_Expr* e, uint32_t elem_size);
static void ir_generator_Generator_emitArrayInit(ir_generator_Generator* gen, const ast_Expr* e);
static _Bool ir_generator_Generator_isExternal(ir_generator_Generator* gen, const ast_Decl* d);
static void ir_generator_Generator_emitFunction(ir_generator_Generator* gen, ast_FunctionDecl* fd);
static void ir_generator_on_var_decl(void* arg, ast_VarDecl* vd);
static void ir_generator_on_function_decl(void* arg, ast_FunctionDecl* d);
static void ir_generator_Generator_on_ast(void* arg, ast_AST* a);
static void ir_generator_Generator_on_module(void* arg, ast_Module* m);
static void ir_generator_generate(const char* target, const char* output_dir, component_List* comps, source_mgr_SourceMgr* sm, _Bool enable_asserts, _Bool print);
static void ir_generator_Generator_collectLocals(ir_generator_Generator* gen, const ast_FunctionDecl* fd);
static void ir_generator_Generator_addLocalVar(ir_generator_Generator* gen, ast_VarDecl* vd);
static void ir_generator_Generator_collectLocalVars(ir_generator_Generator* gen, ast_Stmt* s);
static ir_BlockId ir_generator_Generator_getLabelBlock(ir_generator_Generator* gen, uint32_t label_idx);
static void ir_generator_Generator_emitBinaryOperator(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitLogicalAnd(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitLogicalOr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitShift(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitOpAssign(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitCallExpr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitExpr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitIdentifier(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitSymbol(ir_generator_Generator* gen, ir_Ref* result, ast_Decl* d);
static void ir_generator_Generator_emitVarDecl(ir_generator_Generator* gen, ir_Ref* result, ast_Decl* d);
static void ir_generator_Generator_emitCondOperator(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitUnaryOperator(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitCond(ir_generator_Generator* gen, const ast_Expr* e, ir_BlockId true_blk, ir_BlockId false_blk, ir_BlockId start_blk);
static void ir_generator_Generator_emitAssignCond(ir_generator_Generator* gen, ir_Type t, ir_Ref lhs, ir_Ref rhs, ir_BlockId left, ir_BlockId right, ir_BlockId start);
static _Bool ir_generator_Generator_emitBinaryCond(ir_generator_Generator* gen, const ast_Expr* e, ir_BlockId left, ir_BlockId right, ir_BlockId start);
static void ir_generator_Generator_emitAndCond(ir_generator_Generator* gen, const ast_BinaryOperator* b, ir_BlockId true_blk, ir_BlockId false_blk);
static void ir_generator_Generator_emitOrCond(ir_generator_Generator* gen, const ast_BinaryOperator* b, ir_BlockId true_blk, ir_BlockId false_blk, ir_BlockId start_blk);
static void ir_generator_Generator_emitBuiltin(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitArraySubscript(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static void ir_generator_Generator_emitMemberExpr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e);
static _Bool ir_generator_Generator_emitStmt(ir_generator_Generator* gen, const ast_Stmt* s);
static void ir_generator_Generator_emitIfStmt(ir_generator_Generator* gen, const ast_Stmt* s);
static void ir_generator_Generator_emitWhileStmt(ir_generator_Generator* gen, const ast_Stmt* s);
static void ir_generator_Generator_emitForStmt(ir_generator_Generator* gen, const ast_Stmt* s);
static void ir_generator_Generator_emitSwitchStmt(ir_generator_Generator* gen, const ast_Stmt* s);
static _Bool ir_generator_Generator_emitSwitchCase(ir_generator_Generator* gen, ast_SwitchCase* sc, ir_BlockId join_blk, ir_CaseId caseId, _Bool prev_fallthrough);

static void ir_generator_BasicStructLayouter_init(ir_generator_BasicStructLayouter* l, ir_generator_Generator* gen, ast_StructTypeDecl* std)
{
   l->gen = gen;
   l->std = std;
   l->cur_offset = 0;
   l->offsets = ast_StructTypeDecl_getMemberOffsets(std);
   l->members = ast_StructTypeDecl_getMembers(std);
}

static void ir_generator_BasicStructLayouter_add(ir_generator_BasicStructLayouter* l, uint32_t idx, const ast_Expr* value)
{
   ast_Decl* member = l->members[idx];
   ast_QualType qt = ast_Decl_getType(member);
   uint32_t size = ast_QualType_getSize(&qt, false);
   uint32_t offset = l->offsets[idx];
   if ((offset != l->cur_offset)) {
      uint32_t pad = (offset - l->cur_offset);
      ir_Context_addInitZero(l->gen->ctx, pad);
   }
   ir_generator_Generator_emitInit(l->gen, value, size);
   l->cur_offset = (offset + size);
}

static void ir_generator_BasicStructLayouter_finalize(ir_generator_BasicStructLayouter* l)
{
   uint32_t size = ast_StructTypeDecl_getSize(l->std);
   if ((l->cur_offset != size)) {
      uint32_t pad = (size - l->cur_offset);
      ir_Context_addInitZero(l->gen->ctx, pad);
   }
}

static void ir_generator_FieldStructLayouter_init(ir_generator_FieldStructLayouter* l, ir_generator_Generator* gen, ast_StructTypeDecl* std)
{
   l->gen = gen;
   l->size = ast_StructTypeDecl_getSize(std);
   l->num_inits = 0;
   l->inits = NULL;
   ir_generator_FieldStructLayouter_resize(l, ast_StructTypeDecl_getNumMembers(std));
}

static void ir_generator_FieldStructLayouter_resize(ir_generator_FieldStructLayouter* l, uint32_t max)
{
   l->max_inits = max;
   ir_generator_FieldInit* inits = malloc((max * 16));
   if (l->num_inits) memcpy(inits, l->inits, (l->num_inits * 16));
   if (l->inits) free(l->inits);
   l->inits = inits;
}

static void ir_generator_FieldStructLayouter_add(ir_generator_FieldStructLayouter* l, uint32_t offset, ast_Expr* value)
{
   if ((l->num_inits == l->max_inits)) ir_generator_FieldStructLayouter_resize(l, (l->max_inits * 2));
   ir_generator_FieldInit init = { offset, value };
   if ((l->num_inits == 0)) {
      l->inits[0] = init;
      l->num_inits = 1;
      return;
   }
   uint32_t idx = l->num_inits;
   while (idx) {
      ir_generator_FieldInit* fi = &l->inits[(idx - 1)];
      if ((offset > fi->offset)) break;

      l->inits[idx] = *fi;
      idx--;
   }
   l->inits[idx] = init;
   l->num_inits++;
}

static void ir_generator_FieldStructLayouter_finalize(ir_generator_FieldStructLayouter* l)
{
   uint32_t cur_offset = 0;
   for (uint32_t i = 0; (i < l->num_inits); i++) {
      const ir_generator_FieldInit* fi = &l->inits[i];
      ast_QualType qt = ast_Expr_getType(fi->expr);
      uint32_t size = ast_QualType_getSize(&qt, false);
      if ((cur_offset != fi->offset)) {
         uint32_t pad = (fi->offset - cur_offset);
         ir_Context_addInitZero(l->gen->ctx, pad);
      }
      cur_offset = (fi->offset + size);
      ir_generator_Generator_emitInit(l->gen, fi->expr, size);
   }
   if ((cur_offset != l->size)) {
      uint32_t pad = (l->size - cur_offset);
      ir_Context_addInitZero(l->gen->ctx, pad);
   }
   free(l->inits);
}

static void ir_generator_Generator_init(ir_generator_Generator* gen, source_mgr_SourceMgr* sm, const char* target, const char* output_dir, _Bool enable_asserts, _Bool print)
{
   memset(gen, 0, 392);
   gen->ctx = ir_create();
   value_maplist_List_init(&gen->labels);
   gen->target = target;
   gen->output_dir = output_dir;
   gen->string_idx = 1;
   ir_gen_locals_Locals_init(&gen->locals);
   ref_list_pool_Pool_init(&gen->ref_pool, 4);
   gen->enable_asserts = enable_asserts;
   gen->print = print;
   gen->sm = sm;
   gen->name_buf = string_buffer_create(128, false, 0);
}

static void ir_generator_Generator_free(ir_generator_Generator* gen)
{
   ref_list_pool_Pool_free(&gen->ref_pool);
   value_maplist_List_free(&gen->labels);
   ir_Context_free(gen->ctx);
   string_buffer_Buf_free(gen->name_buf);
   ir_gen_locals_Locals_free(&gen->locals);
}

static void ir_generator_Generator_enterScope(ir_generator_Generator* gen, uint32_t break_block, uint32_t continue_block)
{
   ((gen->num_scopes < 32)) || c2_assert("generator/ir/ir_generator.c2", 93, "ir_generator.Generator.enterScope", "gen.num_scopes < elemsof(gen.scopes)");
   ir_generator_JumpScope* s = &gen->scopes[gen->num_scopes];
   s->break_block = break_block;
   if (continue_block) {
      s->continue_block = continue_block;
   } else {
      if ((gen->num_scopes >= 1)) s->continue_block = gen->scopes[(gen->num_scopes - 1)].continue_block;
   }
   gen->num_scopes++;
}

static void ir_generator_Generator_leaveScope(ir_generator_Generator* gen)
{
   ((gen->num_scopes > 0)) || c2_assert("generator/ir/ir_generator.c2", 107, "ir_generator.Generator.leaveScope", "gen.num_scopes > 0");
   gen->num_scopes--;
}

static const char* ir_generator_Generator_createLocalName(ir_generator_Generator* gen, const ast_Decl* d)
{
   (gen->cur_function) || c2_assert("generator/ir/ir_generator.c2", 112, "ir_generator.Generator.createLocalName", "gen.cur_function");
   string_buffer_Buf* out = gen->name_buf;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, ast_Decl_getModuleName(d));
   string_buffer_Buf_add1(out, '_');
   string_buffer_Buf_add(out, ast_Decl_getName(ast_FunctionDecl_asDecl(gen->cur_function)));
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_Decl_getName(d));
   return string_buffer_Buf_data(out);
}

static const char* ir_generator_Generator_createSymbolName(ir_generator_Generator* gen, const ast_Decl* d)
{
   string_buffer_Buf* out = gen->name_buf;
   string_buffer_Buf_clear(out);
   if (ast_Decl_isExternal(d)) {
      const char* cname = ast_Decl_getCName(d);
      if (cname) {
         string_buffer_Buf_add(out, cname);
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
   } else {
      if (ast_Decl_isGlobal(d)) {
         string_buffer_Buf_add(out, ast_Decl_getModuleName(d));
         string_buffer_Buf_add1(out, '_');
         if (ast_Decl_isFunction(d)) {
            ast_FunctionDecl* fd = ((ast_FunctionDecl*)(d));
            ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
            if (prefix) {
               string_buffer_Buf_add(out, ast_idx2name(prefix->name_idx));
               string_buffer_Buf_add1(out, '_');
            }
         } else if (ast_Decl_isEnumConstant(d)) {
            ast_QualType qt = ast_Decl_getType(d);
            ast_EnumType* et = ((ast_EnumType*)(ast_QualType_getType(&qt)));
            string_buffer_Buf_add(out, ast_EnumType_getName(et));
            string_buffer_Buf_add1(out, '_');
         }

      }
      string_buffer_Buf_add(out, ast_Decl_getName(d));
   }
   return string_buffer_Buf_data(out);
}

static ir_SymbolId ir_generator_Generator_createSymbol(ir_generator_Generator* gen, ast_Decl* d)
{
   uint32_t gen_idx = ast_Decl_getGenIdx(d);
   if (!gen_idx) {
      _Bool is_external = ir_generator_Generator_isExternal(gen, d);
      if (ast_Decl_isFunction(d)) {
         gen_idx = ir_Context_addFunction(gen->ctx, ir_generator_Generator_createSymbolName(gen, d), is_external);
      } else {
         ast_QualType qt = ast_Decl_getType(d);
         gen_idx = ir_Context_addGlobalVar(gen->ctx, ir_generator_Generator_createSymbolName(gen, d), ast_QualType_getAlignment(&qt), is_external);
      }
      ast_Decl_setGenIdx(d, gen_idx);
   }
   return gen_idx;
}

static const char* ir_generator_Generator_createStringVar(ir_generator_Generator* gen)
{
   string_buffer_Buf* out = gen->name_buf;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_print(out, ".str%u", gen->string_idx);
   gen->string_idx++;
   return string_buffer_Buf_data(out);
}

static ir_Type ir_generator_builtin2irtype(ast_BuiltinKind k)
{
   return ir_generator_Ast_type2ir_type[k];
}

static ir_Type ir_generator_Generator_type2irtype(ir_generator_Generator* gen, ast_QualType qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(&qt);
   switch (ast_QualType_getKind(&canon)) {
   case ast_TypeKind_Builtin: {
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&canon);
      return ir_generator_builtin2irtype(ast_BuiltinType_getKind(bi));
   }
   case ast_TypeKind_Pointer:
      return ir_Type_I64;
   case ast_TypeKind_Array: {
      ast_ArrayType* at = ast_QualType_getArrayType(&canon);
      return ir_generator_Generator_type2irtype(gen, ast_ArrayType_getElemType(at));
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = ast_QualType_getStructType(&canon);
      const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
      uint32_t align = ast_StructTypeDecl_getAlignment(std);
      switch (align) {
      case 1:
         return ir_Type_I8;
      case 2:
         return ir_Type_I16;
      case 4:
         return ir_Type_I32;
      default:
         return ir_Type_I64;
      }
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = ast_QualType_getEnum(&canon);
      return ir_generator_Generator_type2irtype(gen, ast_EnumType_getImplType(et));
   }
   case ast_TypeKind_Function:
      return ir_Type_I64;
   case ast_TypeKind_Alias:
      (0) || c2_assert("generator/ir/ir_generator.c2", 238, "ir_generator.Generator.type2irtype", "0");
      break;
   case ast_TypeKind_Module:
      (0) || c2_assert("generator/ir/ir_generator.c2", 241, "ir_generator.Generator.type2irtype", "0");
      break;
   }
   return ir_Type_None;
}

static void ir_generator_Generator_emitInit(ir_generator_Generator* gen, const ast_Expr* e, uint32_t size)
{
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ctv_analyser_get_value(e);
      switch (size) {
      case 1:
         ir_Context_addInitValueU8(gen->ctx, ast_Value_as_u8(&v));
         break;
      case 2:
         ir_Context_addInitValueU16(gen->ctx, ast_Value_as_u16(&v));
         break;
      case 4:
         ir_Context_addInitValueU32(gen->ctx, ast_Value_as_u32(&v));
         break;
      case 8:
         ir_Context_addInitValueU64(gen->ctx, ast_Value_as_u64(&v));
         break;
      }
      return;
   }
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      (0) || c2_assert("generator/ir/ir_generator.c2", 272, "ir_generator.Generator.emitInit", "0");
      break;
   case ast_ExprKind_StringLiteral: {
      const ast_StringLiteral* s = ((ast_StringLiteral*)(e));
      ir_Context_addInitString(gen->ctx, ast_StringLiteral_getText(s), ast_StringLiteral_strlen(s));
      break;
   }
   case ast_ExprKind_Nil:
      (0) || c2_assert("generator/ir/ir_generator.c2", 279, "ir_generator.Generator.emitInit", "0");
      break;
   case ast_ExprKind_Identifier: {
      const ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
      ast_Decl* d = ast_IdentifierExpr_getDecl(i);
      ir_SymbolId sid = ir_generator_Generator_createSymbol(gen, d);
      ir_Context_addInitSymbol(gen->ctx, sid);
      break;
   }
   case ast_ExprKind_Type:
      fallthrough;
   case ast_ExprKind_Call:
      ast_Expr_dump(e);
      (0) || c2_assert("generator/ir/ir_generator.c2", 290, "ir_generator.Generator.emitInit", "0");
      break;
   case ast_ExprKind_InitList: {
      const ast_InitListExpr* ile = ((ast_InitListExpr*)(e));
      uint32_t num_values = ast_InitListExpr_getNumValues(ile);
      if ((num_values == 0)) {
         ir_Context_addInitZero(gen->ctx, size);
         break;
      }
      if (ast_InitListExpr_isArray(ile)) {
         ir_generator_Generator_emitArrayInit(gen, e);
      } else {
         ir_generator_Generator_emitStructInit(gen, e);
      }
      break;
   }
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      fallthrough;
   case ast_ExprKind_BinaryOperator:
      ast_Expr_dump(e);
      (0) || c2_assert("generator/ir/ir_generator.c2", 309, "ir_generator.Generator.emitInit", "0");
      break;
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* uo = ((ast_UnaryOperator*)(e));
      (ast_UnaryOperator_isAddrOf(uo)) || c2_assert("generator/ir/ir_generator.c2", 313, "ir_generator.Generator.emitInit", "uo.isAddrOf()");
      ir_generator_Generator_emitInit(gen, ast_UnaryOperator_getInner(uo), size);
      break;
   }
   case ast_ExprKind_ConditionalOperator:
      fallthrough;
   case ast_ExprKind_Builtin:
      fallthrough;
   case ast_ExprKind_ArraySubscript:
      ast_Expr_dump(e);
      (0) || c2_assert("generator/ir/ir_generator.c2", 320, "ir_generator.Generator.emitInit", "0");
      break;
   case ast_ExprKind_Member: {
      const ast_MemberExpr* m = ((ast_MemberExpr*)(e));
      ast_Decl* d = ast_MemberExpr_getFullDecl(m);
      ir_SymbolId sid = ir_generator_Generator_createSymbol(gen, d);
      ir_Context_addInitSymbol(gen->ctx, sid);
      break;
   }
   case ast_ExprKind_Paren:
      fallthrough;
   case ast_ExprKind_BitOffset:
      ast_Expr_dump(e);
      (0) || c2_assert("generator/ir/ir_generator.c2", 332, "ir_generator.Generator.emitInit", "0");
      break;
   case ast_ExprKind_ExplicitCast: {
      const ast_ExplicitCastExpr* ec = ((ast_ExplicitCastExpr*)(e));
      ir_generator_Generator_emitInit(gen, ast_ExplicitCastExpr_getInner(ec), size);
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
      ir_generator_Generator_emitInit(gen, ast_ImplicitCastExpr_getInner(ic), size);
      break;
   }
   case ast_ExprKind_Range:
      (0) || c2_assert("generator/ir/ir_generator.c2", 345, "ir_generator.Generator.emitInit", "0");
      break;
   }
}

static void ir_generator_Generator_emitStructInit(ir_generator_Generator* gen, const ast_Expr* e)
{
   const ast_InitListExpr* ile = ((ast_InitListExpr*)(e));
   uint32_t num_values = ast_InitListExpr_getNumValues(ile);
   const ast_Expr** values = ast_InitListExpr_getValues2(ile);
   ast_QualType qt = ast_Expr_getType(e);
   ast_StructType* st = ast_QualType_getStructType(&qt);
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   const uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   if (ast_InitListExpr_hasDesignators(ile)) {
      ir_generator_FieldStructLayouter layouter;
      ir_generator_FieldStructLayouter_init(&layouter, gen, std);
      for (uint32_t i = 0; (i < num_values); i++) {
         ast_FieldDesignatedInitExpr* fdi = ((ast_FieldDesignatedInitExpr*)(values[i]));
         ir_generator_FieldStructLayouter_add(&layouter, ast_FieldDesignatedInitExpr_getMemberOffset(fdi), ast_FieldDesignatedInitExpr_getInit(fdi));
      }
      ir_generator_FieldStructLayouter_finalize(&layouter);
   } else {
      ir_generator_BasicStructLayouter layouter;
      ir_generator_BasicStructLayouter_init(&layouter, gen, std);
      for (uint32_t i = 0; (i < num_values); i++) ir_generator_BasicStructLayouter_add(&layouter, i, values[i]);
      ir_generator_BasicStructLayouter_finalize(&layouter);
   }
}

static void ir_generator_on_zero(void* arg, uint32_t size)
{
   ir_generator_Generator* gen = arg;
   ir_Context_addInitZero(gen->ctx, size);
}

static void ir_generator_on_expr(void* arg, const ast_Expr* e, uint32_t elem_size)
{
   ir_generator_Generator* gen = arg;
   ir_generator_Generator_emitInit(gen, e, elem_size);
}

static void ir_generator_Generator_emitArrayInit(ir_generator_Generator* gen, const ast_Expr* e)
{
   const ast_InitListExpr* ile = ((ast_InitListExpr*)(e));
   uint32_t num_values = ast_InitListExpr_getNumValues(ile);
   ast_QualType qt = ast_Expr_getType(e);
   ast_ArrayType* at = ast_QualType_getArrayType(&qt);
   uint32_t array_size = ast_ArrayType_getSize(at);
   ast_QualType et = ast_ArrayType_getElemType(at);
   uint32_t elem_size = ast_QualType_getSize(&et, false);
   if (ast_InitListExpr_hasDesignators(ile)) {
      array_init_sorter_Sorter sorter = array_init_sorter_create(num_values, array_size, elem_size);
      const ast_Expr** values = ast_InitListExpr_getValues2(ile);
      for (uint32_t i = 0; (i < num_values); i++) {
         const ast_Expr* ie = values[i];
         if (ast_Expr_isArrayDesignatedInit(ie)) {
            const ast_ArrayDesignatedInitExpr* ad = ((ast_ArrayDesignatedInitExpr*)(ie));
            const ast_Expr* desig = ast_ArrayDesignatedInitExpr_getDesignator(ad);
            ast_Value v = ctv_analyser_get_value(desig);
            array_init_sorter_Sorter_addAt(&sorter, ast_Value_as_u32(&v), ast_ArrayDesignatedInitExpr_getInit(ad));
         } else {
            array_init_sorter_Sorter_add(&sorter, ie);
         }
      }
      array_init_sorter_Sorter_iterate(&sorter, ir_generator_on_expr, ir_generator_on_zero, gen);
      array_init_sorter_Sorter_free(&sorter);
   } else {
      const ast_Expr** values = ast_InitListExpr_getValues2(ile);
      for (uint32_t i = 0; (i < num_values); i++) {
         ir_generator_Generator_emitInit(gen, values[i], elem_size);
      }
      uint32_t missing = (array_size - num_values);
      if (missing) {
         ir_Context_addInitZero(gen->ctx, (missing * elem_size));
      }
   }
}

static _Bool ir_generator_Generator_isExternal(ir_generator_Generator* gen, const ast_Decl* d)
{
   return ast_Decl_isExported(d);
}

static void ir_generator_Generator_emitFunction(ir_generator_Generator* gen, ast_FunctionDecl* fd)
{
   ir_Context* c = gen->ctx;
   value_maplist_List_clear(&gen->labels);
   ir_gen_locals_Locals_clear(&gen->locals);
   ast_Decl* d = ((ast_Decl*)(fd));
   gen->cur_function = fd;
   _Bool has_prefix = (!ast_Decl_isPublic(d) || ((strcmp(ast_Decl_getName(d), "main") != 0)));
   uint32_t gen_idx = ast_Decl_getGenIdx(d);
   if (!gen_idx) {
      gen_idx = ir_Context_addFunction(c, ir_generator_Generator_createSymbolName(gen, d), ir_generator_Generator_isExternal(gen, d));
      ast_Decl_setGenIdx(d, gen_idx);
   }
   ir_Type rt = ir_Type_None;
   if (ast_FunctionDecl_hasReturn(fd)) {
      rt = ir_generator_Generator_type2irtype(gen, ast_FunctionDecl_getRType(fd));
      ir_Context_setFunctionReturnType(c, rt);
   } else {
      ir_Context_setFunctionReturnType(c, ir_Type_None);
   }
   ir_Context_startFunc(c, gen_idx);
   ir_BlockId body_blk = ir_Context_createBlock(c, ir_BlockKind_FnStart);
   ir_Context_startBlock(c, body_blk);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   ir_Ref param_refs[24];
   for (uint32_t i = 0; (i < num_params); i++) {
      ast_VarDecl* v = params[i];
      ir_Type t2 = ir_generator_Generator_type2irtype(gen, ast_Decl_getType(ast_VarDecl_asDecl(v)));
      ir_generator_Generator_addLocalVar(gen, v);
      ir_Context_addFuncArg(c, t2);
      ir_Ref_init(&param_refs[i], ir_RefKind_Param, (i + 1));
   }
   ir_generator_Generator_collectLocals(gen, fd);
   for (uint32_t i = 0; (i < num_params); i++) {
      ast_VarDecl* v = params[i];
      ir_gen_locals_StackVar* var = ir_gen_locals_Locals_find(&gen->locals, v);
      ir_Context_addStoreInstr(c, var->ir_type, param_refs[i], var->ref);
   }
   ir_generator_Generator_emitStmt(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))));
   if (!ir_Context_isBlockTerminated(c)) {
      ir_Context_addRet0Instr(c);
   }
   ir_Context_endBlock(c);
   ir_Context_endFunc(c);
}

static void ir_generator_on_var_decl(void* arg, ast_VarDecl* vd)
{
   ir_generator_Generator* gen = arg;
   ir_Context* c = gen->ctx;
   ast_Decl* d = ((ast_Decl*)(vd));
   if (!ast_Decl_isUsed(d)) return;

   ast_QualType qt = ast_Decl_getType(d);
   uint32_t gen_idx = ast_Decl_getGenIdx(d);
   if (!gen_idx) {
      gen_idx = ir_Context_addGlobalVar(gen->ctx, ir_generator_Generator_createSymbolName(gen, d), ast_QualType_getAlignment(&qt), ir_generator_Generator_isExternal(gen, d));
      ast_Decl_setGenIdx(d, gen_idx);
   }
   ir_Context_startGlobal(c, gen_idx);
   const ast_Expr* ie = ast_VarDecl_getInit(vd);
   uint32_t size = ast_QualType_getSize(&qt, false);
   if (ie) {
      ir_generator_Generator_emitInit(gen, ie, size);
   } else {
      ir_Context_addInitZero(c, size);
   }
   ir_Context_endGlobal(c);
}

static void ir_generator_on_function_decl(void* arg, ast_FunctionDecl* d)
{
   if (!ast_Decl_isUsed(ast_FunctionDecl_asDecl(d))) return;

   ir_generator_Generator* gen = arg;
   ir_generator_Generator_emitFunction(gen, d);
}

static void ir_generator_Generator_on_ast(void* arg, ast_AST* a)
{
   ast_AST_visitVarDecls(a, ir_generator_on_var_decl, arg);
   ast_AST_visitFunctions(a, ir_generator_on_function_decl, arg);
}

static void ir_generator_Generator_on_module(void* arg, ast_Module* m)
{
   if (!ast_Module_isUsed(m)) return;

   ir_generator_Generator* gen = arg;
   ast_Module_visitASTs(m, ir_generator_Generator_on_ast, arg);
}

static void ir_generator_generate(const char* target, const char* output_dir, component_List* comps, source_mgr_SourceMgr* sm, _Bool enable_asserts, _Bool print)
{
   char ir_dir[512];
   sprintf(ir_dir, "%s/ir", output_dir);
   int32_t err = file_utils_create_directory(ir_dir);
   if (err) {
      console_error("cannot create directory %s: %s", ir_dir, strerror(err));
      return;
   }
   ir_generator_Generator gen;
   ir_generator_Generator_init(&gen, sm, target, ir_dir, enable_asserts, print);
   component_Component* mainComp = component_List_getLast(comps);
   component_Component_visitModules(mainComp, ir_generator_Generator_on_module, &gen);
   if (gen.print) ir_Context_print(gen.ctx);
   ir_generator_Generator_free(&gen);
}

static void ir_generator_Generator_collectLocals(ir_generator_Generator* gen, const ast_FunctionDecl* fd)
{
   ast_VarDecl** fn_params = ast_FunctionDecl_getParams(fd);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ir_gen_locals_Locals_skipSlots(&gen->locals, num_params);
   ir_generator_Generator_collectLocalVars(gen, ((ast_Stmt*)(ast_FunctionDecl_getBody(fd))));
}

static void ir_generator_Generator_addLocalVar(ir_generator_Generator* gen, ast_VarDecl* vd)
{
   ast_QualType qt = ast_Decl_getType(ast_VarDecl_asDecl(vd));
   const ast_StructType* s = ast_QualType_getStructTypeOrNil(&qt);
   uint32_t width;
   uint32_t align;
   if (s) {
      const ast_StructTypeDecl* std = ast_StructType_getDecl(s);
      width = ast_StructTypeDecl_getSize(std);
      align = ast_StructTypeDecl_getAlignment(std);
   } else {
      width = ast_QualType_getAlignment(&qt);
      align = width;
   }
   uint32_t size = ast_QualType_getSize(&qt, false);
   ir_Ref size_ref = ir_Context_addIntegerConstant(gen->ctx, size);
   ir_Ref slot = ir_Context_addStackSlot(gen->ctx, align, size_ref);
   ir_Type ir_type = ir_generator_Generator_type2irtype(gen, qt);
   ir_gen_locals_Locals_add(&gen->locals, vd, width, align, size, slot, ir_type);
   const char* name = ast_Decl_getName(ast_VarDecl_asDecl(vd));
   string_buffer_Buf* out = gen->name_buf;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_print(out, "s%u ", slot.value);
   if (name) string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
   else string_buffer_Buf_add(out, "(unnamed)");
   ir_Context_addComment(gen->ctx, string_buffer_Buf_data(out));
}

static void ir_generator_Generator_collectLocalVars(ir_generator_Generator* gen, ast_Stmt* s)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_If: {
      const ast_IfStmt* if_stmt = ((ast_IfStmt*)(s));
      ir_generator_Generator_collectLocalVars(gen, ast_IfStmt_getCond(if_stmt));
      ast_Stmt* then_stmt = ast_IfStmt_getThen(if_stmt);
      if (then_stmt) ir_generator_Generator_collectLocalVars(gen, then_stmt);
      ast_Stmt* else_stmt = ast_IfStmt_getElse(if_stmt);
      if (else_stmt) ir_generator_Generator_collectLocalVars(gen, else_stmt);
      break;
   }
   case ast_StmtKind_While: {
      const ast_WhileStmt* while_stmt = ((ast_WhileStmt*)(s));
      ir_generator_Generator_collectLocalVars(gen, ast_WhileStmt_getCond(while_stmt));
      ir_generator_Generator_collectLocalVars(gen, ast_WhileStmt_getBody(while_stmt));
      break;
   }
   case ast_StmtKind_For: {
      const ast_ForStmt* for_stmt = ((ast_ForStmt*)(s));
      ast_Stmt* init_stmt = ast_ForStmt_getInit(for_stmt);
      if (init_stmt) ir_generator_Generator_collectLocalVars(gen, init_stmt);
      ast_Stmt* body_stmt = ast_ForStmt_getBody(for_stmt);
      if (body_stmt) ir_generator_Generator_collectLocalVars(gen, body_stmt);
      break;
   }
   case ast_StmtKind_Switch: {
      ast_SwitchStmt* sw = ((ast_SwitchStmt*)(s));
      uint32_t num_cases = ast_SwitchStmt_getNumCases(sw);
      ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
      for (uint32_t i = 0; (i < num_cases); i++) {
         ast_SwitchCase* sc = cases[i];
         uint32_t num_stmts = ast_SwitchCase_getNumStmts(sc);
         ast_Stmt** stmts = ast_SwitchCase_getStmts(sc);
         for (uint32_t j = 0; (j < num_stmts); j++) {
            ir_generator_Generator_collectLocalVars(gen, stmts[j]);
         }
      }
      break;
   }
   case ast_StmtKind_Label: {
      ast_LabelStmt* ls = ((ast_LabelStmt*)(s));
      ir_generator_Generator_collectLocalVars(gen, ast_LabelStmt_getStmt(ls));
      break;
   }
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      const uint32_t num_stmts = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; (i < num_stmts); i++) {
         ir_generator_Generator_collectLocalVars(gen, stmts[i]);
      }
      break;
   }
   case ast_StmtKind_Decl: {
      const ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      if (ast_VarDecl_hasLocalQualifier(vd)) {
         ast_Decl* d = ((ast_Decl*)(vd));
         ir_Ref ref;
         ir_generator_Generator_emitVarDecl(gen, &ref, d);
         ast_QualType qt = ast_Decl_getType(d);
         uint32_t size = ast_QualType_getSize(&qt, false);
         const ast_Expr* ie = ast_VarDecl_getInit(vd);
         ir_Context_startGlobal(gen->ctx, ref.value);
         if (ie) {
            ir_generator_Generator_emitInit(gen, ie, size);
         } else {
            ir_Context_addInitZero(gen->ctx, size);
         }
         ir_Context_endGlobal(gen->ctx);
      } else {
         ir_generator_Generator_addLocalVar(gen, vd);
      }
      break;
   }
   default:
      break;
   }
}

static ir_BlockId ir_generator_Generator_getLabelBlock(ir_generator_Generator* gen, uint32_t label_idx)
{
   ir_BlockId b_id = value_maplist_List_get(&gen->labels, label_idx);
   if (!b_id) {
      b_id = ir_Context_createBlock(gen->ctx, ir_BlockKind_Label);
      value_maplist_List_add(&gen->labels, label_idx, b_id);
   }
   return b_id;
}

static void ir_generator_Generator_emitBinaryOperator(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_Multiply:
      fallthrough;
   case ast_BinaryOpcode_Divide:
      fallthrough;
   case ast_BinaryOpcode_Remainder:
      fallthrough;
   case ast_BinaryOpcode_Add:
      fallthrough;
   case ast_BinaryOpcode_Subtract:
      break;
   case ast_BinaryOpcode_ShiftLeft:
      fallthrough;
   case ast_BinaryOpcode_ShiftRight:
      ir_generator_Generator_emitShift(gen, result, e);
      return;
   case ast_BinaryOpcode_LessThan:
      fallthrough;
   case ast_BinaryOpcode_GreaterThan:
      fallthrough;
   case ast_BinaryOpcode_LessEqual:
      fallthrough;
   case ast_BinaryOpcode_GreaterEqual:
      fallthrough;
   case ast_BinaryOpcode_Equal:
      fallthrough;
   case ast_BinaryOpcode_NotEqual:
      break;
   case ast_BinaryOpcode_And:
      fallthrough;
   case ast_BinaryOpcode_Xor:
      fallthrough;
   case ast_BinaryOpcode_Or:
      break;
   case ast_BinaryOpcode_LAnd:
      ir_generator_Generator_emitLogicalAnd(gen, result, e);
      return;
   case ast_BinaryOpcode_LOr:
      ir_generator_Generator_emitLogicalOr(gen, result, e);
      return;
   case ast_BinaryOpcode_Assign: {
      ir_Ref src;
      ir_generator_Generator_emitExpr(gen, &src, ast_BinaryOperator_getRHS(b));
      ir_Ref dest;
      ir_generator_Generator_emitExpr(gen, &dest, ast_BinaryOperator_getLHS(b));
      ir_Context_addStoreInstr(gen->ctx, ir_Type_I32, src, dest);
      *result = src;
      return;
   }
   case ast_BinaryOpcode_MulAssign:
      fallthrough;
   case ast_BinaryOpcode_DivAssign:
      fallthrough;
   case ast_BinaryOpcode_RemAssign:
      fallthrough;
   case ast_BinaryOpcode_AddAssign:
      fallthrough;
   case ast_BinaryOpcode_SubAssign:
      fallthrough;
   case ast_BinaryOpcode_ShlAssign:
      fallthrough;
   case ast_BinaryOpcode_ShrAssign:
      fallthrough;
   case ast_BinaryOpcode_AndAssign:
      fallthrough;
   case ast_BinaryOpcode_XorAssign:
      fallthrough;
   case ast_BinaryOpcode_OrAssign:
      ir_generator_Generator_emitOpAssign(gen, result, e);
      return;
   }
   ir_InstrKind kind = ir_InstrKind_None;
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_Multiply:
      kind = ir_InstrKind_Mul;
      break;
   case ast_BinaryOpcode_Divide:
      kind = ir_InstrKind_IDiv;
      break;
   case ast_BinaryOpcode_Remainder:
      kind = ir_InstrKind_Rem;
      break;
   case ast_BinaryOpcode_Add:
      kind = ir_InstrKind_Add;
      break;
   case ast_BinaryOpcode_Subtract:
      kind = ir_InstrKind_Sub;
      break;
   case ast_BinaryOpcode_LessThan:
      kind = ir_InstrKind_CmpLt;
      break;
   case ast_BinaryOpcode_GreaterThan:
      kind = ir_InstrKind_CmpGt;
      break;
   case ast_BinaryOpcode_LessEqual:
      kind = ir_InstrKind_CmpLe;
      break;
   case ast_BinaryOpcode_GreaterEqual:
      kind = ir_InstrKind_CmpGe;
      break;
   case ast_BinaryOpcode_Equal:
      kind = ir_InstrKind_CmpEq;
      break;
   case ast_BinaryOpcode_NotEqual:
      kind = ir_InstrKind_CmpNe;
      break;
   case ast_BinaryOpcode_And:
      kind = ir_InstrKind_And;
      break;
   case ast_BinaryOpcode_Xor:
      kind = ir_InstrKind_Xor;
      break;
   case ast_BinaryOpcode_Or:
      kind = ir_InstrKind_Or;
      break;
   default:
      (0) || c2_assert("generator/ir/ir_generator_binop.c2", 123, "ir_generator.Generator.emitBinaryOperator", "0");
      break;
   }
   ((kind != ir_InstrKind_None)) || c2_assert("generator/ir/ir_generator_binop.c2", 126, "ir_generator.Generator.emitBinaryOperator", "kind != InstrKind.None");
   ir_Ref left;
   ir_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   ir_Ref right;
   ir_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   *result = ir_Context_addBinaryInstr(gen->ctx, kind, left, right);
}

static void ir_generator_Generator_emitLogicalAnd(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ir_Context* c = gen->ctx;
   ir_Ref left;
   ir_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   ir_Ref zero;
   ir_Ref_init(&zero, ir_RefKind_Value, 0);
   ir_Ref cond1 = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, left, zero);
   ir_BlockId true_blk = ir_Context_createBlock(c, ir_BlockKind_AndTrue);
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_LogicJoin);
   ir_Context_addJmpIfInstr(c, cond1, true_blk, join_blk);
   ir_BlockId block1 = ir_Context_getCurBlock(c);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, true_blk);
   ir_Ref right;
   ir_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   ir_Ref cond2 = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, right, zero);
   ir_Context_addJmpInstr(c, join_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, join_blk);
   *result = ir_Context_addPhi2Instr(gen->ctx, block1, zero, true_blk, cond2);
}

static void ir_generator_Generator_emitLogicalOr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ir_Context* c = gen->ctx;
   ir_Ref left;
   ir_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   ir_Ref zero;
   ir_Ref_init(&zero, ir_RefKind_Value, 0);
   ir_Ref cond1 = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, left, zero);
   ir_BlockId false_blk = ir_Context_createBlock(c, ir_BlockKind_OrFalse);
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_LogicJoin);
   ir_Context_addJmpIfInstr(c, cond1, join_blk, false_blk);
   ir_BlockId block1 = ir_Context_getCurBlock(c);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, false_blk);
   ir_Ref right;
   ir_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   ir_Ref cond2 = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, right, zero);
   ir_Context_addJmpInstr(c, join_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, join_blk);
   ir_Ref one;
   ir_Ref_init(&one, ir_RefKind_Value, 1);
   *result = ir_Context_addPhi2Instr(gen->ctx, block1, one, false_blk, cond2);
}

static void ir_generator_Generator_emitShift(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ir_InstrKind k;
   if ((ast_BinaryOperator_getOpcode(b) == ast_BinaryOpcode_ShiftLeft)) {
      k = ir_InstrKind_Shl;
   } else {
      k = ir_InstrKind_Shr;
   }
   ir_Ref left;
   ir_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   ir_Ref right;
   ir_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   *result = ir_Context_addBinaryInstr(gen->ctx, k, left, right);
}

static void ir_generator_Generator_emitOpAssign(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ir_InstrKind k = ir_InstrKind_None;
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_MulAssign:
      k = ir_InstrKind_Mul;
      break;
   case ast_BinaryOpcode_DivAssign:
      k = ir_InstrKind_Div;
      break;
   case ast_BinaryOpcode_RemAssign:
      k = ir_InstrKind_Rem;
      break;
   case ast_BinaryOpcode_AddAssign:
      k = ir_InstrKind_Add;
      break;
   case ast_BinaryOpcode_SubAssign:
      k = ir_InstrKind_Sub;
      break;
   case ast_BinaryOpcode_ShlAssign:
      k = ir_InstrKind_Shl;
      break;
   case ast_BinaryOpcode_ShrAssign:
      k = ir_InstrKind_Shr;
      break;
   case ast_BinaryOpcode_AndAssign:
      k = ir_InstrKind_And;
      break;
   case ast_BinaryOpcode_XorAssign:
      k = ir_InstrKind_Xor;
      break;
   case ast_BinaryOpcode_OrAssign:
      k = ir_InstrKind_Or;
      break;
   default:
      (0) || c2_assert("generator/ir/ir_generator_binop.c2", 301, "ir_generator.Generator.emitOpAssign", "0");
      return;
   }
   ((k != ir_InstrKind_None)) || c2_assert("generator/ir/ir_generator_binop.c2", 304, "ir_generator.Generator.emitOpAssign", "k != InstrKind.None");
   ir_Ref right;
   ir_generator_Generator_emitExpr(gen, &right, ast_BinaryOperator_getRHS(b));
   ir_Ref left;
   ir_generator_Generator_emitExpr(gen, &left, ast_BinaryOperator_getLHS(b));
   ir_Type t = ir_Type_I32;
   ir_Ref left_val = ir_Context_addLoadInstr(gen->ctx, t, left);
   right = ir_Context_addBinaryInstr(gen->ctx, k, left_val, right);
   ir_Context_addStoreInstr(gen->ctx, t, right, left);
   *result = right;
}

static void ir_generator_Generator_emitCallExpr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   ast_CallExpr* call = ((ast_CallExpr*)(e));
   ir_Context* c = gen->ctx;
   uint32_t num_args = ast_CallExpr_getNumArgs(call);
   ast_Expr** args = ast_CallExpr_getArgs(call);
   ast_QualType qt = ast_Expr_getType(e);
   _Bool has_result = !ast_QualType_isVoid(&qt);
   _Bool is_tf = ast_CallExpr_isTypeFunc(call);
   ir_RefList* arg_refs = ref_list_pool_Pool_get(&gen->ref_pool);
   ir_Ref name_ref;
   if (is_tf) {
      ast_Expr* func = ast_CallExpr_getFunc(call);
      ir_Ref ref;
      ir_generator_Generator_emitMemberExpr(gen, &ref, func);
      ir_RefList_add(arg_refs, ref);
      const ast_MemberExpr* m = ((ast_MemberExpr*)(func));
      ir_generator_Generator_emitSymbol(gen, &name_ref, ast_MemberExpr_getFullDecl(m));
   } else {
      ir_generator_Generator_emitExpr(gen, &name_ref, ast_CallExpr_getFunc(call));
   }
   for (uint32_t i = 0; (i < num_args); i++) {
      ir_Ref ref;
      ir_generator_Generator_emitExpr(gen, &ref, args[i]);
      ir_RefList_add(arg_refs, ref);
   }
   if ((ir_RefList_getCount(arg_refs) != 0)) {
      ir_Ref ref;
      ir_Ref_init(&ref, ir_RefKind_None, 0);
      ir_RefList_add(arg_refs, ref);
   }
   ir_Ref args_ref;
   if ((ir_RefList_getCount(arg_refs) == 0)) {
      ir_Ref_init(&args_ref, ir_RefKind_None, 0);
   } else {
      uint32_t idx = ir_Context_addCallArgs(c, arg_refs);
      ir_Ref_init(&args_ref, ir_RefKind_RefList, idx);
   }
   ref_list_pool_Pool_put(&gen->ref_pool, arg_refs);
   *result = ir_Context_addCallInstr(c, name_ref, args_ref, has_result, ast_CallExpr_isNoreturn(call));
}

static void ir_generator_Generator_emitExpr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ctv_analyser_get_value(e);
      *result = ir_Context_addIntegerConstant(gen->ctx, ast_Value_as_u32(&v));
      return;
   }
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 52, "ir_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_StringLiteral: {
      ast_StringLiteral* s = ((ast_StringLiteral*)(e));
      ir_SymbolId id = ir_Context_addStringLiteral(gen->ctx, ir_generator_Generator_createStringVar(gen), ast_StringLiteral_getText(s), ast_StringLiteral_getSize(s));
      ir_Ref ref;
      ir_Ref_init(&ref, ir_RefKind_Symbol, id);
      *result = ref;
      break;
   }
   case ast_ExprKind_Nil:
      ir_Ref_init(result, ir_RefKind_Value, 0);
      break;
   case ast_ExprKind_Identifier:
      ir_generator_Generator_emitIdentifier(gen, result, e);
      break;
   case ast_ExprKind_Type:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 69, "ir_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_Call:
      ir_generator_Generator_emitCallExpr(gen, result, e);
      break;
   case ast_ExprKind_InitList:
      ir_Ref_init(result, ir_RefKind_Value, 0);
      break;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 79, "ir_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_BinaryOperator:
      ir_generator_Generator_emitBinaryOperator(gen, result, e);
      break;
   case ast_ExprKind_UnaryOperator:
      ir_generator_Generator_emitUnaryOperator(gen, result, e);
      break;
   case ast_ExprKind_ConditionalOperator:
      ir_generator_Generator_emitCondOperator(gen, result, e);
      break;
   case ast_ExprKind_Builtin:
      ir_generator_Generator_emitBuiltin(gen, result, e);
      break;
   case ast_ExprKind_ArraySubscript:
      ir_generator_Generator_emitArraySubscript(gen, result, e);
      break;
   case ast_ExprKind_Member:
      ir_generator_Generator_emitMemberExpr(gen, result, e);
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      ir_generator_Generator_emitExpr(gen, result, ast_ParenExpr_getInner(p));
      break;
   }
   case ast_ExprKind_BitOffset:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 104, "ir_generator.Generator.emitExpr", "0");
      break;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* ec = ((ast_ExplicitCastExpr*)(e));
      ir_generator_Generator_emitExpr(gen, result, ast_ExplicitCastExpr_getInner(ec));
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* ic = ((ast_ImplicitCastExpr*)(e));
      switch (ast_ImplicitCastExpr_getKind(ic)) {
      case ast_ImplicitCastKind_ArrayToPointerDecay:
         ir_generator_Generator_emitExpr(gen, result, ast_ImplicitCastExpr_getInner(ic));
         break;
      case ast_ImplicitCastKind_LValueToRValue: {
         ir_Ref src;
         ir_generator_Generator_emitExpr(gen, &src, ast_ImplicitCastExpr_getInner(ic));
         *result = ir_Context_addLoadInstr(gen->ctx, ir_Type_I32, src);
         break;
      }
      case ast_ImplicitCastKind_PointerToBoolean:
         ir_generator_Generator_emitExpr(gen, result, ast_ImplicitCastExpr_getInner(ic));
         break;
      case ast_ImplicitCastKind_PointerToInteger:
         (0) || c2_assert("generator/ir/ir_generator_expr.c2", 129, "ir_generator.Generator.emitExpr", "0");
         break;
      case ast_ImplicitCastKind_IntegralCast:
         ir_generator_Generator_emitExpr(gen, result, ast_ImplicitCastExpr_getInner(ic));
         break;
      case ast_ImplicitCastKind_BitCast:
         (0) || c2_assert("generator/ir/ir_generator_expr.c2", 136, "ir_generator.Generator.emitExpr", "0");
         break;
      }
      break;
   }
   case ast_ExprKind_Range:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 141, "ir_generator.Generator.emitExpr", "0");
      break;
   }
}

static void ir_generator_Generator_emitIdentifier(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   ast_IdentifierExpr* i = ((ast_IdentifierExpr*)(e));
   switch (ast_IdentifierExpr_getKind(i)) {
   case ast_IdentifierKind_Unresolved:
      fallthrough;
   case ast_IdentifierKind_Module:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 152, "ir_generator.Generator.emitIdentifier", "0");
      break;
   case ast_IdentifierKind_Function:
      ir_generator_Generator_emitSymbol(gen, result, ast_IdentifierExpr_getDecl(i));
      break;
   case ast_IdentifierKind_Type:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 158, "ir_generator.Generator.emitIdentifier", "0");
      break;
   case ast_IdentifierKind_Var:
      ir_generator_Generator_emitVarDecl(gen, result, ast_IdentifierExpr_getDecl(i));
      break;
   case ast_IdentifierKind_EnumConstant:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 164, "ir_generator.Generator.emitIdentifier", "0");
      break;
   case ast_IdentifierKind_StructMember:
      fallthrough;
   case ast_IdentifierKind_Label:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 168, "ir_generator.Generator.emitIdentifier", "0");
      break;
   }
}

static void ir_generator_Generator_emitSymbol(ir_generator_Generator* gen, ir_Ref* result, ast_Decl* d)
{
   ir_SymbolId sid = ir_generator_Generator_createSymbol(gen, d);
   ir_Ref ref;
   ir_Ref_init(&ref, ir_RefKind_Symbol, sid);
   *result = ref;
}

static void ir_generator_Generator_emitVarDecl(ir_generator_Generator* gen, ir_Ref* result, ast_Decl* d)
{
   const ast_VarDecl* vd = ((ast_VarDecl*)(d));
   if (ast_VarDecl_isGlobal(vd)) {
      ir_generator_Generator_emitSymbol(gen, result, d);
   } else if (ast_VarDecl_hasLocalQualifier(vd)) {
      uint32_t gen_idx = ast_Decl_getGenIdx(d);
      if (!gen_idx) {
         ast_QualType qt = ast_Decl_getType(d);
         gen_idx = ir_Context_addGlobalVar(gen->ctx, ir_generator_Generator_createLocalName(gen, d), ast_QualType_getAlignment(&qt), ir_generator_Generator_isExternal(gen, d));
         ast_Decl_setGenIdx(d, gen_idx);
      }
      ir_Ref ref;
      ir_Ref_init(&ref, ir_RefKind_Symbol, gen_idx);
      *result = ref;
   } else if ((ast_VarDecl_isLocal(vd) || ast_VarDecl_isParameter(vd))) {
      ir_gen_locals_StackVar* var = ir_gen_locals_Locals_find(&gen->locals, vd);
      *result = var->ref;
   } else {
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 198, "ir_generator.Generator.emitVarDecl", "0");
   }


}

static void ir_generator_Generator_emitCondOperator(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   ir_Context* c = gen->ctx;
   const ast_ConditionalOperator* co = ((ast_ConditionalOperator*)(e));
   ir_BlockId then_blk = ir_Context_createBlock(c, ir_BlockKind_CondTrue);
   ir_BlockId else_blk = ir_Context_createBlock(c, ir_BlockKind_CondFalse);
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_CondJoin);
   ir_generator_Generator_emitCond(gen, ast_ConditionalOperator_getCond(co), then_blk, else_blk, then_blk);
   ir_Ref ref1;
   ir_generator_Generator_emitExpr(gen, &ref1, ast_ConditionalOperator_getLHS(co));
   if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, join_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, else_blk);
   ir_Ref ref2;
   ir_generator_Generator_emitExpr(gen, &ref2, ast_ConditionalOperator_getRHS(co));
   if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, join_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, join_blk);
   *result = ir_Context_addPhi2Instr(gen->ctx, then_blk, ref1, else_blk, ref2);
}

static void ir_generator_Generator_emitUnaryOperator(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_UnaryOperator* uo = ((ast_UnaryOperator*)(e));
   switch (ast_UnaryOperator_getOpcode(uo)) {
   case ast_UnaryOpcode_PostInc:
      fallthrough;
   case ast_UnaryOpcode_PostDec:
      fallthrough;
   case ast_UnaryOpcode_PreInc:
      fallthrough;
   case ast_UnaryOpcode_PreDec: {
      ir_Ref left;
      ir_generator_Generator_emitExpr(gen, &left, ast_UnaryOperator_getInner(uo));
      ir_Type t = ir_Type_I32;
      ir_Ref left_val = ir_Context_addLoadInstr(gen->ctx, t, left);
      ir_Ref value;
      ir_Ref_init(&value, ir_RefKind_Value, 1);
      ir_InstrKind k;
      if (((ast_UnaryOperator_getOpcode(uo) == ast_UnaryOpcode_PostInc) || (ast_UnaryOperator_getOpcode(uo) == ast_UnaryOpcode_PreInc))) {
         k = ir_InstrKind_Add;
      } else {
         k = ir_InstrKind_Sub;
      }
      ir_Ref right = ir_Context_addBinaryInstr(gen->ctx, k, left_val, value);
      ir_Context_addStoreInstr(gen->ctx, t, right, left);
      if ((ast_UnaryOperator_getOpcode(uo) <= ast_UnaryOpcode_PostDec)) {
         *result = left_val;
      } else {
         *result = right;
      }
      break;
   }
   case ast_UnaryOpcode_AddrOf:
      fallthrough;
   case ast_UnaryOpcode_Deref:
      ir_generator_Generator_emitExpr(gen, result, ast_UnaryOperator_getInner(uo));
      break;
   case ast_UnaryOpcode_Plus:
      (!ast_Expr_isCtv(e)) || c2_assert("generator/ir/ir_generator_expr.c2", 274, "ir_generator.Generator.emitUnaryOperator", "!e.isCtv()");
      ir_generator_Generator_emitExpr(gen, result, ast_UnaryOperator_getInner(uo));
      break;
   case ast_UnaryOpcode_Minus: {
      (!ast_Expr_isCtv(e)) || c2_assert("generator/ir/ir_generator_expr.c2", 279, "ir_generator.Generator.emitUnaryOperator", "!e.isCtv()");
      ir_Ref left;
      ir_Ref_init(&left, ir_RefKind_Value, 0);
      ir_Ref right;
      ir_generator_Generator_emitExpr(gen, &right, ast_UnaryOperator_getInner(uo));
      *result = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Sub, left, right);
      break;
   }
   case ast_UnaryOpcode_Not: {
      ir_Ref lhs;
      ir_generator_Generator_emitExpr(gen, &lhs, ast_UnaryOperator_getInner(uo));
      ir_Ref rhs = ir_Context_addIntegerConstant(gen->ctx, -1);
      *result = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Xor, lhs, rhs);
      break;
   }
   case ast_UnaryOpcode_LNot: {
      ir_Ref lhs;
      ir_generator_Generator_emitExpr(gen, &lhs, ast_UnaryOperator_getInner(uo));
      ir_Ref zero;
      ir_Ref_init(&zero, ir_RefKind_Value, 0);
      ir_Ref rhs = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, lhs, zero);
      ir_Ref one;
      ir_Ref_init(&one, ir_RefKind_Value, 1);
      rhs = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Xor, rhs, one);
      *result = rhs;
      break;
   }
   }
}

static void ir_generator_Generator_emitCond(ir_generator_Generator* gen, const ast_Expr* e, ir_BlockId true_blk, ir_BlockId false_blk, ir_BlockId start_blk)
{
   ir_Context* c = gen->ctx;
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ctv_analyser_get_value(e);
      if (ast_Value_isZero(&v)) {
         ir_Context_addJmpInstr(c, false_blk);
      } else {
         ir_Context_addJmpInstr(c, true_blk);
      }
      ir_Context_endBlock(c);
      ir_Context_startBlock(c, start_blk);
      return;
   }
   ir_Ref ref;
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      fallthrough;
   case ast_ExprKind_FloatLiteral:
      fallthrough;
   case ast_ExprKind_BooleanLiteral:
      fallthrough;
   case ast_ExprKind_CharLiteral:
      fallthrough;
   case ast_ExprKind_StringLiteral:
      fallthrough;
   case ast_ExprKind_Nil:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 340, "ir_generator.Generator.emitCond", "0");
      break;
   case ast_ExprKind_Identifier:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 343, "ir_generator.Generator.emitCond", "0");
      break;
   case ast_ExprKind_Type:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 346, "ir_generator.Generator.emitCond", "0");
      break;
   case ast_ExprKind_Call:
      break;
   case ast_ExprKind_InitList:
      fallthrough;
   case ast_ExprKind_FieldDesignatedInit:
      fallthrough;
   case ast_ExprKind_ArrayDesignatedInit:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 353, "ir_generator.Generator.emitCond", "0");
      break;
   case ast_ExprKind_BinaryOperator:
      if (ir_generator_Generator_emitBinaryCond(gen, e, true_blk, false_blk, start_blk)) return;

      break;
   case ast_ExprKind_UnaryOperator:
      break;
   case ast_ExprKind_ConditionalOperator:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 361, "ir_generator.Generator.emitCond", "0");
      break;
   case ast_ExprKind_Builtin:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 364, "ir_generator.Generator.emitCond", "0");
      break;
   case ast_ExprKind_ArraySubscript:
      fallthrough;
   case ast_ExprKind_Member:
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = ((ast_ParenExpr*)(e));
      ir_generator_Generator_emitCond(gen, ast_ParenExpr_getInner(p), true_blk, false_blk, start_blk);
      return;
   }
   case ast_ExprKind_BitOffset:
      fallthrough;
   case ast_ExprKind_ExplicitCast:
      fallthrough;
   case ast_ExprKind_ImplicitCast:
      break;
   case ast_ExprKind_Range:
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 378, "ir_generator.Generator.emitCond", "0");
      break;
   }
   ir_generator_Generator_emitExpr(gen, &ref, e);
   ir_Ref zero;
   ir_Ref_init(&zero, ir_RefKind_Value, 0);
   ir_Ref cond = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, ref, zero);
   ir_Context_addJmpIfInstr(c, cond, true_blk, false_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, start_blk);
}

static void ir_generator_Generator_emitAssignCond(ir_generator_Generator* gen, ir_Type t, ir_Ref lhs, ir_Ref rhs, ir_BlockId left, ir_BlockId right, ir_BlockId start)
{
   ir_Context* c = gen->ctx;
   ir_Context_addStoreInstr(c, t, rhs, lhs);
   ir_Ref zero;
   ir_Ref_init(&zero, ir_RefKind_Value, 0);
   ir_Ref cond = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_CmpNe, rhs, zero);
   ir_Context_addJmpIfInstr(c, cond, left, right);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, start);
}

static _Bool ir_generator_Generator_emitBinaryCond(ir_generator_Generator* gen, const ast_Expr* e, ir_BlockId left, ir_BlockId right, ir_BlockId start)
{
   const ast_BinaryOperator* b = ((ast_BinaryOperator*)(e));
   ir_InstrKind k;
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_LessThan:
      k = ir_InstrKind_CmpLt;
      break;
   case ast_BinaryOpcode_GreaterThan:
      k = ir_InstrKind_CmpGt;
      break;
   case ast_BinaryOpcode_LessEqual:
      k = ir_InstrKind_CmpLe;
      break;
   case ast_BinaryOpcode_GreaterEqual:
      k = ir_InstrKind_CmpGe;
      break;
   case ast_BinaryOpcode_Equal:
      k = ir_InstrKind_CmpEq;
      break;
   case ast_BinaryOpcode_NotEqual:
      k = ir_InstrKind_CmpNe;
      break;
   case ast_BinaryOpcode_LAnd:
      ir_generator_Generator_emitAndCond(gen, b, left, right);
      return true;
   case ast_BinaryOpcode_LOr:
      ir_generator_Generator_emitOrCond(gen, b, left, right, start);
      return true;
   case ast_BinaryOpcode_Assign: {
      ir_Ref rhs;
      ir_generator_Generator_emitExpr(gen, &rhs, ast_BinaryOperator_getRHS(b));
      ir_Ref lhs;
      ir_generator_Generator_emitExpr(gen, &lhs, ast_BinaryOperator_getLHS(b));
      ir_Type t = ir_Type_I32;
      ir_generator_Generator_emitAssignCond(gen, t, lhs, rhs, left, right, start);
      return true;
   }
   default:
      return false;
   }
   ir_Ref lhs;
   ir_generator_Generator_emitExpr(gen, &lhs, ast_BinaryOperator_getLHS(b));
   ir_Ref rhs;
   ir_generator_Generator_emitExpr(gen, &rhs, ast_BinaryOperator_getRHS(b));
   ir_Ref cond = ir_Context_addBinaryInstr(gen->ctx, k, lhs, rhs);
   ir_Context* c = gen->ctx;
   ir_Context_addJmpIfInstr(c, cond, left, right);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, start);
   return true;
}

static void ir_generator_Generator_emitAndCond(ir_generator_Generator* gen, const ast_BinaryOperator* b, ir_BlockId true_blk, ir_BlockId false_blk)
{
   ir_BlockId and_true = ir_Context_createBlock(gen->ctx, ir_BlockKind_AndTrue);
   ir_generator_Generator_emitCond(gen, ast_BinaryOperator_getLHS(b), and_true, false_blk, and_true);
   ir_generator_Generator_emitCond(gen, ast_BinaryOperator_getRHS(b), true_blk, false_blk, true_blk);
}

static void ir_generator_Generator_emitOrCond(ir_generator_Generator* gen, const ast_BinaryOperator* b, ir_BlockId true_blk, ir_BlockId false_blk, ir_BlockId start_blk)
{
   ir_BlockId or_false = ir_Context_createBlock(gen->ctx, ir_BlockKind_OrFalse);
   ir_generator_Generator_emitCond(gen, ast_BinaryOperator_getLHS(b), true_blk, or_false, or_false);
   ir_generator_Generator_emitCond(gen, ast_BinaryOperator_getRHS(b), true_blk, false_blk, start_blk);
}

static void ir_generator_Generator_emitBuiltin(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_BuiltinExpr* bi = ((ast_BuiltinExpr*)(e));
   switch (ast_BuiltinExpr_getKind(bi)) {
   case ast_BuiltinExprKind_Sizeof:
      fallthrough;
   case ast_BuiltinExprKind_Elemsof:
      fallthrough;
   case ast_BuiltinExprKind_EnumMin:
      fallthrough;
   case ast_BuiltinExprKind_EnumMax:
      fallthrough;
   case ast_BuiltinExprKind_OffsetOf:
      ast_Expr_dump(e);
      (0) || c2_assert("generator/ir/ir_generator_expr.c2", 485, "ir_generator.Generator.emitBuiltin", "0");
      break;
   case ast_BuiltinExprKind_ToContainer:
      {
         ir_Ref ptr_ref;
         ir_generator_Generator_emitExpr(gen, &ptr_ref, ast_BuiltinExpr_getToContainerPointer(bi));
         ast_Value v = ast_BuiltinExpr_getValue(bi);
         uint32_t offset = ast_Value_as_u32(&v);
         if ((offset == 0)) {
            *result = ptr_ref;
         } else {
            ir_Ref offset_ref = ir_Context_addIntegerConstant(gen->ctx, offset);
            *result = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Sub, ptr_ref, offset_ref);
         }
         break;
      }
   }
}

static void ir_generator_Generator_emitArraySubscript(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_ArraySubscriptExpr* a = ((ast_ArraySubscriptExpr*)(e));
   ast_Expr* base = ast_ArraySubscriptExpr_getBase(a);
   ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
   ast_QualType qt = ast_Expr_getType(base);
   uint32_t base_size = ast_QualType_getSize(&qt, true);
   if (ast_Expr_isCtv(index)) {
      ir_Ref base_ref;
      ir_generator_Generator_emitExpr(gen, &base_ref, base);
      ast_Value v = ctv_analyser_get_value(index);
      uint32_t offset = (ast_Value_as_u32(&v) * base_size);
      if ((offset == 0)) {
         *result = base_ref;
      } else {
         ir_Ref offset_ref = ir_Context_addIntegerConstant(gen->ctx, offset);
         *result = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Add, base_ref, offset_ref);
      }
   } else {
      ir_Ref base_ref;
      ir_generator_Generator_emitExpr(gen, &base_ref, base);
      ir_Ref idx_ref;
      ir_generator_Generator_emitExpr(gen, &idx_ref, index);
      if ((base_size == 1)) {
         *result = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Add, base_ref, idx_ref);
      } else {
         ir_Ref size_ref = ir_Context_addIntegerConstant(gen->ctx, base_size);
         ir_Ref offset_ref = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Mul, idx_ref, size_ref);
         *result = ir_Context_addBinaryInstr(gen->ctx, ir_InstrKind_Add, base_ref, offset_ref);
      }
   }
}

static void ir_generator_Generator_emitMemberExpr(ir_generator_Generator* gen, ir_Ref* result, const ast_Expr* e)
{
   const ast_MemberExpr* m = ((ast_MemberExpr*)(e));
   ir_Context* c = gen->ctx;
   uint32_t tail = 0;
   ast_IdentifierKind kind = ast_MemberExpr_getKind(m);
   if (((kind == ast_IdentifierKind_Var) || (kind == ast_IdentifierKind_Function))) {
      if (ast_MemberExpr_isTypeFunc(m)) {
         tail = 1;
         goto next;
      }
      if (ast_MemberExpr_hasExpr(m)) {
         goto next;
      }
      (!ast_MemberExpr_hasExpr(m)) || c2_assert("generator/ir/ir_generator_expr.c2", 563, "ir_generator.Generator.emitMemberExpr", "!m.hasExpr()");
      ast_Decl* d = ast_MemberExpr_getFullDecl(m);
      ir_generator_Generator_emitSymbol(gen, result, d);
      return;
   }
   ((kind == ast_IdentifierKind_StructMember)) || c2_assert("generator/ir/ir_generator_expr.c2", 569, "ir_generator.Generator.emitMemberExpr", "kind == IdentifierKind.StructMember");
   next:
   {
   }
   ir_Ref base_ref;
   ast_QualType base_type;
   uint32_t idx = 0;
   if (ast_MemberExpr_hasExpr(m)) {
      const ast_Expr* base = ast_MemberExpr_getExprBase(m);
      ir_generator_Generator_emitExpr(gen, &base_ref, base);
      base_type = ast_Expr_getType(base);
   } else {
      ast_Decl* base = ast_MemberExpr_getDecl(m, idx);
      if (ast_Decl_isImport(base)) {
         idx++;
         base = ast_MemberExpr_getDecl(m, idx);
      }
      idx++;
      (ast_Decl_isVarDecl(base)) || c2_assert("generator/ir/ir_generator_expr.c2", 601, "ir_generator.Generator.emitMemberExpr", "base.isVarDecl()");
      ir_generator_Generator_emitVarDecl(gen, &base_ref, base);
      base_type = ast_Decl_getType(base);
   }
   uint32_t numrefs = ast_MemberExpr_getNumRefs(m);
   numrefs -= tail;
   for (uint32_t i = idx; (i < numrefs); i++) {
      if (ast_QualType_isPointer(&base_type)) {
         base_ref = ir_Context_addLoadInstr(c, ir_Type_I32, base_ref);
         base_type = ast_QualType_getPointerBaseType(&base_type);
      }
      (ast_QualType_isStruct(&base_type)) || c2_assert("generator/ir/ir_generator_expr.c2", 615, "ir_generator.Generator.emitMemberExpr", "base_type.isStruct()");
      const ast_StructType* st = ast_QualType_getStructType(&base_type);
      const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
      ast_Decl* d = ast_MemberExpr_getDecl(m, i);
      uint32_t offset = 0;
      ast_Decl* dd = ast_StructTypeDecl_findMember(std, ast_Decl_getNameIdx(d), &offset);
      if (!dd) {
         ast_Expr_dump(e);
      }
      (dd) || c2_assert("generator/ir/ir_generator_expr.c2", 626, "ir_generator.Generator.emitMemberExpr", "dd");
      if ((offset != 0)) {
         ir_Ref offset_ref = ir_Context_addIntegerConstant(c, offset);
         base_ref = ir_Context_addBinaryInstr(c, ir_InstrKind_Add, base_ref, offset_ref);
      }
      base_type = ast_Decl_getType(d);
   }
   *result = base_ref;
}

static _Bool ir_generator_Generator_emitStmt(ir_generator_Generator* gen, const ast_Stmt* s)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      const ast_ReturnStmt* r = ((ast_ReturnStmt*)(s));
      const ast_Expr* retval = ast_ReturnStmt_getValue(r);
      if (retval) {
         ir_Ref ref;
         ir_generator_Generator_emitExpr(gen, &ref, retval);
         ir_Context_addRet1Instr(gen->ctx, ref);
      } else {
         ir_Context_addRet0Instr(gen->ctx);
      }
      return false;
   }
   case ast_StmtKind_Expr: {
      ir_Ref dontcare;
      ir_generator_Generator_emitExpr(gen, &dontcare, ((ast_Expr*)(s)));
      return true;
   }
   case ast_StmtKind_If:
      ir_generator_Generator_emitIfStmt(gen, s);
      return true;
   case ast_StmtKind_While:
      ir_generator_Generator_emitWhileStmt(gen, s);
      return true;
   case ast_StmtKind_For:
      ir_generator_Generator_emitForStmt(gen, s);
      return true;
   case ast_StmtKind_Switch:
      ir_generator_Generator_emitSwitchStmt(gen, s);
      return true;
   case ast_StmtKind_Break:
      (gen->num_scopes) || c2_assert("generator/ir/ir_generator_stmt.c2", 53, "ir_generator.Generator.emitStmt", "gen.num_scopes");
      ir_Context_addJmpInstr(gen->ctx, gen->scopes[(gen->num_scopes - 1)].break_block);
      return false;
   case ast_StmtKind_Continue:
      (gen->num_scopes) || c2_assert("generator/ir/ir_generator_stmt.c2", 57, "ir_generator.Generator.emitStmt", "gen.num_scopes");
      ir_Context_addJmpInstr(gen->ctx, gen->scopes[(gen->num_scopes - 1)].continue_block);
      return false;
   case ast_StmtKind_Fallthrough:
      return false;
   case ast_StmtKind_Label: {
      const ast_LabelStmt* l = ((ast_LabelStmt*)(s));
      ir_Context* c = gen->ctx;
      if (ast_LabelStmt_isUsed(l)) {
         ir_BlockId label_blk = ir_generator_Generator_getLabelBlock(gen, ast_LabelStmt_getNameIdx(l));
         if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, label_blk);
         ir_Context_endBlock(c);
         ir_Context_startBlock(c, label_blk);
         string_buffer_Buf_clear(gen->name_buf);
         string_buffer_Buf_add(gen->name_buf, ast_LabelStmt_getName(l));
         ir_Context_addComment(c, string_buffer_Buf_data(gen->name_buf));
      }
      const ast_Stmt* ls = ast_LabelStmt_getStmt(l);
      (ls) || c2_assert("generator/ir/ir_generator_stmt.c2", 80, "ir_generator.Generator.emitStmt", "ls");
      return ir_generator_Generator_emitStmt(gen, ls);
   }
   case ast_StmtKind_Goto: {
      const ast_GotoStmt* g = ((ast_GotoStmt*)(s));
      ir_BlockId label_blk = ir_generator_Generator_getLabelBlock(gen, ast_GotoStmt_getNameIdx(g));
      ir_Context_addJmpInstr(gen->ctx, label_blk);
      return false;
   }
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = ((ast_CompoundStmt*)(s));
      const uint32_t num_stmts = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; (i < num_stmts); i++) {
         _Bool reachable = ir_generator_Generator_emitStmt(gen, stmts[i]);
         if (!reachable) {
            i++;
            while ((i < num_stmts)) {
               ast_Stmt* s2 = stmts[i];
               if (ast_Stmt_isLabel(s2)) {
                  const ast_LabelStmt* l = ((ast_LabelStmt*)(s2));
                  if (ast_LabelStmt_isUsed(l)) {
                     i--;
                     break;
                  }
               }
               i++;
            }
         }
      }
      return true;
   }
   case ast_StmtKind_Decl: {
      const ast_DeclStmt* ds = ((ast_DeclStmt*)(s));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      if (ast_VarDecl_hasLocalQualifier(vd)) return true;

      const ast_Expr* ie = ast_VarDecl_getInit(vd);
      if (ie) {
         ir_gen_locals_StackVar* var = ir_gen_locals_Locals_find(&gen->locals, vd);
         ir_Ref res;
         ir_generator_Generator_emitExpr(gen, &res, ie);
         if (!ast_VarDecl_hasInitCall(vd)) {
            ir_Context_addStoreInstr(gen->ctx, var->ir_type, res, var->ref);
         }
      }
      return true;
   }
   case ast_StmtKind_Asm:
      break;
   case ast_StmtKind_Assert:
      return true;
   }
   ast_Stmt_dump(s);
   (0) || c2_assert("generator/ir/ir_generator_stmt.c2", 134, "ir_generator.Generator.emitStmt", "0");
   return true;
}

static void ir_generator_Generator_emitIfStmt(ir_generator_Generator* gen, const ast_Stmt* s)
{
   ir_Context* c = gen->ctx;
   const ast_IfStmt* if_stmt = ((ast_IfStmt*)(s));
   const ast_Stmt* cond = ast_IfStmt_getCond(if_stmt);
   const ast_Stmt* then_stmt = ast_IfStmt_getThen(if_stmt);
   const ast_Stmt* else_stmt = ast_IfStmt_getElse(if_stmt);
   ir_BlockId then_blk = ir_Context_createBlock(c, ir_BlockKind_IfTrue);
   ir_BlockId else_blk = 0;
   if (else_stmt) else_blk = ir_Context_createBlock(c, ir_BlockKind_IfFalse);
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_IfJoin);
   ir_BlockId false_blk = join_blk;
   if (else_stmt) false_blk = else_blk;
   if (ast_Stmt_isDecl(cond)) {
      ast_DeclStmt* ds = ((ast_DeclStmt*)(cond));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      ast_Decl* d = ((ast_Decl*)(vd));
      ir_Ref rhs;
      ir_generator_Generator_emitExpr(gen, &rhs, ast_VarDecl_getInit(vd));
      ir_Ref lhs;
      ir_generator_Generator_emitVarDecl(gen, &lhs, d);
      ir_Type t = ir_Type_I32;
      ir_generator_Generator_emitAssignCond(gen, t, lhs, rhs, then_blk, join_blk, then_blk);
   } else {
      (ast_Stmt_isExpr(cond)) || c2_assert("generator/ir/ir_generator_stmt.c2", 182, "ir_generator.Generator.emitIfStmt", "cond.isExpr()");
      ast_Expr* e = ((ast_Expr*)(cond));
      ir_generator_Generator_emitCond(gen, e, then_blk, false_blk, then_blk);
   }
   ir_generator_Generator_emitStmt(gen, then_stmt);
   if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, join_blk);
   ir_Context_endBlock(c);
   if (else_stmt) {
      ir_Context_startBlock(c, else_blk);
      ir_generator_Generator_emitStmt(gen, else_stmt);
      if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, join_blk);
      ir_Context_endBlock(c);
   }
   ir_Context_startBlock(c, join_blk);
}

static void ir_generator_Generator_emitWhileStmt(ir_generator_Generator* gen, const ast_Stmt* s)
{
   ir_Context* c = gen->ctx;
   const ast_WhileStmt* w = ((ast_WhileStmt*)(s));
   ir_BlockId cond_blk = ir_Context_createBlock(c, ir_BlockKind_WhileCond);
   ir_BlockId body_blk = ir_Context_createBlock(c, ir_BlockKind_WhileBody);
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_WhileJoin);
   (!ir_Context_isBlockTerminated(c)) || c2_assert("generator/ir/ir_generator_stmt.c2", 212, "ir_generator.Generator.emitWhileStmt", "!c.isBlockTerminated()");
   ir_Context_addJmpInstr(c, cond_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, cond_blk);
   ast_Stmt* cond = ast_WhileStmt_getCond(w);
   if (ast_Stmt_isDecl(cond)) {
      ast_DeclStmt* ds = ((ast_DeclStmt*)(cond));
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds);
      ast_Decl* d = ((ast_Decl*)(vd));
      ir_Ref rhs;
      ir_generator_Generator_emitExpr(gen, &rhs, ast_VarDecl_getInit(vd));
      ir_Ref lhs;
      ir_generator_Generator_emitVarDecl(gen, &lhs, d);
      ir_Type t = ir_Type_I32;
      ir_generator_Generator_emitAssignCond(gen, t, lhs, rhs, body_blk, join_blk, body_blk);
   } else {
      (ast_Stmt_isExpr(cond)) || c2_assert("generator/ir/ir_generator_stmt.c2", 233, "ir_generator.Generator.emitWhileStmt", "cond.isExpr()");
      ast_Expr* e = ((ast_Expr*)(cond));
      ir_generator_Generator_emitCond(gen, e, body_blk, join_blk, body_blk);
   }
   ir_generator_Generator_enterScope(gen, join_blk, cond_blk);
   ir_generator_Generator_emitStmt(gen, ast_WhileStmt_getBody(w));
   ir_generator_Generator_leaveScope(gen);
   if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, cond_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, join_blk);
}

static void ir_generator_Generator_emitForStmt(ir_generator_Generator* gen, const ast_Stmt* s)
{
   ir_Context* c = gen->ctx;
   const ast_ForStmt* f = ((ast_ForStmt*)(s));
   const ast_Stmt* ie = ast_ForStmt_getInit(f);
   if (ie) ir_generator_Generator_emitStmt(gen, ie);
   ir_BlockId cond_blk = ir_Context_createBlock(c, ir_BlockKind_ForCond);
   ir_BlockId body_blk = ir_Context_createBlock(c, ir_BlockKind_ForBody);
   ir_BlockId cont_blk = ir_Context_createBlock(c, ir_BlockKind_ForCont);
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_ForJoin);
   (!ir_Context_isBlockTerminated(c)) || c2_assert("generator/ir/ir_generator_stmt.c2", 262, "ir_generator.Generator.emitForStmt", "!c.isBlockTerminated()");
   ir_Context_addJmpInstr(c, cond_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, cond_blk);
   ast_Expr* cond = ast_ForStmt_getCond(f);
   if (cond) {
      ir_generator_Generator_emitCond(gen, cond, body_blk, join_blk, body_blk);
   } else {
      ir_Context_endBlock(c);
      ir_Context_startBlock(c, body_blk);
   }
   ir_generator_Generator_enterScope(gen, join_blk, cont_blk);
   ir_generator_Generator_emitStmt(gen, ast_ForStmt_getBody(f));
   ir_generator_Generator_leaveScope(gen);
   if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, cont_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, cont_blk);
   ast_Expr* cont = ast_ForStmt_getCont(f);
   if (cont) {
      ir_Ref dontcare;
      ir_generator_Generator_emitExpr(gen, &dontcare, cont);
   }
   ir_Context_addJmpInstr(c, cond_blk);
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, join_blk);
}

static void ir_generator_Generator_emitSwitchStmt(ir_generator_Generator* gen, const ast_Stmt* s)
{
   ir_Context* c = gen->ctx;
   ast_SwitchStmt* sw = ((ast_SwitchStmt*)(s));
   ast_Expr* cond = ast_SwitchStmt_getCond(sw);
   if (ast_Expr_isCtv(cond)) {
      (0) || c2_assert("generator/ir/ir_generator_switch.c2", 28, "ir_generator.Generator.emitSwitchStmt", "0");
      return;
   }
   if (ast_SwitchStmt_isString(sw)) {
      if (ast_Expr_isCtv(cond)) {
         (0) || c2_assert("generator/ir/ir_generator_switch.c2", 35, "ir_generator.Generator.emitSwitchStmt", "0");
         return;
      }
      return;
   }
   uint32_t num_cases = ast_SwitchStmt_getNumCases(sw);
   ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
   if (((num_cases == 1) && ast_SwitchStmt_hasDefault(sw))) {
      return;
   }
   ir_BlockId join_blk = ir_Context_createBlock(c, ir_BlockKind_SwitchJoin);
   ir_Ref ref;
   ir_generator_Generator_emitExpr(gen, &ref, cond);
   ir_CaseId caseId = ir_Context_addSwitchInstr(gen->ctx, ref, num_cases);
   ir_generator_Generator_enterScope(gen, join_blk, 0);
   _Bool prev_fallthrough = false;
   for (uint32_t i = 0; (i < num_cases); i++) {
      ast_SwitchCase* sc = cases[i];
      prev_fallthrough = ir_generator_Generator_emitSwitchCase(gen, sc, join_blk, (caseId + i), prev_fallthrough);
   }
   if (!ir_Context_isBlockTerminated(c)) ir_Context_addJmpInstr(c, join_blk);
   ir_Context_endBlock(c);
   ir_generator_Generator_leaveScope(gen);
   ir_Context_startBlock(c, join_blk);
}

static _Bool ir_generator_Generator_emitSwitchCase(ir_generator_Generator* gen, ast_SwitchCase* sc, ir_BlockId join_blk, ir_CaseId caseId, _Bool prev_fallthrough)
{
   ir_Context* c = gen->ctx;
   ast_Expr* case_cond = ast_SwitchCase_getCond(sc, 0);
   ast_Value v = { };
   if (case_cond) {
      v = ctv_analyser_get_value(case_cond);
   }
   ir_BlockKind kind = ast_SwitchCase_isDefault(sc) ? ir_BlockKind_SwitchDefault : ir_BlockKind_SwitchCase;
   ir_BlockId case_blk = ir_Context_createBlock(c, kind);
   ir_Context_setCase(gen->ctx, caseId, ast_Value_as_u32(&v), case_blk);
   if (!ir_Context_isBlockTerminated(c)) {
      if (prev_fallthrough) {
         ir_Context_addJmpInstr(c, case_blk);
      } else {
         ir_Context_addJmpInstr(c, join_blk);
      }
   }
   ir_Context_endBlock(c);
   ir_Context_startBlock(c, case_blk);
   if (!ast_SwitchCase_isDefault(sc)) {
      string_buffer_Buf_clear(gen->name_buf);
      ast_Expr_printLiteral(case_cond, gen->name_buf);
      ir_Context_addComment(c, string_buffer_Buf_data(gen->name_buf));
   }
   uint32_t num_stmts = ast_SwitchCase_getNumStmts(sc);
   if ((num_stmts == 0)) {
   } else {
      ast_Stmt** stmts = ast_SwitchCase_getStmts(sc);
      for (uint32_t j = 0; (j < num_stmts); j++) {
         if (!ir_generator_Generator_emitStmt(gen, stmts[j])) break;

      }
   }
   return ast_SwitchCase_hasFallthrough(sc);
}


// --- module compiler ---
typedef struct compiler_PluginHandler_ compiler_PluginHandler;
typedef struct compiler_Options_ compiler_Options;
typedef struct compiler_Compiler_ compiler_Compiler;

typedef void (*compiler_BeginTargetFn)(void* arg, plugin_info_Info* info);

typedef void (*compiler_PluginFn)(void* arg);

struct compiler_PluginHandler_ {
   compiler_BeginTargetFn start_target;
   compiler_PluginFn after_parsing;
   compiler_PluginFn after_analysis;
   compiler_PluginFn end_target;
   void* arg;
};

struct compiler_Options_ {
   _Bool check_only;
   _Bool print_ast;
   _Bool print_ast_early;
   _Bool fast_build;
   _Bool test_mode;
   _Bool print_lib_ast;
   _Bool print_modules;
   _Bool print_symbols;
   _Bool print_external_symbols;
   _Bool print_ast_stats;
   _Bool print_reports;
   _Bool show_libs;
   _Bool print_ir;
   _Bool trace_calls;
   _Bool asan;
   _Bool msan;
   _Bool ubsan;
   uint32_t libdir;
};

struct compiler_Compiler_ {
   string_pool_Pool* auxPool;
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   build_file_Info* build_info;
   build_target_Target* target;
   const compiler_Options* opts;
   target_info_Info targetInfo;
   ast_context_Context* context;
   string_pool_Pool* astPool;
   ast_builder_Builder* builder;
   attr_handler_Handler* attr_handler;
   module_list_List allmodules;
   component_List components;
   keywords_Info kwinfo;
   c2_parser_Parser* parser;
   module_analyser_Analyser* analyser;
   _Bool is_image;
   component_Component* mainComp;
   uint32_t main_idx;
   uint32_t libc_name;
   ast_Decl* mainFunc;
   module_list_List parse_queue;
   string_list_List libdirs;
   component_Component* current;
};

static void compiler_build(string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler);
static void compiler_Compiler_handleModuleImports(void* arg, ast_Module* m);
static void compiler_Compiler_handleImport(void* arg, ast_ImportDecl* id);
static component_Kind compiler_target2compKind(build_target_Kind k);
static void compiler_Compiler_build(compiler_Compiler* c, string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler, plugin_info_Info* info);
static void compiler_Compiler_free(compiler_Compiler* c);
static void compiler_Compiler_add_source(void* arg, const char* name, string_buffer_Buf* content);
static _Bool compiler_Compiler_register_attr(void* arg, uint32_t name, ast_AttrHandlerFn handler, void* arg2);
static _Bool compiler_Compiler_check_exports(compiler_Compiler* c);
static void compiler_Compiler_analyseModule(void* arg, ast_Module* m);
static void compiler_Compiler_analyseUsedModule(void* arg, ast_Module* m);
static void compiler_Compiler_findTopModule(void* arg, ast_Module* m);
static void compiler_Compiler_checkUnused(void* arg, ast_Module* m);
static void compiler_Compiler_checkMain(compiler_Compiler* c);
static void compiler_Compiler_addFeature(compiler_Compiler* c, const char* str, const char* value);
static void compiler_Compiler_addGlobalDefine(compiler_Compiler* c, const char* prefix, const char* tail);
static void compiler_Compiler_createComponent(compiler_Compiler* c, uint32_t name, _Bool is_direct, _Bool is_static);
static void compiler_Compiler_onLib(void* arg, uint32_t name, _Bool is_static);
static void compiler_Compiler_load_libs(compiler_Compiler* c);
static component_Component* compiler_Compiler_find_component(compiler_Compiler* c, ast_Module* m);
static void compiler_Compiler_open_lib(compiler_Compiler* c, component_Component* comp);
static _Bool compiler_Compiler_has_component(compiler_Compiler* c, uint32_t name);
static _Bool compiler_Compiler_find_lib(const compiler_Compiler* c, const char* libname, char* fullpath);
static void compiler_Compiler_parseExternalModule(void* arg, ast_Module* m);
static void compiler_Compiler_parse_lib(compiler_Compiler* c, component_Component* comp);
static void compiler_Compiler_analyse_lib(compiler_Compiler* c, component_Component* comp);
static void compiler_Compiler_showAllLibs(compiler_Compiler* c);
static void compiler_Compiler_showLibs(compiler_Compiler* c, string_buffer_Buf* out, const char* dirname, _Bool show_modules);

static void compiler_build(string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler)
{
   compiler_Compiler c = { };
   plugin_info_Info info = { };
   compiler_Compiler_build(&c, auxPool, sm, diags, build_info, target, opts, pluginHandler, &info);
   if (opts->print_reports) {
      source_mgr_SourceMgr_report(c.sm);
      ast_context_Context_report(c.context);
      string_pool_Pool_report(c.astPool);
   }
   diagnostics_Diags_printStatus(diags);
   pluginHandler->end_target(pluginHandler->arg);
   ast_deinit(c.opts->print_ast_stats);
   compiler_Compiler_free(&c);
}

static void compiler_Compiler_handleModuleImports(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   ast_Module_visitImports(m, compiler_Compiler_handleImport, c);
}

static void compiler_Compiler_handleImport(void* arg, ast_ImportDecl* id)
{
   compiler_Compiler* c = arg;
   if (ast_ImportDecl_getDest(id)) return;

   ast_Decl* d = ((ast_Decl*)(id));
   uint32_t name_idx = ast_Decl_getNameIdx(d);
   ast_Module* m = module_list_List_find(&c->allmodules, name_idx);
   if (!m) {
      diagnostics_Diags_error(c->diags, ast_Decl_getLoc(d), "unknown module: '%s'", ast_idx2name(name_idx));
      return;
   }
   if (!ast_Module_isDirect(m)) {
      component_Component* co = compiler_Compiler_find_component(c, m);
      diagnostics_Diags_error(c->diags, ast_Decl_getLoc(d), "module '%s' is in component '%s' that is not used directly", ast_idx2name(name_idx), component_Component_getName(co));
      exit(-1);
   }
   if ((component_Component_isExternal(c->current) && !ast_Module_isLoaded(m))) {
      if (component_Component_hasModule(c->current, m)) {
         if (!ast_Module_isUsed(m)) module_list_List_add(&c->parse_queue, m);
      } else {
      }
   }
   ast_ImportDecl_setDest(id, m);
   ast_Module_setUsed(m);
   ast_Decl_setChecked(d);
   ast_Decl_setType(d, ast_QualType_create(((ast_Type*)(ast_Module_getType(m)))));
}

static component_Kind compiler_target2compKind(build_target_Kind k)
{
   switch (k) {
   case build_target_Kind_Image:
      return component_Kind_Image;
   case build_target_Kind_Executable:
      return component_Kind_Executable;
   case build_target_Kind_StaticLibrary:
      return component_Kind_StaticLibrary;
   case build_target_Kind_DynamicLibrary:
      return component_Kind_DynamicLibrary;
   }
   return component_Kind_Executable;
}

static void compiler_Compiler_build(compiler_Compiler* c, string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler, plugin_info_Info* info)
{
   memset(c, 0, 832);
   c->auxPool = auxPool;
   c->sm = sm;
   c->diags = diags;
   c->build_info = build_info;
   c->target = target;
   c->opts = opts;
   diagnostics_Diags_setWarningAsError(diags, build_target_Target_getWarnings(target)->are_errors);
   diagnostics_Diags_clear(c->diags);
   c->context = ast_context_create((16 * 1024));
   c->astPool = string_pool_create((128 * 1024), 4096);
   keywords_Info_init(&c->kwinfo, c->astPool);
   c->main_idx = string_pool_Pool_addStr(c->astPool, "main", true);
   uint32_t c2_idx = string_pool_Pool_addStr(c->astPool, "c2", true);
   c->libc_name = string_pool_Pool_addStr(c->auxPool, "libc", true);
   module_list_List_init(&c->parse_queue, false, 64);
   c->attr_handler = attr_handler_create(diags);
   c->builder = ast_builder_create(c->context, diags, c->auxPool, c2_idx, c->main_idx, c->attr_handler);
   module_list_List_init(&c->allmodules, false, 64);
   component_List_init(&c->components);
   c->is_image = (build_target_Target_getKind(target) == build_target_Kind_Image);
   string_list_List_init(&c->libdirs, c->auxPool);
   const char* output_base = constants_output_dir;
   if (c->build_info) {
      const char* output_dir2 = build_file_Info_getOutputDir(c->build_info);
      if (output_dir2) {
         console_debug("using output dir: %s", output_dir2);
         output_base = output_dir2;
      }
   }
   if (!opts->show_libs) string_list_List_add(&c->libdirs, string_pool_Pool_addStr(c->auxPool, output_base, true));
   if (c->build_info) {
      const string_list_List* dirs = build_file_Info_getLibDirs(c->build_info);
      for (uint32_t i = 0; (i < string_list_List_length(dirs)); i++) {
         string_list_List_add(&c->libdirs, string_list_List_get_idx(dirs, i));
      }
      const char* target_str = build_file_Info_getTarget(c->build_info);
      if (target_str) {
         if (!target_info_Info_fromString(&c->targetInfo, target_str)) {
            console_error("invalid target triple: %s", target_str);
            exit(-1);
         }
      } else {
         target_info_Info_getNative(&c->targetInfo);
      }
   } else {
      if (c->is_image) {
         console_error("images require a build-file");
         exit(-1);
      }
      if (c->opts->libdir) string_list_List_add(&c->libdirs, c->opts->libdir);
      target_info_Info_getNative(&c->targetInfo);
   }
   console_debug("triple: %s", target_info_Info_str(&c->targetInfo));
   compiler_Compiler_addGlobalDefine(c, "SYSTEM", target_info_Info_getSystemName(&c->targetInfo));
   compiler_Compiler_addGlobalDefine(c, "ARCH", target_info_Info_getArchName(&c->targetInfo));
   if (opts->asan) compiler_Compiler_addFeature(c, "__ASAN__", "1");
   if (opts->msan) compiler_Compiler_addFeature(c, "__MSAN__", "1");
   if (opts->ubsan) compiler_Compiler_addFeature(c, "__UBSAN__", "1");
   c->parser = c2_parser_create(sm, diags, c->astPool, c->builder, &c->kwinfo, build_target_Target_getFeatures(target));
   ast_initialize(c->context, c->astPool, (c->targetInfo.intWidth / 8), color_useColor());
   c->analyser = module_analyser_create(c->diags, c->context, c->astPool, c->builder, &c->allmodules, build_target_Target_getWarnings(c->target));
   if (opts->show_libs) {
      compiler_Compiler_showAllLibs(c);
      exit(0);
   }
   uint32_t c2comp_name = string_pool_Pool_addStr(c->auxPool, "(internal)", true);
   component_Component* c2comp = component_create(c->context, c->auxPool, &c->allmodules, c2comp_name, component_Kind_Internal, true);
   c2module_loader_load(c->context, c->astPool, c->auxPool, c2comp);
   component_List_add(&c->components, c2comp);
   compiler_Compiler_load_libs(c);
   c->mainComp = component_create(c->context, c->auxPool, &c->allmodules, build_target_Target_getNameIdx(target), compiler_target2compKind(build_target_Target_getKind(target)), true);
   if (!build_target_Target_getNoLibC(target)) component_Component_addDep(c->mainComp, "libc");
   component_List_add(&c->components, c->mainComp);
   ast_builder_Builder_setComponent(c->builder, c->mainComp);
   info->sm = sm;
   info->diags = diags;
   info->target = target;
   info->components = &c->components;
   info->ast_globals = ast_getGlobals();
   info->ast_builtins = ast_builtins;
   info->astPool = c->astPool;
   info->auxPool = c->auxPool;
   info->context = c->context;
   info->builder = c->builder;
   info->addSource = compiler_Compiler_add_source;
   info->register_attr = compiler_Compiler_register_attr;
   info->fn_arg = c;
   strcpy(info->target_name, string_pool_Pool_idx2str(c->auxPool, build_target_Target_getNameIdx(target)));
   sprintf(info->output_dir, "%s/%s", output_base, string_pool_Pool_idx2str(c->auxPool, build_target_Target_getNameIdx(target)));
   int32_t err = file_utils_create_directory(info->output_dir);
   if (err) {
      console_error("cannot create directory %s", info->output_dir);
      exit(-1);
   }
   pluginHandler->start_target(pluginHandler->arg, info);
   console_debug("parsing %s", string_pool_Pool_idx2str(c->auxPool, build_target_Target_getNameIdx(target)));
   uint64_t t1_start = utils_now();
   for (uint32_t j = 0; (j < build_target_Target_numFiles(target)); j++) {
      const build_target_File* f = build_target_Target_getFile(target, j);
      int32_t file_id = source_mgr_SourceMgr_open(sm, f->name, f->loc, true);
      if ((file_id == -1)) return;

      console_debug("parsing %s", source_mgr_SourceMgr_getFileName(sm, file_id));
      c2_parser_Parser_parse(c->parser, file_id, false, false);
      source_mgr_SourceMgr_close(sm, file_id);
   }
   uint64_t t1_end = utils_now();
   console_log_time("parsing", (t1_end - t1_start));
   if (!diagnostics_Diags_isOk(c->diags)) return;

   if (opts->print_ast_early) {
      component_Component_print(c->mainComp, true);
      return;
   }
   ast_builder_Builder_setComponent(c->builder, c->mainComp);
   pluginHandler->after_parsing(pluginHandler->arg);
   uint64_t t2_start = utils_now();
   c->current = c->mainComp;
   console_debug("analysing imports");
   component_Component_visitModules(c->mainComp, compiler_Compiler_handleModuleImports, c);
   if (!diagnostics_Diags_isOk(c->diags)) return;

   console_debug("sorting modules");
   module_sorter_sort(c->mainComp, c->diags);
   if (!compiler_Compiler_check_exports(c)) return;

   for (uint32_t i = component_List_size(&c->components); (i != 0); i--) {
      component_Component* comp = component_List_get(&c->components, (i - 1));
      if (!component_Component_isExternal(comp)) continue;

      compiler_Compiler_parse_lib(c, comp);
   }
   for (uint32_t i = 0; (i < component_List_size(&c->components)); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      console_debug("analysing component %s", component_Component_getName(comp));
      if (!component_Component_isExternal(comp)) continue;

      compiler_Compiler_analyse_lib(c, comp);
   }
   component_Component_visitModules(c->mainComp, compiler_Compiler_analyseModule, c);
   if (diagnostics_Diags_hasErrors(c->diags)) {
      if (opts->print_ast) component_Component_print(c->mainComp, true);
      return;
   }
   compiler_Compiler_checkMain(c);
   const warning_flags_Flags* warnings = build_target_Target_getWarnings(c->target);
   if (!warnings->no_unused) {
      component_Component_visitModules(c->mainComp, compiler_Compiler_checkUnused, c);
   }
   uint64_t t2_end = utils_now();
   console_log_time("analysis", (t2_end - t2_start));
   if (!diagnostics_Diags_isOk(c->diags)) return;

   ast_builder_Builder_setComponent(c->builder, c->mainComp);
   pluginHandler->after_analysis(pluginHandler->arg);
   if (c->opts->print_modules) {
      for (uint32_t i = 0; (i < component_List_size(&c->components)); i++) {
         component_Component_printModules(component_List_get(&c->components, i));
      }
      return;
   }
   if ((c->opts->print_symbols | c->opts->print_external_symbols)) {
      for (uint32_t i = 0; (i < component_List_size(&c->components)); i++) {
         component_Component_printSymbols(component_List_get(&c->components, i), c->opts->print_external_symbols);
      }
      return;
   }
   if (opts->print_ast) component_Component_print(c->mainComp, true);
   if (c->opts->check_only) return;

   component_Component* mainComp = component_List_getLast(&c->components);
   generator_utils_mark_used(mainComp, &c->allmodules, c->opts->test_mode);
   switch (build_target_Target_getBackEnd(target)) {
   case build_target_BackEndKind_None:
      break;
   case build_target_BackEndKind_C: {
      console_debug("generating C");
      uint64_t gen3 = utils_now();
      string_list_List asm_files;
      string_list_List_init(&asm_files, auxPool);
      for (uint32_t i = 0; (i < build_target_Target_numAsmFiles(target)); i++) {
         const build_target_File* file = build_target_Target_getAsmFile(target, i);
         string_list_List_add(&asm_files, file->name);
      }
      c_generator_generate(c->astPool, c->auxPool, info->target_name, build_target_Target_getKind(target), info->output_dir, c->sm, c->build_info, &c->targetInfo, &c->components, &c->allmodules, c->mainFunc, &asm_files, build_target_Target_hasAsserts(c->target), (build_target_Target_getFastBuild(c->target) | c->opts->fast_build), c->opts->asan, c->opts->msan, c->opts->ubsan, c->opts->test_mode, c->opts->trace_calls);
      string_list_List_free(&asm_files);
      uint64_t gen4 = utils_now();
      console_log_time("C generation", (gen4 - gen3));
      if ((!build_target_Target_getNoBuild(target) && !opts->test_mode)) {
         console_debug("building C");
         gen3 = utils_now();
         c_generator_build(info->output_dir);
         gen4 = utils_now();
         console_log_time("C compilation", (gen4 - gen3));
      }
      break;
   }
   case build_target_BackEndKind_QBE: {
      console_debug("generating QBE");
      uint64_t gen3 = utils_now();
      qbe_generator_generate(info->target_name, info->output_dir, &c->components, c->sm, build_target_Target_hasAsserts(c->target), c->opts->print_ir);
      uint64_t gen4 = utils_now();
      console_log_time("QBE generation", (gen4 - gen3));
      if (!build_target_Target_getNoBuild(target)) {
         gen3 = utils_now();
         qbe_generator_build(info->output_dir);
         gen4 = utils_now();
         console_log_time("QBE compilation", (gen4 - gen3));
      }
      break;
   }
   case build_target_BackEndKind_IR: {
      console_debug("generating IR");
      uint64_t gen3 = utils_now();
      ir_generator_generate(info->target_name, info->output_dir, &c->components, c->sm, build_target_Target_hasAsserts(c->target), c->opts->print_ir);
      uint64_t gen4 = utils_now();
      console_log_time("IR generation", (gen4 - gen3));
      break;
   }
   }
}

static void compiler_Compiler_free(compiler_Compiler* c)
{
   module_list_List_free(&c->parse_queue);
   component_List_free(&c->components);
   module_analyser_Analyser_free(c->analyser);
   c2_parser_Parser_free(c->parser);
   module_list_List_free(&c->allmodules);
   ast_builder_Builder_free(c->builder);
   attr_handler_Handler_free(c->attr_handler);
   string_pool_Pool_free(c->astPool);
   ast_context_Context_free(c->context);
   string_list_List_free(&c->libdirs);
}

static void compiler_Compiler_add_source(void* arg, const char* name, string_buffer_Buf* content)
{
   compiler_Compiler* c = arg;
   uint32_t name2 = string_pool_Pool_addStr(c->auxPool, name, false);
   int32_t file_id = source_mgr_SourceMgr_addGenerated(c->sm, content, name2);
   c2_parser_Parser_parse(c->parser, file_id, false, true);
}

static _Bool compiler_Compiler_register_attr(void* arg, uint32_t name, ast_AttrHandlerFn handler, void* arg2)
{
   compiler_Compiler* c = arg;
   return attr_handler_Handler_register(c->attr_handler, name, handler, arg2);
}

static _Bool compiler_Compiler_check_exports(compiler_Compiler* c)
{
   const string_list_List* exports = build_target_Target_getExports(c->target);
   for (uint32_t i = 0; (i < string_list_List_length(exports)); i++) {
      const char* name = string_list_List_get(exports, i);
      uint32_t name_idx = string_pool_Pool_addStr(c->astPool, name, true);
      ast_Module* m = module_list_List_find(&c->allmodules, name_idx);
      if (m) {
         if (ast_Module_isExternal(m)) {
            console_error("cannot export external module %s", name);
            return false;
         }
         ast_Module_setExported(m);
      } else {
         console_error("cannot export %s, no such module", name);
         return false;
      }
   }
   if (c->is_image) {
      if (string_list_List_length(exports)) {
         console_error("images cannot export modules");
         return false;
      }
   }
   return true;
}

static void compiler_Compiler_analyseModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   console_debug("analysing module %s", ast_Module_getName(m));
   module_analyser_Analyser_check(c->analyser, m);
}

static void compiler_Compiler_analyseUsedModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   if (ast_Module_isUsed(m)) {
      module_analyser_Analyser_check(c->analyser, m);
   }
}

static void compiler_Compiler_findTopModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   if (ast_Module_isUsed(m)) return;

   if (c->mainFunc) return;

   c->mainFunc = module_analyser_Analyser_findMain(c->analyser, m, c->main_idx);
}

static void compiler_Compiler_checkUnused(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   unused_checker_check(c->diags, build_target_Target_getWarnings(c->target), m);
}

static void compiler_Compiler_checkMain(compiler_Compiler* c)
{
   component_Component_visitModules(c->mainComp, compiler_Compiler_findTopModule, c);
   if (build_target_Target_needsMain(c->target)) {
      if (!c->mainFunc) {
         if (!c->opts->test_mode) diagnostics_Diags_error(c->diags, 0, "no 'main' function found");
         return;
      }
      if (!ast_Decl_isPublic(c->mainFunc)) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "function 'main' should be declared public");
         return;
      }
      ast_FunctionDecl* main = ((ast_FunctionDecl*)(c->mainFunc));
      if (!ast_FunctionDecl_hasReturn(main)) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "function 'main' should return 'i32'");
         return;
      }
      ast_QualType rtype = ast_FunctionDecl_getRType(main);
      ast_BuiltinType* bi = ast_QualType_getBuiltin(&rtype);
      if ((!ast_QualType_isBuiltin(&rtype) || !ast_BuiltinType_isInt32(bi))) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "function 'main' should return 'i32'");
         return;
      }
   } else {
      if (c->mainFunc) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "libraries cannot have a 'main' function");
      }
   }
}

static void compiler_Compiler_addFeature(compiler_Compiler* c, const char* str, const char* value)
{
   build_target_Target_addFeature(c->target, string_pool_Pool_addStr(c->auxPool, str, true));
}

static void compiler_Compiler_addGlobalDefine(compiler_Compiler* c, const char* prefix, const char* tail)
{
   char tmp[32];
   snprintf(tmp, 32, "%s_%s", prefix, tail);
   for (size_t i = 0; tmp[i]; i++) {
      uint8_t ch = ((uint8_t)(tmp[i]));
      tmp[i] = ((ch == '-')) ? '_' : ((char)(toupper(ch)));
   }
   compiler_Compiler_addFeature(c, tmp, "1");
}

static void compiler_Compiler_createComponent(compiler_Compiler* c, uint32_t name, _Bool is_direct, _Bool is_static)
{
   component_Kind kind = is_static ? component_Kind_ExternalStatic : component_Kind_ExternalDynamic;
   component_Component* comp = component_create(c->context, c->auxPool, &c->allmodules, name, kind, is_direct);
   component_List_add(&c->components, comp);
}

static void compiler_Compiler_onLib(void* arg, uint32_t name, _Bool is_static)
{
   compiler_Compiler* c = arg;
   if ((!is_static && c->is_image)) {
      console_error("images cannot use dynamic libraries");
      exit(-1);
   }
   if ((build_target_Target_getNoLibC(c->target) && (name == c->libc_name))) {
      console_error("cannot use libc and have nolibc");
      exit(-1);
   }
   compiler_Compiler_createComponent(c, name, true, is_static);
}

static void compiler_Compiler_load_libs(compiler_Compiler* c)
{
   build_target_Target_visitLibs(c->target, compiler_Compiler_onLib, c);
   if (!build_target_Target_getNoLibC(c->target)) {
      if (!build_target_Target_hasLib(c->target, c->libc_name)) {
         compiler_Compiler_createComponent(c, c->libc_name, true, false);
      }
   }
   for (uint32_t i = 0; (i < component_List_size(&c->components)); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      if (component_Component_isExternal(comp)) compiler_Compiler_open_lib(c, comp);
   }
   component_sorter_sort(component_List_get_all(&c->components), component_List_size(&c->components), c->diags);
}

static component_Component* compiler_Compiler_find_component(compiler_Compiler* c, ast_Module* m)
{
   for (uint32_t i = 0; (i < component_List_size(&c->components)); i++) {
      component_Component* co = component_List_get(&c->components, i);
      if (component_Component_hasModule(co, m)) return co;

   }
   return NULL;
}

static void compiler_Compiler_open_lib(compiler_Compiler* c, component_Component* comp)
{
   const char* libstr = component_Component_getName(comp);
   console_debug("opening lib %s", libstr);
   char libdir[512];
   if (!compiler_Compiler_find_lib(c, libstr, libdir)) {
      console_error("cannot find library '%s'", libstr);
      exit(-1);
   }
   char fullname[512];
   snprintf(fullname, 512, "%s/%s", libdir, constants_manifest_name);
   uint32_t filename_idx = string_pool_Pool_addStr(c->auxPool, fullname, false);
   int32_t file_id = source_mgr_SourceMgr_open(c->sm, filename_idx, 0, false);
   if ((file_id == -1)) return;

   uint32_t dirname = string_pool_Pool_addStr(c->auxPool, libdir, false);
   component_Component_setPath(comp, dirname);
   string_list_List mods; string_list_List_init(&mods, c->astPool);
   _Bool ok = manifest_parse(c->sm, file_id, c->astPool, comp, &mods);
   if (!ok) {
      exit(-1);
   }
   for (uint32_t i = 0; (i < string_list_List_length(&mods)); i++) {
      uint32_t mod_name = string_list_List_get_idx(&mods, i);
      ast_Module* m = component_Component_getOrAddModule(comp, mod_name);
      if (!m) {
         m = module_list_List_find(&c->allmodules, mod_name);
         component_Component* other = compiler_Compiler_find_component(c, m);
         (other) || c2_assert("compiler/compiler_libs.c2", 119, "compiler.Compiler.open_lib", "other");
         console_error("module '%s' exists in components %s and %s", string_list_List_get(&mods, i), component_Component_getName(other), component_Component_getName(comp));
         exit(-1);
      }
   }
   string_list_List_free(&mods);
   const string_list_List* deps = component_Component_getDeps(comp);
   for (uint32_t i = 0; (i < string_list_List_length(deps)); i++) {
      uint32_t depname = string_list_List_get_idx(deps, i);
      if (compiler_Compiler_has_component(c, depname)) continue;

      if ((build_target_Target_getNoLibC(c->target) && (depname == c->libc_name))) {
         console_error("cannot use %s since it depends on unused libc", component_Component_getName(comp));
         exit(-1);
      }
      compiler_Compiler_createComponent(c, depname, false, false);
   }
   source_mgr_SourceMgr_close(c->sm, file_id);
}

static _Bool compiler_Compiler_has_component(compiler_Compiler* c, uint32_t name)
{
   for (uint32_t i = 0; (i < component_List_size(&c->components)); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      if ((component_Component_getNameIdx(comp) == name)) return true;

   }
   return false;
}

static _Bool compiler_Compiler_find_lib(const compiler_Compiler* c, const char* libname, char* fullpath)
{
   for (uint32_t i = 0; (i < string_list_List_length(&c->libdirs)); i++) {
      const char* dirname = string_list_List_get(&c->libdirs, i);
      sprintf(fullpath, "%s/%s/%s", dirname, libname, constants_manifest_name);
      struct stat statbuf;
      int32_t err = stat(fullpath, &statbuf);
      if (!err) {
         sprintf(fullpath, "%s/%s", dirname, libname);
         return true;
      }
   }
   return false;
}

static void compiler_Compiler_parseExternalModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   if (!ast_Module_isUsed(m)) return;

   char filename[512];
   int32_t len = sprintf(filename, "%s/%s.c2i", component_Component_getPath(c->current), ast_Module_getName(m));
   uint32_t name = string_pool_Pool_add(c->auxPool, filename, ((size_t)(len)), false);
   int32_t file_id = source_mgr_SourceMgr_open(c->sm, name, 0, false);
   if ((file_id == -1)) return;

   ast_Module_setLoaded(m);
   console_debug("parsing %s", source_mgr_SourceMgr_getFileName(c->sm, file_id));
   c2_parser_Parser_parse(c->parser, file_id, true, false);
   source_mgr_SourceMgr_close(c->sm, file_id);
}

static void compiler_Compiler_parse_lib(compiler_Compiler* c, component_Component* comp)
{
   console_debug("parsing component %s", component_Component_getName(comp));
   c->current = comp;
   ast_builder_Builder_setComponent(c->builder, comp);
   module_list_List_clear(&c->parse_queue);
   module_list_List* mods = component_Component_getModules(comp);
   for (uint32_t i = 0; (i < module_list_List_length(mods)); i++) {
      ast_Module* m = module_list_List_at(mods, i);
      if (ast_Module_isUsed(m)) module_list_List_add(&c->parse_queue, m);
   }
   for (uint32_t i = 0; (i < module_list_List_length(&c->parse_queue)); i++) {
      ast_Module* m = module_list_List_at(&c->parse_queue, i);
      compiler_Compiler_parseExternalModule(c, m);
      ast_Module_visitImports(m, compiler_Compiler_handleImport, c);
   }
}

static void compiler_Compiler_analyse_lib(compiler_Compiler* c, component_Component* comp)
{
   module_sorter_sort(comp, c->diags);
   component_Component_visitModules(comp, compiler_Compiler_analyseUsedModule, c);
   if (c->opts->print_lib_ast) component_Component_print(comp, true);
}

static void compiler_Compiler_showAllLibs(compiler_Compiler* c)
{
   string_buffer_Buf* out = string_buffer_create(1024, color_useColor(), 2);
   string_buffer_Buf_add(out, "libraries:\n");
   _Bool show_modules = false;
   for (uint32_t i = 0; (i < string_list_List_length(&c->libdirs)); i++) {
      compiler_Compiler_showLibs(c, out, string_list_List_get(&c->libdirs, i), show_modules);
   }
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void compiler_Compiler_showLibs(compiler_Compiler* c, string_buffer_Buf* out, const char* dirname, _Bool show_modules)
{
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_color(out, color_Blue);
   string_buffer_Buf_add(out, dirname);
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_newline(out);
   DIR* dir = opendir(dirname);
   if ((dir == NULL)) {
      console_error("cannot open library dir '%s': %s", dirname, strerror((*__errno_location())));
      return;
   }
   char fullname[512];
   {
      dirent* entry;
      while ((entry = readdir(dir))) {
         const char* name = entry->d_name;
         if (((name[0] != '.') && (entry->d_type == DT_DIR))) {
            int32_t len = snprintf(fullname, 512, "%s/%s/%s", dirname, name, constants_manifest_name);
            if ((len >= 512)) continue;

            struct stat statbuf;
            int32_t err = stat(fullname, &statbuf);
            if (err) continue;

            uint32_t filename_idx = string_pool_Pool_add(c->auxPool, fullname, ((size_t)(len)), false);
            string_buffer_Buf_indent(out, 2);
            string_buffer_Buf_print(out, "%-12s", name);
            {
               int32_t file_id = source_mgr_SourceMgr_open(c->sm, filename_idx, 0, false);
               if ((file_id == -1)) return;

               uint32_t name_idx = string_pool_Pool_addStr(c->auxPool, name, true);
               component_Component* comp = component_create(c->context, c->auxPool, &c->allmodules, name_idx, component_Kind_ExternalStatic, true);
               string_list_List mods; string_list_List_init(&mods, c->auxPool);
               manifest_parse(c->sm, file_id, c->astPool, comp, &mods);
               component_List_add(&c->components, comp);
               string_list_List_free(&mods);
               string_buffer_Buf_add(out, "  ");
               string_buffer_Buf_color(out, color_Yellow);
               if (component_Component_isAvailableStatic(comp)) {
                  string_buffer_Buf_add(out, "static ");
               } else {
                  string_buffer_Buf_add(out, "       ");
               }
               if (component_Component_isAvailableDynamic(comp)) {
                  string_buffer_Buf_add(out, "dynamic");
               } else {
                  string_buffer_Buf_add(out, "       ");
               }
               const string_list_List* deps = component_Component_getDeps(comp);
               uint32_t num_deps = string_list_List_length(deps);
               if (num_deps) {
                  string_buffer_Buf_add(out, "  ");
                  string_buffer_Buf_color(out, color_Magenta);
                  string_buffer_Buf_add(out, "requires: ");
                  for (uint32_t i = 0; (i < num_deps); i++) {
                     if ((i != 0)) string_buffer_Buf_add(out, ", ");
                     string_buffer_Buf_add(out, string_list_List_get(deps, i));
                  }
               }
               source_mgr_SourceMgr_close(c->sm, file_id);
               string_buffer_Buf_color(out, color_Normal);
               string_buffer_Buf_newline(out);
            }
         }
      }
   }
   closedir(dir);
}


// --- module c2c_main ---
typedef struct c2c_main_Options_ c2c_main_Options;
typedef struct c2c_main_Context_ c2c_main_Context;

struct c2c_main_Options_ {
   _Bool log_verbose;
   _Bool force_warnings;
   _Bool print_timing;
   _Bool show_targets;
   _Bool show_plugins;
   _Bool no_plugins;
   _Bool use_qbe_backend;
   _Bool use_ir_backend;
   _Bool trace_calls;
   const char* build_file;
   const char* other_dir;
   const char* output_name;
   string_list_List targets;
   string_list_List files;
};

struct c2c_main_Context_ {
   utils_PathInfo path_info;
   string_pool_Pool* auxPool;
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   c2c_main_Options opts;
   compiler_Options comp_opts;
   c2recipe_Recipe* recipe;
   build_file_Info* build_info;
   int32_t recipe_id;
   plugin_mgr_Mgr* plugins;
   const build_target_PluginList* pl;
   compiler_PluginHandler pluginHandler;
   uint32_t plugins_feature;
};

static const char c2c_main_Recipe_help[841] = "---- recipe.txt ----\n\nplugin <name> [<plugin-options>]\n\nconfig <options>\n\nset <name>\n   <files>\nend\n\nexecutable <name>\n   $warnings <no-unused>\n             <no-unused-variable>\n             <no-unused-function>\n             <no-unused-parameter>\n             <no-unused-type>\n             <no-unused-module>\n             <no-unused-import> \n             <no-unused-public>\n             <no-unused-label> \n             <no-unused-enum-constant>\n             <promote-to-error> \n   $backend [c|qbe] <check>\n              <fast>\n              <no-build>\n   $nolibc\n   $disable-asserts\n   $config <options>\n   $plugin <name> [<plugin-options>]\n   $use <library-name> dynamic/static\n   (set-name)\n   <file1.c2>\n   <file2.c2>\nend\n\nlib <name> dynamic/static\n   $export <module-names>\n   other options same as executable\nend\n\n--------------------\n";

static const char c2c_main_Usage_help[1648] = "Usage: c2c <options> [<targets>]\n       c2c <options> <filenames>\nOptions:\n  -a                print ASTs\n  -A                print Library ASTs\n  -b [file]         use specified build file\n  -d [dir]          change to [dir] first\n  -h                print this help\n  -i                use IR backend\n  -I                use IR backend and print generated IR\n  -m                print modules\n  -o [file]         force the output name for a single target\n  -q                use QBE backend (EXPERIMENTAL, only for single files)\n  -Q                use QBE backend and print generated QBE code\n  -r                print reports\n  -s                print symbols\n  -S                print library symbols\n  -t                print timings\n  -T                print AST statistics\n  -v                verbose logging\n  -w                enable all warnings (overrides recipe)\n  --asan            generate code with address sanity checks\n  --msan            generate code with memory sanity checks\n  --ubsan           generate code with undefined behavior sanity checks\n  --check           only parse and check\n  --create [name]   create an empty project recipe.txt and main.c2\n  --fast            do fast, un-optimized build\n  --help            print this help\n  --help-recipe     print the recipe syntax\n  --noplugins       do not use plugins\n  --showlibs        print available libraries\n  --showplugins     print available plugins\n  --targets         show available targets in recipe\n  --test            test mode (do not check for main() function)\n  --trace-calls     generate code that traces function calls\n  --version         print version\n";

static void c2c_main_Options_init(c2c_main_Options* opts, string_pool_Pool* pool);
static void c2c_main_Options_free(c2c_main_Options* opts);
static void c2c_main_write_file_or_die(const char* filename, string_buffer_Buf* buf);
static void c2c_main_create_project(const char* name);
static void c2c_main_print_recipe_help(void);
static void c2c_main_print_version(void);
static void c2c_main_usage(void);
static void c2c_main_missing_arg(const char* option);
static int32_t c2c_main_parse_long_opt(int32_t i, int32_t argc, char** argv, compiler_Options* comp_opts, c2c_main_Options* opts);
static void c2c_main_parse_opts(int32_t argc, char** argv, compiler_Options* comp_opts, c2c_main_Options* opts);
static void c2c_main_plugins_start_target(void* arg, plugin_info_Info* info);
static void c2c_main_plugins_after_parsing(void* arg);
static void c2c_main_plugins_after_analysis(void* arg);
static void c2c_main_plugins_end_target(void* arg);
static void c2c_main_Context_init(c2c_main_Context* c);
static void c2c_main_Context_handle_args(c2c_main_Context* c, int32_t argc, char** argv);
static void c2c_main_Context_handle_plugins(c2c_main_Context* c);
static _Bool c2c_main_Context_build_target(c2c_main_Context* c, build_target_Target* target, const char* target_name);
static _Bool c2c_main_Context_build_targets(c2c_main_Context* c);
static void c2c_main_Context_free(c2c_main_Context* c);
int32_t main(int32_t argc, char** argv);

static void c2c_main_Options_init(c2c_main_Options* opts, string_pool_Pool* pool)
{
   memset(opts, 0, 88);
   string_list_List_init(&opts->targets, pool);
   string_list_List_init(&opts->files, pool);
}

static void c2c_main_Options_free(c2c_main_Options* opts)
{
   string_list_List_free(&opts->targets);
   string_list_List_free(&opts->files);
}

static void c2c_main_write_file_or_die(const char* filename, string_buffer_Buf* buf)
{
   file_utils_Writer writer;
   if (!file_utils_Writer_write(&writer, filename, string_buffer_Buf_udata(buf), string_buffer_Buf_size(buf))) {
      console_error("c2c: cannot write to %s: %s", filename, file_utils_Writer_getError(&writer));
      exit(EXIT_FAILURE);
   }
}

static void c2c_main_create_project(const char* name)
{
   if ((file_utils_exists("main.c2") || file_utils_exists("recipe.txt"))) {
      console_error("c2c: main.c2 and/or recipe.txt already exist");
      exit(EXIT_FAILURE);
   }
   string_buffer_Buf* buf = string_buffer_create(4096, false, 2);
   string_buffer_Buf_print(buf, "module %s_main;\n\npublic fn i32 main(i32 argc, char** argv) {\n\n    return 0;\n}\n", name);
   c2c_main_write_file_or_die("main.c2", buf);
   string_buffer_Buf_clear(buf);
   string_buffer_Buf_print(buf, "plugin deps_generator [all-targets files private]\nplugin refs_generator [all-targets]\n\nexecutable %s\n    $warnings no-unused\n    $backend c\n\n    main.c2\nend\n", name);
   c2c_main_write_file_or_die("recipe.txt", buf);
   string_buffer_Buf_free(buf);
   console_log("created new project files");
   exit(EXIT_SUCCESS);
}

static void c2c_main_print_recipe_help(void)
{
   console_log(c2c_main_Recipe_help);
}

static void c2c_main_print_version(void)
{
   console_log("version: %s", git_version_Describe);
}

static void c2c_main_usage(void)
{
   console_log(c2c_main_Usage_help);
   exit(EXIT_FAILURE);
}

static void c2c_main_missing_arg(const char* option)
{
   console_error("c2c: missing argument for option '%s'", option);
   exit(EXIT_FAILURE);
}

static int32_t c2c_main_parse_long_opt(int32_t i, int32_t argc, char** argv, compiler_Options* comp_opts, c2c_main_Options* opts)
{
   const char* arg = argv[i];
   switch (c2_strswitch((arg + 2), "\005check" "\006create" "\004fast" "\004help" "\013help-recipe" "\011noplugins" "\010showlibs" "\013showplugins" "\007targets" "\004test" "\013trace-calls" "\004asan" "\004msan" "\005ubsan" "\007version")) {
   case 2: // "check"
      comp_opts->check_only = true;
      break;
   case 3: // "create"
      if ((i == (argc - 1))) c2c_main_missing_arg(arg);
      i++;
      c2c_main_create_project(argv[i]);
      break;
   case 4: // "fast"
      comp_opts->fast_build = true;
      break;
   case 5: // "help"
      c2c_main_usage();
      break;
   case 6: // "help-recipe"
      c2c_main_print_recipe_help();
      exit(EXIT_SUCCESS);
   case 7: // "noplugins"
      opts->no_plugins = true;
      break;
   case 8: // "showlibs"
      comp_opts->show_libs = true;
      break;
   case 9: // "showplugins"
      opts->show_plugins = true;
      break;
   case 10: // "targets"
      opts->show_targets = true;
      break;
   case 11: // "test"
      comp_opts->test_mode = true;
      break;
   case 12: // "trace-calls"
      opts->trace_calls = true;
      break;
   case 13: // "asan"
      comp_opts->asan = true;
      break;
   case 14: // "msan"
      comp_opts->msan = true;
      break;
   case 15: // "ubsan"
      comp_opts->ubsan = true;
      break;
   case 16: // "version"
      c2c_main_print_version();
      exit(EXIT_SUCCESS);
   default:
      console_error("c2c: unknown option: %s", arg);
      exit(EXIT_FAILURE);
   }
   return i;
}

static void c2c_main_parse_opts(int32_t argc, char** argv, compiler_Options* comp_opts, c2c_main_Options* opts)
{
   for (int32_t i = 1; (i < argc); i++) {
      const char* arg = argv[i];
      if ((arg[0] == '-')) {
         if ((arg[1] == '-')) {
            i = c2c_main_parse_long_opt(i, argc, argv, comp_opts, opts);
         } else {
            if ((strlen(arg) != 2)) {
               console_error("c2c: unknown option '%s'", arg);
               exit(EXIT_FAILURE);
            }
            switch (arg[1]) {
            case '0':
               comp_opts->print_ast_early = true;
               break;
            case 'A':
               comp_opts->print_lib_ast = true;
               break;
            case 'I':
               opts->use_ir_backend = true;
               comp_opts->print_ir = true;
               break;
            case 'Q':
               opts->use_qbe_backend = true;
               comp_opts->print_ir = true;
               break;
            case 'S':
               comp_opts->print_external_symbols = true;
               break;
            case 'T':
               comp_opts->print_ast_stats = true;
               break;
            case 'a':
               comp_opts->print_ast = true;
               break;
            case 'b':
               if ((i == (argc - 1))) c2c_main_missing_arg(arg);
               i++;
               opts->build_file = argv[i];
               break;
            case 'd':
               if ((i == (argc - 1))) c2c_main_missing_arg(arg);
               i++;
               opts->other_dir = argv[i];
               break;
            case '?':
               fallthrough;
            case 'h':
               c2c_main_usage();
               break;
            case 'i':
               opts->use_ir_backend = true;
               break;
            case 'm':
               comp_opts->print_modules = true;
               break;
            case 'o':
               if ((i == (argc - 1))) c2c_main_missing_arg(arg);
               i++;
               opts->output_name = argv[i];
               break;
            case 'q':
               opts->use_qbe_backend = true;
               break;
            case 'r':
               comp_opts->print_reports = true;
               break;
            case 's':
               comp_opts->print_symbols = true;
               break;
            case 't':
               opts->print_timing = true;
               break;
            case 'v':
               opts->log_verbose = true;
               break;
            case 'w':
               opts->force_warnings = true;
               break;
            default:
               console_error("c2c: unknown option '-%c'", arg[1]);
               exit(EXIT_FAILURE);
               break;
            }
         }
      } else {
         if (string_utils_endsWith(arg, ".c2")) string_list_List_addStr(&opts->files, arg);
         else string_list_List_addStr(&opts->targets, arg);
      }
   }
   uint32_t num_targets = string_list_List_length(&opts->targets);
   uint32_t num_files = string_list_List_length(&opts->files);
   if ((num_targets && num_files)) {
      console_error("c2c: recipe targets cannot be combined with <files>");
      exit(EXIT_FAILURE);
   }
   if ((opts->use_qbe_backend && (num_files != 1))) {
      console_error("c2c: option -q can only be used for a single file");
      exit(EXIT_FAILURE);
   }
   if ((opts->use_qbe_backend && opts->use_ir_backend)) {
      console_error("c2c: only one backend can be selected");
      exit(EXIT_FAILURE);
   }
   if ((opts->output_name && (num_targets > 1))) {
      console_error("c2c: option -o can only be used for a single target");
      exit(EXIT_FAILURE);
   }
}

static void c2c_main_plugins_start_target(void* arg, plugin_info_Info* info)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_beginTarget(plugins, info);
}

static void c2c_main_plugins_after_parsing(void* arg)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_postParse(plugins);
}

static void c2c_main_plugins_after_analysis(void* arg)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_postAnalysis(plugins);
}

static void c2c_main_plugins_end_target(void* arg)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_endTarget(plugins);
}

static void c2c_main_Context_init(c2c_main_Context* c)
{
   memset(c, 0, 1248);
   c->auxPool = string_pool_create((32 * 1024), 256);
   c->sm = source_mgr_create(c->auxPool, constants_Max_open_files);
   c->diags = diagnostics_create(c->sm, color_useColor(), &c->path_info);
   c->recipe = c2recipe_create(c->sm, c->auxPool);
   c2c_main_Options_init(&c->opts, c->auxPool);
   c->recipe_id = -1;
}

static void c2c_main_Context_handle_args(c2c_main_Context* c, int32_t argc, char** argv)
{
   c2c_main_parse_opts(argc, argv, &c->comp_opts, &c->opts);
   console_setTiming(c->opts.print_timing);
   console_setDebug(c->opts.log_verbose);
   if (c->opts.other_dir) {
      if (chdir(c->opts.other_dir)) {
         console_error("c2c: cannot chdir to %s: %s", c->opts.other_dir, strerror((*__errno_location())));
         exit(EXIT_FAILURE);
      }
   }
   if (string_list_List_length(&c->opts.files)) {
      const char* basename = string_utils_getBasename(string_list_List_get(&c->opts.files, 0));
      const char* ext = string_utils_getExtension(basename);
      uint32_t target_idx = string_pool_Pool_add(c->auxPool, basename, ((uint32_t)((ext - basename))), true);
      build_target_BackEndKind backend = build_target_BackEndKind_C;
      if (c->opts.use_qbe_backend) backend = build_target_BackEndKind_QBE;
      if (c->opts.use_ir_backend) backend = build_target_BackEndKind_IR;
      build_target_Target* t = c2recipe_Recipe_addTarget(c->recipe, target_idx, 0, build_target_Kind_Executable);
      build_target_Target_setBackEnd(t, backend);
      for (uint32_t i = 0; (i < string_list_List_length(&c->opts.files)); i++) build_target_Target_addFile(t, string_list_List_get_idx(&c->opts.files, i), 0);
      build_target_Target_disableWarnings(t);
   } else {
      if (!utils_findProjectDir(&c->path_info)) {
         console_error("c2c: error: cannot find project root directory\n     c2c requires a %s file in the project root,\n     Use argument -h for c2c usage and a list of available options", constants_recipe_name);
         exit(EXIT_FAILURE);
      }
      uint32_t recipe_idx = string_pool_Pool_addStr(c->auxPool, constants_recipe_name, false);
      c->recipe_id = source_mgr_SourceMgr_open(c->sm, recipe_idx, 0, false);
      if ((c->recipe_id == -1)) exit(EXIT_FAILURE);
      if (!c2recipe_Recipe_parse(c->recipe, c->recipe_id)) exit(EXIT_FAILURE);
   }
   if (!c->opts.build_file) {
      c->opts.build_file = utils_findBuildFile();
   }
   c->plugins = plugin_mgr_create(c->auxPool, c->opts.print_timing, c->opts.log_verbose, c->opts.no_plugins);
   if (c->opts.build_file) {
      console_log("using build-file %s", c->opts.build_file);
      c->build_info = build_file_parse(c->sm, c->auxPool, c->opts.build_file);
      if (!c->build_info) exit(EXIT_FAILURE);
      const string_list_List* plugin_dirs = build_file_Info_getPluginDirs(c->build_info);
      for (uint32_t i = 0; (i < string_list_List_length(plugin_dirs)); i++) {
         plugin_mgr_Mgr_addPath(c->plugins, string_list_List_get_idx(plugin_dirs, i));
      }
      if (!c->opts.show_plugins) {
         for (uint32_t i = 0; (i < build_file_Info_getNumPlugins(c->build_info)); i++) {
            const build_file_Plugin* p = build_file_Info_getPlugin(c->build_info, i);
            if (!plugin_mgr_Mgr_loadGlobal(c->plugins, p->name, p->options)) {
               source_mgr_Location loc = source_mgr_SourceMgr_locate(c->sm, p->loc);
               char loc_str[256];
               sprintf(loc_str, "%s:%u:%u", loc.filename, loc.line, loc.column);
               console_error_diag(loc_str, "%s", plugin_mgr_Mgr_getError(c->plugins));
               exit(EXIT_FAILURE);
            }
         }
      }
   } else {
      const char* plugin_dir = getenv("C2_PLUGINDIR");
      if (plugin_dir) {
         uint32_t path_name = string_pool_Pool_addStr(c->auxPool, plugin_dir, true);
         plugin_mgr_Mgr_addPath(c->plugins, path_name);
      }
   }
   const char* libdir = getenv("C2_LIBDIR");
   if (libdir) c->comp_opts.libdir = string_pool_Pool_addStr(c->auxPool, libdir, true);
   if ((!libdir && !c->opts.build_file)) {
      console_warn("environment variable C2_LIBDIR not set!");
   }
}

static void c2c_main_Context_handle_plugins(c2c_main_Context* c)
{
   if (c->opts.show_plugins) {
      plugin_mgr_Mgr_show(c->plugins);
      exit(EXIT_SUCCESS);
   }
   c->pl = c2recipe_Recipe_getPlugins(c->recipe);
   for (uint32_t i = 0; (i < build_target_PluginList_size(c->pl)); i++) {
      const build_target_Plugin* p = build_target_PluginList_get(c->pl, i);
      if (!plugin_mgr_Mgr_loadGlobal(c->plugins, p->name, p->options)) {
         source_mgr_Location loc = source_mgr_SourceMgr_locate(c->sm, p->loc);
         char loc_str[256];
         sprintf(loc_str, "%s:%u:%u", loc.filename, loc.line, loc.column);
         console_error_diag(loc_str, "%s", plugin_mgr_Mgr_getError(c->plugins));
         exit(EXIT_FAILURE);
      }
   }
   c->plugins_feature = string_pool_Pool_addStr(c->auxPool, "C2_PLUGINS", false);
   compiler_PluginHandler pluginHandler = { .start_target = c2c_main_plugins_start_target, .after_parsing = c2c_main_plugins_after_parsing, .after_analysis = c2c_main_plugins_after_analysis, .end_target = c2c_main_plugins_end_target, .arg = c->plugins };
   c->pluginHandler = pluginHandler;
}

static _Bool c2c_main_Context_build_target(c2c_main_Context* c, build_target_Target* target, const char* target_name)
{
   uint32_t num_errors = diagnostics_Diags_getNumErrors(c->diags);
   if (c->opts.force_warnings) build_target_Target_enableWarnings(target);
   if (c->opts.output_name) {
      console_log("building %s as %s", target_name, c->opts.output_name);
      target_name = c->opts.output_name;
      build_target_Target_setNameIdx(target, string_pool_Pool_addStr(c->auxPool, target_name, true));
   } else {
      console_log("building %s", target_name);
   }
   c->comp_opts.trace_calls = c->opts.trace_calls;
   if ((c->opts.trace_calls && build_target_Target_getNoLibC(target))) {
      c->comp_opts.trace_calls = false;
      console_warn("c2c: disabling --trace-calls for nolibc target %s", target_name);
   }
   c->pl = build_target_Target_getPlugins(target);
   for (uint32_t j = 0; (j < build_target_PluginList_size(c->pl)); j++) {
      const build_target_Plugin* p = build_target_PluginList_get(c->pl, j);
      if (!plugin_mgr_Mgr_loadLocal(c->plugins, p->name, p->options)) {
         source_mgr_Location loc = source_mgr_SourceMgr_locate(c->sm, p->loc);
         char loc_str[256];
         sprintf(loc_str, "%s:%u:%u", loc.filename, loc.line, loc.column);
         console_error_diag(loc_str, "%s", plugin_mgr_Mgr_getError(c->plugins));
         continue;
      }
   }
   if (!c->opts.no_plugins) build_target_Target_addFeature(target, c->plugins_feature);
   if (c->opts.use_ir_backend) build_target_Target_setBackEnd(target, build_target_BackEndKind_IR);
   if (!build_target_Target_hasBackEnd(target)) {
      if ((!c->comp_opts.test_mode && !c->comp_opts.check_only)) {
         console_error("c2c: no backend for target %s defined in %s", target_name, constants_recipe_name);
         if ((c->recipe_id != -1)) source_mgr_SourceMgr_clear(c->sm, c->recipe_id);
         return false;
      }
   }
   compiler_build(c->auxPool, c->sm, c->diags, c->build_info, target, &c->comp_opts, &c->pluginHandler);
   if ((c->recipe_id != -1)) source_mgr_SourceMgr_clear(c->sm, c->recipe_id);
   return (diagnostics_Diags_getNumErrors(c->diags) > num_errors);
}

static _Bool c2c_main_Context_build_targets(c2c_main_Context* c)
{
   _Bool has_filter = ((string_list_List_length(&c->opts.targets) != 0));
   _Bool hasError = false;
   for (uint32_t i = 0; (i < c2recipe_Recipe_numTargets(c->recipe)); i++) {
      build_target_Target* target = c2recipe_Recipe_getTarget(c->recipe, i);
      uint32_t target_idx = build_target_Target_getNameIdx(target);
      const char* target_name = string_pool_Pool_idx2str(c->auxPool, target_idx);
      if (has_filter) {
         if (!string_list_List_contains_idx(&c->opts.targets, target_idx)) continue;

         string_list_List_del(&c->opts.targets, target_idx);
      }
      if (c->opts.show_targets) {
         console_log("%s", target_name);
         continue;
      }
      hasError |= c2c_main_Context_build_target(c, target, target_name);
   }
   if ((has_filter && string_list_List_length(&c->opts.targets))) {
      for (uint32_t i = 0; (i < string_list_List_length(&c->opts.targets)); i++) {
         const char* name = string_list_List_get(&c->opts.targets, i);
         console_warn("no such target in %s: %s", constants_recipe_name, name);
      }
   }
   return hasError;
}

static void c2c_main_Context_free(c2c_main_Context* c)
{
   plugin_mgr_Mgr_free(c->plugins);
   if (c->build_info) build_file_Info_free(c->build_info);
   c2recipe_Recipe_free(c->recipe);
   c2c_main_Options_free(&c->opts);
   diagnostics_Diags_free(c->diags);
   source_mgr_SourceMgr_free(c->sm);
   string_pool_Pool_free(c->auxPool);
}

int32_t main(int32_t argc, char** argv)
{
   console_init();
   c2c_main_Context c; c2c_main_Context_init(&c);
   c2c_main_Context_handle_args(&c, argc, argv);
   c2c_main_Context_handle_plugins(&c);
   _Bool hasError = c2c_main_Context_build_targets(&c);
   c2c_main_Context_free(&c);
   return hasError ? -1 : 0;
}

