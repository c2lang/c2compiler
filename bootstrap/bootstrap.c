// WARNING: this file is auto-generated by the C2 compiler.
// Any changes you make might be lost!

#ifndef EXTERNAL_H
#define EXTERNAL_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wincompatible-library-redeclaration"
#  pragma clang diagnostic ignored "-Wunknown-warning-option"
#  pragma clang diagnostic ignored "-Wparentheses-equality"
#  pragma clang diagnostic ignored "-Wsometimes-uninitialized"
#  pragma clang diagnostic ignored "-Wtypedef-redefinition"
#  pragma clang diagnostic ignored "-Wstring-plus-int"
#  if (__clang_major__ >= 10)
#    define fallthrough  __attribute__((fallthrough))
#  endif
#elif defined(__GNUC__)
#  if (__GNUC__ >= 11)
#    define fallthrough  [[fallthrough]]
#  elif (__GNUC__ >= 7)
#    define fallthrough  __attribute__((fallthrough))
#  endif
#  pragma GCC diagnostic ignored "-Wmain"
#  if (__GNUC__ >= 10)
#    pragma GCC diagnostic ignored "-Wzero-length-bounds"
#  endif
#  if (__GNUC__ >= 7)
#    pragma GCC diagnostic ignored "-Wformat-overflow"
#    pragma GCC diagnostic ignored "-Wstringop-overflow"
#  endif
#endif

#ifndef fallthrough
#  define fallthrough
#endif

// --- internally added ---
#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 202311L
#define bool _Bool
#define true 1
#define false 0
#endif
typedef signed char int8_t;
typedef unsigned char uint8_t;
typedef signed short int16_t;
typedef unsigned short uint16_t;
typedef signed int int32_t;
typedef unsigned int uint32_t;
typedef signed long int64_t;
typedef unsigned long uint64_t;
typedef signed long ssize_t;
typedef unsigned long size_t;

#define NULL ((void*)0)
#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))
#define offsetof(type, member) __builtin_offsetof(type, member)
#define to_container(type, member, ptr) ((type*)((char*)(ptr) - offsetof(type, member)))

static int c2_strswitch(const char* s1, const char* s2) {
    if (!s1) return 0;  // nil
    if (!*s1) return 1; // ""
    int idx = 2;
    while (*s2) {
        unsigned len = *s2++ & 0xFF;
        for (unsigned i = 0;; i++) {
            if (i == len) {
                if (s1[i] == '\0')
                    return idx;
                break;
            }
            if (s1[i] != s2[i])
                break;
        }
        s2 += len;
        idx++;
    }
    return idx;
}
#endif

// --- module c2 ---

#define c2_max_i32 2147483647
#define c2_min_i64 (-9223372036854775807L - 1)
#define c2_max_u64 0xffffffffffffffffUL


// --- module i32 ---

#define i32_max 2147483647


// --- module i64 ---

#define i64_max 9223372036854775807L


// --- module u32 ---

#define u32_max 0xffffffffU


// --- module u64 ---

#define u64_max 18446744073709551615UL


// --- module varargs ---
// Note: this module is a special case and is custom generated
#define va_list __builtin_va_list
#define va_start __builtin_va_start
#define va_end __builtin_va_end


// --- module c_errno ---

extern int* __errno_location(void);
#define c_errno_ENOENT 2
#define c_errno_EINTR 4
#define c_errno_ENOMEM 12
#define c_errno_EEXIST 17
#define c_errno_ENAMETOOLONG 36


// --- module csetjmp ---
typedef struct __jmp_buf_tag_ __jmp_buf_tag;

struct __jmp_buf_tag_ {
   char data[200];
};

typedef __jmp_buf_tag* jmp_buf;
int32_t setjmp(jmp_buf __env);
__attribute__((noreturn))
void longjmp(jmp_buf __env, int32_t __val);


// --- module ctype ---

int isalnum(int c);
int isalpha(int c);
int isdigit(int c);
int islower(int c);
int isprint(int c);
int isspace(int c);
int isupper(int c);
int isxdigit(int c);
int toupper(int c);
int isblank(int c);


// --- module libc_dirent ---
typedef struct DIR_ DIR;
typedef struct dirent_ dirent;

struct DIR_ {
};

typedef int32_t (*FilterFn)(const dirent* _arg0);

typedef int32_t (*DirentCompareFn)(const dirent** _arg0, const dirent** _arg1);

struct dirent_ {
   unsigned long long d_ino;
   long long d_off;
   unsigned short d_reclen;
   uint8_t d_type;
   char d_name[256];
};

#define libc_dirent_DT_DIR 4
#define libc_dirent_DT_REG 8
DIR* opendir(const char* name);
int closedir(DIR* dirp);
dirent* readdir(DIR* dirp);


// --- module libc_fcntl ---

#define libc_fcntl_O_BINARY 0
#define libc_fcntl_O_RDONLY 0
#define libc_fcntl_O_WRONLY 01
#define libc_fcntl_O_CREAT 0100
#define libc_fcntl_O_TRUNC 01000
#define libc_fcntl_F_SETFD 2
#define libc_fcntl_FD_CLOEXEC 1
int open(const char* __file, int __oflag, ...);
int fcntl(int32_t __fd, int __cmd, ...);


// --- module stdio ---
typedef struct _IO_marker_ _IO_marker;
typedef struct FILE_ FILE;

struct _IO_marker_ {
   _IO_marker* next;
   FILE* sbuf;
   int32_t _pos;
};

typedef uint64_t off_t;
struct FILE_ {
};

extern FILE* stdout;
extern FILE* stderr;
int fflush(FILE* __stream);
__attribute__((__format__(printf, 2, 3)))
int fprintf(FILE* __stream, const char* __format, ...);
__attribute__((__format__(printf, 1, 2)))
int printf(const char* __format, ...);
__attribute__((__format__(printf, 2, 3)))
int sprintf(char* __s, const char* __format, ...);
__attribute__((__format__(printf, 3, 4)))
int snprintf(char* __s, size_t size, const char* __format, ...);
__attribute__((__format__(scanf, 2, 3)))
int sscanf(const char* s, const char* format, ...);
int fputs(const char* __s, FILE* __stream);
int puts(const char* __s);
void perror(const char* __s);
int vsprintf(char* str, const char* format, va_list ap);
int vsnprintf(char* str, size_t size, const char* format, va_list ap);


// --- module stdlib ---
typedef struct div_t_ div_t;
typedef struct Ldiv_t_ Ldiv_t;
typedef struct random_data_ random_data;
typedef struct drand48_data_ drand48_data;

struct div_t_ {
   int quot;
   int rem;
};

struct Ldiv_t_ {
   long quot;
   long rem;
};

struct random_data_ {
};

struct drand48_data_ {
};

typedef void (*AtExitFn)(void);

typedef void (*OnExitFn)(int32_t _arg0, void* _arg1);

typedef int32_t (*__compar_fn_t)(const void* _arg0, const void* _arg1);

#define stdlib_EXIT_FAILURE 1
#define stdlib_EXIT_SUCCESS 0
void* calloc(size_t count, size_t size);
void* malloc(size_t size);
void* realloc(void* ptr, size_t size);
void free(void* ptr);
double atof(const char* nptr);
double strtod(const char* nptr, char** endptr);
__attribute__((noreturn))
void exit(int __status);
__attribute__((noreturn))
void _exit(int __status);
char* getenv(const char* __name);


// --- module string ---

void* memcpy(void* dest, const void* src, size_t n);
void* memmove(void* dest, const void* src, size_t n);
char* strcpy(char* dest, const char* src);
char* strdup(const char* s);
char* strcat(char* dest, const char* src);
int memcmp(const void* s1, const void* s2, size_t n);
int strcmp(const char* s1, const char* s2);
int strncmp(const char* s1, const char* s2, size_t n);
void* memchr(const void* s, int c, size_t n);
char* strtok(char* s1, const char* s2);
void* memset(void* s, int c, size_t n);
char* strerror(int errnum);
size_t strlen(const char* s);
int strcasecmp(const char* s1, const char* s2);


// --- module sys_stat ---

struct stat {
   unsigned long st_dev;
   unsigned long st_ino;
   unsigned long st_nlink;
   unsigned int st_mode;
   unsigned int st_uid;
   unsigned int st_gid;
   unsigned long st_rdev;
   long st_size;
   long st_blksize;
   long st_blocks;
   long st_atime;
   long st_atime_nsec;
   long st_mtime;
   long st_mtime_nsec;
   long st_ctime;
   long st_ctime_nsec;
   long reserved[3];
};

typedef uint32_t Mode;
#define sys_stat_S_IFMT 0170000
#define sys_stat_S_IFREG 0100000
#define sys_stat_S_IFDIR 040000
int fstat(int fd, struct stat* buf);
int stat(const char* pathname, struct stat* buf);
int mkdir(const char* __file, unsigned int mode);


// --- module sys_time ---
typedef struct timeval_ timeval;
typedef struct timezone_ timezone;

typedef int64_t time_t;
typedef int64_t suseconds_t;
struct timeval_ {
   time_t tv_sec;
   suseconds_t tv_usec;
};

struct timezone_ {
   int tz_minuteswest;
   int tz_dsttime;
};

int gettimeofday(timeval* tv, timezone* tz);


// --- module sys_utsname ---
typedef struct utsname_ utsname;

#define sys_utsname_NAME_LEN 65
struct utsname_ {
   char sysname[65];
   char nodename[65];
   char release[65];
   char version[65];
   char machine[65];
   char domainname[65];
};

int uname(utsname* buf);


// --- module unistd ---

typedef int32_t pid_t;
#define unistd_STDOUT_FILENO 1
#define unistd_STDERR_FILENO 2
char* getcwd(char* buf, size_t size);
int chdir(const char* path);
int close(int fd);
long read(int fd, void* buf, unsigned long count);
int isatty(int fd);
ssize_t write(int fd, const void* buf, size_t count);
int pipe(int* pipefd);
int fsync(int fd);
pid_t fork(void);
pid_t waitpid(pid_t pid, int* wstatus, int options);
int dup2(int oldfd, int newfd);
int execv(const char* pathname, char** argv);


// --- module dlfcn ---

#define dlfcn_RTLD_DEFAULT ((void*)(size_t)(0))
#define dlfcn_RTLD_NOW 0x2
#define dlfcn_RTLD_LOCAL 0
void* dlopen(const char* file, int mode);
int dlclose(void* handle);
void* dlsym(void* handle, const char* name);
char* dlerror(void);


// --- module color ---

typedef uint8_t color_Color;
enum color_Color {
   color_Color_None,
   color_Color_Black,
   color_Color_Red,
   color_Color_Green,
   color_Color_Yellow,
   color_Color_Blue,
   color_Color_Magenta,
   color_Color_Cyan,
   color_Color_Grey,
   color_Color_Darkgrey,
   color_Color_Bred,
   color_Color_Bgreen,
   color_Color_Byellow,
   color_Color_Bblue,
   color_Color_Bmagenta,
   color_Color_Bcyan,
   color_Color_White,
   color_Color_Normal,
};

#define color_Black color_Color_Black
#define color_Red color_Color_Red
#define color_Green color_Color_Green
#define color_Yellow color_Color_Yellow
#define color_Blue color_Color_Blue
#define color_Magenta color_Color_Magenta
#define color_Cyan color_Color_Cyan
#define color_Grey color_Color_Grey
#define color_Darkgrey color_Color_Darkgrey
#define color_Bred color_Color_Bred
#define color_Bgreen color_Color_Bgreen
#define color_Byellow color_Color_Byellow
#define color_Bblue color_Color_Bblue
#define color_Bmagenta color_Color_Bmagenta
#define color_Bcyan color_Color_Bcyan
#define color_White color_Color_White
#define color_Normal color_Color_Normal
static const char* color_defaultColors[18] = {
   [color_Color_None] = "",
   [color_Color_Black] = "\033[0;30m",
   [color_Color_Red] = "\033[0;31m",
   [color_Color_Green] = "\033[0;32m",
   [color_Color_Yellow] = "\033[0;33m",
   [color_Color_Blue] = "\033[0;34m",
   [color_Color_Magenta] = "\033[0;35m",
   [color_Color_Cyan] = "\033[0;36m",
   [color_Color_Grey] = "\033[0;37m",
   [color_Color_Darkgrey] = "\033[1;30m",
   [color_Color_Bred] = "\033[1;31m",
   [color_Color_Bgreen] = "\033[1;32m",
   [color_Color_Byellow] = "\033[1;33m",
   [color_Color_Bblue] = "\033[1;34m",
   [color_Color_Bmagenta] = "\033[1;35m",
   [color_Color_Bcyan] = "\033[1;36m",
   [color_Color_White] = "\033[1;37m",
   [color_Color_Normal] = "\033[0m"
};
static bool color_useColor(void);
static const char* color_Color_str(color_Color col);

static bool color_useColor(void)
{
   return isatty(1);
}

static const char* color_Color_str(color_Color col)
{
   return color_defaultColors[col];
}


// --- module constants ---

#define constants_MaxCallArgs 24
#define constants_MaxScopes 32
#define constants_MaxIdentifierLen 31
#define constants_MaxFeatureDepth 6
#define constants_MaxErrorMsgLen 127
#define constants_MaxMultiString (64 * 1024)
#define constants_MaxMultiDeclBits 4
#define constants_MaxMultiDecl ((1 << constants_MaxMultiDeclBits) - 1)
static const char* constants_output_dir = "output";
static const char* constants_recipe_name = "recipe.txt";
static const char* constants_buildfile_name = "build.yaml";
static const char* constants_manifest_name = "manifest.yaml";
static const char* constants_refs_filename = "refs";


// --- module ast_context ---
typedef struct ast_context_Block_ ast_context_Block;
typedef struct ast_context_Context_ ast_context_Context;

struct ast_context_Block_ {
   ast_context_Block* next;
   uint32_t size;
   uint32_t allocated;
   uint8_t data[0];
};

struct ast_context_Context_ {
   ast_context_Block* blk_head;
   ast_context_Block* blk_tail;
   uint32_t blk_size;
   uint32_t num_allocs;
   uint8_t* cur_data;
   uint32_t cur_size;
   uint32_t cur_allocated;
};

static ast_context_Block* ast_context_Block_create(uint32_t blk_size);
static ast_context_Block* ast_context_Block_free(ast_context_Block* b);
static void ast_context_Context_init(ast_context_Context* c, uint32_t blk_size);
static ast_context_Context* ast_context_create(uint32_t blk_size);
static void ast_context_Context_freeBlocks(ast_context_Context* c);
static void ast_context_Context_free(ast_context_Context* c);
static void* ast_context_Context_alloc(ast_context_Context* c, uint32_t len);
static void ast_context_Context_report(const ast_context_Context* c);

static ast_context_Block* ast_context_Block_create(uint32_t blk_size)
{
   ast_context_Block* b = malloc(16 + blk_size);
   b->next = NULL;
   b->size = 0;
   b->allocated = blk_size;
   return b;
}

static ast_context_Block* ast_context_Block_free(ast_context_Block* b)
{
   ast_context_Block* next = b->next;
   free(b);
   return next;
}

static void ast_context_Context_init(ast_context_Context* c, uint32_t blk_size)
{
   c->blk_head = NULL;
   c->blk_tail = NULL;
   c->blk_size = blk_size >= 1024 ? blk_size - 16 : blk_size;
   c->num_allocs = 0;
   c->cur_data = NULL;
   c->cur_size = 0;
   c->cur_allocated = 0;
}

static ast_context_Context* ast_context_create(uint32_t blk_size)
{
   ast_context_Context* c = malloc(40);
   ast_context_Context_init(c, blk_size);
   return c;
}

static void ast_context_Context_freeBlocks(ast_context_Context* c)
{
   ast_context_Block* blk = c->blk_head;
   while (blk) blk = ast_context_Block_free(blk);
   c->blk_head = c->blk_tail = NULL;
}

static void ast_context_Context_free(ast_context_Context* c)
{
   ast_context_Context_freeBlocks(c);
   free(c);
}

static void* ast_context_Context_alloc(ast_context_Context* c, uint32_t len)
{
   len = (len + 7) & ~0x7;
   c->num_allocs++;
   if (c->cur_size + len > c->cur_allocated) {
      if (!c->blk_size) c->blk_size = 16384 - 16;
      ast_context_Block* newb = ast_context_Block_create(len > c->blk_size ? len : c->blk_size);
      ast_context_Block* last = c->blk_tail;
      if (last) {
         last->size = c->cur_size;
         last->next = newb;
      } else {
         c->blk_head = newb;
      }
      c->blk_tail = newb;
      c->cur_size = 0;
      c->cur_allocated = newb->allocated;
      c->cur_data = newb->data;
   }
   void* cur = c->cur_data + c->cur_size;
   c->cur_size += len;
   return cur;
}

static void ast_context_Context_report(const ast_context_Context* c)
{
   uint32_t blocks = 0;
   uint32_t total = 0;
   uint32_t slack = 0;
   uint32_t avail = 0;
   if (c->blk_tail) c->blk_tail->size = c->cur_size;
   for (const ast_context_Block* blk = c->blk_head; blk; blk = blk->next) {
      blocks++;
      total += blk->size;
      slack += avail;
      avail = blk->allocated - blk->size;
   }
   uint32_t avg = 0;
   if (c->num_allocs) avg = total / c->num_allocs;
   printf("context: %u allocs, total %u (%u KB), avg %u bytes, %u blocks (%u), slack %u, avail %u\n", c->num_allocs, total, (total + 1023) / 1024, avg, blocks, c->blk_size, slack, avail);
}


// --- module number_radix ---

typedef uint8_t number_radix_Radix;
enum number_radix_Radix {
   number_radix_Radix_Default,
   number_radix_Radix_Hex,
   number_radix_Radix_Octal,
   number_radix_Radix_Binary,
};



// --- module src_loc ---
typedef struct src_loc_SrcRange_ src_loc_SrcRange;

typedef uint32_t src_loc_SrcLoc;
struct src_loc_SrcRange_ {
   src_loc_SrcLoc start;
   src_loc_SrcLoc end;
};



// --- module string_buffer ---
typedef struct string_buffer_Buf_ string_buffer_Buf;

struct string_buffer_Buf_ {
   uint32_t capacity;
   uint32_t size_;
   char* data_;
   bool own;
   bool grow;
   bool truncated;
   bool colors;
   uint32_t indent_step;
};

static const uint8_t string_buffer_ToHex[16] = {
   '0',
   '1',
   '2',
   '3',
   '4',
   '5',
   '6',
   '7',
   '8',
   '9',
   'A',
   'B',
   'C',
   'D',
   'E',
   'F'
};
static string_buffer_Buf* string_buffer_Buf_init(string_buffer_Buf* buf, char* data, uint32_t capacity, bool grow, bool use_colors, uint32_t indent_step);
static string_buffer_Buf* string_buffer_create(uint32_t capacity, bool use_colors, uint32_t indent_step);
static void string_buffer_Buf_deinit(string_buffer_Buf* buf);
static void string_buffer_Buf_free(string_buffer_Buf* buf);
static bool string_buffer_Buf_extend(string_buffer_Buf* buf, uint32_t len);
static void string_buffer_Buf_setColors(string_buffer_Buf* buf, bool colors);
static void string_buffer_Buf_setIndent(string_buffer_Buf* buf, uint32_t indent_step);
static uint32_t string_buffer_Buf_size(const string_buffer_Buf* buf);
static const void* string_buffer_Buf_data(const string_buffer_Buf* buf);
static const char* string_buffer_Buf_str(const string_buffer_Buf* buf);
static void* string_buffer_Buf_detach(string_buffer_Buf* buf, uint32_t* psize);
static void string_buffer_Buf_clear(string_buffer_Buf* buf);
static void string_buffer_Buf_color(string_buffer_Buf* buf, color_Color col);
static char string_buffer_Buf_at(const string_buffer_Buf* buf, uint32_t i);
static void string_buffer_Buf_add1(string_buffer_Buf* buf, char c);
static void string_buffer_Buf_add(string_buffer_Buf* buf, const char* text);
static void string_buffer_Buf_add2(string_buffer_Buf* buf, const char* text, uint32_t len);
static void string_buffer_Buf_newline(string_buffer_Buf* buf);
static void string_buffer_Buf_space(string_buffer_Buf* buf);
static void string_buffer_Buf_lparen(string_buffer_Buf* buf);
static void string_buffer_Buf_rparen(string_buffer_Buf* buf);
static void string_buffer_Buf_stripTrailingSpaces(string_buffer_Buf* buf);
__attribute__((__format__(printf, 2, 3)))
static void string_buffer_Buf_print(string_buffer_Buf* buf, const char* format, ...);
static void string_buffer_Buf_vprintf(string_buffer_Buf* buf, const char* format, va_list args);
static void string_buffer_Buf_unindent(string_buffer_Buf* buf);
static void string_buffer_Buf_indent(string_buffer_Buf* buf, uint32_t indent);
static bool string_buffer_Buf_endsWith(const string_buffer_Buf* buf, char c);
static uint32_t string_buffer_Buf_encodeBytes(string_buffer_Buf* buf, const char* p, uint32_t len, char sep);
static void string_buffer_Buf_encodeHex(string_buffer_Buf* buf, const uint8_t* data, uint32_t len);
static void string_buffer_Buf_trim(string_buffer_Buf* buf, uint32_t len);
static void string_buffer_Buf_resetToLastNewline(string_buffer_Buf* buf);

static string_buffer_Buf* string_buffer_Buf_init(string_buffer_Buf* buf, char* data, uint32_t capacity, bool grow, bool use_colors, uint32_t indent_step)
{
   ;//assert(capacity);
   buf->capacity = capacity;
   buf->size_ = 0;
   buf->data_ = data;
   buf->own = false;
   buf->truncated = false;
   buf->grow = grow;
   buf->colors = use_colors;
   buf->indent_step = indent_step;
   if (!data) {
      buf->data_ = malloc(capacity);
      buf->own = true;
   }
   return buf;
}

static string_buffer_Buf* string_buffer_create(uint32_t capacity, bool use_colors, uint32_t indent_step)
{
   string_buffer_Buf* buf = malloc(24);
   return string_buffer_Buf_init(buf, NULL, capacity, true, use_colors, indent_step);
}

static void string_buffer_Buf_deinit(string_buffer_Buf* buf)
{
   if (buf->own) free(buf->data_);
   buf->data_ = NULL;
}

static void string_buffer_Buf_free(string_buffer_Buf* buf)
{
   if (buf) {
      string_buffer_Buf_deinit(buf);
      free(buf);
   }
}

static bool string_buffer_Buf_extend(string_buffer_Buf* buf, uint32_t len)
{
   if (!buf->grow) {
      buf->truncated = true;
      return false;
   }
   uint32_t new_cap = buf->capacity * 2;
   while (buf->size_ + len + 1 > new_cap) new_cap *= 2;
   buf->capacity = new_cap;
   char* data2 = malloc(new_cap);
   memcpy(data2, buf->data_, buf->size_);
   if (buf->own) free(buf->data_);
   buf->data_ = data2;
   buf->own = true;
   return true;
}

static void string_buffer_Buf_setColors(string_buffer_Buf* buf, bool colors)
{
   buf->colors = colors;
}

static void string_buffer_Buf_setIndent(string_buffer_Buf* buf, uint32_t indent_step)
{
   buf->indent_step = indent_step;
}

static uint32_t string_buffer_Buf_size(const string_buffer_Buf* buf)
{
   return buf->size_;
}

static const void* string_buffer_Buf_data(const string_buffer_Buf* buf)
{
   buf->data_[buf->size_] = '\0';
   return buf->data_;
}

static const char* string_buffer_Buf_str(const string_buffer_Buf* buf)
{
   return string_buffer_Buf_data(buf);
}

static void* string_buffer_Buf_detach(string_buffer_Buf* buf, uint32_t* psize)
{
   *psize = buf->size_;
   buf->data_[buf->size_] = '\0';
   if (buf->own) {
      void* data = realloc(buf->data_, buf->size_ + 1);
      if (!data) data = buf->data_;
      buf->data_ = NULL;
      buf->size_ = 0;
      buf->capacity = 0;
      buf->own = false;
      return data;
   } else {
      void* data = malloc(buf->size_ + 1);
      return memcpy(data, buf->data_, buf->size_ + 1);
   }
}

static void string_buffer_Buf_clear(string_buffer_Buf* buf)
{
   buf->size_ = 0;
   buf->truncated = false;
}

static void string_buffer_Buf_color(string_buffer_Buf* buf, color_Color col)
{
   if (buf->colors) string_buffer_Buf_add(buf, color_Color_str(col));
}

static char string_buffer_Buf_at(const string_buffer_Buf* buf, uint32_t i)
{
   return i < buf->size_ ? buf->data_[i] : '\0';
}

static void string_buffer_Buf_add1(string_buffer_Buf* buf, char c)
{
   if (buf->size_ + 2 > buf->capacity) {
      if (!string_buffer_Buf_extend(buf, 1)) return;
   }
   buf->data_[buf->size_] = c;
   buf->size_ += 1;
}

static void string_buffer_Buf_add(string_buffer_Buf* buf, const char* text)
{
   uint32_t len = (uint32_t)strlen(text);
   string_buffer_Buf_add2(buf, text, len);
}

static void string_buffer_Buf_add2(string_buffer_Buf* buf, const char* text, uint32_t len)
{
   if (buf->size_ + len + 1 > buf->capacity) {
      if (!string_buffer_Buf_extend(buf, len)) len = buf->capacity - buf->size_ - 1;
   }
   memcpy(&buf->data_[buf->size_], text, len);
   buf->size_ += len;
}

static void string_buffer_Buf_newline(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, '\n');
}

static void string_buffer_Buf_space(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, ' ');
}

static void string_buffer_Buf_lparen(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, '(');
}

static void string_buffer_Buf_rparen(string_buffer_Buf* buf)
{
   string_buffer_Buf_add1(buf, ')');
}

static void string_buffer_Buf_stripTrailingSpaces(string_buffer_Buf* buf)
{
   while (buf->size_ && buf->data_[buf->size_ - 1] == ' ') buf->size_--;
}

__attribute__((__format__(printf, 2, 3)))
static void string_buffer_Buf_print(string_buffer_Buf* buf, const char* format, ...)
{
   char tmp[4096];
   va_list args;
   va_start(args, format);
   int32_t len = vsnprintf(tmp, 4096, format, args);
   va_end(args);
   ;//assert(len < 4096);
   string_buffer_Buf_add2(buf, tmp, (uint32_t)len);
}

static void string_buffer_Buf_vprintf(string_buffer_Buf* buf, const char* format, va_list args)
{
   char tmp[4096];
   int32_t len = vsnprintf(tmp, 4096, format, args);
   ;//assert(len < 4096);
   string_buffer_Buf_add2(buf, tmp, (uint32_t)len);
}

static void string_buffer_Buf_unindent(string_buffer_Buf* buf)
{
   uint32_t i = buf->indent_step;
   while (i-- > 0 && buf->size_ && buf->data_[buf->size_ - 1] == ' ') buf->size_--;
}

static void string_buffer_Buf_indent(string_buffer_Buf* buf, uint32_t indent)
{
   indent *= buf->indent_step;
   if (buf->size_ + indent + 1 > buf->capacity) {
      if (!string_buffer_Buf_extend(buf, indent)) indent = buf->capacity - buf->size_ - 1;
   }
   if (indent == 0) return;
   char* cur = buf->data_ + buf->size_;
   for (uint32_t i = 0; i < indent; i++) cur[i] = ' ';
   buf->size_ += indent;
}

static bool string_buffer_Buf_endsWith(const string_buffer_Buf* buf, char c)
{
   return (buf->size_ && buf->data_[buf->size_ - 1] == c);
}

static uint32_t string_buffer_Buf_encodeBytes(string_buffer_Buf* buf, const char* p, uint32_t len, char sep)
{
   uint32_t size = buf->size_;
   uint32_t copy = 0;
   const char* end = p + len;
   while (p < end) {
      uint8_t c = *p++;
      switch (c) {
      case '\a':
         c = 'a';
         goto add_char;
      case '\b':
         c = 'b';
         goto add_char;
      case '\f':
         c = 'f';
         goto add_char;
      case '\n':
         c = 'n';
         goto add_char;
      case '\r':
         c = 'r';
         goto add_char;
      case '\t':
         c = 't';
         goto add_char;
      case '\v':
         c = 'v';
         goto add_char;
      case '"':
      case '\'':
         if (sep && sep != c) goto normal;
         fallthrough;
      case '\\':
      add_char:
         if (copy) string_buffer_Buf_add2(buf, p - copy - 1, copy);
         string_buffer_Buf_add1(buf, '\\');
         string_buffer_Buf_add1(buf, c);
         copy = 0;
         break;
      default:
         if (c < ' ' || c >= 0x7f) {
            char arr[4];
            if (copy) string_buffer_Buf_add2(buf, p - copy - 1, copy);
            arr[0] = '\\';
            arr[1] = '0' + ((c >> 6) & 7);
            arr[2] = '0' + ((c >> 3) & 7);
            arr[3] = '0' + (c & 7);
            uint32_t esc_len = 4;
            if (c == 0 && (p == end || !(*p >= '0' && *p <= '9'))) esc_len = 2;
            string_buffer_Buf_add2(buf, arr, esc_len);
            copy = 0;
            break;
         }
      normal:
         copy++;
         break;
      }
   }
   if (copy) string_buffer_Buf_add2(buf, p - copy, copy);
   return buf->size_ - size;
}

static void string_buffer_Buf_encodeHex(string_buffer_Buf* buf, const uint8_t* data, uint32_t len)
{
   if (buf->size_ + len * 3 + 1 > buf->capacity) {
      if (!string_buffer_Buf_extend(buf, len * 3)) len = (buf->capacity - buf->size_ - 1) / 3;
   }
   char* cp = &buf->data_[buf->size_];
   for (uint32_t i = 0; i < len; i++) {
      if (i != 0) *cp++ = ' ';
      uint8_t v = data[i];
      *cp++ = string_buffer_ToHex[v >> 4];
      *cp++ = string_buffer_ToHex[v & 0xf];
   }
   buf->size_ = (uint32_t)(cp - buf->data_);
}

static void string_buffer_Buf_trim(string_buffer_Buf* buf, uint32_t len)
{
   buf->size_ = (buf->size_ >= len) ? buf->size_ - len : 0;
}

static void string_buffer_Buf_resetToLastNewline(string_buffer_Buf* buf)
{
   while (buf->size_) {
      buf->size_--;
      if (buf->data_[buf->size_] == '\n') break;
   }
}


// --- module string_pool ---
typedef struct string_pool_Pool_ string_pool_Pool;

typedef uint32_t string_pool_HashEntry;
struct string_pool_Pool_ {
   uint32_t data_size;
   uint32_t data_capacity;
   char* data;
   uint32_t num_adds;
   uint32_t total_size;
   uint32_t hash_count;
   uint32_t hash_mask;
   uint32_t entry_size;
   uint32_t entry_capacity;
   string_pool_HashEntry* entries;
};

#define string_pool_NEXT_SHIFT 17
#define string_pool_INDEX_BITS ((1 << string_pool_NEXT_SHIFT) - 1)
#define string_pool_INDEX_SHIFT 2
#define string_pool_DATA_ALIGN (1 << string_pool_INDEX_SHIFT)
#define string_pool_HASH_INITIAL 13
#define string_pool_HASH_PRIME 17
static string_pool_Pool* string_pool_create(uint32_t data_capacity, uint32_t hash_size);
static void string_pool_Pool_free(string_pool_Pool* p);
static uint32_t string_pool_hash(const char* text, size_t len);
static const char* string_pool_Pool_idx2str(const string_pool_Pool* p, uint32_t idx);
static bool string_pool_same_string(const char* left, const char* right, size_t rlen);
static uint32_t string_pool_Pool_add(string_pool_Pool* p, const char* text, size_t len, bool filter);
static uint32_t string_pool_Pool_addStr(string_pool_Pool* p, const char* text, bool filter);
static void string_pool_Pool_resize_data(string_pool_Pool* p, uint32_t capacity);
static void string_pool_Pool_resize_entries(string_pool_Pool* p, uint32_t capacity);
static void string_pool_Pool_report(const string_pool_Pool* p, const char* name);

static string_pool_Pool* string_pool_create(uint32_t data_capacity, uint32_t hash_size)
{
   string_pool_Pool* p = calloc(1, 48);
   string_pool_Pool_resize_data(p, data_capacity);
   p->data[0] = 0;
   p->data_size = string_pool_DATA_ALIGN;
   if (hash_size & (hash_size - 1)) {
      hash_size |= hash_size >> 16;
      hash_size |= hash_size >> 8;
      hash_size |= hash_size >> 4;
      hash_size |= hash_size >> 2;
      hash_size |= hash_size >> 1;
      hash_size += 1;
   }
   if (hash_size < 256) hash_size = 256;
   p->hash_mask = hash_size - 1;
   p->entry_size = hash_size;
   p->entry_capacity = hash_size * 2;
   p->entries = calloc(p->entry_capacity, 4);
   return p;
}

static void string_pool_Pool_free(string_pool_Pool* p)
{
   free(p->entries);
   free(p->data);
   free(p);
}

static uint32_t string_pool_hash(const char* text, size_t len)
{
   uint32_t result = string_pool_HASH_INITIAL;
   for (uint32_t i = 0; i < len; i++) {
      result = result ^ text[i];
      result *= string_pool_HASH_PRIME;
   }
   return result;
}

static const char* string_pool_Pool_idx2str(const string_pool_Pool* p, uint32_t idx)
{
   return p->data + idx;
}

static bool string_pool_same_string(const char* left, const char* right, size_t rlen)
{
   for (uint32_t i = 0; i < rlen; i++) {
      if (left[i] != right[i]) return false;
   }
   return (left[rlen] == '\0');
}

static uint32_t string_pool_Pool_add(string_pool_Pool* p, const char* text, size_t len, bool filter)
{
   p->num_adds++;
   p->total_size += len + 1;
   if (filter) {
      size_t i = string_pool_hash(text, len) & p->hash_mask;
      string_pool_HashEntry v = p->entries[i];
      if (v != 0) {
         string_pool_HashEntry next;
         for (;;) {
            uint32_t index = (v & string_pool_INDEX_BITS) << string_pool_INDEX_SHIFT;
            const char* word = p->data + index;
            if (string_pool_same_string(word, text, len)) return index;
            next = v >> string_pool_NEXT_SHIFT;
            if (next == 0) break;
            i = next;
            v = p->entries[i];
         }
         next = p->entry_size;
         if (next == p->entry_capacity) {
            string_pool_Pool_resize_entries(p, p->entry_capacity * 2);
         }
         p->entries[i] = v | (next << string_pool_NEXT_SHIFT);
         p->entry_size++;
         i = next;
      }
      p->entries[i] = (p->data_size >> string_pool_INDEX_SHIFT);
      p->hash_count++;
   }
   while (p->data_size + len + 1 > p->data_capacity) {
      if (text >= p->data && text < p->data + p->data_size) {
         ssize_t offset = text - p->data;
         string_pool_Pool_resize_data(p, p->data_capacity * 2);
         text = p->data + offset;
      } else {
         string_pool_Pool_resize_data(p, p->data_capacity * 2);
      }
   }
   uint32_t idx = p->data_size;
   char* dest = p->data + idx;
   memcpy(dest, text, len);
   dest[len] = 0;
   p->data_size += len / string_pool_DATA_ALIGN * string_pool_DATA_ALIGN + string_pool_DATA_ALIGN;
   return idx;
}

static uint32_t string_pool_Pool_addStr(string_pool_Pool* p, const char* text, bool filter)
{
   return string_pool_Pool_add(p, text, strlen(text), filter);
}

static void string_pool_Pool_resize_data(string_pool_Pool* p, uint32_t capacity)
{
   p->data_capacity = capacity;
   char* data2 = malloc(capacity);
   if (p->data_size) {
      memcpy(data2, p->data, p->data_size);
      free(p->data);
   }
   p->data = data2;
}

static void string_pool_Pool_resize_entries(string_pool_Pool* p, uint32_t capacity)
{
   string_pool_HashEntry* entries = malloc(capacity * 4);
   if (p->entries) {
      memcpy(entries, p->entries, p->entry_size * 4);
      free(p->entries);
   }
   p->entry_capacity = capacity;
   p->entries = entries;
}

static void string_pool_Pool_report(const string_pool_Pool* p, const char* name)
{
   uint32_t max = 0;
   uint32_t min = 999;
   uint32_t hash_size = p->hash_mask + 1;
   uint32_t count = 0;
   uint32_t cc[256] = { };
   for (uint32_t i = 0; i < hash_size; i++) {
      string_pool_HashEntry v = p->entries[i];
      if (v != 0) {
         uint32_t num = 1;
         while (v >> string_pool_NEXT_SHIFT) {
            num++;
            v = p->entries[v >> string_pool_NEXT_SHIFT];
         }
         count += num;
         if (num < 256) cc[num]++;
         if (num) {
            if (num > max) max = num;
            if (num < min) min = num;
         }
      }
   }
   printf("%s: count %u, adds %u, data %u/%u\n", name, p->hash_count, p->num_adds, p->data_size, p->data_capacity);
   printf("  hash: entries: %u/%u/%u/%u, min %u, max %u, avg %.2f, memory %u\n", hash_size, count, p->entry_size, p->entry_capacity, min, max, count ? (count + 0.0) / (hash_size - cc[0]) : 0.0, p->entry_capacity * 4);
   printf("  buckets: %u", cc[0]);
   for (uint32_t i = 1; i <= max; i++) printf(", %u", cc[i]);
   printf("\n");
}


// --- module yaml ---
typedef struct yaml_Node_ yaml_Node;
typedef struct yaml_StackLevel_ yaml_StackLevel;
typedef struct yaml_Data_ yaml_Data;
typedef struct yaml_Iter_ yaml_Iter;
typedef struct yaml_Location_ yaml_Location;
typedef struct yaml_Token_ yaml_Token;
typedef struct yaml_Tokenizer_ yaml_Tokenizer;
typedef struct yaml_Parser_ yaml_Parser;

typedef uint8_t yaml_NodeKind;
enum yaml_NodeKind {
   yaml_NodeKind_Unknown,
   yaml_NodeKind_Scalar,
   yaml_NodeKind_Map,
   yaml_NodeKind_Sequence,
};

struct yaml_Node_ {
   yaml_NodeKind kind;
   uint32_t next_idx;
   uint32_t name_idx;
   union {
      uint32_t text_idx;
      uint32_t child_idx;
   };
};

struct yaml_StackLevel_ {
   int32_t indent;
   yaml_Node* node;
   yaml_Node* last_child;
};

struct yaml_Data_ {
   char* text;
   uint32_t text_size;
   uint32_t text_cur;
   yaml_Node* nodes;
   uint32_t nodes_count;
   uint32_t nodes_cur;
   yaml_StackLevel* stack;
};

#define yaml_MaxDepth 8
#define yaml_MinText 256
#define yaml_MinNodes 32
static const char* yaml_node_names[4] = { [yaml_NodeKind_Unknown] = "UNK", [yaml_NodeKind_Scalar] = "SCA", [yaml_NodeKind_Map] = "MAP", [yaml_NodeKind_Sequence] = "SEQ" };
static void yaml_Data_init(yaml_Data* d, uint32_t text_size, uint32_t nodes_count, yaml_StackLevel* stack);
static void yaml_Data_destroy(yaml_Data* d);
static void yaml_Data_resize_nodes(yaml_Data* d);
static void yaml_Data_resize_text(yaml_Data* d);
static yaml_Node* yaml_Data_add_node(yaml_Data* d, yaml_NodeKind kind, uint32_t name_idx);
static inline
uint32_t yaml_Data_node2idx(const yaml_Data* d, const yaml_Node* n);
static uint32_t yaml_Data_add_text(yaml_Data* d, const char* text, uint32_t len);
static yaml_Node* yaml_Data_idx2node(const yaml_Data* d, uint32_t idx);
static void yaml_Parser_dump(const yaml_Parser* p, bool verbose);
static void yaml_Data_dump(const yaml_Data* d, bool verbose);
static void yaml_Data_dump_node(const yaml_Data* d, const yaml_Node* n, int32_t indent);
struct yaml_Iter_ {
   const void* data;
   const yaml_Node* node;
};

static bool yaml_Node_isMap(const yaml_Node* n);
static bool yaml_Node_isSequence(const yaml_Node* n);
static bool yaml_Node_isScalar(const yaml_Node* n);
static const yaml_Node* yaml_Parser_getRoot(const yaml_Parser* p);
static const char* yaml_Parser_getScalarValue(const yaml_Parser* p, const char* path);
static const yaml_Node* yaml_Parser_findNode(const yaml_Parser* p, const char* path);
static const yaml_Node* yaml_Data_findNode(const yaml_Data* d, const char* path);
static const yaml_Node* yaml_Data_findChildNode(const yaml_Data* d, const char* path, uint32_t next);
static yaml_Iter yaml_Parser_getNodeChildIter(const yaml_Parser* p, const yaml_Node* n);
static void yaml_Iter_next(yaml_Iter* iter);
static bool yaml_Iter_done(const yaml_Iter* iter);
static const char* yaml_Iter_getName(const yaml_Iter* iter);
static const char* yaml_Iter_getValue(const yaml_Iter* iter);
static yaml_Iter yaml_Iter_getChildIter(yaml_Iter* parent);
static const char* yaml_Iter_getChildScalarValue(yaml_Iter* iter, const char* path);
static const char* yaml_starts_with(const char* full, const char* start);
struct yaml_Location_ {
   uint32_t line;
   uint32_t column;
};

typedef uint8_t yaml_TokenKind;
enum yaml_TokenKind {
   yaml_TokenKind_None,
   yaml_TokenKind_Plain_Scalar,
   yaml_TokenKind_Single_Quoted_Scalar,
   yaml_TokenKind_Double_Quoted_Scalar,
   yaml_TokenKind_Colon,
   yaml_TokenKind_Dash,
   yaml_TokenKind_Indent,
   yaml_TokenKind_Dedent,
   yaml_TokenKind_Doc_Start,
   yaml_TokenKind_Doc_End,
   yaml_TokenKind_Directive,
   yaml_TokenKind_Eof,
   yaml_TokenKind_Error,
};

struct yaml_Token_ {
   yaml_Location loc;
   yaml_TokenKind kind;
   bool same_line;
   union {
      const char* error_msg;
      uint32_t text_idx;
      int32_t indent;
   };
};

struct yaml_Tokenizer_ {
   const char* cur;
   const char* input_start;
   const char* line_start;
   char* error_msg;
   uint32_t line_number;
   int32_t cur_indent;
   bool same_line;
   yaml_Data* data;
   yaml_Token next;
};

static const char* yaml_token_names[13] = {
   [yaml_TokenKind_None] = "none",
   [yaml_TokenKind_Plain_Scalar] = "scalar",
   [yaml_TokenKind_Single_Quoted_Scalar] = "'scalar'",
   [yaml_TokenKind_Double_Quoted_Scalar] = "\"scalar\"",
   [yaml_TokenKind_Colon] = ":",
   [yaml_TokenKind_Dash] = "-",
   [yaml_TokenKind_Indent] = "indent",
   [yaml_TokenKind_Dedent] = "dedent",
   [yaml_TokenKind_Doc_Start] = "---",
   [yaml_TokenKind_Doc_End] = "...",
   [yaml_TokenKind_Directive] = "%",
   [yaml_TokenKind_Eof] = "eof",
   [yaml_TokenKind_Error] = "error"
};
static const char* yaml_Token_str(const yaml_Token* tok);
static void yaml_Tokenizer_init(yaml_Tokenizer* t, const char* input, yaml_Data* d, char* error_msg);
static void yaml_Tokenizer_lex(yaml_Tokenizer* t, yaml_Token* result);
static yaml_Token* yaml_Tokenizer_lex_next(yaml_Tokenizer* t);
static bool yaml_Tokenizer_lex_indent(yaml_Tokenizer* t, yaml_Token* result);
static void yaml_Tokenizer_lex_comment(yaml_Tokenizer* t);
static void yaml_Tokenizer_lex_directive(yaml_Tokenizer* t, yaml_Token* result);
static void yaml_Tokenizer_lex_quoted_string(yaml_Tokenizer* t, yaml_Token* result, char delim);
static bool yaml_is_string(char c);
static void yaml_Tokenizer_lex_string(yaml_Tokenizer* t, yaml_Token* result);
__attribute__((__format__(printf, 3, 4)))
static void yaml_Tokenizer_error(yaml_Tokenizer* t, yaml_Token* result, const char* format, ...);
#define yaml_MaxDiag 256
struct yaml_Parser_ {
   yaml_Token token;
   yaml_Tokenizer tokenizer;
   int32_t cur_indent;
   bool doc_started;
   bool in_document;
   yaml_StackLevel stack[8];
   uint32_t stack_size;
   yaml_Data data;
   __jmp_buf_tag jmp_err;
   char message[256];
};

static yaml_Parser* yaml_Parser_create(void);
static void yaml_Parser_destroy(yaml_Parser* p);
static bool yaml_Parser_parse(yaml_Parser* p, const char* input);
static const char* yaml_Parser_getMessage(const yaml_Parser* p);
__attribute__((__format__(printf, 2, 3)))
static void yaml_Parser_error(yaml_Parser* p, const char* format, ...);
static void yaml_Parser_consumeToken(yaml_Parser* p);
static void yaml_Parser_expectAndConsume(yaml_Parser* p, yaml_TokenKind kind);
static void yaml_Parser_parse_doc(yaml_Parser* p);
static void yaml_Parser_parse_node(yaml_Parser* p);
static void yaml_Parser_parse_value(yaml_Parser* p);
static void yaml_Parser_parse_node_or_value(yaml_Parser* p);
static void yaml_Parser_doc_start(yaml_Parser* p);
static void yaml_Parser_doc_end(yaml_Parser* p);
static void yaml_Parser_add_scalar_value(yaml_Parser* p, uint32_t value_idx);
static void yaml_Parser_pop(yaml_Parser* p);
static void yaml_Parser_push_root(yaml_Parser* p);
static void yaml_Parser_push_node(yaml_Parser* p, yaml_Node* n, yaml_NodeKind parent_kind, int32_t indent);

static void yaml_Data_init(yaml_Data* d, uint32_t text_size, uint32_t nodes_count, yaml_StackLevel* stack)
{
   if (text_size < yaml_MinText) text_size = yaml_MinText;
   d->text = malloc(text_size);
   d->text_size = text_size;
   d->text_cur = 1;
   d->text[0] = '\0';
   if (nodes_count < yaml_MinNodes) nodes_count = yaml_MinNodes;
   d->nodes = malloc(nodes_count * 16);
   d->nodes_count = nodes_count;
   d->nodes_cur = 1;
   memset(&d->nodes[0], 0, 16);
   d->stack = stack;
}

static void yaml_Data_destroy(yaml_Data* d)
{
   free(d->text);
   free(d->nodes);
}

static void yaml_Data_resize_nodes(yaml_Data* d)
{
   d->nodes_count *= 2;
   yaml_Node* nodes2 = malloc(d->nodes_count * 16);
   memcpy(nodes2, d->nodes, d->nodes_cur * 16);
   for (uint32_t i = 0; i < yaml_MaxDepth; i++) {
      yaml_StackLevel* sl = &d->stack[i];
      if (sl->node) {
         ssize_t node_idx = sl->node - d->nodes;
         sl->node = &nodes2[node_idx];
      }
      if (sl->last_child) {
         ssize_t last_child_idx = sl->last_child - d->nodes;
         sl->last_child = &nodes2[last_child_idx];
      }
   }
   free(d->nodes);
   d->nodes = nodes2;
}

static void yaml_Data_resize_text(yaml_Data* d)
{
   d->text_size *= 2;
   char* text2 = malloc(d->text_size);
   memcpy(text2, d->text, d->text_cur);
   free(d->text);
   d->text = text2;
}

static yaml_Node* yaml_Data_add_node(yaml_Data* d, yaml_NodeKind kind, uint32_t name_idx)
{
   if (d->nodes_cur >= d->nodes_count - 1) yaml_Data_resize_nodes(d);
   yaml_Node* result = &d->nodes[d->nodes_cur];
   d->nodes_cur++;
   result->kind = kind;
   result->next_idx = 0;
   result->name_idx = name_idx;
   result->child_idx = 0;
   return result;
}

static inline
uint32_t yaml_Data_node2idx(const yaml_Data* d, const yaml_Node* n)
{
   return (uint32_t)(n - d->nodes);
}

static uint32_t yaml_Data_add_text(yaml_Data* d, const char* text, uint32_t len)
{
   uint32_t idx = d->text_cur;
   while (idx + len + 1 >= d->text_size) yaml_Data_resize_text(d);
   memcpy(d->text + idx, text, len);
   d->text[idx + len] = '\0';
   d->text_cur += len + 1;
   return idx;
}

static yaml_Node* yaml_Data_idx2node(const yaml_Data* d, uint32_t idx)
{
   return &d->nodes[idx];
}

static void yaml_Parser_dump(const yaml_Parser* p, bool verbose)
{
   yaml_Data_dump(&p->data, verbose);
}

static void yaml_Data_dump(const yaml_Data* d, bool verbose)
{
   uint32_t node_count = d->nodes_cur;
   if (verbose) {
      printf("Text %u/%u\n", d->text_cur, d->text_size);
      const char* cp = d->text + 1;
      const char* end = d->text + d->text_cur;
      while (cp < end) {
         uint32_t len = (uint32_t)strlen(cp);
         uint32_t offset = (uint32_t)(cp - d->text);
         printf("  [%3u] %s\n", offset, cp);
         cp += len + 1;
      }
      printf("Nodes %u/%u\n", node_count, d->nodes_count);
      for (uint32_t i = 1; i < node_count; i++) {
         const yaml_Node* n = &d->nodes[i];
         printf("  [%2u] %s  next %3u  name %3u  value/child %3u\n", i, yaml_node_names[n->kind], n->next_idx, n->name_idx, n->text_idx);
      }
   }
   if (node_count > 1) yaml_Data_dump_node(d, &d->nodes[1], 0);
}

static void yaml_Data_dump_node(const yaml_Data* d, const yaml_Node* n, int32_t indent)
{
   for (int32_t i = 0; i < indent; i++) printf("   ");
   printf("[%2u] %s", yaml_Data_node2idx(d, n), yaml_node_names[n->kind]);
   printf("  name: ");
   if (n->name_idx) printf("%s", &d->text[n->name_idx]);
   else printf("-");
   printf("  value: ");
   switch (n->kind) {
   case yaml_NodeKind_Unknown:
      printf("-\n");
      break;
   case yaml_NodeKind_Scalar:
      if (n->text_idx) printf("%s", &d->text[n->text_idx]);
      printf("\n");
      break;
   case yaml_NodeKind_Map:
   case yaml_NodeKind_Sequence:
      printf("-\n");
      if (n->child_idx) yaml_Data_dump_node(d, yaml_Data_idx2node(d, n->child_idx), indent + 1);
      break;
   }
   if (n->next_idx) {
      yaml_Data_dump_node(d, yaml_Data_idx2node(d, n->next_idx), indent);
   }
}

static bool yaml_Node_isMap(const yaml_Node* n)
{
   return n->kind == yaml_NodeKind_Map;
}

static bool yaml_Node_isSequence(const yaml_Node* n)
{
   return n->kind == yaml_NodeKind_Sequence;
}

static bool yaml_Node_isScalar(const yaml_Node* n)
{
   return n->kind == yaml_NodeKind_Scalar;
}

static const yaml_Node* yaml_Parser_getRoot(const yaml_Parser* p)
{
   uint32_t node_count = p->data.nodes_cur;
   if (node_count <= 1) return NULL;
   return &p->data.nodes[1];
}

static const char* yaml_Parser_getScalarValue(const yaml_Parser* p, const char* path)
{
   const yaml_Node* n = yaml_Parser_findNode(p, path);
   if (n && yaml_Node_isScalar(n)) return &p->data.text[n->text_idx];
   return NULL;
}

static const yaml_Node* yaml_Parser_findNode(const yaml_Parser* p, const char* path)
{
   return yaml_Data_findNode(&p->data, path);
}

static const yaml_Node* yaml_Data_findNode(const yaml_Data* d, const char* path)
{
   uint32_t node_count = d->nodes_cur;
   if (node_count <= 1) return NULL;
   const yaml_Node* root = &d->nodes[1];
   if (root->kind == yaml_NodeKind_Sequence) return NULL;
   return yaml_Data_findChildNode(d, path, root->child_idx);
}

static const yaml_Node* yaml_Data_findChildNode(const yaml_Data* d, const char* path, uint32_t next)
{
   while (next) {
      const yaml_Node* node = yaml_Data_idx2node(d, next);
      if (node->name_idx) {
         const char* name = &d->text[node->name_idx];
         const char* rest = yaml_starts_with(path, name);
         if (rest) {
            path = rest;
            if (path[0] == 0) return node;
            if (node->kind == yaml_NodeKind_Sequence) return NULL;
            next = node->child_idx;
            continue;
         }
      }
      next = node->next_idx;
   }
   return NULL;
}

static yaml_Iter yaml_Parser_getNodeChildIter(const yaml_Parser* p, const yaml_Node* n)
{
   yaml_Iter iter = { .data = &p->data, .node = NULL };
   if (n && n->kind != yaml_NodeKind_Scalar && n->child_idx) {
      iter.node = yaml_Data_idx2node(&p->data, n->child_idx);
   }
   return iter;
}

static void yaml_Iter_next(yaml_Iter* iter)
{
   const yaml_Data* d = (yaml_Data*)iter->data;
   if (iter->node) {
      if (iter->node->next_idx) iter->node = yaml_Data_idx2node(d, iter->node->next_idx);
      else iter->node = NULL;
   }
}

static bool yaml_Iter_done(const yaml_Iter* iter)
{
   return iter->node == NULL;
}

static const char* yaml_Iter_getName(const yaml_Iter* iter)
{
   const yaml_Data* d = (yaml_Data*)iter->data;
   if (iter->node) return &d->text[iter->node->name_idx];
   return NULL;
}

static const char* yaml_Iter_getValue(const yaml_Iter* iter)
{
   const yaml_Data* d = (yaml_Data*)iter->data;
   if (iter->node && iter->node->kind == yaml_NodeKind_Scalar) return &d->text[iter->node->text_idx];
   return NULL;
}

static yaml_Iter yaml_Iter_getChildIter(yaml_Iter* parent)
{
   yaml_Iter iter = { .data = parent->data, .node = NULL };
   if (parent->node == NULL) return iter;
   const yaml_Node* n = parent->node;
   if (n->kind != yaml_NodeKind_Scalar && n->child_idx) {
      const yaml_Data* d = (yaml_Data*)iter.data;
      iter.node = yaml_Data_idx2node(d, n->child_idx);
   }
   return iter;
}

static const char* yaml_Iter_getChildScalarValue(yaml_Iter* iter, const char* path)
{
   if (!iter->node) return NULL;
   if (iter->node->kind == yaml_NodeKind_Sequence) return NULL;
   const yaml_Data* d = (yaml_Data*)iter->data;
   const yaml_Node* n = yaml_Data_findChildNode(d, path, iter->node->child_idx);
   if (n && yaml_Node_isScalar(n)) return &d->text[n->text_idx];
   return NULL;
}

static const char* yaml_starts_with(const char* full, const char* start)
{
   uint32_t len = (uint32_t)strlen(start);
   if (strncmp(full, start, len) == 0) {
      full += len;
      if (full[0] == '.') return full + 1;
      if (full[0] == 0) return full;
   }
   return NULL;
}

static const char* yaml_Token_str(const yaml_Token* tok)
{
   return yaml_token_names[tok->kind];
}

static void yaml_Tokenizer_init(yaml_Tokenizer* t, const char* input, yaml_Data* d, char* error_msg)
{
   memset(t, 0, 80);
   t->cur = input;
   t->input_start = input;
   t->line_start = input;
   t->error_msg = error_msg;
   t->line_number = 1;
   t->data = d;
   t->next.kind = yaml_TokenKind_None;
}

static void yaml_Tokenizer_lex(yaml_Tokenizer* t, yaml_Token* result)
{
   if (t->next.kind != yaml_TokenKind_None) {
      *result = t->next;
      t->next.kind = yaml_TokenKind_None;
      return;
   }
   *result = (yaml_Token){ .same_line = t->same_line };
   t->same_line = true;
   while (1) {
      result->loc.line = t->line_number;
      result->loc.column = (uint32_t)(t->cur - t->line_start) + 1;
      bool at_bol = result->loc.column == 1;
      if (at_bol && t->cur_indent && *t->cur != ' ' && *t->cur != '\r' && *t->cur != '\n') {
         result->kind = yaml_TokenKind_Dedent;
         result->indent = 0;
         t->cur_indent = 0;
         t->same_line = false;
         return;
      }
      switch (*t->cur) {
      case '\0':
         result->kind = yaml_TokenKind_Eof;
         return;
      case '\t':
         yaml_Tokenizer_error(t, result, "file contains TAB characters");
         return;
      case '\r':
         t->cur++;
         if (*t->cur != '\n') {
            yaml_Tokenizer_error(t, result, "missing LF char after CR");
            return;
         }
         fallthrough;
      case '\n':
         t->cur++;
         t->line_number++;
         t->line_start = t->cur;
         t->same_line = true;
         result->same_line = false;
         break;
      case ' ':
         if (at_bol) {
            if (yaml_Tokenizer_lex_indent(t, result)) return;
            break;
         }
         t->cur++;
         break;
      case '"':
         yaml_Tokenizer_lex_quoted_string(t, result, '"');
         return;
      case '#':
         yaml_Tokenizer_lex_comment(t);
         break;
      case '%':
         yaml_Tokenizer_lex_directive(t, result);
         return;
      case '\'':
         yaml_Tokenizer_lex_quoted_string(t, result, '\'');
         return;
      case '-':
         if (t->cur[1] == ' ' || t->cur[1] == '\r' || t->cur[1] == '\n') {
            result->kind = yaml_TokenKind_Dash;
            t->cur++;
            return;
         }
         if (at_bol && t->cur[1] == '-' && t->cur[2] == '-') {
            result->kind = yaml_TokenKind_Doc_Start;
            t->cur += 3;
            return;
         }
         yaml_Tokenizer_lex_string(t, result);
         return;
      case '.':
         if (at_bol && t->cur[1] == '.' && t->cur[2] == '.') {
            result->kind = yaml_TokenKind_Doc_End;
            t->cur += 3;
            return;
         }
         yaml_Tokenizer_lex_string(t, result);
         return;
      case ':':
         result->kind = yaml_TokenKind_Colon;
         t->cur++;
         return;
      default:
         if (yaml_is_string(*t->cur)) {
            yaml_Tokenizer_lex_string(t, result);
            return;
         }
         if (isprint(*t->cur)) {
            yaml_Tokenizer_error(t, result, "unhandled char '%c' (0x%02x)", *t->cur, *t->cur);
         } else {
            yaml_Tokenizer_error(t, result, "unhandled byte 0x%02x", *t->cur);
         }
         return;
      }
   }
}

static yaml_Token* yaml_Tokenizer_lex_next(yaml_Tokenizer* t)
{
   if (t->next.kind == yaml_TokenKind_None) yaml_Tokenizer_lex(t, &t->next);
   return &t->next;
}

static bool yaml_Tokenizer_lex_indent(yaml_Tokenizer* t, yaml_Token* result)
{
   const char* start = t->cur;
   while (*t->cur == ' ') t->cur++;
   int32_t indent = (int32_t)(t->cur - start);
   if (t->cur_indent == indent) return false;
   if (t->cur_indent > indent) result->kind = yaml_TokenKind_Dedent;
   else result->kind = yaml_TokenKind_Indent;
   result->indent = indent;
   t->cur_indent = indent;
   return true;
}

static void yaml_Tokenizer_lex_comment(yaml_Tokenizer* t)
{
   t->cur++;
   while (*t->cur && *t->cur != '\r' && *t->cur != '\n') t->cur++;
}

static void yaml_Tokenizer_lex_directive(yaml_Tokenizer* t, yaml_Token* result)
{
   t->cur++;
   const char* start = t->cur;
   while (*t->cur && *t->cur != '\r' && *t->cur != '\n') t->cur++;
   result->kind = yaml_TokenKind_Directive;
   result->text_idx = yaml_Data_add_text(t->data, start, (uint32_t)(t->cur - start));
}

static void yaml_Tokenizer_lex_quoted_string(yaml_Tokenizer* t, yaml_Token* result, char delim)
{
   t->cur++;
   const char* start = t->cur;
   while (*t->cur != delim) {
      switch (*t->cur) {
      case '\0':
      case '\r':
      case '\n':
         yaml_Tokenizer_error(t, result, "unterminated string");
         return;
      }
      t->cur++;
   }
   result->kind = (delim == '"') ? yaml_TokenKind_Double_Quoted_Scalar : yaml_TokenKind_Single_Quoted_Scalar;
   result->text_idx = yaml_Data_add_text(t->data, start, (uint32_t)(t->cur - start));
   t->cur++;
}

static bool yaml_is_string(char c)
{
   if (isalpha(c) || isdigit(c) || c == '_' || c == '-' || c == '.' || c == '/' || c == '~') {
      return true;
   }
   return false;
}

static void yaml_Tokenizer_lex_string(yaml_Tokenizer* t, yaml_Token* result)
{
   const char* start = t->cur;
   t->cur++;
   while (1) {
      char c = *t->cur;
      if (yaml_is_string(c)) {
         t->cur++;
         continue;
      }
      if (c == ' ' && yaml_is_string(t->cur[1])) {
         t->cur += 2;
         continue;
      }
      break;
   }
   result->kind = yaml_TokenKind_Plain_Scalar;
   result->text_idx = yaml_Data_add_text(t->data, start, (uint32_t)(t->cur - start));
}

__attribute__((__format__(printf, 3, 4)))
static void yaml_Tokenizer_error(yaml_Tokenizer* t, yaml_Token* result, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   int32_t len = vsnprintf(t->error_msg, yaml_MaxDiag, format, args);
   if ((uint32_t)len < yaml_MaxDiag) {
      snprintf(t->error_msg + len, yaml_MaxDiag - len, "at line %u:%u", result->loc.line, result->loc.column);
   }
   va_end(args);
   result->kind = yaml_TokenKind_Error;
   result->error_msg = t->error_msg;
}

static yaml_Parser* yaml_Parser_create(void)
{
   yaml_Parser* p = calloc(1, 808);
   yaml_Data_init(&p->data, 1024, 32, p->stack);
   return p;
}

static void yaml_Parser_destroy(yaml_Parser* p)
{
   yaml_Data_destroy(&p->data);
   free(p);
}

static bool yaml_Parser_parse(yaml_Parser* p, const char* input)
{
   yaml_Tokenizer_init(&p->tokenizer, input, &p->data, p->message);
   p->token.kind = yaml_TokenKind_None;
   int32_t res = setjmp(&p->jmp_err);
   if (res == 0) {
      yaml_Parser_consumeToken(p);
      while (p->token.kind != yaml_TokenKind_Eof) yaml_Parser_parse_doc(p);
   } else {
      return false;
   }
   return true;
}

static const char* yaml_Parser_getMessage(const yaml_Parser* p)
{
   return p->message;
}

__attribute__((__format__(printf, 2, 3)))
static void yaml_Parser_error(yaml_Parser* p, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   char* cp = p->message;
   int32_t len = vsnprintf(cp, yaml_MaxDiag, format, args);
   va_end(args);
   if ((uint32_t)len < yaml_MaxDiag) {
      snprintf(cp + len, yaml_MaxDiag - len, "at line %u:%u", p->token.loc.line, p->token.loc.column);
   }
   longjmp(&p->jmp_err, 1);
}

static void yaml_Parser_consumeToken(yaml_Parser* p)
{
   yaml_Tokenizer_lex(&p->tokenizer, &p->token);
   if (p->token.kind == yaml_TokenKind_Error) longjmp(&p->jmp_err, 1);
}

static void yaml_Parser_expectAndConsume(yaml_Parser* p, yaml_TokenKind kind)
{
   if (p->token.kind != kind) {
      yaml_Parser_error(p, "expected '%s', got '%s'", yaml_token_names[kind], yaml_Token_str(&p->token));
   }
   yaml_Parser_consumeToken(p);
}

static void yaml_Parser_parse_doc(yaml_Parser* p)
{
   while (1) {
      switch (p->token.kind) {
      case yaml_TokenKind_Doc_Start:
         yaml_Parser_consumeToken(p);
         if (p->doc_started) yaml_Parser_doc_end(p);
         yaml_Parser_doc_start(p);
         break;
      case yaml_TokenKind_Doc_End:
         if (!p->doc_started || !p->in_document) {
            yaml_Parser_error(p, "END document without start");
         }
         yaml_Parser_consumeToken(p);
         yaml_Parser_doc_end(p);
         return;
      case yaml_TokenKind_Directive:
         yaml_Parser_consumeToken(p);
         break;
      case yaml_TokenKind_Eof:
         return;
      default:
         if (!p->doc_started) yaml_Parser_doc_start(p);
         yaml_Parser_parse_node(p);
         break;
      }
   }
}

static void yaml_Parser_parse_node(yaml_Parser* p)
{
   switch (p->token.kind) {
   case yaml_TokenKind_Plain_Scalar:
   case yaml_TokenKind_Single_Quoted_Scalar:
   case yaml_TokenKind_Double_Quoted_Scalar: {
      yaml_Node* n = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, p->token.text_idx);
      yaml_Parser_push_node(p, n, yaml_NodeKind_Unknown, p->cur_indent);
      yaml_Parser_consumeToken(p);
      yaml_Parser_expectAndConsume(p, yaml_TokenKind_Colon);
      yaml_Parser_parse_value(p);
      break;
   }
   case yaml_TokenKind_Dash: {
      yaml_Parser_consumeToken(p);
      yaml_Node* n = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, 0);
      yaml_Parser_push_node(p, n, yaml_NodeKind_Sequence, p->cur_indent + 1);
      yaml_Parser_parse_node_or_value(p);
      break;
   }
   case yaml_TokenKind_Indent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      break;
   case yaml_TokenKind_Dedent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      yaml_Parser_pop(p);
      break;
   case yaml_TokenKind_Doc_Start:
   case yaml_TokenKind_Doc_End:
      break;
   default:
      yaml_Parser_error(p, "%s() unhandled token '%s'", "parse_node", yaml_Token_str(&p->token));
      break;
   }
}

static void yaml_Parser_parse_value(yaml_Parser* p)
{
   switch (p->token.kind) {
   case yaml_TokenKind_Plain_Scalar:
   case yaml_TokenKind_Single_Quoted_Scalar:
   case yaml_TokenKind_Double_Quoted_Scalar:
      if (p->token.same_line) {
         yaml_Parser_add_scalar_value(p, p->token.text_idx);
         yaml_Parser_consumeToken(p);
      } else {
      }
      return;
   case yaml_TokenKind_Dash: {
      yaml_Parser_consumeToken(p);
      yaml_Node* n = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, 0);
      yaml_Parser_push_node(p, n, yaml_NodeKind_Sequence, p->cur_indent + 1);
      yaml_Parser_parse_node_or_value(p);
      return;
   }
   case yaml_TokenKind_Indent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      yaml_Parser_parse_node(p);
      return;
   case yaml_TokenKind_Dedent:
      p->cur_indent = p->token.indent;
      yaml_Parser_consumeToken(p);
      yaml_Parser_pop(p);
      return;
   case yaml_TokenKind_Doc_Start:
   case yaml_TokenKind_Doc_End:
      return;
   case yaml_TokenKind_Eof:
      yaml_Parser_add_scalar_value(p, 0);
      return;
   default:
      yaml_Parser_error(p, "%s() unhandled token '%s'", "parse_value", yaml_Token_str(&p->token));
      break;
   }
}

static void yaml_Parser_parse_node_or_value(yaml_Parser* p)
{
   switch (p->token.kind) {
   case yaml_TokenKind_Plain_Scalar:
   case yaml_TokenKind_Single_Quoted_Scalar:
   case yaml_TokenKind_Double_Quoted_Scalar: {
      yaml_Token* next = yaml_Tokenizer_lex_next(&p->tokenizer);
      if (next->kind == yaml_TokenKind_Colon) {
         p->cur_indent += 2;
         p->tokenizer.cur_indent += 2;
         yaml_Parser_parse_node(p);
         return;
      }
      break;
   }
   default:
      break;
   }
   yaml_Parser_parse_value(p);
}

static void yaml_Parser_doc_start(yaml_Parser* p)
{
   yaml_Parser_push_root(p);
   p->doc_started = true;
   p->in_document = true;
}

static void yaml_Parser_doc_end(yaml_Parser* p)
{
   p->cur_indent = -1;
   if (p->stack_size == 1 && p->stack[0].node->kind == yaml_NodeKind_Unknown) {
      p->stack[0].node->kind = yaml_NodeKind_Map;
   }
   yaml_Parser_pop(p);
   p->cur_indent = 0;
   p->in_document = false;
}

static void yaml_Parser_add_scalar_value(yaml_Parser* p, uint32_t value_idx)
{
   yaml_StackLevel* top = &p->stack[p->stack_size - 1];
   yaml_Node* n = top->node;
   if (n->kind != yaml_NodeKind_Unknown) {
      yaml_Parser_error(p, "%s() cannot add scalar to node", "add_scalar_value");
   }
   n->kind = yaml_NodeKind_Scalar;
   n->text_idx = value_idx;
}

static void yaml_Parser_pop(yaml_Parser* p)
{
   int32_t indent = p->cur_indent;
   while (1) {
      yaml_StackLevel* top = &p->stack[p->stack_size - 1];
      if (top->indent <= indent) break;
      if (p->stack_size >= 1) {
         yaml_StackLevel* prev = &p->stack[p->stack_size - 2];
         prev->last_child = top->node;
      }
      if (top->node->kind == yaml_NodeKind_Unknown) top->node->kind = yaml_NodeKind_Scalar;
      top->indent = 0;
      top->node = NULL;
      top->last_child = NULL;
      p->stack_size--;
   }
}

static void yaml_Parser_push_root(yaml_Parser* p)
{
   yaml_Node* root = yaml_Data_add_node(&p->data, yaml_NodeKind_Unknown, 0);
   yaml_StackLevel* top = &p->stack[0];
   if (p->stack_size) {
      top->node->next_idx = yaml_Data_node2idx(&p->data, root);
   }
   top->node = root;
   top->indent = -1;
   top->last_child = NULL;
   p->stack_size = 1;
}

static void yaml_Parser_push_node(yaml_Parser* p, yaml_Node* n, yaml_NodeKind parent_kind, int32_t indent)
{
   ;//assert(p->stack_size);
   uint32_t n_idx = yaml_Data_node2idx(&p->data, n);
   yaml_StackLevel* top = &p->stack[p->stack_size - 1];
   if (indent < top->indent) {
      ;//assert(indent + 1 == top->indent);
      yaml_Parser_pop(p);
      top = &p->stack[p->stack_size - 1];
   }
   if (top->indent == indent) {
      if (top->node) {
         if (top->node->kind == yaml_NodeKind_Unknown) top->node->kind = yaml_NodeKind_Scalar;
         top->node->next_idx = n_idx;
      }
      top->last_child = NULL;
   } else {
      ;//assert(p->stack_size + 1 < yaml_MaxDepth);
      ;//assert(indent > top->indent);
      yaml_Node* parent = top->node;
      if (parent->kind == yaml_NodeKind_Unknown) {
         if (parent_kind == yaml_NodeKind_Unknown) parent_kind = yaml_NodeKind_Map;
         parent->kind = parent_kind;
      }
      if (top->last_child) {
         top->last_child->next_idx = n_idx;
      } else {
         ;//assert(parent->child_idx == 0);
         parent->child_idx = n_idx;
      }
      top->last_child = n;
      p->stack_size++;
      top = &p->stack[p->stack_size - 1];
   }
   top->indent = indent;
   top->node = n;
   yaml_StackLevel* prev = &p->stack[p->stack_size - 2];
   yaml_Node* parent = prev->node;
   if (parent->kind != parent_kind && !(parent->kind == yaml_NodeKind_Map && parent_kind == yaml_NodeKind_Unknown)) {
      if (parent->kind == yaml_NodeKind_Sequence) {
         yaml_Parser_error(p, "invalid scalar after sequence");
      } else {
         yaml_Parser_error(p, "invalid scalar after %s", yaml_node_names[parent->kind]);
      }
   }
}


// --- module console ---

static bool console_use_color = false;
static bool console_show_debug = false;
static bool console_show_timing = false;
#define console_BUF_SIZE 4096
static void console_init(void);
static void console_setDebug(bool enable);
static void console_setTiming(bool enable);
__attribute__((__format__(printf, 1, 2)))
static void console_debug(const char* format, ...);
__attribute__((__format__(printf, 1, 2)))
static void console_log(const char* format, ...);
__attribute__((__format__(printf, 1, 2)))
static void console_warn(const char* format, ...);
__attribute__((__format__(printf, 1, 2)))
static void console_error(const char* format, ...);
__attribute__((__format__(printf, 2, 3)))
static void console_error_diag(const char* loc, const char* format, ...);
static void console_log_time(const char* item, uint64_t duration);

static void console_init(void)
{
   console_use_color = color_useColor();
}

static void console_setDebug(bool enable)
{
   console_show_debug = enable;
}

static void console_setTiming(bool enable)
{
   console_show_timing = enable;
}

__attribute__((__format__(printf, 1, 2)))
static void console_debug(const char* format, ...)
{
   if (!console_show_debug) return;
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsnprintf(buf, 4096, format, args);
   va_end(args);
   if (console_use_color) {
      printf("%s%s%s\n", color_Color_str(color_Blue), buf, color_Color_str(color_Normal));
   } else {
      printf("%s\n", buf);
   }
}

__attribute__((__format__(printf, 1, 2)))
static void console_log(const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsnprintf(buf, 4096, format, args);
   va_end(args);
   printf("%s\n", buf);
}

__attribute__((__format__(printf, 1, 2)))
static void console_warn(const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsnprintf(buf, 4096, format, args);
   va_end(args);
   if (console_use_color) {
      fprintf(stderr, "%swarning: %s%s\n", color_Color_str(color_Yellow), buf, color_Color_str(color_Normal));
   } else {
      fprintf(stderr, "warning: %s\n", buf);
   }
}

__attribute__((__format__(printf, 1, 2)))
static void console_error(const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsprintf(buf, format, args);
   va_end(args);
   if (console_use_color) {
      fprintf(stderr, "%serror: %s%s\n", color_Color_str(color_Red), buf, color_Color_str(color_Normal));
   } else {
      fprintf(stderr, "error: %s\n", buf);
   }
}

__attribute__((__format__(printf, 2, 3)))
static void console_error_diag(const char* loc, const char* format, ...)
{
   char buf[4096];
   va_list args;
   va_start(args, format);
   vsprintf(buf, format, args);
   va_end(args);
   if (console_use_color) {
      fprintf(stderr, "%s%s: error: %s%s\n", color_Color_str(color_Red), loc, buf, color_Color_str(color_Normal));
   } else {
      fprintf(stderr, "%s: error: %s\n", loc, buf);
   }
}

static void console_log_time(const char* item, uint64_t duration)
{
   if (!console_show_timing) return;
   if (console_use_color) {
      printf("%s%s took %lu usec%s\n", color_Color_str(color_Blue), item, duration, color_Color_str(color_Normal));
   } else {
      printf("%s took %lu usec\n", item, duration);
   }
}


// --- module file_list ---
typedef struct file_list_File_ file_list_File;
typedef struct file_list_FileList_ file_list_FileList;

struct file_list_File_ {
   uint32_t name;
   src_loc_SrcLoc loc;
};

struct file_list_FileList_ {
   file_list_File* files;
   uint32_t count;
   uint32_t capacity;
};

static void file_list_FileList_init(file_list_FileList* l, uint32_t cap);
static void file_list_FileList_free(file_list_FileList* l);
static bool file_list_FileList_add(file_list_FileList* l, uint32_t filename, src_loc_SrcLoc loc);
static uint32_t file_list_FileList_getCount(const file_list_FileList* l);
static const file_list_File* file_list_FileList_get(const file_list_FileList* l, uint32_t idx);

static void file_list_FileList_init(file_list_FileList* l, uint32_t cap)
{
   l->count = 0;
   l->capacity = cap;
   l->files = NULL;
   if (l->capacity) l->files = malloc(l->capacity * 8);
}

static void file_list_FileList_free(file_list_FileList* l)
{
   free(l->files);
}

static bool file_list_FileList_add(file_list_FileList* l, uint32_t filename, src_loc_SrcLoc loc)
{
   for (uint32_t i = 0; i < l->count; i++) {
      if (l->files[i].name == filename) return false;
   }
   if (l->count == l->capacity) {
      if (l->capacity) l->capacity *= 2;
      else l->capacity += 4;
      file_list_File* files2 = malloc(l->capacity * 8);
      if (l->count) {
         memcpy(files2, l->files, l->count * 8);
         free(l->files);
      }
      l->files = files2;
   }
   l->files[l->count].name = filename;
   l->files[l->count].loc = loc;
   l->count++;
   return true;
}

static uint32_t file_list_FileList_getCount(const file_list_FileList* l)
{
   return l->count;
}

static const file_list_File* file_list_FileList_get(const file_list_FileList* l, uint32_t idx)
{
   return &l->files[idx];
}


// --- module file_utils ---
typedef struct file_utils_File_ file_utils_File;

#define file_utils_Max_path 512
struct file_utils_File_ {
   char path[512];
   int32_t handle;
   int32_t error;
   uint32_t contents_size;
   void* contents;
};

#define file_utils_Err_not_a_file 2001
#define file_utils_Err_read_error 2002
#define file_utils_Err_too_large 2003
#define file_utils_Err_write_error 2004
static const char* file_utils_get_basename(const char* s);
static const char* file_utils_get_extension(const char* s);
static size_t file_utils_pstrcpy(char* dest, size_t size, const char* src);
static size_t file_utils_copy_dirname(char* buf, size_t size, const char* dir);
static const char* file_utils_make_path(char* buf, size_t size, const char* dir, const char* filename);
static const char* file_utils_make_path_ext(char* buf, size_t size, const char* dir, const char* filename, const char* ext);
static const char* file_utils_make_path3(char* buf, size_t size, const char* dir, const char* subdir, const char* filename);
static int32_t file_utils_create_path(const char* path);
static bool file_utils_path_exists(const char* path);
static bool file_utils_is_file(const char* filename);
static bool file_utils_is_dir(const char* dirname);
static bool file_utils_File_init(file_utils_File* file, const char* dir, const char* filename);
static bool file_utils_File_init_ext(file_utils_File* file, const char* dir, const char* filename, const char* ext);
static void file_utils_File_close(file_utils_File* file);
static bool file_utils_File_exists(file_utils_File* file);
static const char* file_utils_File_getError(file_utils_File* file);
static ssize_t file_utils_read2(int32_t hd, void* data, size_t len);
static bool file_utils_File_load(file_utils_File* file);
static bool file_utils_File_isOpen(const file_utils_File* file);
static const void* file_utils_File_data(file_utils_File* file);
static uint32_t file_utils_File_data_size(file_utils_File* file);
static bool file_utils_File_isEmpty(const file_utils_File* file);
static void* file_utils_File_detach(file_utils_File* file, uint32_t* psize);
static ssize_t file_utils_write2(int32_t hd, const void* data, size_t len);
static bool file_utils_File_write(file_utils_File* file, const void* data, size_t len);
static int32_t file_utils_copy_file(const char* source, const char* dest);

static const char* file_utils_get_basename(const char* s)
{
   const char* base = s;
   while (*s) {
      if (*s++ == '/') base = s;
   }
   return base;
}

static const char* file_utils_get_extension(const char* s)
{
   const char* ext = NULL;
   for (; *s; s++) {
      if (*s == '/') ext = NULL;
      if (*s == '.') ext = s;
   }
   return ext ? ext : s;
}

static size_t file_utils_pstrcpy(char* dest, size_t size, const char* src)
{
   size_t i;
   for (i = 0; i < size; i++) {
      if ((dest[i] = src[i]) == '\0') return i;
   }
   if (size) dest[size - 1] = '\0';
   return size;
}

static size_t file_utils_copy_dirname(char* buf, size_t size, const char* dir)
{
   size_t pos = file_utils_pstrcpy(buf, size, dir);
   if (pos && pos < size && dir[pos - 1] != '/') {
      if (pos + 1 < size) {
         buf[pos] = '/';
         buf[pos + 1] = '\0';
      }
      pos += 1;
   }
   return pos;
}

static const char* file_utils_make_path(char* buf, size_t size, const char* dir, const char* filename)
{
   size_t pos = 0;
   if (*filename != '/') pos = file_utils_copy_dirname(buf, size, dir);
   if (pos < size) {
      pos += file_utils_pstrcpy(buf + pos, size - pos, filename);
      if (pos < size) return buf;
   }
   (*__errno_location()) = c_errno_ENAMETOOLONG;
   return NULL;
}

static const char* file_utils_make_path_ext(char* buf, size_t size, const char* dir, const char* filename, const char* ext)
{
   size_t pos = 0;
   if (*filename != '/') pos = file_utils_copy_dirname(buf, size, dir);
   if (pos < size) {
      pos += file_utils_pstrcpy(buf + pos, size - pos, filename);
      if (pos < size) {
         pos += file_utils_pstrcpy(buf + pos, size - pos, ext);
         if (pos < size) return buf;
      }
   }
   (*__errno_location()) = c_errno_ENAMETOOLONG;
   return NULL;
}

static const char* file_utils_make_path3(char* buf, size_t size, const char* dir, const char* subdir, const char* filename)
{
   size_t pos = 0;
   if (*filename != '/') {
      if (*subdir != '/') pos = file_utils_copy_dirname(buf, size, dir);
      if (pos < size) pos += file_utils_copy_dirname(buf + pos, size - pos, subdir);
   }
   if (pos < size) {
      pos += file_utils_pstrcpy(buf + pos, size - pos, filename);
      if (pos < size) return buf;
   }
   (*__errno_location()) = c_errno_ENAMETOOLONG;
   return NULL;
}

static int32_t file_utils_create_path(const char* path)
{
   char tmp[512];
   char* p = tmp;
   if (!*path) return 0;
   *p++ = *path++;
   for (;;) {
      char c = *path++;
      if (c == '/' && (p[-1] == '/' || *path == '\0')) continue;
      if (c == '/' || c == '\0') {
         *p = '\0';
         if (mkdir(tmp, 0777) && (*__errno_location()) != c_errno_EEXIST) return (*__errno_location());
         if (c == '\0') break;
      }
      if (p > &tmp[512 - 2]) return (*__errno_location()) = c_errno_ENAMETOOLONG;
      *p++ = c;
   }
   return 0;
}

static bool file_utils_path_exists(const char* path)
{
   struct stat statbuf;
   return !stat(path, &statbuf);
}

static bool file_utils_is_file(const char* filename)
{
   struct stat statbuf;
   return !stat(filename, &statbuf) && (statbuf.st_mode & sys_stat_S_IFMT) == sys_stat_S_IFREG;
}

static bool file_utils_is_dir(const char* dirname)
{
   struct stat statbuf;
   return !stat(dirname, &statbuf) && (statbuf.st_mode & sys_stat_S_IFMT) == sys_stat_S_IFDIR;
}

static bool file_utils_File_init(file_utils_File* file, const char* dir, const char* filename)
{
   file->handle = 0;
   file->error = 0;
   file->contents_size = 0;
   file->contents = NULL;
   if (!file_utils_make_path(file->path, 512, dir, filename)) {
      file->error = c_errno_ENAMETOOLONG;
      return false;
   }
   return true;
}

static bool file_utils_File_init_ext(file_utils_File* file, const char* dir, const char* filename, const char* ext)
{
   if (!file_utils_File_init(file, dir, filename)) return false;
   uint32_t len = (uint32_t)strlen(file->path);
   len += file_utils_pstrcpy(file->path + len, 512 - len, ext);
   if (len >= 512) {
      file->error = c_errno_ENAMETOOLONG;
      return false;
   }
   return true;
}

static void file_utils_File_close(file_utils_File* file)
{
   if (file->contents) {
      free(file->contents);
      file->contents = NULL;
   }
}

static bool file_utils_File_exists(file_utils_File* file)
{
   return file_utils_path_exists(file->path);
}

static const char* file_utils_File_getError(file_utils_File* file)
{
   switch (file->error) {
   case file_utils_Err_not_a_file:
      return "not a regular file";
   case file_utils_Err_read_error:
      return "read error";
   case file_utils_Err_write_error:
      return "write error";
   case file_utils_Err_too_large:
      return "file too large";
   default:
      break;
   }
   return strerror(file->error);
}

static ssize_t file_utils_read2(int32_t hd, void* data, size_t len)
{
   uint8_t* p = data;
   ssize_t total_read = 0;
   while (len > 0) {
      ssize_t nread = read(hd, p, len);
      if (nread >= 0) {
         total_read += nread;
         p += nread;
         len -= nread;
      } else {
         if ((*__errno_location()) != c_errno_EINTR) return -1;
      }
   }
   return total_read;
}

static bool file_utils_File_load(file_utils_File* file)
{
   if (file->error) return false;
   file->contents_size = 0;
   if (file->contents) {
      free(file->contents);
      file->contents = NULL;
   }
   int32_t fd = open(file->path, libc_fcntl_O_RDONLY | libc_fcntl_O_BINARY);
   if (fd < 0) {
      file->error = (*__errno_location());
      return false;
   }
   struct stat statbuf;
   if (fstat(fd, &statbuf)) {
      file->error = (*__errno_location());
      close(fd);
      return false;
   }
   if ((statbuf.st_mode & sys_stat_S_IFMT) != sys_stat_S_IFREG) {
      file->error = file_utils_Err_not_a_file;
      close(fd);
      return false;
   }
   uint32_t size = (uint32_t)statbuf.st_size;
   if (size != statbuf.st_size) {
      file->error = file_utils_Err_too_large;
      close(fd);
      return false;
   }
   uint8_t* region = malloc((size_t)size + 1);
   if (!region) {
      file->error = c_errno_ENOMEM;
      close(fd);
      return false;
   }
   ssize_t numread = file_utils_read2(fd, region, size);
   if (numread < 0) {
      file->error = (*__errno_location());
      free(region);
      close(fd);
      return false;
   }
   if ((size_t)numread != size) {
      file->error = file_utils_Err_read_error;
      free(region);
      close(fd);
      return false;
   }
   region[size] = '\0';
   file->contents = region;
   file->contents_size = size;
   close(fd);
   return true;
}

static bool file_utils_File_isOpen(const file_utils_File* file)
{
   return file->contents != NULL;
}

static const void* file_utils_File_data(file_utils_File* file)
{
   return file->contents;
}

static uint32_t file_utils_File_data_size(file_utils_File* file)
{
   return file->contents_size;
}

static bool file_utils_File_isEmpty(const file_utils_File* file)
{
   return file->contents_size == 0;
}

static void* file_utils_File_detach(file_utils_File* file, uint32_t* psize)
{
   void* data = file->contents;
   *psize = file->contents_size;
   file->contents = NULL;
   file->contents_size = 0;
   return data;
}

static ssize_t file_utils_write2(int32_t hd, const void* data, size_t len)
{
   const uint8_t* p = data;
   ssize_t total_written = 0;
   while (len > 0) {
      ssize_t written = write(hd, p, len);
      if (written >= 0) {
         total_written += written;
         p += written;
         len -= written;
      } else {
         if ((*__errno_location()) != c_errno_EINTR) return -1;
      }
   }
   return total_written;
}

static bool file_utils_File_write(file_utils_File* file, const void* data, size_t len)
{
   if (file->error) return false;
   int32_t fd = open(file->path, libc_fcntl_O_CREAT | libc_fcntl_O_WRONLY | libc_fcntl_O_TRUNC | libc_fcntl_O_BINARY, 0660);
   if (fd < 0) {
      file->error = (*__errno_location());
      return false;
   }
   ssize_t written = file_utils_write2(fd, data, len);
   if (written < 0) {
      file->error = (*__errno_location());
      close(fd);
      return false;
   }
   if ((size_t)written != len) {
      file->error = file_utils_Err_write_error;
      close(fd);
      return false;
   }
   close(fd);
   return true;
}

static int32_t file_utils_copy_file(const char* source, const char* dest)
{
   char tmp[512];
   file_utils_pstrcpy(tmp, 512, dest);
   const char* base = file_utils_get_basename(tmp);
   if (base != tmp) {
      uint32_t len = (uint32_t)(base - tmp);
      tmp[len - 1] = 0;
      if (file_utils_create_path(tmp)) return -1;
   }
   file_utils_File src; file_utils_File_init(&src, "", source);
   if (!file_utils_File_load(&src)) return -1;
   file_utils_File dst; file_utils_File_init(&dst, "", dest);
   bool ok = file_utils_File_write(&dst, src.contents, src.contents_size);
   file_utils_File_close(&dst);
   file_utils_File_close(&src);
   return !ok;
}


// --- module linked_list ---
typedef struct linked_list_Element_ linked_list_Element;

struct linked_list_Element_ {
   linked_list_Element* prev;
   linked_list_Element* next;
};

static void linked_list_Element_init(linked_list_Element* src);
static void linked_list_Element_addTail(linked_list_Element* src, linked_list_Element* item);
static void linked_list_Element_addFront(linked_list_Element* src, linked_list_Element* item);
static linked_list_Element* linked_list_Element_popFront(linked_list_Element* item);
static void linked_list_Element_remove(linked_list_Element* item);
static uint64_t linked_list_Element_size(const linked_list_Element* src);
static bool linked_list_Element_isEmpty(const linked_list_Element* src);
static void linked_list_Element_move(linked_list_Element* src, linked_list_Element* dest);

static void linked_list_Element_init(linked_list_Element* src)
{
   src->prev = src;
   src->next = src;
}

static void linked_list_Element_addTail(linked_list_Element* src, linked_list_Element* item)
{
   linked_list_Element* old_tail = src->prev;
   src->prev = item;
   item->next = src;
   item->prev = old_tail;
   old_tail->next = item;
}

static void linked_list_Element_addFront(linked_list_Element* src, linked_list_Element* item)
{
   linked_list_Element* old_head = src->next;
   old_head->prev = item;
   item->next = old_head;
   item->prev = src;
   src->next = item;
}

static linked_list_Element* linked_list_Element_popFront(linked_list_Element* item)
{
   linked_list_Element* node = item->next;
   linked_list_Element_remove(node);
   return node;
}

static void linked_list_Element_remove(linked_list_Element* item)
{
   linked_list_Element* prev = item->prev;
   linked_list_Element* next = item->next;
   prev->next = next;
   next->prev = prev;
}

static uint64_t linked_list_Element_size(const linked_list_Element* src)
{
   uint64_t count = 0;
   linked_list_Element* node = src->next;
   while (node != src) {
      count++;
      node = node->next;
   }
   return count;
}

static bool linked_list_Element_isEmpty(const linked_list_Element* src)
{
   return src->next == src;
}

static void linked_list_Element_move(linked_list_Element* src, linked_list_Element* dest)
{
   linked_list_Element* node = src->next;
   while (node != src) {
      linked_list_Element* tmp = node;
      node = node->next;
      linked_list_Element_remove(tmp);
      linked_list_Element_addTail(dest, tmp);
   }
}


// --- module process_utils ---

#define process_utils_MAX_ARG_LEN 512
#define process_utils_MAX_ARGS 16
static bool process_utils_doWIFSIGNALED(int32_t state);
static bool process_utils_doWIFEXITED(int32_t state);
static char process_utils_getWEXITSTATUS(int32_t state);
__attribute__((noreturn)) __attribute__((__format__(printf, 2, 3)))
static void process_utils_child_error(int32_t fd, const char* format, ...);
static int32_t process_utils_run_args(const char* path, const char* cmd, const char* args, const char* logfile);
static uint32_t process_utils_parseArgs(const char* args, char** argv, uint32_t maxargs, char* tmp, size_t tmp_size);
static const char* process_utils_find_bin(char* dest, size_t size, const char* name);
static int32_t process_utils_run2(const char* path, const char* cmd, const char* args, char* output, size_t output_size);

static bool process_utils_doWIFSIGNALED(int32_t state)
{
   return ((state & 0x7f) > 0 && (state & 0x7f) < 0x7f);
}

static bool process_utils_doWIFEXITED(int32_t state)
{
   return ((state & 0xff) == 0);
}

static char process_utils_getWEXITSTATUS(int32_t state)
{
   return (char)((state >> 8) & 0xff);
}

__attribute__((noreturn)) __attribute__((__format__(printf, 2, 3)))
static void process_utils_child_error(int32_t fd, const char* format, ...)
{
   char msg[256];
   va_list args;
   va_start(args, format);
   int32_t res = vsnprintf(msg, 256, format, args);
   va_end(args);
   if (res >= 0) {
      size_t len = (size_t)res;
      msg[len++] = '\n';
      msg[len] = '\0';
      write(fd, msg, len);
      fsync(fd);
      fprintf(stderr, "[exec] %s\n", msg);
      fflush(stderr);
   }
   _exit(stdlib_EXIT_FAILURE);
}

static int32_t process_utils_run_args(const char* path, const char* cmd, const char* args, const char* logfile)
{
   fflush(NULL);
   int32_t error_pipe[2];
   if (pipe(error_pipe)) {
      fprintf(stderr, "pipe() failed: %s\n", strerror((*__errno_location())));
      return -1;
   }
   if (fcntl(error_pipe[1], libc_fcntl_F_SETFD, libc_fcntl_FD_CLOEXEC)) {
      fprintf(stderr, "fcncl(FD_CLOEXEC) failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   pid_t child_pid = fork();
   if (child_pid == -1) {
      fprintf(stderr, "fork() failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   if (child_pid == 0) {
      close(error_pipe[0]);
      char filename[512];
      file_utils_make_path(filename, 512, path, logfile);
      close(unistd_STDOUT_FILENO);
      int32_t fdout = open(filename, libc_fcntl_O_TRUNC | libc_fcntl_O_CREAT | libc_fcntl_O_WRONLY, 0644);
      if (fdout == -1) {
         process_utils_child_error(error_pipe[1], "cannot open output '%s': %s", filename, strerror((*__errno_location())));
      }
      while (dup2(unistd_STDOUT_FILENO, unistd_STDERR_FILENO) == -1) {
         if ((*__errno_location()) != c_errno_EINTR) process_utils_child_error(error_pipe[1], "dup2(): %s", strerror((*__errno_location())));
      }
      if (path && *path) {
         char* cwd = getcwd(NULL, 0);
         printf("current dir: %s\n", cwd);
         free(cwd);
         if (chdir(path) != 0) {
            process_utils_child_error(error_pipe[1], "cannot change to dir '%s': %s", path, strerror((*__errno_location())));
         }
         printf("changing to dir: %s\n", path);
      }
      char self[512];
      if (!process_utils_find_bin(self, 512, cmd)) {
         process_utils_child_error(error_pipe[1], "command not found: %s", cmd);
      }
      char* argv[18];
      char argbuf[512];
      uint32_t argc = 0;
      argv[argc++] = self;
      if (args && *args) {
         argc += process_utils_parseArgs(args, &argv[1], process_utils_MAX_ARGS, argbuf, 512);
      }
      argv[argc] = NULL;
      printf("running command: %s %s\n", cmd, args ? args : "");
      fflush(stdout);
      execv(self, argv);
      int32_t lasterr = (*__errno_location());
      fprintf(stderr, "failed to start %s: %s\n", cmd, strerror(lasterr));
      process_utils_child_error(error_pipe[1], "error starting %s: %s", cmd, strerror(lasterr));
      _exit(-1);
   } else {
      close(error_pipe[1]);
      char error[256];
      ssize_t numread = read(error_pipe[0], error, 256 - 1);
      if (numread < 0) {
         fprintf(stderr, "Error reading pipe\n");
         close(error_pipe[0]);
         return -1;
      }
      error[numread] = '\0';
      close(error_pipe[0]);
      if (numread != 0) {
         return -1;
      }
      int32_t state = 0;
      pid_t pid = waitpid(child_pid, &state, 0);
      if (pid == -1) {
         fprintf(stderr, "Error waiting for pid: %s\n", strerror((*__errno_location())));
         return -1;
      }
      if (process_utils_doWIFSIGNALED(state)) {
         return -1;
      }
      if (process_utils_doWIFEXITED(state)) {
         char exitcode = process_utils_getWEXITSTATUS(state);
         if (exitcode != 0) return -1;
      } else {
         return -1;
      }
   }
   return 0;
}

static uint32_t process_utils_parseArgs(const char* args, char** argv, uint32_t maxargs, char* tmp, size_t tmp_size)
{
   uint32_t argc = 0;
   size_t len = strlen(args);
   if (len >= tmp_size) len = tmp_size - 1;
   memcpy(tmp, args, len);
   tmp[len] = '\0';
   char* token = strtok(tmp, " ");
   while (argc + 1 < maxargs && token) {
      argv[argc++] = token;
      token = strtok(NULL, " ");
   }
   argv[argc] = NULL;
   return argc;
}

static const char* process_utils_find_bin(char* dest, size_t size, const char* name)
{
   struct stat statbuf;
   const char* s = getenv("PATH");
   if (!s) s = "";
   for (;;) {
      int32_t len = 0;
      while (s[len] && s[len] != ':') len++;
      int32_t len2 = (len > 0 && s[len - 1] != '/');
      int32_t len3 = snprintf(dest, size, "%.*s%.*s%s", len, s, len2, "/", name);
      if ((size_t)len3 < size && stat(dest, &statbuf) == 0) return dest;
      s += len;
      if (!*s++) break;
   }
   return NULL;
}

static int32_t process_utils_run2(const char* path, const char* cmd, const char* args, char* output, size_t output_size)
{
   fflush(NULL);
   int32_t error_pipe[2];
   if (pipe(error_pipe)) {
      fprintf(stderr, "pipe() failed: %s\n", strerror((*__errno_location())));
      return -1;
   }
   if (fcntl(error_pipe[1], libc_fcntl_F_SETFD, libc_fcntl_FD_CLOEXEC)) {
      fprintf(stderr, "fcncl(FD_CLOEXEC) failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   int32_t output_pipe[2];
   if (pipe(output_pipe)) {
      fprintf(stderr, "pipe() failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      return -1;
   }
   pid_t child_pid = fork();
   if (child_pid == -1) {
      fprintf(stderr, "fork() failed: %s\n", strerror((*__errno_location())));
      close(error_pipe[0]);
      close(error_pipe[1]);
      close(output_pipe[0]);
      close(output_pipe[1]);
      return -1;
   }
   if (child_pid == 0) {
      close(output_pipe[0]);
      close(error_pipe[0]);
      while (dup2(output_pipe[1], unistd_STDOUT_FILENO) == -1) {
         if ((*__errno_location()) != c_errno_EINTR) process_utils_child_error(error_pipe[1], "dup(): %s", strerror((*__errno_location())));
      }
      close(output_pipe[1]);
      while (dup2(unistd_STDOUT_FILENO, unistd_STDERR_FILENO) == -1) {
         if ((*__errno_location()) != c_errno_EINTR) process_utils_child_error(error_pipe[1], "dup2(): %s", strerror((*__errno_location())));
      }
      if (path && *path) {
         if (chdir(path) != 0) {
            process_utils_child_error(error_pipe[1], "cannot change to dir '%s': %s", path, strerror((*__errno_location())));
         }
      }
      char self[512];
      if (!process_utils_find_bin(self, 512, cmd)) {
         process_utils_child_error(error_pipe[1], "command not found: %s", cmd);
      }
      char* argv[18];
      char argbuf[512];
      uint32_t argc = 0;
      argv[argc++] = self;
      if (args && *args) {
         argc += process_utils_parseArgs(args, &argv[1], process_utils_MAX_ARGS, argbuf, 512);
      }
      argv[argc] = NULL;
      execv(self, argv);
      int32_t lasterr = (*__errno_location());
      fprintf(stderr, "failed to start %s: %s\n", cmd, strerror(lasterr));
      process_utils_child_error(error_pipe[1], "error starting %s: %s", cmd, strerror(lasterr));
      _exit(-1);
   } else {
      close(error_pipe[1]);
      close(output_pipe[1]);
      char error[256];
      ssize_t numread = read(error_pipe[0], error, 256 - 1);
      if (numread < 0) {
         fprintf(stderr, "Error reading pipe\n");
         close(error_pipe[0]);
         close(output_pipe[0]);
         return -1;
      }
      error[numread] = '\0';
      close(error_pipe[0]);
      if (numread != 0) {
         printf("ERROR %s\n", error);
         close(output_pipe[0]);
         return -1;
      }
      int32_t state = 0;
      pid_t pid = waitpid(child_pid, &state, 0);
      if (pid == -1) {
         fprintf(stderr, "Error waiting for pid: %s\n", strerror((*__errno_location())));
         close(output_pipe[0]);
         return -1;
      }
      if (process_utils_doWIFSIGNALED(state)) {
         close(output_pipe[0]);
         return -1;
      }
      if (process_utils_doWIFEXITED(state)) {
         char exitcode = process_utils_getWEXITSTATUS(state);
         if (exitcode != 0) return -1;
         numread = read(output_pipe[0], output, output_size - 1);
         if (numread < 0) {
            fprintf(stderr, "error reading process output\n");
            close(output_pipe[0]);
            return -1;
         }
         output[numread] = '\0';
         while (numread > 0 && isspace(output[numread - 1])) output[--numread] = '\0';
         size_t skip = 0;
         while (isspace(output[skip])) skip++;
         if (skip) {
            numread -= skip;
            memmove(output, output + skip, (uint32_t)numread + 1);
         }
      } else {
         fprintf(stderr, "child exited ABNORMALLY\n");
         close(output_pipe[0]);
         return -1;
      }
      close(output_pipe[0]);
   }
   return 0;
}


// --- module source_mgr ---
typedef struct source_mgr_CheckPoint_ source_mgr_CheckPoint;
typedef struct source_mgr_Location_ source_mgr_Location;
typedef struct source_mgr_File_ source_mgr_File;
typedef struct source_mgr_SourceMgr_ source_mgr_SourceMgr;

struct source_mgr_CheckPoint_ {
   uint32_t line;
   uint32_t column;
};

struct source_mgr_Location_ {
   uint32_t line;
   uint32_t column;
   const char* filename;
   const char* line_start;
};

struct source_mgr_File_ {
   uint32_t filename;
   uint32_t offset;
   uint32_t data_size;
   bool is_generated;
   bool is_const;
   char* data;
   source_mgr_CheckPoint* checkpoints;
};

struct source_mgr_SourceMgr_ {
   string_pool_Pool* pool;
   source_mgr_File* files;
   uint32_t num_files;
   uint32_t max_files;
   uint32_t max_offset;
   uint32_t index_count;
   uint32_t index_capacity;
   uint16_t* index;
};

typedef void (*source_mgr_Visitor)(void* arg, uint32_t start, uint32_t size, const char* filename, const char* contents);

#define source_mgr_InitialMaxFiles 32
#define source_mgr_FileIndexSize 4096
#define source_mgr_CheckPointSize 128
static void source_mgr_File_clear(source_mgr_File* f);
static source_mgr_CheckPoint source_mgr_update_checkpoint(source_mgr_CheckPoint cp, const char* src, uint32_t len);
static void source_mgr_File_addCheckPoints(source_mgr_File* f);
static source_mgr_CheckPoint source_mgr_File_findCheckPoint(source_mgr_File* f, uint32_t offset);
static source_mgr_SourceMgr* source_mgr_create(string_pool_Pool* pool);
static void source_mgr_SourceMgr_free(source_mgr_SourceMgr* sm);
static void source_mgr_SourceMgr_clear(source_mgr_SourceMgr* sm, int32_t handle);
static void source_mgr_SourceMgr_resize(source_mgr_SourceMgr* sm);
static int32_t source_mgr_SourceMgr_addGenerated(source_mgr_SourceMgr* sm, const char* name, void* data, uint32_t size);
static int32_t source_mgr_SourceMgr_addResource(source_mgr_SourceMgr* sm, const char* name, const void* data, uint32_t size);
static int32_t source_mgr_SourceMgr_loadFile(source_mgr_SourceMgr* sm, const char* filename, src_loc_SrcLoc sloc);
static int32_t source_mgr_SourceMgr_addFile(source_mgr_SourceMgr* sm, const char* filename, void* data, uint32_t size, bool is_generated, bool is_const);
static const char* source_mgr_SourceMgr_get_content(source_mgr_SourceMgr* sm, int32_t handle);
static uint32_t source_mgr_SourceMgr_get_offset(source_mgr_SourceMgr* sm, int32_t handle);
static uint32_t source_mgr_SourceMgr_getFileNameIdx(source_mgr_SourceMgr* sm, int32_t handle);
static const char* source_mgr_SourceMgr_getFileName(source_mgr_SourceMgr* sm, int32_t handle);
static source_mgr_File* source_mgr_SourceMgr_find_file(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc);
static source_mgr_Location source_mgr_SourceMgr_locate(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc);
static char* source_mgr_SourceMgr_loc2str(source_mgr_SourceMgr* sm, src_loc_SrcLoc sloc, char* tmp, size_t tmp_size);
static uint32_t source_mgr_SourceMgr_getNumFiles(const source_mgr_SourceMgr* sm);
static void source_mgr_SourceMgr_visitFiles(const source_mgr_SourceMgr* sm, void* arg, source_mgr_Visitor visitor);
static void source_mgr_SourceMgr_report(source_mgr_SourceMgr* sm, bool full);

static void source_mgr_File_clear(source_mgr_File* f)
{
   if (!f->is_const) free(f->data);
   f->data = NULL;
   free(f->checkpoints);
   f->checkpoints = NULL;
}

static source_mgr_CheckPoint source_mgr_update_checkpoint(source_mgr_CheckPoint cp, const char* src, uint32_t len)
{
   for (uint32_t i = 0; i < len; i++) {
      cp.column++;
      uint32_t mask = (src[i] == '\n');
      cp.line += mask;
      cp.column &= mask - 1;
   }
   return cp;
}

static void source_mgr_File_addCheckPoints(source_mgr_File* f)
{
   uint32_t ncheck = f->data_size / source_mgr_CheckPointSize;
   source_mgr_CheckPoint* cp = malloc((ncheck + 1) * 8);
   source_mgr_CheckPoint pos = { 0, 0 };
   const char* src = f->data;
   f->checkpoints = cp;
   while (ncheck-- > 0) {
      *cp++ = pos;
      pos = source_mgr_update_checkpoint(pos, src, source_mgr_CheckPointSize);
      src += source_mgr_CheckPointSize;
   }
   *cp = pos;
}

static source_mgr_CheckPoint source_mgr_File_findCheckPoint(source_mgr_File* f, uint32_t offset)
{
   if (!f->checkpoints) source_mgr_File_addCheckPoints(f);
   source_mgr_CheckPoint pos = f->checkpoints[offset / source_mgr_CheckPointSize];
   uint32_t chunk = offset % source_mgr_CheckPointSize;
   const char* src = f->data + offset - chunk;
   return source_mgr_update_checkpoint(pos, src, chunk);
}

static source_mgr_SourceMgr* source_mgr_create(string_pool_Pool* pool)
{
   source_mgr_SourceMgr* sm = calloc(1, 48);
   sm->pool = pool;
   sm->max_files = source_mgr_InitialMaxFiles;
   sm->files = malloc(32 * sm->max_files);
   sm->max_offset = source_mgr_FileIndexSize;
   sm->index_capacity = 1024 * 1024 / source_mgr_FileIndexSize;
   sm->index = malloc(2 * sm->index_capacity);
   sm->index[0] = 0;
   return sm;
}

static void source_mgr_SourceMgr_free(source_mgr_SourceMgr* sm)
{
   for (uint32_t i = 0; i < sm->num_files; i++) {
      source_mgr_File_clear(&sm->files[i]);
   }
   free(sm->files);
   free(sm->index);
   free(sm);
}

static void source_mgr_SourceMgr_clear(source_mgr_SourceMgr* sm, int32_t handle)
{
   uint32_t start_handle = 0;
   if (handle >= 0) start_handle = (uint32_t)(handle + 1);
   for (uint32_t i = start_handle; i < sm->num_files; i++) {
      source_mgr_File_clear(&sm->files[i]);
   }
   sm->num_files = start_handle;
   sm->index_count = 1;
   if (sm->num_files) {
      const source_mgr_File* f = &sm->files[sm->num_files - 1];
      sm->index_count = (f->offset + f->data_size) / source_mgr_FileIndexSize + 1;
   }
   sm->max_offset = sm->index_count * source_mgr_FileIndexSize;
}

static void source_mgr_SourceMgr_resize(source_mgr_SourceMgr* sm)
{
   sm->max_files *= 2;
   source_mgr_File* files2 = malloc(32 * sm->max_files);
   memcpy(files2, sm->files, sm->num_files * 32);
   free(sm->files);
   sm->files = files2;
}

static int32_t source_mgr_SourceMgr_addGenerated(source_mgr_SourceMgr* sm, const char* name, void* data, uint32_t size)
{
   return source_mgr_SourceMgr_addFile(sm, name, data, size, true, false);
}

static int32_t source_mgr_SourceMgr_addResource(source_mgr_SourceMgr* sm, const char* name, const void* data, uint32_t size)
{
   return source_mgr_SourceMgr_addFile(sm, name, (void*)data, size, true, true);
}

static int32_t source_mgr_SourceMgr_loadFile(source_mgr_SourceMgr* sm, const char* filename, src_loc_SrcLoc sloc)
{
   file_utils_File file; file_utils_File_init(&file, "", filename);
   if (!file_utils_File_load(&file)) {
      char tmp[256];
      *tmp = '\0';
      if (sloc) {
         source_mgr_Location loc = source_mgr_SourceMgr_locate(sm, sloc);
         if (loc.line_start) {
            snprintf(tmp, 256, "%s:%u:%u: ", loc.filename, loc.line, loc.column);
         }
      }
      if (color_useColor()) {
         fprintf(stderr, "%s%serror:%s cannot open %s: %s\n", tmp, color_Color_str(color_Red), color_Color_str(color_Normal), filename, file_utils_File_getError(&file));
      } else {
         fprintf(stderr, "%serror: cannot open %s: %s\n", tmp, filename, file_utils_File_getError(&file));
      }
      return -1;
   }
   uint32_t size;
   void* data = file_utils_File_detach(&file, &size);
   return source_mgr_SourceMgr_addFile(sm, filename, data, size, false, false);
}

static int32_t source_mgr_SourceMgr_addFile(source_mgr_SourceMgr* sm, const char* filename, void* data, uint32_t size, bool is_generated, bool is_const)
{
   if (sm->num_files == sm->max_files) source_mgr_SourceMgr_resize(sm);
   int32_t file_id = (int32_t)sm->num_files;
   source_mgr_File* f = &sm->files[sm->num_files];
   memset(f, 0, 32);
   f->filename = string_pool_Pool_addStr(sm->pool, filename, true);
   f->offset = sm->max_offset;
   f->data_size = size;
   f->data = data;
   f->is_const = is_const;
   f->is_generated = is_generated;
   sm->max_offset += (size + source_mgr_FileIndexSize) & -source_mgr_FileIndexSize;
   sm->num_files++;
   uint32_t index_pos = sm->index_count;
   uint32_t index_max = sm->max_offset / source_mgr_FileIndexSize;
   if (index_max > sm->index_capacity) {
      uint32_t new_capacity = sm->index_capacity;
      while ((new_capacity += new_capacity / 2 + 128) < index_max) continue;

      uint16_t* new_index = malloc(new_capacity * 2);
      memcpy(new_index, sm->index, index_pos * 2);
      free(sm->index);
      sm->index = new_index;
      sm->index_capacity = new_capacity;
   }
   while (index_pos < index_max) {
      sm->index[index_pos++] = (uint16_t)file_id;
   }
   sm->index_count = index_pos;
   return file_id;
}

static const char* source_mgr_SourceMgr_get_content(source_mgr_SourceMgr* sm, int32_t handle)
{
   ;//assert((uint32_t)handle < sm->num_files);
   return sm->files[handle].data;
}

static uint32_t source_mgr_SourceMgr_get_offset(source_mgr_SourceMgr* sm, int32_t handle)
{
   ;//assert((uint32_t)handle < sm->num_files);
   return sm->files[handle].offset;
}

static uint32_t source_mgr_SourceMgr_getFileNameIdx(source_mgr_SourceMgr* sm, int32_t handle)
{
   ;//assert((uint32_t)handle < sm->num_files);
   return sm->files[handle].filename;
}

static const char* source_mgr_SourceMgr_getFileName(source_mgr_SourceMgr* sm, int32_t handle)
{
   ;//assert((uint32_t)handle < sm->num_files);
   return string_pool_Pool_idx2str(sm->pool, sm->files[handle].filename);
}

static source_mgr_File* source_mgr_SourceMgr_find_file(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc)
{
   if (loc >= source_mgr_FileIndexSize && loc < sm->max_offset) {
      uint32_t file = sm->index[loc / source_mgr_FileIndexSize];
      return &sm->files[file];
   }
   return NULL;
}

static source_mgr_Location source_mgr_SourceMgr_locate(source_mgr_SourceMgr* sm, src_loc_SrcLoc loc)
{
   source_mgr_Location l = { 1, 1, "-", NULL };
   source_mgr_File* f = source_mgr_SourceMgr_find_file(sm, loc);
   if (f) {
      ;//assert(loc >= f->offset);
      uint32_t offset = loc - f->offset;
      ;//assert(offset <= f->data_size);
      source_mgr_CheckPoint pos = source_mgr_File_findCheckPoint(f, offset);
      l.line = pos.line + 1;
      l.column = pos.column + 1;
      l.line_start = f->data + offset - pos.column;
      l.filename = string_pool_Pool_idx2str(sm->pool, f->filename);
   }
   return l;
}

static char* source_mgr_SourceMgr_loc2str(source_mgr_SourceMgr* sm, src_loc_SrcLoc sloc, char* tmp, size_t tmp_size)
{
   source_mgr_Location loc = source_mgr_SourceMgr_locate(sm, sloc);
   if (loc.line_start) {
      snprintf(tmp, tmp_size, "%s:%u:%u", loc.filename, loc.line, loc.column);
   } else {
      snprintf(tmp, tmp_size, "-");
   }
   return tmp;
}

static uint32_t source_mgr_SourceMgr_getNumFiles(const source_mgr_SourceMgr* sm)
{
   return sm->num_files;
}

static void source_mgr_SourceMgr_visitFiles(const source_mgr_SourceMgr* sm, void* arg, source_mgr_Visitor visitor)
{
   for (uint32_t i = 0; i < sm->num_files; i++) {
      source_mgr_File* f = &sm->files[i];
      visitor(arg, f->offset, f->data_size, string_pool_Pool_idx2str(sm->pool, f->filename), f->data);
   }
}

static void source_mgr_SourceMgr_report(source_mgr_SourceMgr* sm, bool full)
{
   uint32_t total_size = 48 + sm->max_files * 32 + sm->index_capacity * 2;
   uint32_t total_bytes = 0;
   uint32_t total_lines = 0;
   if (full) printf("source-mgr: %u files\n", sm->num_files);
   for (uint32_t i = 0; i < sm->num_files; i++) {
      source_mgr_File* f = &sm->files[i];
      total_bytes += f->data_size;
      total_size += f->data_size + 1;
      uint32_t lines = 0;
      if (f->data_size && f->checkpoints) {
         total_size += (f->data_size / source_mgr_CheckPointSize + 1) * 8;
         uint32_t last = f->offset + f->data_size - 1;
         source_mgr_Location loc = source_mgr_SourceMgr_locate(sm, last);
         lines = loc.line;
         total_lines += lines;
      }
      if (full) {
         printf("  %7u  %6u  %4u  %s%s\n", f->offset, f->data_size, lines, string_pool_Pool_idx2str(sm->pool, f->filename), f->is_generated ? " (generated)" : "");
      }
   }
   printf("source-mgr: %u files, %u bytes, %u total size, %u lines\n", sm->num_files, total_bytes, total_size, total_lines);
}


// --- module string_list ---
typedef struct string_list_List_ string_list_List;

struct string_list_List_ {
   string_pool_Pool* pool;
   uint32_t* indexes;
   uint32_t count;
   uint32_t capacity;
};

static void string_list_List_init(string_list_List* l, string_pool_Pool* pool);
static void string_list_List_free(string_list_List* l);
static void string_list_List_clear(string_list_List* l);
static void string_list_List_resize(string_list_List* l, uint32_t capacity);
static void string_list_List_add(string_list_List* l, uint32_t name_idx);
static uint32_t string_list_List_del(string_list_List* l, uint32_t idx);
static void string_list_List_addStr(string_list_List* l, const char* str);
static bool string_list_List_contains(const string_list_List* l, const char* name);
static bool string_list_List_contains_idx(const string_list_List* l, uint32_t idx);
static uint32_t string_list_List_length(const string_list_List* l);
static const char* string_list_List_get(const string_list_List* l, uint32_t idx);
static uint32_t string_list_List_get_idx(const string_list_List* l, uint32_t idx);
static uint32_t* string_list_List_getData(string_list_List* l);

static void string_list_List_init(string_list_List* l, string_pool_Pool* pool)
{
   memset(l, 0, 24);
   l->pool = pool;
   string_list_List_resize(l, 16);
}

static void string_list_List_free(string_list_List* l)
{
   free(l->indexes);
   l->indexes = NULL;
}

static void string_list_List_clear(string_list_List* l)
{
   l->count = 0;
}

static void string_list_List_resize(string_list_List* l, uint32_t capacity)
{
   l->capacity = capacity;
   uint32_t* indexes2 = malloc(capacity * 4);
   if (l->count) {
      memcpy(indexes2, l->indexes, l->count * 4);
      free(l->indexes);
   }
   l->indexes = indexes2;
}

static void string_list_List_add(string_list_List* l, uint32_t name_idx)
{
   if (l->count == l->capacity) string_list_List_resize(l, l->capacity * 2);
   l->indexes[l->count] = name_idx;
   l->count++;
}

static uint32_t string_list_List_del(string_list_List* l, uint32_t idx)
{
   uint32_t j = 0;
   uint32_t count = l->count;
   for (uint32_t i = 0; i < count; i++) {
      if (l->indexes[i] != idx) l->indexes[j++] = l->indexes[i];
   }
   l->count = j;
   return count - j;
}

static void string_list_List_addStr(string_list_List* l, const char* str)
{
   string_list_List_add(l, string_pool_Pool_addStr(l->pool, str, true));
}

static bool string_list_List_contains(const string_list_List* l, const char* name)
{
   for (uint32_t i = 0; i < l->count; i++) {
      if (strcmp(string_pool_Pool_idx2str(l->pool, l->indexes[i]), name) == 0) return true;
   }
   return false;
}

static bool string_list_List_contains_idx(const string_list_List* l, uint32_t idx)
{
   for (uint32_t i = 0; i < l->count; i++) {
      if (l->indexes[i] == idx) return true;
   }
   return false;
}

static uint32_t string_list_List_length(const string_list_List* l)
{
   return l->count;
}

static const char* string_list_List_get(const string_list_List* l, uint32_t idx)
{
   return string_pool_Pool_idx2str(l->pool, l->indexes[idx]);
}

static uint32_t string_list_List_get_idx(const string_list_List* l, uint32_t idx)
{
   return l->indexes[idx];
}

static uint32_t* string_list_List_getData(string_list_List* l)
{
   return l->indexes;
}


// --- module string_utils ---

typedef void (*string_utils_PathHandler)(void* arg, const char* path, uint32_t len);

static char* string_utils_toLower(const char* input, char* output);
static char* string_utils_toUpper(const char* input, char* output);
static char* string_utils_stripNewLine(char* buf);
static bool string_utils_endsWith(const char* text, const char* tail);
static void string_utils_split_paths(const char* input, void* arg, string_utils_PathHandler handler);

static char* string_utils_toLower(const char* input, char* output)
{
   size_t i;
   for (i = 0; input[i]; i++) {
      output[i] = (char)toupper(input[i]);
   }
   output[i] = '\0';
   return output;
}

static char* string_utils_toUpper(const char* input, char* output)
{
   size_t i;
   for (i = 0; input[i]; i++) {
      output[i] = (char)toupper(input[i]);
   }
   output[i] = '\0';
   return output;
}

static char* string_utils_stripNewLine(char* buf)
{
   size_t len = strlen(buf);
   if (len > 0 && buf[len - 1] == '\n') {
      buf[--len] = '\0';
      if (len > 0 && buf[len - 1] == '\r') buf[--len] = '\0';
   }
   return buf;
}

static bool string_utils_endsWith(const char* text, const char* tail)
{
   size_t len = strlen(text);
   size_t tlen = strlen(tail);
   return (tlen <= len && !memcmp(text + len - tlen, tail, tlen));
}

static void string_utils_split_paths(const char* input, void* arg, string_utils_PathHandler handler)
{
   const char* start = input;
   for (const char* cp = start;; cp++) {
      if (*cp == '\0' || *cp == ':') {
         if (cp != start) handler(arg, start, (uint32_t)(cp - start));
         if (*cp == '\0') return;
         start = cp + 1;
      }
   }
}


// --- module utf8 ---

static uint32_t utf8_encode(char* dest, uint32_t max_len, uint32_t cc);
static uint32_t utf8_decode(const char* p, uint32_t max_len, uint32_t* pc);
static uint32_t utf8_sync(const char* p);

static uint32_t utf8_encode(char* dest, uint32_t max_len, uint32_t cc)
{
   if (cc < 0x80) {
      if (max_len >= 1) {
         dest[0] = (char)cc;
         return 1;
      }
   } else if (cc < 0x800) {
      if (max_len >= 2) {
         dest[0] = (char)(0xc0 + (cc >> 6));
         dest[1] = (char)(0x80 + (cc & 0x3f));
         return 2;
      }
   } else if (cc < 0x10000) {
      if (max_len >= 3) {
         dest[0] = (char)(0xe0 + (cc >> 12));
         dest[1] = (char)(0x80 + ((cc >> 6) & 0x3f));
         dest[2] = (char)(0x80 + (cc & 0x3f));
         return 3;
      }
   } else if (cc < 0x110000) {
      if (max_len >= 4) {
         dest[0] = (char)(0xf0 + (cc >> 18));
         dest[1] = (char)(0x80 + ((cc >> 12) & 0x3f));
         dest[2] = (char)(0x80 + ((cc >> 6) & 0x3f));
         dest[3] = (char)(0x80 + (cc & 0x3f));
         return 4;
      }
   }
   return 0;
}

static uint32_t utf8_decode(const char* p, uint32_t max_len, uint32_t* pc)
{
   if (!max_len) return 0;
   uint32_t c = (uint8_t)*p++;
   if (c < 0x80) {
      *pc = c;
      return 1;
   } else if (c < 0xc2) {
   } else if (c < 0xe0) {
      if (max_len >= 2 && p[0] >= 0x80 && p[0] <= 0xbf) {
         *pc = ((c - 0xc0) << 6) + (p[0] - 0x80);
         return 2;
      }
   } else if (c < 0xf0) {
      if (max_len >= 3 && p[0] >= 0x80 && p[0] <= 0xbf && p[1] >= 0x80 && p[1] <= 0xbf) {
         c = ((c - 0xe0) << 12) + ((p[0] - 0x80) << 6) + (p[1] - 0x80);
         if (c >= 0x800) {
            *pc = c;
            return 3;
         }
      }
   } else if (c <= 0xf4) {
      if (max_len >= 4 && p[0] >= 0x80 && p[0] <= 0xbf && p[1] >= 0x80 && p[1] <= 0xbf && p[2] >= 0x80 && p[2] <= 0xbf) {
         c = ((c - 0xf0) << 18) + ((p[0] - 0x80) << 12) + ((p[1] - 0x80) << 6) + (p[2] - 0x80);
         if (c >= 0x10000 && c < 0x110000) {
            *pc = c;
            return 4;
         }
      }
   }
   return 0;
}

static uint32_t utf8_sync(const char* p)
{
   uint32_t i = 0;
   while (i < 3 && (p[i] & 0xc0) == 0x80) i++;
   return i;
}


// --- module utils ---
typedef struct utils_PathInfo_ utils_PathInfo;

struct utils_PathInfo_ {
   char orig2root[512];
   char root2orig[512];
};

static uint64_t utils_now(void);
static bool utils_PathInfo_hasSubdir(const utils_PathInfo* pi);
static bool utils_findProjectDir(utils_PathInfo* info);
static const char* utils_findBuildFile(void);

static uint64_t utils_now(void)
{
   timeval tv;
   gettimeofday(&tv, NULL);
   uint64_t now64 = (uint64_t)tv.tv_sec;
   now64 *= 1000000;
   now64 += tv.tv_usec;
   return now64;
}

static bool utils_PathInfo_hasSubdir(const utils_PathInfo* pi)
{
   return pi->orig2root[0] != 0;
}

static bool utils_findProjectDir(utils_PathInfo* info)
{
   if (info) {
      info->root2orig[0] = 0;
      info->orig2root[0] = 0;
   }
   char base_path[512];
   char rel_path[512];
   base_path[0] = 0;
   rel_path[0] = 0;
   char buffer[512];
   while (1) {
      char* path = getcwd(buffer, 512);
      if (path == NULL) {
         perror("getcwd");
         return false;
      }
      if (base_path[0] == 0) strcpy(base_path, path);
      struct stat buf;
      if (stat(constants_recipe_name, &buf)) {
         if (path[0] == '/' && path[1] == '\0') return false;
         if ((*__errno_location()) != c_errno_ENOENT) {
            perror("stat");
            return false;
         }
      } else {
         if ((buf.st_mode & sys_stat_S_IFMT) == sys_stat_S_IFREG) {
            char* path_prefix = base_path + strlen(path);
            if (*path_prefix == '/') path_prefix++;
            if (info) {
               strcpy(info->orig2root, path_prefix);
               strcpy(info->root2orig, rel_path);
            }
            return true;
         }
      }
      if (chdir("..")) {
         perror("chdir");
         return false;
      }
      strcat(rel_path, "../");
   }
}

static const char* utils_findBuildFile(void)
{
   struct stat buf;
   int32_t error = stat(constants_buildfile_name, &buf);
   if (error) return NULL;
   return constants_buildfile_name;
}


// --- module warning_flags ---
typedef struct warning_flags_Flags_ warning_flags_Flags;

struct warning_flags_Flags_ {
   bool no_unused;
   bool no_unused_variable;
   bool no_unused_function;
   bool no_unused_parameter;
   bool no_unused_type;
   bool no_unused_module;
   bool no_unused_import;
   bool no_unused_public;
   bool no_unused_label;
   bool no_unused_enum_constant;
   bool no_unreachable_code;
   bool no_unknown_attribute;
   bool no_deprecated;
   bool are_errors;
};



// --- module build_file ---
typedef struct build_file_Plugin_ build_file_Plugin;
typedef struct build_file_Info_ build_file_Info;

struct build_file_Plugin_ {
   uint32_t name;
   uint32_t options;
   src_loc_SrcLoc loc;
};

struct build_file_Info_ {
   string_pool_Pool* pool;
   const char* filename;
   uint32_t target;
   uint32_t output_dir;
   uint32_t cc;
   uint32_t cflags;
   uint32_t ldflags;
   uint32_t ldflags2;
   uint32_t asmflags;
   uint32_t linkerscript;
   string_list_List lib_dirs;
   string_list_List plugin_dirs;
   build_file_Plugin* plugins;
   uint32_t plugin_count;
   uint32_t plugin_max;
};

static void build_file_Info_addPlugin(build_file_Info* info, const char* name, const char* options, src_loc_SrcLoc loc);
static const char* build_file_Info_getTarget(const build_file_Info* info);
static const char* build_file_Info_getOutputDir(const build_file_Info* info);
static const char* build_file_Info_getCC(const build_file_Info* info);
static const char* build_file_Info_getCFlags(const build_file_Info* info);
static const char* build_file_Info_getLinkerFlags(const build_file_Info* info);
static const char* build_file_Info_getLdFlags2(const build_file_Info* info);
static const char* build_file_Info_getAsmFlags(const build_file_Info* info);
static const string_list_List* build_file_Info_getLibDirs(const build_file_Info* info);
static const string_list_List* build_file_Info_getPluginDirs(const build_file_Info* info);
static const build_file_Plugin* build_file_Info_getPlugin(const build_file_Info* info, uint32_t idx);
static uint32_t build_file_Info_getNumPlugins(const build_file_Info* info);
static void build_file_Info_free(build_file_Info* info);

static void build_file_Info_addPlugin(build_file_Info* info, const char* name, const char* options, src_loc_SrcLoc loc)
{
   if (info->plugin_count == info->plugin_max) {
      info->plugin_max += 2;
      build_file_Plugin* plugins2 = malloc(info->plugin_max * 12);
      if (info->plugins) {
         memcpy(plugins2, info->plugins, info->plugin_count * 12);
         free(info->plugins);
      }
      info->plugins = plugins2;
   }
   build_file_Plugin* p = &info->plugins[info->plugin_count];
   info->plugin_count++;
   p->name = string_pool_Pool_addStr(info->pool, name, false);
   p->options = string_pool_Pool_addStr(info->pool, options, false);
   p->loc = loc;
}

static const char* build_file_Info_getTarget(const build_file_Info* info)
{
   if (info->target) return string_pool_Pool_idx2str(info->pool, info->target);
   return NULL;
}

static const char* build_file_Info_getOutputDir(const build_file_Info* info)
{
   if (info->output_dir) return string_pool_Pool_idx2str(info->pool, info->output_dir);
   return NULL;
}

static const char* build_file_Info_getCC(const build_file_Info* info)
{
   if (info->cc) return string_pool_Pool_idx2str(info->pool, info->cc);
   return NULL;
}

static const char* build_file_Info_getCFlags(const build_file_Info* info)
{
   if (info->cflags) return string_pool_Pool_idx2str(info->pool, info->cflags);
   return NULL;
}

static const char* build_file_Info_getLinkerFlags(const build_file_Info* info)
{
   if (info->ldflags) return string_pool_Pool_idx2str(info->pool, info->ldflags);
   return NULL;
}

static const char* build_file_Info_getLdFlags2(const build_file_Info* info)
{
   if (info->ldflags2) return string_pool_Pool_idx2str(info->pool, info->ldflags2);
   return NULL;
}

static const char* build_file_Info_getAsmFlags(const build_file_Info* info)
{
   if (info->asmflags) return string_pool_Pool_idx2str(info->pool, info->asmflags);
   return NULL;
}

static const string_list_List* build_file_Info_getLibDirs(const build_file_Info* info)
{
   return &info->lib_dirs;
}

static const string_list_List* build_file_Info_getPluginDirs(const build_file_Info* info)
{
   return &info->plugin_dirs;
}

static const build_file_Plugin* build_file_Info_getPlugin(const build_file_Info* info, uint32_t idx)
{
   return &info->plugins[idx];
}

static uint32_t build_file_Info_getNumPlugins(const build_file_Info* info)
{
   return info->plugin_count;
}

static void build_file_Info_free(build_file_Info* info)
{
   string_list_List_free(&info->lib_dirs);
   string_list_List_free(&info->plugin_dirs);
   free(info);
}


// --- module build_file_parser ---

static uint32_t build_file_parser_expandField(build_file_Info* info, const char* raw);
static bool build_file_parser_getYamlInfo(yaml_Parser* parser, build_file_Info* info);
static bool build_file_parser_parseInfo(build_file_Info* info, const char* data);
static build_file_Info* build_file_parser_parse(source_mgr_SourceMgr* sm, string_pool_Pool* pool, const char* filename);

static uint32_t build_file_parser_expandField(build_file_Info* info, const char* raw)
{
   if (!raw) return 0;
   if (raw[0] == '$') {
      const char* expand = getenv(raw + 1);
      if (!expand) {
         fprintf(stderr, "[build-file] warning: environment variable '%s' not set!\n", raw + 1);
         return 0;
      }
      raw = expand;
   }
   return string_pool_Pool_addStr(info->pool, raw, false);
}

static bool build_file_parser_getYamlInfo(yaml_Parser* parser, build_file_Info* info)
{
   const char* target = yaml_Parser_getScalarValue(parser, "target");
   info->target = build_file_parser_expandField(info, target);
   const char* outputDir = yaml_Parser_getScalarValue(parser, "output_dir");
   info->output_dir = build_file_parser_expandField(info, outputDir);
   const char* cc = yaml_Parser_getScalarValue(parser, "toolchain.cc");
   info->cc = build_file_parser_expandField(info, cc);
   const char* cflags = yaml_Parser_getScalarValue(parser, "toolchain.cflags");
   info->cflags = build_file_parser_expandField(info, cflags);
   const char* ldflags = yaml_Parser_getScalarValue(parser, "toolchain.ldflags");
   info->ldflags = build_file_parser_expandField(info, ldflags);
   const char* ldflags2 = yaml_Parser_getScalarValue(parser, "toolchain.ldflags2");
   info->ldflags2 = build_file_parser_expandField(info, ldflags2);
   const char* asmflags = yaml_Parser_getScalarValue(parser, "toolchain.asmflags");
   info->asmflags = build_file_parser_expandField(info, asmflags);
   const char* linkerscript = yaml_Parser_getScalarValue(parser, "toolchain.linkerscript");
   info->linkerscript = build_file_parser_expandField(info, linkerscript);
   const yaml_Node* dirs = yaml_Parser_findNode(parser, "libdir");
   yaml_Iter iter = yaml_Parser_getNodeChildIter(parser, dirs);
   while (!yaml_Iter_done(&iter)) {
      const char* dir = yaml_Iter_getValue(&iter);
      string_list_List_add(&info->lib_dirs, build_file_parser_expandField(info, dir));
      yaml_Iter_next(&iter);
   }
   dirs = yaml_Parser_findNode(parser, "plugindir");
   iter = yaml_Parser_getNodeChildIter(parser, dirs);
   while (!yaml_Iter_done(&iter)) {
      const char* dir = yaml_Iter_getValue(&iter);
      string_list_List_add(&info->plugin_dirs, build_file_parser_expandField(info, dir));
      yaml_Iter_next(&iter);
   }
   const yaml_Node* root = yaml_Parser_getRoot(parser);
   iter = yaml_Parser_getNodeChildIter(parser, root);
   while (!yaml_Iter_done(&iter)) {
      const char* name = yaml_Iter_getName(&iter);
      if (strncmp(name, "plugin.,", 7) == 0) {
         const char* options = yaml_Iter_getChildScalarValue(&iter, "options");
         if (!options) {
            fprintf(stderr, "[build-file] missing options for %s\n", name);
            exit(-1);
         }
         src_loc_SrcLoc loc = 0;
         build_file_Info_addPlugin(info, name + 7, options, loc);
      }
      yaml_Iter_next(&iter);
   }
   return true;
}

static bool build_file_parser_parseInfo(build_file_Info* info, const char* data)
{
   yaml_Parser* parser = yaml_Parser_create();
   bool ok = yaml_Parser_parse(parser, data);
   if (ok) {
      ok = build_file_parser_getYamlInfo(parser, info);
   } else {
      fprintf(stderr, "Error: %s\n", yaml_Parser_getMessage(parser));
   }
   yaml_Parser_destroy(parser);
   return ok;
}

static build_file_Info* build_file_parser_parse(source_mgr_SourceMgr* sm, string_pool_Pool* pool, const char* filename)
{
   build_file_Info info = { };
   info.pool = pool;
   info.filename = filename;
   string_list_List_init(&info.lib_dirs, pool);
   string_list_List_init(&info.plugin_dirs, pool);
   int32_t file_id = source_mgr_SourceMgr_loadFile(sm, filename, 0);
   if (file_id == -1) return NULL;
   bool ok = build_file_parser_parseInfo(&info, source_mgr_SourceMgr_get_content(sm, file_id));
   if (!ok) return NULL;
   build_file_Info* result = malloc(112);
   memcpy(result, &info, 112);
   return result;
}


// --- module dsm_sorter ---
typedef struct dsm_sorter_Sorter_ dsm_sorter_Sorter;

struct dsm_sorter_Sorter_ {
   uint8_t* array;
   uint32_t count;
};

static void dsm_sorter_Sorter_init(dsm_sorter_Sorter* s, uint32_t count);
static void dsm_sorter_Sorter_free(dsm_sorter_Sorter* s);
static void dsm_sorter_Sorter_add_dep(dsm_sorter_Sorter* s, uint32_t src, uint32_t dst);
static const uint8_t* dsm_sorter_Sorter_get_array(dsm_sorter_Sorter* s);
static const uint8_t* dsm_sorter_Sorter_sort(dsm_sorter_Sorter* s);

static void dsm_sorter_Sorter_init(dsm_sorter_Sorter* s, uint32_t count)
{
   s->array = calloc(1, count * (count + 2));
   s->count = count;
   ;//assert(count <= 256);
}

static void dsm_sorter_Sorter_free(dsm_sorter_Sorter* s)
{
   free(s->array);
}

static void dsm_sorter_Sorter_add_dep(dsm_sorter_Sorter* s, uint32_t src, uint32_t dst)
{
   uint32_t offset = src * s->count + dst;
   s->array[offset] = 1;
}

static const uint8_t* dsm_sorter_Sorter_get_array(dsm_sorter_Sorter* s)
{
   return s->array;
}

static const uint8_t* dsm_sorter_Sorter_sort(dsm_sorter_Sorter* s)
{
   const uint32_t count = s->count;
   uint8_t* sorted = &s->array[count * (count + 1)];
   uint8_t* ringbuf = &s->array[count * count];
   uint32_t head = 0;
   uint32_t size = count;
   for (uint8_t i = 0; i < count; i++) ringbuf[i] = i;
   uint32_t iterations = 0;
   while (size) {
      if (iterations > size) {
         return NULL;
      }
      uint8_t idx = ringbuf[head];
      head = (head + 1) % count;
      uint32_t offset = idx * count;
      bool has_deps = false;
      for (uint32_t j = 0; j < count; j++) {
         if (s->array[offset + j] != 0) {
            has_deps = true;
            break;
         }
      }
      if (has_deps) {
         ringbuf[(head + size - 1) % count] = idx;
         iterations++;
      } else {
         sorted[count - size] = (uint8_t)idx;
         iterations = 0;
         size--;
         for (uint32_t x = 0; x < count; x++) s->array[x * count + idx] = 0;
      }
   }
   return sorted;
}


// --- module target_info ---
typedef struct target_info_Info_ target_info_Info;

typedef uint8_t target_info_Arch;
enum target_info_Arch {
   target_info_Arch_Unknown,
   target_info_Arch_I686,
   target_info_Arch_Arm,
   target_info_Arch_X86_64,
   target_info_Arch_Amd64,
   target_info_Arch_Arm64,
   target_info_Arch_Riscv_32,
   target_info_Arch_Riscv_64,
};

typedef uint8_t target_info_System;
enum target_info_System {
   target_info_System_Unknown,
   target_info_System_Linux,
   target_info_System_Darwin,
   target_info_System_Cygwin,
   target_info_System_FreeBSD,
   target_info_System_OpenBSD,
};

typedef uint8_t target_info_Vendor;
enum target_info_Vendor {
   target_info_Vendor_Unknown,
   target_info_Vendor_Apple,
};

typedef uint8_t target_info_Abi;
enum target_info_Abi {
   target_info_Abi_Unknown,
   target_info_Abi_GNU,
   target_info_Abi_GNU_EABI,
   target_info_Abi_MACHO,
   target_info_Abi_WIN32,
   target_info_Abi_Rv32G,
   target_info_Abi_BSD,
};

struct target_info_Info_ {
   target_info_Arch arch;
   target_info_System sys;
   target_info_Vendor vendor;
   target_info_Abi abi;
   uint32_t intWidth;
   char triple[80];
};

static const char* target_info_system_names[6] = { "unknown", "linux", "darwin", "cygwin", "freebsd", "openbsd" };
static const char* target_info_arch_names[8] = {
   "unknown",
   "i686",
   "arm",
   "x86_64",
   "amd64",
   "arm64",
   "riscv32",
   "riscv64"
};
static const char* target_info_vendor_names[2] = { "unknown", "apple" };
static const char* target_info_abi_names[7] = {
   "unknown",
   "gnu",
   "gnueabi",
   "macho",
   "win32",
   "rv32",
   "bsd"
};
static target_info_System target_info_str2sys(const char* name);
static target_info_Arch target_info_str2arch(const char* name);
static target_info_Vendor target_info_str2vendor(const char* name);
static target_info_Abi target_info_str2abi(const char* name);
static void target_info_Info_init(target_info_Info* info);
static const char* target_info_Info_str(const target_info_Info* info);
static const char* target_info_Info_getSystemName(const target_info_Info* info);
static const char* target_info_Info_getArchName(const target_info_Info* info);

static target_info_System target_info_str2sys(const char* name)
{
   for (uint32_t i = 0; i < 6; i++) {
      if (strcasecmp(target_info_system_names[(target_info_System)i], name) == 0) return (target_info_System)i;
   }
   return target_info_System_Unknown;
}

static target_info_Arch target_info_str2arch(const char* name)
{
   for (uint32_t i = 0; i < 8; i++) {
      if (strcasecmp(target_info_arch_names[(target_info_Arch)i], name) == 0) return (target_info_Arch)i;
   }
   return target_info_Arch_Unknown;
}

static target_info_Vendor target_info_str2vendor(const char* name)
{
   for (uint32_t i = 0; i < 2; i++) {
      if (strcasecmp(target_info_vendor_names[(target_info_Vendor)i], name) == 0) return (target_info_Vendor)i;
   }
   return target_info_Vendor_Unknown;
}

static target_info_Abi target_info_str2abi(const char* name)
{
   for (uint32_t i = 0; i < 7; i++) {
      if (strcasecmp(target_info_abi_names[(target_info_Abi)i], name) == 0) return (target_info_Abi)i;
   }
   return target_info_Abi_Unknown;
}

static void target_info_Info_init(target_info_Info* info)
{
   switch (info->arch) {
   case target_info_Arch_Unknown:
      info->intWidth = 64;
      break;
   case target_info_Arch_I686:
   case target_info_Arch_Arm:
      info->intWidth = 32;
      break;
   case target_info_Arch_X86_64:
   case target_info_Arch_Arm64:
   case target_info_Arch_Amd64:
      info->intWidth = 64;
      break;
   case target_info_Arch_Riscv_32:
      info->intWidth = 32;
      break;
   case target_info_Arch_Riscv_64:
      info->intWidth = 64;
      break;
   }
   snprintf(info->triple, 80, "%s-%s-%s-%s", target_info_arch_names[info->arch], target_info_vendor_names[info->vendor], target_info_system_names[info->sys], target_info_abi_names[info->abi]);
}

static const char* target_info_Info_str(const target_info_Info* info)
{
   return info->triple;
}

static const char* target_info_Info_getSystemName(const target_info_Info* info)
{
   return target_info_system_names[info->sys];
}

static const char* target_info_Info_getArchName(const target_info_Info* info)
{
   return target_info_arch_names[info->arch];
}


// --- module token ---
typedef struct token_Token_ token_Token;

typedef uint8_t token_Kind;
enum token_Kind {
   token_Kind_None,
   token_Kind_Identifier,
   token_Kind_IntegerLiteral,
   token_Kind_FloatLiteral,
   token_Kind_CharLiteral,
   token_Kind_StringLiteral,
   token_Kind_LParen,
   token_Kind_RParen,
   token_Kind_LSquare,
   token_Kind_RSquare,
   token_Kind_LBrace,
   token_Kind_RBrace,
   token_Kind_Exclaim,
   token_Kind_ExclaimEqual,
   token_Kind_Star,
   token_Kind_StarEqual,
   token_Kind_Amp,
   token_Kind_AmpAmp,
   token_Kind_AmpEqual,
   token_Kind_Pipe,
   token_Kind_PipePipe,
   token_Kind_PipeEqual,
   token_Kind_Equal,
   token_Kind_EqualEqual,
   token_Kind_Semicolon,
   token_Kind_Colon,
   token_Kind_At,
   token_Kind_Caret,
   token_Kind_CaretEqual,
   token_Kind_Question,
   token_Kind_Dot,
   token_Kind_Ellipsis,
   token_Kind_Comma,
   token_Kind_Plus,
   token_Kind_PlusPlus,
   token_Kind_PlusEqual,
   token_Kind_Minus,
   token_Kind_MinusMinus,
   token_Kind_MinusEqual,
   token_Kind_Tilde,
   token_Kind_Slash,
   token_Kind_SlashEqual,
   token_Kind_Percent,
   token_Kind_PercentEqual,
   token_Kind_Less,
   token_Kind_LessLess,
   token_Kind_LessEqual,
   token_Kind_LessLessEqual,
   token_Kind_Greater,
   token_Kind_GreaterGreater,
   token_Kind_GreaterEqual,
   token_Kind_GreaterGreaterEqual,
   token_Kind_KW_bool,
   token_Kind_KW_char,
   token_Kind_KW_i8,
   token_Kind_KW_i16,
   token_Kind_KW_i32,
   token_Kind_KW_i64,
   token_Kind_KW_u8,
   token_Kind_KW_u16,
   token_Kind_KW_u32,
   token_Kind_KW_u64,
   token_Kind_KW_reg8,
   token_Kind_KW_reg16,
   token_Kind_KW_reg32,
   token_Kind_KW_reg64,
   token_Kind_KW_isize,
   token_Kind_KW_usize,
   token_Kind_KW_f32,
   token_Kind_KW_f64,
   token_Kind_KW_void,
   token_Kind_KW_as,
   token_Kind_KW_asm,
   token_Kind_KW_assert,
   token_Kind_KW_break,
   token_Kind_KW_case,
   token_Kind_KW_cast,
   token_Kind_KW_const,
   token_Kind_KW_continue,
   token_Kind_KW_default,
   token_Kind_KW_elemsof,
   token_Kind_KW_else,
   token_Kind_KW_enum_max,
   token_Kind_KW_enum_min,
   token_Kind_KW_enum,
   token_Kind_KW_fallthrough,
   token_Kind_KW_false,
   token_Kind_KW_fn,
   token_Kind_KW_for,
   token_Kind_KW_goto,
   token_Kind_KW_if,
   token_Kind_KW_import,
   token_Kind_KW_local,
   token_Kind_KW_module,
   token_Kind_KW_nil,
   token_Kind_KW_offsetof,
   token_Kind_KW_public,
   token_Kind_KW_return,
   token_Kind_KW_sizeof,
   token_Kind_KW_static_assert,
   token_Kind_KW_struct,
   token_Kind_KW_switch,
   token_Kind_KW_template,
   token_Kind_KW_to_container,
   token_Kind_KW_true,
   token_Kind_KW_type,
   token_Kind_KW_union,
   token_Kind_KW_volatile,
   token_Kind_KW_while,
   token_Kind_Feat_if,
   token_Kind_Feat_ifdef,
   token_Kind_Feat_ifndef,
   token_Kind_Feat_elif,
   token_Kind_Feat_else,
   token_Kind_Feat_endif,
   token_Kind_Feat_error,
   token_Kind_Feat_warning,
   token_Kind_Invalid,
   token_Kind_LineComment,
   token_Kind_BlockComment,
   token_Kind_Eof,
   token_Kind_Error,
};

struct token_Token_ {
   src_loc_SrcLoc loc;
   uint16_t len : 16;
   token_Kind kind : 8;
   bool done : 1;
   uint8_t radix : 2;
   uint8_t raw : 1;
   bool reserved : 1;
   bool suffix_F : 1;
   union {
      const char* error_msg;
      struct {
         uint32_t text_idx;
         uint32_t text_len;
      };
      uint32_t name_idx;
      uint64_t int_value;
      double float_value;
      uint8_t char_value;
      char invalid[8];
   };
};

static const char* token_token_names[122] = {
   [token_Kind_None] = "none",
   [token_Kind_Identifier] = "identifier",
   [token_Kind_IntegerLiteral] = "integer",
   [token_Kind_FloatLiteral] = "float",
   [token_Kind_CharLiteral] = "character",
   [token_Kind_StringLiteral] = "string",
   [token_Kind_LParen] = "(",
   [token_Kind_RParen] = ")",
   [token_Kind_LSquare] = "[",
   [token_Kind_RSquare] = "]",
   [token_Kind_LBrace] = "{",
   [token_Kind_RBrace] = "}",
   [token_Kind_Exclaim] = "!",
   [token_Kind_ExclaimEqual] = "!=",
   [token_Kind_Star] = "*",
   [token_Kind_StarEqual] = "*=",
   [token_Kind_Amp] = "&",
   [token_Kind_AmpAmp] = "&&",
   [token_Kind_AmpEqual] = "&=",
   [token_Kind_Pipe] = "|",
   [token_Kind_PipePipe] = "||",
   [token_Kind_PipeEqual] = "|=",
   [token_Kind_Equal] = "=",
   [token_Kind_EqualEqual] = "==",
   [token_Kind_Semicolon] = ";",
   [token_Kind_Colon] = ":",
   [token_Kind_At] = "@",
   [token_Kind_Caret] = "^",
   [token_Kind_CaretEqual] = "^=",
   [token_Kind_Question] = "?",
   [token_Kind_Dot] = ".",
   [token_Kind_Ellipsis] = "...",
   [token_Kind_Comma] = ",",
   [token_Kind_Plus] = "+",
   [token_Kind_PlusPlus] = "++",
   [token_Kind_PlusEqual] = "+=",
   [token_Kind_Minus] = "-",
   [token_Kind_MinusMinus] = "--",
   [token_Kind_MinusEqual] = "-=",
   [token_Kind_Tilde] = "~",
   [token_Kind_Slash] = "/",
   [token_Kind_SlashEqual] = "/=",
   [token_Kind_Percent] = "%",
   [token_Kind_PercentEqual] = "%=",
   [token_Kind_Less] = "<",
   [token_Kind_LessLess] = "<<",
   [token_Kind_LessEqual] = "<=",
   [token_Kind_LessLessEqual] = "<<=",
   [token_Kind_Greater] = ">",
   [token_Kind_GreaterGreater] = ">>",
   [token_Kind_GreaterEqual] = ">=",
   [token_Kind_GreaterGreaterEqual] = ">>=",
   [token_Kind_KW_bool] = "bool",
   [token_Kind_KW_char] = "char",
   [token_Kind_KW_i8] = "i8",
   [token_Kind_KW_i16] = "i16",
   [token_Kind_KW_i32] = "i32",
   [token_Kind_KW_i64] = "i64",
   [token_Kind_KW_u8] = "u8",
   [token_Kind_KW_u16] = "u16",
   [token_Kind_KW_u32] = "u32",
   [token_Kind_KW_u64] = "u64",
   [token_Kind_KW_reg8] = "reg8",
   [token_Kind_KW_reg16] = "reg16",
   [token_Kind_KW_reg32] = "reg32",
   [token_Kind_KW_reg64] = "reg64",
   [token_Kind_KW_isize] = "isize",
   [token_Kind_KW_usize] = "usize",
   [token_Kind_KW_f32] = "f32",
   [token_Kind_KW_f64] = "f64",
   [token_Kind_KW_void] = "void",
   [token_Kind_KW_as] = "as",
   [token_Kind_KW_asm] = "asm",
   [token_Kind_KW_assert] = "assert",
   [token_Kind_KW_break] = "break",
   [token_Kind_KW_case] = "case",
   [token_Kind_KW_cast] = "cast",
   [token_Kind_KW_const] = "const",
   [token_Kind_KW_continue] = "continue",
   [token_Kind_KW_default] = "default",
   [token_Kind_KW_elemsof] = "elemsof",
   [token_Kind_KW_else] = "else",
   [token_Kind_KW_enum_max] = "enum_max",
   [token_Kind_KW_enum_min] = "enum_min",
   [token_Kind_KW_enum] = "enum",
   [token_Kind_KW_fallthrough] = "fallthrough",
   [token_Kind_KW_false] = "false",
   [token_Kind_KW_fn] = "fn",
   [token_Kind_KW_for] = "for",
   [token_Kind_KW_goto] = "goto",
   [token_Kind_KW_if] = "if",
   [token_Kind_KW_import] = "import",
   [token_Kind_KW_local] = "local",
   [token_Kind_KW_module] = "module",
   [token_Kind_KW_nil] = "nil",
   [token_Kind_KW_offsetof] = "offsetof",
   [token_Kind_KW_public] = "public",
   [token_Kind_KW_return] = "return",
   [token_Kind_KW_sizeof] = "sizeof",
   [token_Kind_KW_static_assert] = "static_assert",
   [token_Kind_KW_struct] = "struct",
   [token_Kind_KW_switch] = "switch",
   [token_Kind_KW_template] = "template",
   [token_Kind_KW_to_container] = "to_container",
   [token_Kind_KW_true] = "true",
   [token_Kind_KW_type] = "type",
   [token_Kind_KW_union] = "union",
   [token_Kind_KW_volatile] = "volatile",
   [token_Kind_KW_while] = "while",
   [token_Kind_Feat_if] = "#if",
   [token_Kind_Feat_ifdef] = "#ifdef",
   [token_Kind_Feat_ifndef] = "#ifndef",
   [token_Kind_Feat_elif] = "#elif",
   [token_Kind_Feat_else] = "#else",
   [token_Kind_Feat_endif] = "#endif",
   [token_Kind_Feat_error] = "#error",
   [token_Kind_Feat_warning] = "#warning",
   [token_Kind_Invalid] = "invalid",
   [token_Kind_LineComment] = "l-comment",
   [token_Kind_BlockComment] = "b-comment",
   [token_Kind_Eof] = "eof",
   [token_Kind_Error] = "error"
};
static bool token_Kind_isKeyword(token_Kind kind);
static bool token_Kind_isQualifier(token_Kind kind);
static bool token_Kind_isBuiltinType(token_Kind kind);
static bool token_Kind_isBuiltinTypeOrVoid(token_Kind kind);
static const char* token_Kind_str(token_Kind k);
static void token_Token_init(token_Token* tok);
static number_radix_Radix token_Token_getRadix(const token_Token* tok);

static bool token_Kind_isKeyword(token_Kind kind)
{
   return kind >= token_Kind_KW_bool && kind <= token_Kind_KW_while;
}

static bool token_Kind_isQualifier(token_Kind kind)
{
   return kind == token_Kind_KW_const || kind == token_Kind_KW_volatile;
}

static bool token_Kind_isBuiltinType(token_Kind kind)
{
   return kind >= token_Kind_KW_bool && kind < token_Kind_KW_void;
}

static bool token_Kind_isBuiltinTypeOrVoid(token_Kind kind)
{
   return kind >= token_Kind_KW_bool && kind <= token_Kind_KW_void;
}

static const char* token_Kind_str(token_Kind k)
{
   return token_token_names[k];
}

static void token_Token_init(token_Token* tok)
{
   memset(tok, 0, 16);
}

static number_radix_Radix token_Token_getRadix(const token_Token* tok)
{
   return (number_radix_Radix)tok->radix;
}


// --- module init_checker ---
typedef struct init_checker_InitEntry_ init_checker_InitEntry;
typedef struct init_checker_Checker_ init_checker_Checker;

struct init_checker_InitEntry_ {
   uint32_t index;
   src_loc_SrcLoc loc;
};

struct init_checker_Checker_ {
   init_checker_InitEntry* entries;
   uint32_t count;
   uint32_t capacity;
   uint32_t max;
};

static void init_checker_Checker_free(init_checker_Checker* c);
static void init_checker_Checker_clear(init_checker_Checker* c);
static uint32_t init_checker_Checker_getCount(const init_checker_Checker* c);
static void init_checker_Checker_add(init_checker_Checker* c, uint32_t index, src_loc_SrcLoc loc);
static void init_checker_Checker_add2(init_checker_Checker* c, uint32_t index1, uint32_t index2, src_loc_SrcLoc loc);
static src_loc_SrcLoc init_checker_Checker_find(init_checker_Checker* c, uint32_t index);
static src_loc_SrcLoc init_checker_Checker_find2(init_checker_Checker* c, uint32_t index1, uint32_t index2);

static void init_checker_Checker_free(init_checker_Checker* c)
{
   free(c->entries);
   c->entries = NULL;
   c->count = 0;
   c->capacity = 0;
   c->max = 0;
}

static void init_checker_Checker_clear(init_checker_Checker* c)
{
   c->count = 0;
   c->max = 0;
}

static uint32_t init_checker_Checker_getCount(const init_checker_Checker* c)
{
   return c->count;
}

static void init_checker_Checker_add(init_checker_Checker* c, uint32_t index, src_loc_SrcLoc loc)
{
   if (c->count >= c->capacity) {
      c->capacity = c->capacity ? c->capacity * 2 : 8;
      init_checker_InitEntry* entries = malloc(c->capacity * 8);
      if (c->entries) {
         memcpy(entries, c->entries, c->count * 8);
         free(c->entries);
      }
      c->entries = entries;
   }
   init_checker_InitEntry* entry = &c->entries[c->count];
   entry->index = index;
   entry->loc = loc;
   if (index > c->max) c->max = index;
   c->count++;
}

static void init_checker_Checker_add2(init_checker_Checker* c, uint32_t index1, uint32_t index2, src_loc_SrcLoc loc)
{
   init_checker_Checker_add(c, index1, loc);
   if (index1 != index2) init_checker_Checker_add(c, index2, 0);
}

static src_loc_SrcLoc init_checker_Checker_find(init_checker_Checker* c, uint32_t index)
{
   if (index > c->max) return 0;
   for (uint32_t i = 0; i < c->count; i++) {
      if (c->entries[i].loc == 0) {
         if (c->entries[i - 1].index <= index && c->entries[i].index >= index) return c->entries[i - 1].loc;
      } else {
         if (c->entries[i].index == index) return c->entries[i].loc;
      }
   }
   return 0;
}

static src_loc_SrcLoc init_checker_Checker_find2(init_checker_Checker* c, uint32_t index1, uint32_t index2)
{
   if (index1 > c->max) return 0;
   for (uint32_t i = 0; i < c->count; i++) {
      if (c->entries[i].loc == 0) {
         if (c->entries[i - 1].index <= index2 && c->entries[i].index >= index1) return c->entries[i - 1].loc;
      } else {
         if (c->entries[i].index >= index1 && c->entries[i].index <= index2) return c->entries[i].loc;
      }
   }
   return 0;
}


// --- module name_vector ---
typedef struct name_vector_NameVector_ name_vector_NameVector;

struct name_vector_NameVector_ {
   uint32_t* data;
   uint32_t count;
   uint32_t capacity;
};

static void name_vector_NameVector_init(name_vector_NameVector* v, uint32_t capacity);
static void name_vector_NameVector_free(name_vector_NameVector* v);
static void name_vector_NameVector_clear(name_vector_NameVector* v);
static void name_vector_NameVector_resize(name_vector_NameVector* v);
static uint32_t name_vector_NameVector_add(name_vector_NameVector* v, uint32_t name_idx);
static uint32_t name_vector_NameVector_get(const name_vector_NameVector* v, uint32_t idx);
static bool name_vector_NameVector_find(name_vector_NameVector* v, uint32_t name_idx, uint32_t* index);

static void name_vector_NameVector_init(name_vector_NameVector* v, uint32_t capacity)
{
   v->data = NULL;
   v->count = 0;
   v->capacity = capacity;
   if (capacity) v->data = malloc(capacity * 4);
}

static void name_vector_NameVector_free(name_vector_NameVector* v)
{
   if (v->data) free(v->data);
   v->count = 0;
   v->capacity = 0;
   v->data = NULL;
}

static void name_vector_NameVector_clear(name_vector_NameVector* v)
{
   v->count = 0;
}

static void name_vector_NameVector_resize(name_vector_NameVector* v)
{
   v->capacity = v->capacity == 0 ? 4 : v->capacity * 2;
   void* data2 = malloc(v->capacity * 4);
   if (v->data) {
      memcpy(data2, v->data, v->count * 4);
      free(v->data);
   }
   v->data = data2;
}

static uint32_t name_vector_NameVector_add(name_vector_NameVector* v, uint32_t name_idx)
{
   if (v->count == v->capacity) name_vector_NameVector_resize(v);
   uint32_t index = v->count;
   v->data[index] = name_idx;
   v->count++;
   return index;
}

static uint32_t name_vector_NameVector_get(const name_vector_NameVector* v, uint32_t idx)
{
   return v->data[idx];
}

static bool name_vector_NameVector_find(name_vector_NameVector* v, uint32_t name_idx, uint32_t* index)
{
   for (uint32_t i = 0; i < v->count; i++) {
      if (v->data[i] == name_idx) {
         *index = i;
         return true;
      }
   }
   return false;
}


// --- module printf_utils ---
typedef struct printf_utils_PrintfConversion_ printf_utils_PrintfConversion;
typedef struct printf_utils_ScanfConversion_ printf_utils_ScanfConversion;

typedef uint8_t printf_utils_PrintfSpecifier;
enum printf_utils_PrintfSpecifier {
   printf_utils_PrintfSpecifier_Invalid,
   printf_utils_PrintfSpecifier_String,
   printf_utils_PrintfSpecifier_Char,
   printf_utils_PrintfSpecifier_Integer,
   printf_utils_PrintfSpecifier_FloatingPoint,
   printf_utils_PrintfSpecifier_Pointer,
   printf_utils_PrintfSpecifier_Offset,
   printf_utils_PrintfSpecifier_Percent,
};

struct printf_utils_PrintfConversion_ {
   char c;
   uint8_t nflags;
   bool has_width : 1;
   bool has_width_star : 1;
   bool has_prec : 1;
   bool has_prec_star : 1;
   uint32_t len;
   int32_t width;
   int32_t prec;
};

typedef bool (*printf_utils_PrintfFormatHandler)(void* arg, uint32_t offset, printf_utils_PrintfSpecifier specifier, printf_utils_PrintfConversion* conv);

typedef uint8_t printf_utils_ScanfSpecifier;
enum printf_utils_ScanfSpecifier {
   printf_utils_ScanfSpecifier_Invalid,
   printf_utils_ScanfSpecifier_String,
   printf_utils_ScanfSpecifier_Char,
   printf_utils_ScanfSpecifier_Integer,
   printf_utils_ScanfSpecifier_FloatingPoint,
   printf_utils_ScanfSpecifier_Pointer,
   printf_utils_ScanfSpecifier_Scanset,
   printf_utils_ScanfSpecifier_Offset,
   printf_utils_ScanfSpecifier_Percent,
};

struct printf_utils_ScanfConversion_ {
   char c;
   bool has_star;
   bool has_width;
   uint32_t len;
   int32_t width;
   uint32_t len2;
};

typedef bool (*printf_utils_ScanfFormatHandler)(void* arg, uint32_t offset, printf_utils_ScanfSpecifier specifier, printf_utils_ScanfConversion* conv);

static printf_utils_PrintfSpecifier printf_utils_getPrintfSpecifier(const char* format, printf_utils_PrintfConversion* conv);
static bool printf_utils_parsePrintfFormat(const char* format, printf_utils_PrintfFormatHandler handler, void* arg);
static printf_utils_ScanfSpecifier printf_utils_getScanfSpecifier(const char* format, printf_utils_ScanfConversion* conv);
static bool printf_utils_parseScanfFormat(const char* format, printf_utils_ScanfFormatHandler handler, void* arg);

static printf_utils_PrintfSpecifier printf_utils_getPrintfSpecifier(const char* format, printf_utils_PrintfConversion* conv)
{
   const char* cp = format;
   *conv = (printf_utils_PrintfConversion){ .width = -1, .prec = -1 };
   for (;;) {
      switch (*cp) {
      case ' ':
      case '+':
      case '-':
      case '#':
      case '\'':
      case '0':
         conv->nflags++;
         cp++;
         continue;
      }
      break;
   }
   if (*cp == '*') {
      conv->has_width = true;
      conv->has_width_star = true;
      cp++;
   } else if (isdigit(*cp)) {
      conv->has_width = true;
      conv->width = *cp++ - '0';
      while (isdigit(*cp)) {
         conv->width = conv->width * 10 + *cp++ - '0';
      }
   }
   if (*cp == '.') {
      conv->has_prec = true;
      cp++;
      if (*cp == '*') {
         conv->has_prec_star = true;
         cp++;
      } else if (isdigit(*cp)) {
         conv->prec = *cp++ - '0';
         while (isdigit(*cp)) {
            conv->prec = conv->prec * 10 + *cp++ - '0';
         }
      }
   }
   conv->len = (uint32_t)(cp - format);
   switch (conv->c = *cp) {
   case '%':
      if (cp == format) return printf_utils_PrintfSpecifier_Percent;
      return printf_utils_PrintfSpecifier_Invalid;
   case 'c':
      return printf_utils_PrintfSpecifier_Char;
   case 'a':
   case 'e':
   case 'f':
   case 'g':
   case 'A':
   case 'E':
   case 'F':
   case 'G':
      return printf_utils_PrintfSpecifier_FloatingPoint;
   case 'p':
      return printf_utils_PrintfSpecifier_Pointer;
   case 's':
      return printf_utils_PrintfSpecifier_String;
   case 'b':
   case 'B':
   case 'd':
   case 'o':
   case 'x':
   case 'X':
      return printf_utils_PrintfSpecifier_Integer;
   case 'n':
      return printf_utils_PrintfSpecifier_Offset;
   }
   return printf_utils_PrintfSpecifier_Invalid;
}

static bool printf_utils_parsePrintfFormat(const char* format, printf_utils_PrintfFormatHandler handler, void* arg)
{
   const char* cp = format;
   while (*cp) {
      if (*cp++ == '%') {
         uint32_t offset = (uint32_t)(cp - format);
         printf_utils_PrintfConversion conv;
         printf_utils_PrintfSpecifier s = printf_utils_getPrintfSpecifier(cp, &conv);
         cp += conv.len;
         if (*cp) cp++;
         if (!handler(arg, offset, s, &conv)) return false;
      }
   }
   return true;
}

static printf_utils_ScanfSpecifier printf_utils_getScanfSpecifier(const char* format, printf_utils_ScanfConversion* conv)
{
   const char* cp = format;
   *conv = (printf_utils_ScanfConversion){ .width = -1 };
   if (*cp == '*') {
      conv->has_star = true;
      cp++;
   }
   if (isdigit(*cp)) {
      conv->has_width = true;
      conv->width = *cp++ - '0';
      while (isdigit(*cp)) {
         conv->width = conv->width * 10 + *cp++ - '0';
      }
   }
   conv->len = (uint32_t)(cp - format);
   switch (conv->c = *cp) {
   case '%':
      if (cp == format) return printf_utils_ScanfSpecifier_Percent;
      return printf_utils_ScanfSpecifier_Invalid;
   case 'b':
   case 'd':
   case 'i':
   case 'o':
   case 'u':
   case 'x':
      return printf_utils_ScanfSpecifier_Integer;
   case 'a':
   case 'e':
   case 'f':
   case 'g':
      return printf_utils_ScanfSpecifier_FloatingPoint;
   case 'c':
      return printf_utils_ScanfSpecifier_Char;
   case 's':
      return printf_utils_ScanfSpecifier_String;
   case '[': {
      uint32_t pos = 1;
      if (cp[pos] == '^') pos++;
      if (cp[pos] == '[') pos++;
      while (cp[pos] && cp[pos++] != ']') continue;

      conv->len2 = pos - 1;
      return printf_utils_ScanfSpecifier_Scanset;
   }
   case 'p':
      return printf_utils_ScanfSpecifier_Pointer;
   case 'n':
      return printf_utils_ScanfSpecifier_Offset;
   }
   return printf_utils_ScanfSpecifier_Invalid;
}

static bool printf_utils_parseScanfFormat(const char* format, printf_utils_ScanfFormatHandler handler, void* arg)
{
   const char* cp = format;
   while (*cp) {
      if (*cp++ == '%') {
         uint32_t offset = (uint32_t)(cp - format);
         printf_utils_ScanfConversion conv;
         printf_utils_ScanfSpecifier s = printf_utils_getScanfSpecifier(cp, &conv);
         cp += conv.len;
         if (*cp) cp++;
         cp += conv.len2;
         if (!handler(arg, offset, s, &conv)) return false;
      }
   }
   return true;
}


// --- module attr ---
typedef struct attr_AttrValue_ attr_AttrValue;
typedef struct attr_Attr_ attr_Attr;
typedef struct attr_AttrRegistry_ attr_AttrRegistry;

typedef uint8_t attr_AttrKind;
enum attr_AttrKind {
   attr_AttrKind_Unknown,
   attr_AttrKind_Export,
   attr_AttrKind_Packed,
   attr_AttrKind_Unused,
   attr_AttrKind_UnusedParams,
   attr_AttrKind_Section,
   attr_AttrKind_NoReturn,
   attr_AttrKind_Inline,
   attr_AttrKind_PrintfFormat,
   attr_AttrKind_ScanfFormat,
   attr_AttrKind_Aligned,
   attr_AttrKind_Weak,
   attr_AttrKind_Opaque,
   attr_AttrKind_CName,
   attr_AttrKind_CDef,
   attr_AttrKind_NoTypeDef,
   attr_AttrKind_Constructor,
   attr_AttrKind_Destructor,
   attr_AttrKind_Pure,
   attr_AttrKind_AutoFile,
   attr_AttrKind_AutoLine,
   attr_AttrKind_AutoFunc,
   attr_AttrKind_Embed,
   attr_AttrKind_Deprecated,
};

typedef uint8_t attr_AttrValueKind;
enum attr_AttrValueKind {
   attr_AttrValueKind_None,
   attr_AttrValueKind_Number,
   attr_AttrValueKind_String,
};

struct attr_AttrValue_ {
   src_loc_SrcLoc loc;
   union {
      uint32_t text;
      uint32_t number;
   };
};

struct attr_Attr_ {
   void* decl;
   uint32_t name;
   src_loc_SrcLoc loc;
   attr_AttrKind kind;
   attr_AttrValueKind value_kind;
   attr_AttrValue value;
};

struct attr_AttrRegistry_ {
   uint32_t name_indexes[24];
};

typedef uint8_t attr_AttrReq;
enum attr_AttrReq {
   attr_AttrReq_NoArg = 0,
   attr_AttrReq_Arg,
   attr_AttrReq_Number,
   attr_AttrReq_String,
   attr_AttrReq_Power2,
   attr_AttrReq_Ok,
};

static const char* attr_attrKind_names[24] = {
   "?",
   "export",
   "packed",
   "unused",
   "unused_params",
   "section",
   "noreturn",
   "inline",
   "printf_format",
   "scanf_format",
   "aligned",
   "weak",
   "opaque",
   "cname",
   "cdef",
   "no_typedef",
   "constructor",
   "destructor",
   "pure",
   "auto_file",
   "auto_line",
   "auto_func",
   "embed",
   "deprecated"
};
static const attr_AttrReq attr_Required_arg[24] = {
   [attr_AttrKind_Unknown] = attr_AttrReq_NoArg,
   [attr_AttrKind_Export] = attr_AttrReq_NoArg,
   [attr_AttrKind_Packed] = attr_AttrReq_NoArg,
   [attr_AttrKind_Unused] = attr_AttrReq_NoArg,
   [attr_AttrKind_UnusedParams] = attr_AttrReq_NoArg,
   [attr_AttrKind_Section] = attr_AttrReq_String,
   [attr_AttrKind_NoReturn] = attr_AttrReq_NoArg,
   [attr_AttrKind_Inline] = attr_AttrReq_NoArg,
   [attr_AttrKind_PrintfFormat] = attr_AttrReq_NoArg,
   [attr_AttrKind_ScanfFormat] = attr_AttrReq_NoArg,
   [attr_AttrKind_Aligned] = attr_AttrReq_Number,
   [attr_AttrKind_Weak] = attr_AttrReq_NoArg,
   [attr_AttrKind_Opaque] = attr_AttrReq_NoArg,
   [attr_AttrKind_CName] = attr_AttrReq_String,
   [attr_AttrKind_CDef] = attr_AttrReq_String,
   [attr_AttrKind_NoTypeDef] = attr_AttrReq_NoArg,
   [attr_AttrKind_Constructor] = attr_AttrReq_NoArg,
   [attr_AttrKind_Destructor] = attr_AttrReq_NoArg,
   [attr_AttrKind_Pure] = attr_AttrReq_NoArg,
   [attr_AttrKind_AutoFile] = attr_AttrReq_NoArg,
   [attr_AttrKind_AutoLine] = attr_AttrReq_NoArg,
   [attr_AttrKind_AutoFunc] = attr_AttrReq_NoArg,
   [attr_AttrKind_Embed] = attr_AttrReq_String,
   [attr_AttrKind_Deprecated] = attr_AttrReq_String
};
static const char* attr_Attr_kind2name(const attr_Attr* a);
static void attr_AttrRegistry_init(attr_AttrRegistry* ar, string_pool_Pool* pool);
static attr_AttrKind attr_AttrRegistry_find(attr_AttrRegistry* ar, uint32_t name_idx);
static bool attr_isPowerOf2(uint32_t val);
static attr_AttrReq attr_Attr_checkArgument(const attr_Attr* a);

static const char* attr_Attr_kind2name(const attr_Attr* a)
{
   return attr_attrKind_names[a->kind];
}

static void attr_AttrRegistry_init(attr_AttrRegistry* ar, string_pool_Pool* pool)
{
   ar->name_indexes[0] = 0;
   for (attr_AttrKind kind = (attr_AttrKind)1; kind <= attr_AttrKind_Deprecated; kind++) {
      ar->name_indexes[kind] = string_pool_Pool_addStr(pool, attr_attrKind_names[kind], true);
   }
}

static attr_AttrKind attr_AttrRegistry_find(attr_AttrRegistry* ar, uint32_t name_idx)
{
   for (attr_AttrKind kind = (attr_AttrKind)1; kind <= attr_AttrKind_Deprecated; kind++) {
      if (name_idx == ar->name_indexes[kind]) return kind;
   }
   return attr_AttrKind_Unknown;
}

static bool attr_isPowerOf2(uint32_t val)
{
   return val && !(val & (val - 1));
}

static attr_AttrReq attr_Attr_checkArgument(const attr_Attr* a)
{
   switch (attr_Required_arg[a->kind]) {
   case attr_AttrReq_NoArg:
      if (a->value_kind != attr_AttrValueKind_None) return attr_AttrReq_NoArg;
      break;
   case attr_AttrReq_Number:
      switch (a->value_kind) {
      case attr_AttrValueKind_None:
         return attr_AttrReq_Arg;
      case attr_AttrValueKind_Number:
         if (a->kind == attr_AttrKind_Aligned) {
            if (!attr_isPowerOf2(a->value.number)) return attr_AttrReq_Power2;
         }
         break;
      case attr_AttrValueKind_String:
         return attr_AttrReq_Number;
      }
      break;
   case attr_AttrReq_String:
      switch (a->value_kind) {
      case attr_AttrValueKind_None:
         return attr_AttrReq_Arg;
      case attr_AttrValueKind_Number:
         return attr_AttrReq_String;
      case attr_AttrValueKind_String:
         break;
      }
      break;
   default:
      break;
   }
   return attr_AttrReq_Ok;
}


// --- module attr_table ---
typedef struct attr_table_Table_ attr_table_Table;

struct attr_table_Table_ {
   uint32_t count;
   uint32_t capacity;
   attr_Attr* attrs;
};

static attr_table_Table* attr_table_create(void);
static void attr_table_Table_free(attr_table_Table* t);
static void attr_table_Table_resize(attr_table_Table* t, uint32_t capacity);
static void attr_table_Table_add(attr_table_Table* t, void* decl, const attr_Attr* at);
static const attr_Attr* attr_table_Table_find(const attr_table_Table* t, const void* decl, attr_AttrKind kind);

static attr_table_Table* attr_table_create(void)
{
   attr_table_Table* t = calloc(1, 16);
   attr_table_Table_resize(t, 2);
   return t;
}

static void attr_table_Table_free(attr_table_Table* t)
{
   free(t->attrs);
   free(t);
}

static void attr_table_Table_resize(attr_table_Table* t, uint32_t capacity)
{
   t->capacity = capacity;
   attr_Attr* attrs2 = malloc(capacity * 32);
   if (t->count) {
      memcpy(attrs2, t->attrs, t->count * 32);
      free(t->attrs);
   }
   t->attrs = attrs2;
}

static void attr_table_Table_add(attr_table_Table* t, void* decl, const attr_Attr* at)
{
   if (t->count == t->capacity) attr_table_Table_resize(t, t->capacity * 2);
   attr_Attr* a = &t->attrs[t->count];
   *a = *at;
   a->decl = decl;
   t->count++;
}

static const attr_Attr* attr_table_Table_find(const attr_table_Table* t, const void* decl, attr_AttrKind kind)
{
   for (uint32_t i = 0; i < t->count; i++) {
      const attr_Attr* a = &t->attrs[i];
      if (a->decl == decl && a->kind == kind) return a;
   }
   return NULL;
}


// --- module ast ---
typedef struct ast_DeclBits_ ast_DeclBits;
typedef struct ast_Decl_ ast_Decl;
typedef struct ast_AliasTypeDecl_ ast_AliasTypeDecl;
typedef struct ast_ArrayValue_ ast_ArrayValue;
typedef struct ast_DeclStmtBits_ ast_DeclStmtBits;
typedef struct ast_DeclStmt_ ast_DeclStmt;
typedef struct ast_EnumConstantDeclBits_ ast_EnumConstantDeclBits;
typedef struct ast_EnumConstantDecl_ ast_EnumConstantDecl;
typedef struct ast_EnumTypeDeclBits_ ast_EnumTypeDeclBits;
typedef struct ast_EnumTypeDecl_ ast_EnumTypeDecl;
typedef struct ast_FunctionDeclBits_ ast_FunctionDeclBits;
typedef struct ast_FunctionDeclFlags_ ast_FunctionDeclFlags;
typedef struct ast_FunctionDecl_ ast_FunctionDecl;
typedef struct ast_FunctionTypeDecl_ ast_FunctionTypeDecl;
typedef struct ast_ImportDeclBits_ ast_ImportDeclBits;
typedef struct ast_ImportDecl_ ast_ImportDecl;
typedef struct ast_StaticAssert_ ast_StaticAssert;
typedef struct ast_StructTypeDeclBits_ ast_StructTypeDeclBits;
typedef struct ast_FieldInitInfo_ ast_FieldInitInfo;
typedef struct ast_FieldInitField_ ast_FieldInitField;
typedef struct ast_StructMemberLayout_ ast_StructMemberLayout;
typedef struct ast_StructLayout_ ast_StructLayout;
typedef struct ast_StructTypeDecl_ ast_StructTypeDecl;
typedef struct ast_Value_ ast_Value;
typedef union ast_FP64_ ast_FP64;
typedef struct ast_VarDeclBits_ ast_VarDeclBits;
typedef struct ast_BitFieldLayout_ ast_BitFieldLayout;
typedef struct ast_BitFieldInfo_ ast_BitFieldInfo;
typedef struct ast_VarDeclInit_ ast_VarDeclInit;
typedef struct ast_VarDecl_ ast_VarDecl;
typedef struct ast_StmtBits_ ast_StmtBits;
typedef struct ast_Stmt_ ast_Stmt;
typedef struct ast_AsmStmtBits_ ast_AsmStmtBits;
typedef struct ast_AsmStmt_ ast_AsmStmt;
typedef struct ast_AssertStmt_ ast_AssertStmt;
typedef struct ast_BreakStmt_ ast_BreakStmt;
typedef struct ast_CompoundStmtBits_ ast_CompoundStmtBits;
typedef struct ast_CompoundStmt_ ast_CompoundStmt;
typedef struct ast_ContinueStmt_ ast_ContinueStmt;
typedef struct ast_FallthroughStmt_ ast_FallthroughStmt;
typedef struct ast_ForStmt_ ast_ForStmt;
typedef struct ast_GotoStmt_ ast_GotoStmt;
typedef struct ast_IfStmtBits_ ast_IfStmtBits;
typedef struct ast_IfStmt_ ast_IfStmt;
typedef struct ast_LabelStmtBits_ ast_LabelStmtBits;
typedef struct ast_LabelStmt_ ast_LabelStmt;
typedef struct ast_ReturnStmtBits_ ast_ReturnStmtBits;
typedef struct ast_ReturnStmt_ ast_ReturnStmt;
typedef struct ast_SwitchCaseBits_ ast_SwitchCaseBits;
typedef struct ast_SwitchCase_ ast_SwitchCase;
typedef struct ast_SwitchStmtBits_ ast_SwitchStmtBits;
typedef struct ast_SwitchStmt_ ast_SwitchStmt;
typedef struct ast_WhileStmt_ ast_WhileStmt;
typedef struct ast_ExprBits_ ast_ExprBits;
typedef struct ast_Expr_ ast_Expr;
typedef struct ast_AlternateExpr_ ast_AlternateExpr;
typedef struct ast_ArrayDesignatedInitExpr_ ast_ArrayDesignatedInitExpr;
typedef struct ast_ArraySubscriptExprBits_ ast_ArraySubscriptExprBits;
typedef struct ast_ArraySubscriptExpr_ ast_ArraySubscriptExpr;
typedef struct ast_BinaryOperatorBits_ ast_BinaryOperatorBits;
typedef struct ast_BinaryOperator_ ast_BinaryOperator;
typedef struct ast_BitOffsetExprBits_ ast_BitOffsetExprBits;
typedef struct ast_BitOffsetExpr_ ast_BitOffsetExpr;
typedef struct ast_BooleanLiteralBits_ ast_BooleanLiteralBits;
typedef struct ast_BooleanLiteral_ ast_BooleanLiteral;
typedef struct ast_BuiltinExprBits_ ast_BuiltinExprBits;
typedef struct ast_ToContainerData_ ast_ToContainerData;
typedef struct ast_OffsetOfData_ ast_OffsetOfData;
typedef struct ast_BuiltinExpr_ ast_BuiltinExpr;
typedef struct ast_CallExprBits_ ast_CallExprBits;
typedef struct ast_CallExpr_ ast_CallExpr;
typedef struct ast_CharLiteralBits_ ast_CharLiteralBits;
typedef struct ast_CharLiteral_ ast_CharLiteral;
typedef struct ast_ConditionalOperator_ ast_ConditionalOperator;
typedef struct ast_ExplicitCastExprBits_ ast_ExplicitCastExprBits;
typedef struct ast_ExplicitCastExpr_ ast_ExplicitCastExpr;
typedef struct ast_FieldDesignatedInitExpr_ ast_FieldDesignatedInitExpr;
typedef struct ast_FloatLiteralBits_ ast_FloatLiteralBits;
typedef struct ast_FloatLiteral_ ast_FloatLiteral;
typedef struct ast_IdentifierExprBits_ ast_IdentifierExprBits;
typedef struct ast_IdentifierExpr_ ast_IdentifierExpr;
typedef struct ast_ImplicitCastBits_ ast_ImplicitCastBits;
typedef struct ast_ImplicitCastExpr_ ast_ImplicitCastExpr;
typedef struct ast_InitListExprBits_ ast_InitListExprBits;
typedef struct ast_InitListExpr_ ast_InitListExpr;
typedef struct ast_IntegerLiteralBits_ ast_IntegerLiteralBits;
typedef struct ast_IntegerLiteral_ ast_IntegerLiteral;
typedef struct ast_MemberExprBits_ ast_MemberExprBits;
typedef union ast_MemberRef_ ast_MemberRef;
typedef struct ast_MemberExpr_ ast_MemberExpr;
typedef struct ast_NamedArgument_ ast_NamedArgument;
typedef struct ast_NilExpr_ ast_NilExpr;
typedef struct ast_ParenExprBits_ ast_ParenExprBits;
typedef struct ast_ParenExpr_ ast_ParenExpr;
typedef struct ast_RangeExpr_ ast_RangeExpr;
typedef struct ast_StringLiteralBits_ ast_StringLiteralBits;
typedef struct ast_StringLiteral_ ast_StringLiteral;
typedef struct ast_TypeExprBits_ ast_TypeExprBits;
typedef struct ast_TypeExpr_ ast_TypeExpr;
typedef struct ast_UnaryOperatorBits_ ast_UnaryOperatorBits;
typedef struct ast_UnaryOperator_ ast_UnaryOperator;
typedef struct ast_TypeBits_ ast_TypeBits;
typedef struct ast_Type_ ast_Type;
typedef struct ast_AliasType_ ast_AliasType;
typedef struct ast_ArrayTypeBits_ ast_ArrayTypeBits;
typedef struct ast_ArrayType_ ast_ArrayType;
typedef struct ast_BuiltinTypeBits_ ast_BuiltinTypeBits;
typedef struct ast_BuiltinType_ ast_BuiltinType;
typedef struct ast_EnumType_ ast_EnumType;
typedef struct ast_FunctionType_ ast_FunctionType;
typedef struct ast_ModuleType_ ast_ModuleType;
typedef struct ast_PointerType_ ast_PointerType;
typedef struct ast_QualType_ ast_QualType;
typedef struct ast_StructType_ ast_StructType;
typedef struct ast_TypeRefBits_ ast_TypeRefBits;
typedef struct ast_Ref_ ast_Ref;
typedef struct ast_TypeRef_ ast_TypeRef;
typedef struct ast_TypeRefHolder_ ast_TypeRefHolder;
typedef struct ast_VoidType_ ast_VoidType;
typedef struct ast_ArrayValueList_ ast_ArrayValueList;
typedef struct ast_AST_ ast_AST;
typedef struct ast_DeclList_ ast_DeclList;
typedef struct ast_ExprList_ ast_ExprList;
typedef struct ast_FunctionDeclList_ ast_FunctionDeclList;
typedef struct ast_ImportDeclList_ ast_ImportDeclList;
typedef struct ast_TemplateInstance_ ast_TemplateInstance;
typedef struct ast_TemplateFunction_ ast_TemplateFunction;
typedef struct ast_InstanceTable_ ast_InstanceTable;
typedef struct ast_Instantiator_ ast_Instantiator;
typedef struct ast_Module_ ast_Module;
typedef struct ast_PointerPoolSlot_ ast_PointerPoolSlot;
typedef struct ast_PointerPool_ ast_PointerPool;
typedef struct ast_StaticAssertList_ ast_StaticAssertList;
typedef struct ast_StringTypeSlot_ ast_StringTypeSlot;
typedef struct ast_StringTypePool_ ast_StringTypePool;
typedef struct ast_SymbolTable_ ast_SymbolTable;
typedef struct ast_Globals_ ast_Globals;
typedef struct ast_Evaluator_ ast_Evaluator;
typedef union ast_Fun_ ast_Fun;

typedef uint8_t ast_DeclKind;
enum ast_DeclKind {
   ast_DeclKind_Function,
   ast_DeclKind_Import,
   ast_DeclKind_StructType,
   ast_DeclKind_EnumType,
   ast_DeclKind_EnumConstant,
   ast_DeclKind_FunctionType,
   ast_DeclKind_AliasType,
   ast_DeclKind_Variable,
};

typedef uint8_t ast_DeclCheckState;
enum ast_DeclCheckState {
   ast_DeclCheckState_Unchecked,
   ast_DeclCheckState_InProgress,
   ast_DeclCheckState_Checked,
};

struct ast_DeclBits_ {
   uint32_t kind : 4;
   uint32_t check_state : 2;
   uint32_t is_public : 1;
   uint32_t is_used : 1;
   uint32_t is_used_public : 1;
   uint32_t has_attr : 1;
   uint32_t attr_export : 1;
   uint32_t attr_unused : 1;
   uint32_t is_external : 1;
   uint32_t is_generated : 1;
   uint32_t has_gen_idx : 1;
};

struct ast_ImportDeclBits_ {
   uint32_t  : 15;
   uint32_t is_local : 1;
};

struct ast_FunctionDeclBits_ {
   uint32_t  : 15;
   uint32_t is_variadic : 1;
   uint32_t has_prefix : 1;
   uint32_t call_kind : 2;
   uint32_t has_return : 1;
   uint32_t def_kind : 3;
   uint32_t has_body : 1;
};

struct ast_StructTypeDeclBits_ {
   uint32_t  : 15;
   uint32_t is_struct : 1;
   uint32_t is_global : 1;
   uint32_t attr_packed : 1;
   uint32_t attr_opaque : 1;
   uint32_t attr_notypedef : 1;
};

struct ast_EnumTypeDeclBits_ {
   uint32_t  : 15;
   uint32_t is_incremental : 1;
   uint32_t is_regular : 1;
   uint32_t num_constants : 12;
};

struct ast_EnumConstantDeclBits_ {
   uint32_t  : 15;
   uint32_t has_init : 1;
   uint32_t enum_index : 12;
};

struct ast_VarDeclBits_ {
   uint32_t  : 15;
   uint32_t kind : 3;
   uint32_t is_bitfield : 1;
   uint32_t has_init : 1;
   uint32_t has_local : 1;
   uint32_t has_init_call : 1;
   uint32_t attr_weak : 1;
   uint32_t addr_used : 1;
   uint32_t auto_attr : 2;
   uint32_t format_attr : 2;
};

struct ast_QualType_ {
   size_t ptr;
};

struct ast_Decl_ {
   union {
      ast_DeclBits declBits;
      ast_ImportDeclBits importDeclBits;
      ast_FunctionDeclBits functionDeclBits;
      ast_StructTypeDeclBits structTypeDeclBits;
      ast_EnumTypeDeclBits enumTypeDeclBits;
      ast_EnumConstantDeclBits enumConstantDeclBits;
      ast_VarDeclBits varDeclBits;
      uint32_t bits;
   };
   union {
      src_loc_SrcLoc loc;
      uint32_t gen_idx;
   };
   uint32_t name_idx;
   uint16_t ast_idx;
   uint16_t offset;
   ast_QualType qt;
};

static const char* ast_declKind_names[8] = {
   "FunctionDecl",
   "ImportDecl",
   "StructTypeDecl",
   "EnumTypeDecl",
   "EnumConstantDecl",
   "FunctionType",
   "AliasTypeDecl",
   "VarDecl"
};
static const char* ast_declCheckState_names[3] = { "unchecked", "in-progress", "checked" };
#define ast_NumDeclBits 15
static void ast_Decl_init(ast_Decl* d, ast_DeclKind k, uint32_t name_idx, src_loc_SrcLoc loc, bool is_public, ast_QualType qt, uint32_t ast_idx);
static bool ast_Decl_hasGenIdx(const ast_Decl* d);
static void ast_Decl_setGenIdx(ast_Decl* d, uint32_t idx);
static uint32_t ast_Decl_getGenIdx(const ast_Decl* d);
static ast_DeclKind ast_Decl_getKind(const ast_Decl* d);
static ast_DeclCheckState ast_Decl_getCheckState(const ast_Decl* d);
static bool ast_Decl_isChecked(const ast_Decl* d);
static bool ast_Decl_isCheckInProgress(const ast_Decl* d);
static void ast_Decl_setChecked(ast_Decl* d);
static void ast_Decl_setCheckInProgress(ast_Decl* d);
static void ast_Decl_setHasAttr(ast_Decl* d);
static bool ast_Decl_hasAttr(const ast_Decl* d);
static void ast_Decl_setAttrExport(ast_Decl* d);
static void ast_Decl_setExportedIfPublic(ast_Decl* d);
static bool ast_Decl_isExported(const ast_Decl* d);
static bool ast_Decl_isGlobal(const ast_Decl* d);
static bool ast_Decl_isBitfield(const ast_Decl* d);
static void ast_Decl_setAttrUnused(ast_Decl* d);
static bool ast_Decl_hasAttrUnused(const ast_Decl* d);
static bool ast_Decl_isStructType(const ast_Decl* d);
static bool ast_Decl_isImport(const ast_Decl* d);
static bool ast_Decl_isEnum(const ast_Decl* d);
static bool ast_Decl_isEnumConstant(const ast_Decl* d);
static bool ast_Decl_isFunction(const ast_Decl* d);
static bool ast_Decl_isVariable(const ast_Decl* d);
static const char* ast_Decl_getName(const ast_Decl* d);
static uint32_t ast_Decl_getNameIdx(const ast_Decl* d);
static const char* ast_Decl_getModuleName(const ast_Decl* d);
static src_loc_SrcLoc ast_Decl_getLoc(const ast_Decl* d);
static ast_QualType ast_Decl_getType(const ast_Decl* d);
static void ast_Decl_setType(ast_Decl* d, ast_QualType qt);
static ast_AST* ast_Decl_getAST(const ast_Decl* d);
static uint32_t ast_Decl_getASTIdx(const ast_Decl* d);
static ast_Module* ast_Decl_getModule(const ast_Decl* d);
static bool ast_Decl_isPublic(const ast_Decl* d);
static bool ast_Decl_isUsed(const ast_Decl* d);
static bool ast_Decl_isUsedPublic(const ast_Decl* d);
static void ast_Decl_setUsed(ast_Decl* d);
static void ast_Decl_clearUsed(ast_Decl* d);
static void ast_Decl_setUsedPublic(ast_Decl* d);
static bool ast_Decl_isExternal(const ast_Decl* d);
static void ast_Decl_setExternal(ast_Decl* d);
static bool ast_Decl_isGenerated(const ast_Decl* d);
static void ast_Decl_setGenerated(ast_Decl* d);
static void ast_Decl_clearGenerated(ast_Decl* d);
static void ast_Decl_dump(const ast_Decl* d);
static bool ast_Decl_isTypeDecl(const ast_Decl* d);
static bool ast_Decl_isVarDecl(const ast_Decl* d);
static const char* ast_Decl_getKindName(const ast_Decl* d);
static const char* ast_Decl_getCName(const ast_Decl* d);
static bool ast_Decl_hasCName(const ast_Decl* d);
static const char* ast_Decl_getCDef(const ast_Decl* d);
static const char* ast_Decl_getSection(const ast_Decl* d);
static const char* ast_Decl_getFullName(const ast_Decl* d);
static void ast_Decl_print(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent);
static void ast_Decl_printKind(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent, bool print_type);
static void ast_Decl_printName(const ast_Decl* d, string_buffer_Buf* out);
static void ast_Decl_printBits(const ast_Decl* d, string_buffer_Buf* out);
static void ast_Decl_printAttrs(const ast_Decl* d, string_buffer_Buf* out);
static void ast_Decl_printUsed(const ast_Decl* d, string_buffer_Buf* out);
struct ast_TypeRefBits_ {
   uint32_t is_const : 1;
   uint32_t is_volatile : 1;
   uint32_t num_ptrs : 2;
   uint32_t num_arrays : 2;
   uint32_t incr_array : 1;
   uint32_t kind : 2;
   uint32_t has_prefix : 1;
   uint32_t builtin_kind : 4;
};

struct ast_Ref_ {
   src_loc_SrcLoc loc;
   uint32_t name_idx;
   ast_Decl* decl;
};

struct ast_TypeRef_ {
   union {
      ast_TypeRefBits flags;
      uint32_t flagBits;
   };
   union {
      uint32_t dest;
      src_loc_SrcLoc loc;
   };
   ast_Ref refs[0];
};

struct ast_AliasTypeDecl_ {
   ast_Decl base;
   ast_TypeRef typeRef;
};

static ast_AliasTypeDecl* ast_AliasTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* ref);
static ast_Decl* ast_AliasTypeDecl_asDecl(ast_AliasTypeDecl* d);
static ast_TypeRef* ast_AliasTypeDecl_getTypeRef(ast_AliasTypeDecl* d);
static void ast_AliasTypeDecl_print(const ast_AliasTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_ArrayValue_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   ast_Expr* value;
};

static ast_ArrayValue* ast_ArrayValue_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value);
static uint32_t ast_ArrayValue_getNameIdx(const ast_ArrayValue* d);
static src_loc_SrcLoc ast_ArrayValue_getLoc(const ast_ArrayValue* d);
static ast_Expr* ast_ArrayValue_getValue(const ast_ArrayValue* d);
static void ast_ArrayValue_print(const ast_ArrayValue* d, string_buffer_Buf* out);
struct ast_DeclStmtBits_ {
   uint32_t  : 4;
   uint32_t count : 4;
};

struct ast_StmtBits_ {
   uint32_t kind : 4;
};

struct ast_AsmStmtBits_ {
   uint32_t  : 4;
   uint32_t is_basic : 1;
   uint32_t is_volatile : 1;
};

struct ast_CompoundStmtBits_ {
   uint32_t  : 4;
   uint32_t count : 28;
};

struct ast_IfStmtBits_ {
   uint32_t  : 4;
   uint32_t has_else : 1;
};

struct ast_LabelStmtBits_ {
   uint32_t  : 4;
   uint32_t is_used : 1;
};

struct ast_ReturnStmtBits_ {
   uint32_t  : 4;
   uint32_t has_value : 1;
};

struct ast_SwitchStmtBits_ {
   uint32_t  : 4;
   uint32_t is_string : 1;
   uint32_t has_default : 1;
   uint32_t num_cases : 26;
};

struct ast_ExprBits_ {
   uint32_t  : 4;
   uint32_t kind : 5;
   uint32_t is_ctv : 1;
   uint32_t is_ctc : 1;
   uint32_t valtype : 2;
   uint32_t has_effect : 1;
};

struct ast_ArraySubscriptExprBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_BinaryOperatorBits_ {
   uint32_t  : 14;
   uint32_t kind : 5;
};

struct ast_BitOffsetExprBits_ {
   uint32_t  : 14;
   uint32_t width : 8;
};

struct ast_BooleanLiteralBits_ {
   uint32_t  : 14;
   uint32_t value : 1;
};

struct ast_BuiltinExprBits_ {
   uint32_t  : 14;
   uint32_t kind : 3;
   uint32_t src_len : 15;
};

struct ast_CallExprBits_ {
   uint32_t  : 14;
   uint32_t calls_type_func : 1;
   uint32_t calls_static_sf : 1;
   uint32_t is_template_call : 1;
   uint32_t format_attr : 2;
   uint32_t has_auto_args : 1;
   uint32_t is_noreturn : 1;
   uint32_t num_args : 8;
};

struct ast_CharLiteralBits_ {
   uint32_t  : 14;
   uint32_t value : 8;
   uint32_t radix : 2;
   uint32_t src_len : 8;
};

struct ast_ExplicitCastExprBits_ {
   uint32_t  : 14;
   uint32_t c_style : 1;
   uint32_t src_len : 17;
};

struct ast_FloatLiteralBits_ {
   uint32_t  : 14;
   uint32_t radix : 2;
   uint32_t src_len : 16;
};

struct ast_IdentifierExprBits_ {
   uint32_t  : 14;
   uint32_t has_decl : 1;
   uint32_t kind : 3;
   uint32_t name_len : 14;
};

struct ast_ImplicitCastBits_ {
   uint32_t  : 14;
   uint32_t kind : 3;
};

struct ast_InitListExprBits_ {
   uint32_t  : 14;
   uint32_t is_array : 1;
   uint32_t has_designators : 1;
};

struct ast_IntegerLiteralBits_ {
   uint32_t  : 14;
   uint32_t radix : 2;
   uint32_t src_len : 16;
};

struct ast_MemberExprBits_ {
   uint32_t  : 14;
   uint32_t kind : 3;
   uint32_t num_decls : 2;
   uint32_t has_expr : 1;
   uint32_t is_struct_func : 1;
   uint32_t is_static_sf : 1;
   uint32_t is_const_base : 1;
   uint32_t is_volatile_base : 1;
   uint32_t conversion : 2;
   uint32_t is_bitfield : 1;
   uint32_t base_len : 5;
};

struct ast_ParenExprBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_StringLiteralBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_TypeExprBits_ {
   uint32_t  : 14;
   uint32_t src_len : 18;
};

struct ast_UnaryOperatorBits_ {
   uint32_t  : 14;
   uint32_t kind : 4;
};

struct ast_Stmt_ {
   union {
      ast_StmtBits stmtBits;
      ast_AsmStmtBits asmStmtBits;
      ast_CompoundStmtBits compoundStmtBits;
      ast_DeclStmtBits declStmtBits;
      ast_IfStmtBits ifStmtBits;
      ast_LabelStmtBits labelStmtBits;
      ast_ReturnStmtBits returnStmtBits;
      ast_SwitchStmtBits switchStmtBits;
      ast_ExprBits exprBits;
      ast_ArraySubscriptExprBits arraySubscriptExprBits;
      ast_BinaryOperatorBits binaryOperatorBits;
      ast_BitOffsetExprBits bitOffsetBits;
      ast_BooleanLiteralBits booleanLiteralBits;
      ast_BuiltinExprBits builtinExprBits;
      ast_CallExprBits callExprBits;
      ast_CharLiteralBits charLiteralBits;
      ast_ExplicitCastExprBits explicitCastExprBits;
      ast_FloatLiteralBits floatLiteralBits;
      ast_IdentifierExprBits identifierExprBits;
      ast_ImplicitCastBits implicitCastBits;
      ast_InitListExprBits initListExprBits;
      ast_IntegerLiteralBits integerLiteralBits;
      ast_MemberExprBits memberExprBits;
      ast_ParenExprBits parenExprBits;
      ast_StringLiteralBits stringLiteralBits;
      ast_TypeExprBits typeExprBits;
      ast_UnaryOperatorBits unaryOperatorBits;
      uint32_t bits;
   };
   src_loc_SrcLoc loc;
};

struct ast_DeclStmt_ {
   ast_Stmt base;
   ast_VarDecl* decl[0];
};

static ast_DeclStmt* ast_DeclStmt_create(ast_context_Context* c, ast_VarDecl** decl, uint32_t count);
static ast_Stmt* ast_DeclStmt_instantiate(ast_DeclStmt* s, ast_Instantiator* inst);
static ast_VarDecl* ast_DeclStmt_getDecl(const ast_DeclStmt* d, uint32_t i);
static uint32_t ast_DeclStmt_getDeclCount(const ast_DeclStmt* d);
static void ast_DeclStmt_print(const ast_DeclStmt* s, string_buffer_Buf* out, uint32_t indent);
typedef uint8_t ast_ValueKind;
enum ast_ValueKind {
   ast_ValueKind_Integer,
   ast_ValueKind_Float,
   ast_ValueKind_Error,
};

struct ast_Value_ {
   ast_ValueKind kind;
   uint8_t width;
   bool negative;
   bool overflow;
   union {
      uint64_t uvalue;
      double fvalue;
      const char* error_msg;
   };
};

struct ast_EnumConstantDecl_ {
   ast_Decl base;
   ast_Value value;
   ast_Expr* init[0];
};

static ast_EnumConstantDecl* ast_EnumConstantDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, ast_Expr* initValue);
static ast_Decl* ast_EnumConstantDecl_asDecl(ast_EnumConstantDecl* d);
static ast_Value ast_EnumConstantDecl_getValue(const ast_EnumConstantDecl* d);
static void ast_EnumConstantDecl_setValue(ast_EnumConstantDecl* d, ast_Value value);
static void ast_EnumConstantDecl_setIndex(ast_EnumConstantDecl* d, uint32_t index);
static uint32_t ast_EnumConstantDecl_getIndex(const ast_EnumConstantDecl* d);
static ast_Expr* ast_EnumConstantDecl_getInit(const ast_EnumConstantDecl* d);
static ast_Expr** ast_EnumConstantDecl_getInit2(ast_EnumConstantDecl* d);
static void ast_EnumConstantDecl_print(const ast_EnumConstantDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_EnumTypeDecl_ {
   ast_Decl base;
   ast_QualType implType;
   uint32_t num_enum_functions;
   ast_FunctionDecl** enum_functions;
   ast_EnumConstantDecl* constants[0];
   ast_EnumConstantDecl** incr_constants[0];
};

static ast_EnumTypeDecl* ast_EnumTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, ast_QualType implType, bool is_incremental, ast_EnumConstantDecl** constants, uint32_t num_constants);
static void ast_EnumTypeDecl_setRegular(ast_EnumTypeDecl* d);
static bool ast_EnumTypeDecl_isRegular(const ast_EnumTypeDecl* d);
static ast_QualType ast_EnumTypeDecl_getImplType(const ast_EnumTypeDecl* d);
static ast_Decl* ast_EnumTypeDecl_asDecl(ast_EnumTypeDecl* d);
static bool ast_EnumTypeDecl_isIncremental(const ast_EnumTypeDecl* d);
static uint32_t ast_EnumTypeDecl_getNumConstants(const ast_EnumTypeDecl* d);
static ast_EnumConstantDecl** ast_EnumTypeDecl_getConstants(ast_EnumTypeDecl* d);
static void ast_EnumTypeDecl_setIncrConstants(ast_EnumTypeDecl* d, ast_context_Context* c, ast_IdentifierExpr** constants, uint32_t count);
static ast_EnumConstantDecl* ast_EnumTypeDecl_findConstant(ast_EnumTypeDecl* d, uint32_t name_idx);
static ast_EnumConstantDecl* ast_EnumTypeDecl_getConstant(const ast_EnumTypeDecl* d, uint32_t idx);
static void ast_EnumTypeDecl_setEnumFunctions(ast_EnumTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count);
static ast_Decl* ast_EnumTypeDecl_findFunction(const ast_EnumTypeDecl* d, uint32_t name_idx);
static void ast_EnumTypeDecl_print(ast_EnumTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
typedef uint8_t ast_CallKind;
enum ast_CallKind {
   ast_CallKind_Invalid,
   ast_CallKind_Normal,
   ast_CallKind_TypeFunc,
   ast_CallKind_StaticTypeFunc,
};

typedef uint8_t ast_DefKind;
enum ast_DefKind {
   ast_DefKind_Global,
   ast_DefKind_Type,
   ast_DefKind_StructMember,
   ast_DefKind_Param,
   ast_DefKind_Template,
};

struct ast_FunctionDeclFlags_ {
   uint16_t instance_ast_idx : 16;
   uint32_t num_auto_args : 4;
   uint32_t attr_unused_params : 1;
   uint32_t attr_noreturn : 1;
   uint32_t attr_inline : 1;
   uint32_t attr_weak : 1;
   uint32_t attr_constructor : 1;
   uint32_t attr_destructor : 1;
   uint32_t attr_pure : 1;
   uint32_t attr_deprecated : 1;
   uint32_t format_attr : 2;
};

struct ast_FunctionDecl_ {
   ast_Decl base;
   union {
      ast_CompoundStmt* body;
      void* address;
   };
   ast_QualType rt;
   uint8_t num_params;
   uint8_t attr_format_arg;
   uint16_t instance_idx;
   uint32_t template_name;
   src_loc_SrcLoc template_loc;
   union {
      ast_FunctionDeclFlags flags;
      uint32_t flagBits;
   };
   ast_Ref prefix;
   ast_TypeRef rtype;
};

static const char* ast_callKind_names[4] = { "Invalid", "Normal", "SF", "SSF" };
static const char* ast_defKind_names[5] = { "global", "type", "struct-member", "param", "template" };
static ast_FunctionDecl* ast_FunctionDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, bool is_variadic, ast_DefKind def_kind);
static ast_FunctionDecl* ast_FunctionDecl_createTemplate(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, bool is_variadic);
static ast_FunctionDecl* ast_FunctionDecl_instantiate(const ast_FunctionDecl* fd, ast_Instantiator* inst);
static void ast_FunctionDecl_setBody(ast_FunctionDecl* d, ast_CompoundStmt* body);
static bool ast_FunctionDecl_hasBody(const ast_FunctionDecl* d);
static ast_CompoundStmt* ast_FunctionDecl_getBody(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAddress(ast_FunctionDecl* d, void* address);
static ast_CompoundStmt* ast_FunctionDecl_getAddress(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_isInline(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_canBeNil(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setRType(ast_FunctionDecl* d, ast_QualType rt);
static ast_QualType ast_FunctionDecl_getRType(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasReturn(const ast_FunctionDecl* d);
static ast_Decl* ast_FunctionDecl_asDecl(ast_FunctionDecl* d);
static ast_TypeRef* ast_FunctionDecl_getReturnTypeRef(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasPrefix(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_isType(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_isTemplate(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_isMemberType(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_isParam(const ast_FunctionDecl* d);
static ast_DefKind ast_FunctionDecl_getDefKind(const ast_FunctionDecl* d);
static uint32_t ast_FunctionDecl_getTemplateNameIdx(const ast_FunctionDecl* d);
static src_loc_SrcLoc ast_FunctionDecl_getTemplateLoc(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setTemplateInstanceIdx(ast_FunctionDecl* d, uint16_t idx);
static uint16_t ast_FunctionDecl_getTemplateInstanceIdx(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setInstanceName(ast_FunctionDecl* d, uint32_t name_idx);
static ast_Module* ast_FunctionDecl_getInstanceModule(ast_FunctionDecl* d);
static ast_Ref* ast_FunctionDecl_getPrefix(ast_FunctionDecl* d);
static const char* ast_FunctionDecl_getCName(const ast_FunctionDecl* d);
static const char* ast_FunctionDecl_getPrefixName(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setCallKind(ast_FunctionDecl* d, ast_CallKind kind);
static bool ast_FunctionDecl_isTypeFunc(const ast_FunctionDecl* d);
static ast_CallKind ast_FunctionDecl_getCallKind(const ast_FunctionDecl* d);
static bool ast_FunctionDecl_isVariadic(const ast_FunctionDecl* d);
static uint32_t ast_FunctionDecl_getNumParams(const ast_FunctionDecl* d);
static ast_VarDecl** ast_FunctionDecl_getParams(const ast_FunctionDecl* d);
static uint32_t ast_FunctionDecl_getNumAutoArgs(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setNumAutoArgs(ast_FunctionDecl* d, uint32_t num);
static void ast_FunctionDecl_setAttrUnusedParams(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrUnusedParams(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrNoReturn(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrNoReturn(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrInline(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrInline(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrWeak(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrWeak(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrConstructor(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrConstructor(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrDestructor(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrDestructor(const ast_FunctionDecl* d);
static void ast_FunctionDecl_setAttrPure(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrPure(const ast_FunctionDecl* d);
typedef uint8_t ast_FormatAttr;
enum ast_FormatAttr {
   ast_FormatAttr_None,
   ast_FormatAttr_Printf,
   ast_FormatAttr_Scanf,
};

static void ast_FunctionDecl_setFormatAttr(ast_FunctionDecl* d, ast_FormatAttr format_attr, uint8_t format_arg);
static ast_FormatAttr ast_FunctionDecl_getFormatAttr(const ast_FunctionDecl* d, uint8_t* format_arg_ptr);
static void ast_FunctionDecl_setAttrDeprecated(ast_FunctionDecl* d);
static bool ast_FunctionDecl_hasAttrDeprecated(const ast_FunctionDecl* d);
static const char* ast_FunctionDecl_getDiagKind(const ast_FunctionDecl* d);
static void ast_FunctionDecl_print(const ast_FunctionDecl* d, string_buffer_Buf* out, uint32_t indent);
static void ast_FunctionDecl_printType(const ast_FunctionDecl* d, string_buffer_Buf* out);
struct ast_FunctionTypeDecl_ {
   ast_Decl base;
   ast_FunctionDecl* func;
};

static ast_FunctionTypeDecl* ast_FunctionTypeDecl_create(ast_context_Context* c, ast_FunctionDecl* func);
static ast_Decl* ast_FunctionTypeDecl_asDecl(ast_FunctionTypeDecl* t);
static ast_FunctionDecl* ast_FunctionTypeDecl_getDecl(const ast_FunctionTypeDecl* d);
static void ast_FunctionTypeDecl_print(const ast_FunctionTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_ImportDecl_ {
   ast_Decl base;
   uint32_t alias_idx;
   src_loc_SrcLoc alias_loc;
   ast_Module* dest;
};

static ast_ImportDecl* ast_ImportDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, uint32_t ast_idx, bool is_local);
static ast_Decl* ast_ImportDecl_asDecl(ast_ImportDecl* d);
static const char* ast_ImportDecl_getAliasName(const ast_ImportDecl* d);
static uint32_t ast_ImportDecl_getAliasNameIdx(const ast_ImportDecl* d);
static uint32_t ast_ImportDecl_getImportNameIdx(const ast_ImportDecl* d);
static src_loc_SrcLoc ast_ImportDecl_getLoc(const ast_ImportDecl* d);
static void ast_ImportDecl_setDest(ast_ImportDecl* d, ast_Module* mod);
static ast_Module* ast_ImportDecl_getDest(const ast_ImportDecl* d);
static bool ast_ImportDecl_isLocal(const ast_ImportDecl* d);
static void ast_ImportDecl_print(const ast_ImportDecl* d, string_buffer_Buf* out, uint32_t indent);
struct ast_StaticAssert_ {
   uint32_t ast_idx;
   uint32_t loc;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_StaticAssert* ast_StaticAssert_create(ast_context_Context* c, uint32_t ast_idx, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_AST* ast_StaticAssert_getAST(const ast_StaticAssert* d);
static ast_Expr* ast_StaticAssert_getLhs(const ast_StaticAssert* d);
static ast_Expr* ast_StaticAssert_getRhs(const ast_StaticAssert* d);
static void ast_StaticAssert_print(const ast_StaticAssert* d, string_buffer_Buf* out, uint32_t indent);
struct ast_FieldInitField_ {
   uint32_t name_idx;
   uint32_t member_idx;
   uint32_t offset;
   uint8_t bitfield_offset;
   uint8_t bitfield_width;
   uint8_t is_bitfield : 1;
   uint8_t bitfield_signed : 1;
   uint8_t bitfield_base_size : 4;
   ast_Decl* decl;
};

struct ast_FieldInitInfo_ {
   uint32_t num_fields;
   uint32_t num_indexes;
   ast_FieldInitField fields[0];
};

struct ast_StructMemberLayout_ {
   uint32_t offset;
   uint32_t size;
   uint8_t is_bitfield : 1;
   uint8_t bitfield_offset : 7;
   uint8_t bitfield_width;
   uint8_t bitfield_signed : 1;
};

struct ast_StructLayout_ {
   uint32_t size;
   uint32_t alignment;
   uint32_t attr_alignment;
   ast_StructMemberLayout members[0];
};

struct ast_StructTypeDecl_ {
   ast_Decl base;
   uint32_t num_members;
   uint32_t num_struct_functions;
   ast_FunctionDecl** struct_functions;
   ast_FieldInitInfo* field_info;
   ast_Decl* members[0];
};

static bool ast_FieldInitField_isZeroSizeBitfield(const ast_FieldInitField* f);
static void ast_FieldInitField_print(const ast_FieldInitField* f, string_buffer_Buf* out);
static const ast_FieldInitField* ast_FieldInitInfo_find(const ast_FieldInitInfo* fi, uint32_t name);
static ast_StructTypeDecl* ast_StructTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, bool is_struct, bool is_global, ast_Decl** members, uint32_t num_members);
static ast_Decl* ast_StructTypeDecl_asDecl(ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getNumMembers(const ast_StructTypeDecl* d);
static ast_Decl** ast_StructTypeDecl_getMembers(ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_isStruct(const ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_isUnion(const ast_StructTypeDecl* d);
static const ast_FunctionDecl** ast_StructTypeDecl_getStructFunctions(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getNumStructFunctions(const ast_StructTypeDecl* d);
static ast_StructLayout* ast_StructTypeDecl_getLayout(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getSize(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getAlignment(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getAttrAlignment(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setAttrAlignment(ast_StructTypeDecl* d, uint32_t alignment);
static void ast_StructTypeDecl_setPacked(ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_isPacked(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setOpaque(ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_isOpaque(const ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_isGlobal(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setAttrNoTypeDef(ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_hasAttrNoTypeDef(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_setStructFunctions(ast_StructTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count);
static ast_Decl* ast_StructTypeDecl_findAny(const ast_StructTypeDecl* s, uint32_t name_idx);
static ast_Decl* ast_StructTypeDecl_findMember(const ast_StructTypeDecl* s, uint32_t name_idx, uint32_t* offset);
static ast_FieldInitInfo* ast_StructTypeDecl_createFieldInfo(ast_StructTypeDecl* d, ast_context_Context* c);
static const ast_FieldInitInfo* ast_StructTypeDecl_getFieldInfo(const ast_StructTypeDecl* d);
static uint32_t ast_StructTypeDecl_getDesigMemberCount(const ast_StructTypeDecl* d);
static bool ast_StructTypeDecl_hasFieldInfo(const ast_StructTypeDecl* d);
static void ast_StructTypeDecl_print(const ast_StructTypeDecl* d, string_buffer_Buf* out, uint32_t indent);
union ast_FP64_ {
   double d;
   uint64_t bits;
};

static ast_Value ast_Value_createUnsigned(uint64_t uvalue);
static ast_Value ast_Value_createSigned(int64_t svalue);
static ast_Value ast_Value_createBool(bool value);
static ast_Value ast_Value_createFloat(double fvalue);
static ast_Value ast_Value_error(const char* msg);
static void ast_Value_setUnsigned(ast_Value* v, uint64_t uvalue);
static void ast_Value_setSigned(ast_Value* v, int64_t svalue);
static void ast_Value_setFloat(ast_Value* v, double fvalue);
static bool ast_Value_isNegative(const ast_Value* v);
static bool ast_Value_isFloat(const ast_Value* v);
static bool ast_Value_isDecimal(const ast_Value* v);
static bool ast_Value_isError(const ast_Value* v);
static bool ast_Value_isZero(const ast_Value* v);
static double ast_Value_toFloat(const ast_Value* v);
static uint8_t ast_Value_as_u8(const ast_Value* v);
static uint16_t ast_Value_as_u16(const ast_Value* v);
static int32_t ast_Value_as_i32(const ast_Value* v);
static uint32_t ast_Value_as_u32(const ast_Value* v);
static uint64_t ast_Value_as_u64(const ast_Value* v);
static uint8_t ast_Value_getWidth(const ast_Value* v);
static bool ast_Value_checkRange(const ast_Value* v, int64_t min, uint64_t max);
static ast_Value ast_Value_negate(const ast_Value* v);
static ast_Value ast_Value_bitnot(const ast_Value* v);
static ast_Value ast_Value_lnot(const ast_Value* v);
static ast_Value ast_Value_minus(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_add(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_multiply(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_divide(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_remainder(const ast_Value* v1, const ast_Value* v2);
static void ast_Value_left_shift2(ast_Value* v, uint32_t shift);
static ast_Value ast_Value_left_shift(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_right_shift(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_and(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_or(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_xor(const ast_Value* v1, const ast_Value* v2);
static ast_Value ast_Value_toBool(const ast_Value* v);
static bool ast_Value_is_equal(const ast_Value* v1, const ast_Value* v2);
static bool ast_Value_is_less(const ast_Value* v1, const ast_Value* v2);
static bool ast_Value_is_less_equal(const ast_Value* v1, const ast_Value* v2);
static bool ast_Value_is_greater(const ast_Value* v1, const ast_Value* v2);
static bool ast_Value_is_greater_equal(const ast_Value* v1, const ast_Value* v2);
static bool ast_Value_isNext(const ast_Value* v1, const ast_Value* v2);
static void ast_Value_mask(ast_Value* v, uint32_t width);
static void ast_Value_truncate(ast_Value* orig, uint32_t width, bool is_signed);
static void ast_Value_incr(ast_Value* v);
static void ast_Value_decr(ast_Value* v);
static ast_Value ast_Value_castAs(const ast_Value* v, ast_QualType qt);
static bool ast_isfinite(double d);
static int32_t ast_signbit(double d);
static double ast_fabs(double d);
static char* ast_ftoa(char* dest, size_t size, double d);
static const char* ast_Value_str(const ast_Value* v);
typedef uint8_t ast_VarDeclKind;
enum ast_VarDeclKind {
   ast_VarDeclKind_GlobalVar,
   ast_VarDeclKind_LocalVar,
   ast_VarDeclKind_FunctionParam,
   ast_VarDeclKind_StructMember,
};

typedef uint32_t ast_AutoAttr;
enum ast_AutoAttr {
   ast_AutoAttr_None,
   ast_AutoAttr_File,
   ast_AutoAttr_Line,
   ast_AutoAttr_Func,
};

struct ast_BitFieldLayout_ {
   uint8_t bit_width;
   uint8_t bit_offset;
};

struct ast_BitFieldInfo_ {
   ast_Expr* expr;
   src_loc_SrcLoc loc;
   ast_BitFieldLayout layout;
};

struct ast_VarDeclInit_ {
   ast_Expr* expr;
   src_loc_SrcLoc loc;
};

struct ast_VarDecl_ {
   ast_Decl base;
   ast_TypeRef typeRef;
};

static const char* ast_varDeclNames[4] = { " global", " local", " parameter", " member" };
static ast_VarDecl* ast_VarDecl_create(ast_context_Context* c, ast_VarDeclKind kind, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, src_loc_SrcLoc assignLoc, bool has_embed, ast_Expr* initValue);
static ast_VarDecl* ast_VarDecl_createStructMember(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, ast_Expr* bitfield);
static ast_VarDecl* ast_VarDecl_instantiate(const ast_VarDecl* vd, ast_Instantiator* inst);
static const char* ast_VarDecl_getName(const ast_VarDecl* d);
static ast_Decl* ast_VarDecl_asDecl(ast_VarDecl* d);
static uint32_t ast_VarDecl_getOffset(const ast_VarDecl* d);
static void ast_VarDecl_setOffset(ast_VarDecl* d, uint32_t offset);
static ast_VarDeclKind ast_VarDecl_getKind(const ast_VarDecl* d);
static bool ast_VarDecl_isGlobal(const ast_VarDecl* d);
static bool ast_VarDecl_isLocal(const ast_VarDecl* d);
static bool ast_VarDecl_isParameter(const ast_VarDecl* d);
static bool ast_VarDecl_isStructMember(const ast_VarDecl* d);
static bool ast_VarDecl_isBitField(const ast_VarDecl* d);
static bool ast_VarDecl_isAddrUsed(const ast_VarDecl* d);
static void ast_VarDecl_setAddrUsed(ast_VarDecl* d);
static ast_TypeRef* ast_VarDecl_getTypeRef(ast_VarDecl* d);
static src_loc_SrcLoc ast_VarDecl_getAssignLoc(const ast_VarDecl* d);
static bool ast_VarDecl_hasInit(const ast_VarDecl* d);
static ast_Expr* ast_VarDecl_getInit(const ast_VarDecl* d);
static ast_Expr** ast_VarDecl_getInit2(ast_VarDecl* d);
static void ast_VarDecl_setInit(ast_VarDecl* d, ast_Expr* initValue);
static ast_BitFieldInfo* ast_VarDecl_getBitFieldInfo(const ast_VarDecl* d);
static ast_Expr* ast_VarDecl_getBitfield(const ast_VarDecl* d);
static void ast_VarDecl_setBitfieldWidth(ast_VarDecl* d, uint8_t width);
static ast_BitFieldLayout* ast_VarDecl_getBitfieldLayout(const ast_VarDecl* d);
static bool ast_VarDecl_hasLocalQualifier(const ast_VarDecl* d);
static void ast_VarDecl_setLocal(ast_VarDecl* d, bool has_local);
static void ast_VarDecl_setInitCall(ast_VarDecl* d, bool has_init_call);
static bool ast_VarDecl_hasInitCall(const ast_VarDecl* d);
static void ast_VarDecl_setAttrWeak(ast_VarDecl* d);
static bool ast_VarDecl_hasAttrWeak(const ast_VarDecl* d);
static ast_AutoAttr ast_VarDecl_getAutoAttr(const ast_VarDecl* d);
static void ast_VarDecl_setAttrAutoFile(ast_VarDecl* d);
static bool ast_VarDecl_hasAttrAutoFile(const ast_VarDecl* d);
static void ast_VarDecl_setAttrAutoLine(ast_VarDecl* d);
static bool ast_VarDecl_hasAttrAutoLine(const ast_VarDecl* d);
static void ast_VarDecl_setAttrAutoFunc(ast_VarDecl* d);
static bool ast_VarDecl_hasAttrAutoFunc(const ast_VarDecl* d);
static bool ast_VarDecl_hasAutoAttr(const ast_VarDecl* d);
static void ast_VarDecl_setFormatAttr(ast_VarDecl* d, ast_FormatAttr kind);
static ast_FormatAttr ast_VarDecl_getFormatAttr(const ast_VarDecl* d);
static void ast_VarDecl_print(const ast_VarDecl* d, string_buffer_Buf* out, uint32_t indent);
static void ast_VarDecl_printType(const ast_VarDecl* d, string_buffer_Buf* out);
typedef uint8_t ast_StmtKind;
enum ast_StmtKind {
   ast_StmtKind_Return,
   ast_StmtKind_Expr,
   ast_StmtKind_If,
   ast_StmtKind_While,
   ast_StmtKind_For,
   ast_StmtKind_Switch,
   ast_StmtKind_Break,
   ast_StmtKind_Continue,
   ast_StmtKind_Fallthrough,
   ast_StmtKind_Label,
   ast_StmtKind_Goto,
   ast_StmtKind_Compound,
   ast_StmtKind_Decl,
   ast_StmtKind_Asm,
   ast_StmtKind_Assert,
};

static const char* ast_stmtKind_names[15] = {
   "ReturnStmt",
   "ExprStmt",
   "IfStmt",
   "WhileStmt",
   "ForStmt",
   "SwitchStmt",
   "BreakStmt",
   "ContinueStmt",
   "FallthroughStmt",
   "LabelStmt",
   "GotoStmt",
   "CompoundStmt",
   "DeclStmt",
   "Asm",
   "AssertStmt"
};
#define ast_NumStmtBits 4
static void ast_Stmt_init(ast_Stmt* s, ast_StmtKind k, src_loc_SrcLoc loc);
static ast_Stmt* ast_Stmt_instantiate(ast_Stmt* s, ast_Instantiator* inst);
static ast_StmtKind ast_Stmt_getKind(const ast_Stmt* s);
static bool ast_Stmt_isExpr(const ast_Stmt* s);
static bool ast_Stmt_isCompound(const ast_Stmt* s);
static bool ast_Stmt_isFallthrough(const ast_Stmt* s);
static bool ast_Stmt_isDecl(const ast_Stmt* s);
static bool ast_Stmt_isLabel(const ast_Stmt* s);
static src_loc_SrcLoc ast_Stmt_getLoc(const ast_Stmt* s);
static void ast_Stmt_dump(const ast_Stmt* s);
static void ast_Stmt_print(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent);
static void ast_Stmt_printKind(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_AsmStmt_ {
   ast_Stmt base;
   ast_StringLiteral* asm_string;
   uint8_t num_constraints;
   uint8_t num_exprs;
   uint8_t num_clobbers;
   uint8_t num_outputs;
   uint8_t num_inputs;
   uint8_t pad[2];
   ast_Expr* constraints[0];
   ast_Expr* exprs[0];
   ast_Expr* clobbers[0];
   uint32_t names[0];
};

static ast_AsmStmt* ast_AsmStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, bool is_basic, bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* str);
static ast_Stmt* ast_AsmStmt_instantiate(ast_AsmStmt* s, ast_Instantiator* inst);
static bool ast_AsmStmt_isVolatile(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumConstraints(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumClobbers(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumExprs(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumOutputs(const ast_AsmStmt* s);
static uint32_t ast_AsmStmt_getNumInputs(const ast_AsmStmt* s);
static ast_StringLiteral* ast_AsmStmt_getString(const ast_AsmStmt* s);
static const ast_Expr** ast_AsmStmt_getConstraints(const ast_AsmStmt* s);
static ast_Expr** ast_AsmStmt_getExprs(const ast_AsmStmt* s);
static ast_Expr** ast_AsmStmt_getClobbers(const ast_AsmStmt* s);
static uint32_t* ast_AsmStmt_getNames(const ast_AsmStmt* s);
static void ast_AsmStmt_print(const ast_AsmStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_AssertStmt_ {
   ast_Stmt base;
   ast_Expr* inner;
};

static ast_AssertStmt* ast_AssertStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* inner);
static ast_Stmt* ast_AssertStmt_instantiate(ast_AssertStmt* s, ast_Instantiator* inst);
static ast_Expr* ast_AssertStmt_getInner(const ast_AssertStmt* s);
static ast_Expr** ast_AssertStmt_getInner2(ast_AssertStmt* s);
static void ast_AssertStmt_print(const ast_AssertStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_BreakStmt_ {
   ast_Stmt base;
};

static ast_BreakStmt* ast_BreakStmt_create(ast_context_Context* c, src_loc_SrcLoc loc);
static void ast_BreakStmt_print(const ast_BreakStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_CompoundStmt_ {
   ast_Stmt base;
   ast_Stmt* stmts[0];
};

static ast_CompoundStmt* ast_CompoundStmt_create(ast_context_Context* c, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count);
static ast_CompoundStmt* ast_CompoundStmt_instantiate(ast_CompoundStmt* s, ast_Instantiator* inst);
static uint32_t ast_CompoundStmt_getCount(const ast_CompoundStmt* s);
static ast_Stmt** ast_CompoundStmt_getStmts(ast_CompoundStmt* s);
static src_loc_SrcLoc ast_CompoundStmt_getEndLoc(const ast_CompoundStmt* e);
static void ast_CompoundStmt_print(const ast_CompoundStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_ContinueStmt_ {
   ast_Stmt base;
};

static ast_ContinueStmt* ast_ContinueStmt_create(ast_context_Context* c, src_loc_SrcLoc loc);
static void ast_ContinueStmt_print(const ast_ContinueStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_FallthroughStmt_ {
   ast_Stmt base;
};

static ast_FallthroughStmt* ast_FallthroughStmt_create(ast_context_Context* c, src_loc_SrcLoc loc);
static void ast_FallthroughStmt_print(const ast_FallthroughStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_ForStmt_ {
   ast_Stmt base;
   ast_Stmt* init;
   ast_Expr* cond;
   ast_Expr* cont;
   ast_Stmt* body;
};

static ast_ForStmt* ast_ForStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* cont, ast_Stmt* body);
static ast_Stmt* ast_ForStmt_instantiate(ast_ForStmt* s, ast_Instantiator* inst);
static ast_Stmt* ast_ForStmt_getInit(const ast_ForStmt* s);
static ast_Expr* ast_ForStmt_getCond(const ast_ForStmt* s);
static ast_Expr* ast_ForStmt_getCont(const ast_ForStmt* s);
static ast_Stmt* ast_ForStmt_getBody(const ast_ForStmt* s);
static ast_Stmt** ast_ForStmt_getInit2(ast_ForStmt* s);
static ast_Expr** ast_ForStmt_getCond2(ast_ForStmt* s);
static ast_Expr** ast_ForStmt_getCont2(ast_ForStmt* s);
static void ast_ForStmt_print(const ast_ForStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_GotoStmt_ {
   ast_Stmt base;
   uint32_t name;
};

static ast_GotoStmt* ast_GotoStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc);
static const char* ast_GotoStmt_getName(const ast_GotoStmt* g);
static uint32_t ast_GotoStmt_getNameIdx(const ast_GotoStmt* g);
static void ast_GotoStmt_print(const ast_GotoStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_IfStmt_ {
   ast_Stmt base;
   ast_Stmt* cond;
   ast_Stmt* then;
   ast_Stmt* else_stmt[0];
};

static ast_IfStmt* ast_IfStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt);
static ast_Stmt* ast_IfStmt_instantiate(ast_IfStmt* s, ast_Instantiator* inst);
static ast_Stmt* ast_IfStmt_getCond(const ast_IfStmt* s);
static ast_Stmt** ast_IfStmt_getCond2(ast_IfStmt* s);
static ast_Stmt* ast_IfStmt_getThen(const ast_IfStmt* s);
static ast_Stmt* ast_IfStmt_getElse(const ast_IfStmt* s);
static void ast_IfStmt_print(const ast_IfStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_LabelStmt_ {
   ast_Stmt base;
   uint32_t name;
   ast_Stmt* stmt;
};

static ast_LabelStmt* ast_LabelStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt);
static ast_Stmt* ast_LabelStmt_instantiate(ast_LabelStmt* s, ast_Instantiator* inst);
static void ast_LabelStmt_setUsed(ast_LabelStmt* s);
static bool ast_LabelStmt_isUsed(const ast_LabelStmt* s);
static const char* ast_LabelStmt_getName(const ast_LabelStmt* s);
static uint32_t ast_LabelStmt_getNameIdx(const ast_LabelStmt* s);
static ast_Stmt* ast_LabelStmt_getStmt(const ast_LabelStmt* s);
static void ast_LabelStmt_print(const ast_LabelStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_ReturnStmt_ {
   ast_Stmt base;
   ast_Expr* value[0];
};

static ast_ReturnStmt* ast_ReturnStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* value);
static ast_Stmt* ast_ReturnStmt_instantiate(ast_ReturnStmt* s, ast_Instantiator* inst);
static ast_Expr* ast_ReturnStmt_getValue(const ast_ReturnStmt* s);
static ast_Expr** ast_ReturnStmt_getValue2(ast_ReturnStmt* s);
static void ast_ReturnStmt_print(const ast_ReturnStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_SwitchCaseBits_ {
   uint32_t num_conds : 8;
   uint32_t num_stmts : 10;
   uint32_t is_default : 1;
   uint32_t has_decls : 1;
   uint32_t has_fallthrough : 1;
};

struct ast_SwitchCase_ {
   union {
      ast_SwitchCaseBits bits;
      uint32_t allbits;
   };
   src_loc_SrcLoc loc;
   ast_Expr* conds[0];
};

static ast_SwitchCase* ast_SwitchCase_create(ast_context_Context* c, src_loc_SrcLoc loc, bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts);
static ast_SwitchCase* ast_SwitchCase_instantiate(ast_SwitchCase* src, ast_Instantiator* inst);
static uint32_t ast_SwitchCase_getNumConds(const ast_SwitchCase* s);
static ast_Expr* ast_SwitchCase_getCond(ast_SwitchCase* s, uint32_t index);
static uint32_t ast_SwitchCase_getNumStmts(const ast_SwitchCase* s);
static ast_Stmt** ast_SwitchCase_getStmts(ast_SwitchCase* s);
static ast_Stmt* ast_SwitchCase_getStmt(const ast_SwitchCase* s, uint32_t n);
static bool ast_SwitchCase_isDefault(const ast_SwitchCase* s);
static bool ast_SwitchCase_hasDecls(const ast_SwitchCase* s);
static void ast_SwitchCase_setHasDecls(ast_SwitchCase* s);
static void ast_SwitchCase_setHasFallthrough(ast_SwitchCase* s);
static bool ast_SwitchCase_hasFallthrough(const ast_SwitchCase* s);
static src_loc_SrcLoc ast_SwitchCase_getLoc(const ast_SwitchCase* s);
static void ast_SwitchCase_print(const ast_SwitchCase* s, string_buffer_Buf* out, uint32_t indent);
struct ast_SwitchStmt_ {
   ast_Stmt base;
   ast_Stmt* cond;
   ast_SwitchCase* cases[0];
};

static ast_SwitchStmt* ast_SwitchStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_SwitchCase** cases, uint32_t numCases, bool has_default);
static ast_Stmt* ast_SwitchStmt_instantiate(ast_SwitchStmt* s, ast_Instantiator* inst);
static ast_Stmt* ast_SwitchStmt_getCond(const ast_SwitchStmt* s);
static ast_Stmt** ast_SwitchStmt_getCond2(ast_SwitchStmt* s);
static bool ast_SwitchStmt_isString(const ast_SwitchStmt* s);
static void ast_SwitchStmt_setString(ast_SwitchStmt* s);
static bool ast_SwitchStmt_hasDefault(const ast_SwitchStmt* s);
static uint32_t ast_SwitchStmt_getNumCases(const ast_SwitchStmt* s);
static ast_SwitchCase** ast_SwitchStmt_getCases(ast_SwitchStmt* s);
static void ast_SwitchStmt_print(const ast_SwitchStmt* s, string_buffer_Buf* out, uint32_t indent);
struct ast_WhileStmt_ {
   ast_Stmt base;
   ast_Stmt* cond;
   ast_Stmt* body;
};

static ast_WhileStmt* ast_WhileStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* body);
static ast_Stmt* ast_WhileStmt_instantiate(ast_WhileStmt* s, ast_Instantiator* inst);
static void ast_WhileStmt_print(const ast_WhileStmt* s, string_buffer_Buf* out, uint32_t indent);
static ast_Stmt* ast_WhileStmt_getCond(const ast_WhileStmt* s);
static ast_Stmt** ast_WhileStmt_getCond2(ast_WhileStmt* s);
static ast_Stmt* ast_WhileStmt_getBody(const ast_WhileStmt* s);
typedef uint8_t ast_ExprKind;
enum ast_ExprKind {
   ast_ExprKind_IntegerLiteral,
   ast_ExprKind_FloatLiteral,
   ast_ExprKind_BooleanLiteral,
   ast_ExprKind_CharLiteral,
   ast_ExprKind_StringLiteral,
   ast_ExprKind_Nil,
   ast_ExprKind_Identifier,
   ast_ExprKind_Type,
   ast_ExprKind_Call,
   ast_ExprKind_InitList,
   ast_ExprKind_FieldDesignatedInit,
   ast_ExprKind_ArrayDesignatedInit,
   ast_ExprKind_BinaryOperator,
   ast_ExprKind_UnaryOperator,
   ast_ExprKind_ConditionalOperator,
   ast_ExprKind_Builtin,
   ast_ExprKind_ArraySubscript,
   ast_ExprKind_Member,
   ast_ExprKind_Paren,
   ast_ExprKind_BitOffset,
   ast_ExprKind_ExplicitCast,
   ast_ExprKind_ImplicitCast,
   ast_ExprKind_Range,
   ast_ExprKind_NamedArgument,
   ast_ExprKind_Alternate,
};

typedef uint8_t ast_ValType;
enum ast_ValType {
   ast_ValType_NValue,
   ast_ValType_RValue,
   ast_ValType_LValue,
};

struct ast_Expr_ {
   ast_Stmt base;
   ast_QualType qt;
};

static const char* ast_exprKind_names[25] = {
   "IntegerLiteral",
   "FloatLiteral",
   "BooleanLiteral",
   "CharLiteral",
   "StringLiteral",
   "Nil",
   "Identifier",
   "TypeExpr",
   "Call",
   "InitList",
   "FieldDesignatedInit",
   "ArrayDesignatedInit",
   "BinaryOperator",
   "UnaryOperator",
   "ConditionalOp",
   "Builtin",
   "ArraySubscript",
   "Member",
   "Paren",
   "BitOffset",
   "ExplicitCast",
   "ImplicitCast",
   "RangeExpr",
   "NamedArgument",
   "Alternate"
};
static const char* ast_valType_names[3] = { "nvalue", "rvalue", "lvalue" };
#define ast_NumExprBits (ast_NumStmtBits + 10)
static void ast_Expr_init(ast_Expr* e, ast_ExprKind k, src_loc_SrcLoc loc, bool ctv, bool ctc, bool has_effect, ast_ValType valtype);
static ast_Expr* ast_Expr_instantiate(ast_Expr* e, ast_Instantiator* inst);
static ast_Stmt* ast_Expr_asStmt(ast_Expr* e);
static ast_ExprKind ast_Expr_getKind(const ast_Expr* e);
static bool ast_Expr_isStringLiteral(const ast_Expr* e);
static bool ast_Expr_isNil(const ast_Expr* e);
static bool ast_Expr_isIdentifier(const ast_Expr* e);
static bool ast_Expr_isCall(const ast_Expr* e);
static bool ast_Expr_isUnaryOp(const ast_Expr* e);
static bool ast_Expr_isImplicitCast(const ast_Expr* e);
static bool ast_Expr_isType(const ast_Expr* e);
static bool ast_Expr_isInitList(const ast_Expr* e);
static bool ast_Expr_isTilde(const ast_Expr* e);
static bool ast_Expr_isBinaryOperator(const ast_Expr* e);
static bool ast_Expr_isMember(const ast_Expr* e);
static bool ast_Expr_isFieldDesignatedInit(const ast_Expr* e);
static bool ast_Expr_isArrayDesignatedInit(const ast_Expr* e);
static bool ast_Expr_isBitOffset(const ast_Expr* e);
static bool ast_Expr_isParen(const ast_Expr* e);
static bool ast_Expr_isRange(const ast_Expr* e);
static bool ast_Expr_isAssignment(const ast_Expr* e);
static bool ast_Expr_isInitlistAssignment(const ast_Expr* e);
static bool ast_Expr_isNamedArgument(const ast_Expr* e);
static bool ast_Expr_isCtv(const ast_Expr* e);
static bool ast_Expr_isCtc(const ast_Expr* e);
static void ast_Expr_setCtv(ast_Expr* e);
static void ast_Expr_setCtc(ast_Expr* e);
static void ast_Expr_copyCtcFlags(ast_Expr* e, const ast_Expr* other);
static void ast_Expr_copyConstantFlags(ast_Expr* e, const ast_Expr* other);
static void ast_Expr_combineConstantFlags(ast_Expr* e, const ast_Expr* lhs, const ast_Expr* rhs);
static bool ast_Expr_hasEffect(const ast_Expr* e);
static ast_ValType ast_Expr_getValType(const ast_Expr* e);
static bool ast_Expr_isNValue(const ast_Expr* e);
static bool ast_Expr_isLValue(const ast_Expr* e);
static void ast_Expr_setLValue(ast_Expr* e);
static void ast_Expr_setRValue(ast_Expr* e);
static void ast_Expr_copyValType(ast_Expr* e, const ast_Expr* other);
static bool ast_Expr_isBitfield(const ast_Expr* e);
static bool ast_Expr_isPositiveOrUB(const ast_Expr* e);
static src_loc_SrcLoc ast_Expr_getLoc(const ast_Expr* e);
static src_loc_SrcLoc ast_Expr_getStartLoc(const ast_Expr* e);
static src_loc_SrcLoc ast_Expr_getEndLoc(const ast_Expr* e);
static src_loc_SrcRange ast_Expr_getRange(const ast_Expr* e);
static void ast_Expr_setType(ast_Expr* e, ast_QualType qt);
static ast_QualType ast_Expr_getType(const ast_Expr* e);
static bool ast_Expr_needsSemi(const ast_Expr* e);
static void ast_Expr_dump(const ast_Expr* e);
static void ast_Expr_print(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_Expr_printLiteral(const ast_Expr* e, string_buffer_Buf* out);
static void ast_Expr_printKind(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_Expr_printTypeBits(const ast_Expr* e, string_buffer_Buf* out);
struct ast_AlternateExpr_ {
   ast_Expr base;
   ast_Expr* original;
   ast_Expr* generated;
};

static ast_AlternateExpr* ast_AlternateExpr_create(ast_context_Context* c, ast_Expr* original, ast_Expr* generated);
static ast_Expr* ast_AlternateExpr_instantiate(ast_AlternateExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_AlternateExpr_getOriginal(const ast_AlternateExpr* e);
static ast_Expr* ast_AlternateExpr_getGenerated(const ast_AlternateExpr* e);
static void ast_AlternateExpr_print(const ast_AlternateExpr* e, string_buffer_Buf* out, uint32_t indent);
static src_loc_SrcLoc ast_AlternateExpr_getStartLoc(const ast_AlternateExpr* e);
static src_loc_SrcLoc ast_AlternateExpr_getEndLoc(const ast_AlternateExpr* e);
static void ast_AlternateExpr_printLiteral(const ast_AlternateExpr* e, string_buffer_Buf* out);
struct ast_ArrayDesignatedInitExpr_ {
   ast_Expr base;
   ast_Expr* designator;
   ast_Expr* initValue;
};

static ast_ArrayDesignatedInitExpr* ast_ArrayDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue);
static ast_Expr* ast_ArrayDesignatedInitExpr_instantiate(ast_ArrayDesignatedInitExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_ArrayDesignatedInitExpr_getDesignator(const ast_ArrayDesignatedInitExpr* e);
static ast_Expr** ast_ArrayDesignatedInitExpr_getDesignator2(ast_ArrayDesignatedInitExpr* e);
static ast_Expr* ast_ArrayDesignatedInitExpr_getInit(const ast_ArrayDesignatedInitExpr* e);
static ast_Expr** ast_ArrayDesignatedInitExpr_getInit2(ast_ArrayDesignatedInitExpr* e);
static src_loc_SrcLoc ast_ArrayDesignatedInitExpr_getEndLoc(const ast_ArrayDesignatedInitExpr* e);
static void ast_ArrayDesignatedInitExpr_print(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_ArrayDesignatedInitExpr_printLiteral(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out);
struct ast_ArraySubscriptExpr_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* idx;
};

static ast_ArraySubscriptExpr* ast_ArraySubscriptExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* lhs, ast_Expr* idx);
static ast_Expr* ast_ArraySubscriptExpr_instantiate(ast_ArraySubscriptExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_ArraySubscriptExpr_getBase(const ast_ArraySubscriptExpr* e);
static ast_Expr** ast_ArraySubscriptExpr_getBase2(ast_ArraySubscriptExpr* e);
static ast_Expr* ast_ArraySubscriptExpr_getIndex(const ast_ArraySubscriptExpr* e);
static ast_Expr** ast_ArraySubscriptExpr_getIndex2(ast_ArraySubscriptExpr* e);
static src_loc_SrcLoc ast_ArraySubscriptExpr_getStartLoc(const ast_ArraySubscriptExpr* e);
static src_loc_SrcLoc ast_ArraySubscriptExpr_getEndLoc(const ast_ArraySubscriptExpr* e);
static void ast_ArraySubscriptExpr_printLiteral(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out);
static void ast_ArraySubscriptExpr_print(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out, uint32_t indent);
typedef uint8_t ast_BinaryOpcode;
enum ast_BinaryOpcode {
   ast_BinaryOpcode_Multiply,
   ast_BinaryOpcode_Divide,
   ast_BinaryOpcode_Remainder,
   ast_BinaryOpcode_Add,
   ast_BinaryOpcode_Subtract,
   ast_BinaryOpcode_ShiftLeft,
   ast_BinaryOpcode_ShiftRight,
   ast_BinaryOpcode_LessThan,
   ast_BinaryOpcode_GreaterThan,
   ast_BinaryOpcode_LessEqual,
   ast_BinaryOpcode_GreaterEqual,
   ast_BinaryOpcode_Equal,
   ast_BinaryOpcode_NotEqual,
   ast_BinaryOpcode_And,
   ast_BinaryOpcode_Xor,
   ast_BinaryOpcode_Or,
   ast_BinaryOpcode_LAnd,
   ast_BinaryOpcode_LOr,
   ast_BinaryOpcode_Assign,
   ast_BinaryOpcode_MulAssign,
   ast_BinaryOpcode_DivAssign,
   ast_BinaryOpcode_RemAssign,
   ast_BinaryOpcode_AddAssign,
   ast_BinaryOpcode_SubAssign,
   ast_BinaryOpcode_ShlAssign,
   ast_BinaryOpcode_ShrAssign,
   ast_BinaryOpcode_AndAssign,
   ast_BinaryOpcode_XorAssign,
   ast_BinaryOpcode_OrAssign,
};

struct ast_BinaryOperator_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static const char* ast_binaryOpcode_names[29] = {
   "*",
   "/",
   "%",
   "+",
   "-",
   "<<",
   ">>",
   "<",
   ">",
   "<=",
   ">=",
   "==",
   "!=",
   "&",
   "^",
   "|",
   "&&",
   "||",
   "=",
   "*=",
   "/=",
   "%=",
   "+=",
   "-=",
   "<<=",
   ">>=",
   "&=",
   "^=",
   "|="
};
static bool ast_BinaryOpcode_isComparison(ast_BinaryOpcode opcode);
static const char* ast_BinaryOpcode_str(ast_BinaryOpcode opcode);
static ast_BinaryOperator* ast_BinaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_BinaryOpcode kind, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_BinaryOperator_instantiate(ast_BinaryOperator* e, ast_Instantiator* inst);
static ast_BinaryOpcode ast_BinaryOperator_getOpcode(const ast_BinaryOperator* e);
static ast_Expr* ast_BinaryOperator_getLHS(const ast_BinaryOperator* e);
static ast_Expr** ast_BinaryOperator_getLHS2(ast_BinaryOperator* e);
static ast_Expr* ast_BinaryOperator_getRHS(const ast_BinaryOperator* e);
static ast_Expr** ast_BinaryOperator_getRHS2(ast_BinaryOperator* e);
static const char* ast_BinaryOperator_getOpcodeStr(const ast_BinaryOperator* e);
static src_loc_SrcLoc ast_BinaryOperator_getStartLoc(const ast_BinaryOperator* e);
static src_loc_SrcLoc ast_BinaryOperator_getEndLoc(const ast_BinaryOperator* e);
static void ast_BinaryOperator_print(const ast_BinaryOperator* e, string_buffer_Buf* out, uint32_t indent);
static void ast_BinaryOperator_printLiteral(const ast_BinaryOperator* e, string_buffer_Buf* out);
struct ast_BitOffsetExpr_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_BitOffsetExpr* ast_BitOffsetExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_BitOffsetExpr_instantiate(ast_BitOffsetExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_BitOffsetExpr_getLHS(const ast_BitOffsetExpr* e);
static ast_Expr** ast_BitOffsetExpr_getLHS2(ast_BitOffsetExpr* e);
static ast_Expr* ast_BitOffsetExpr_getRHS(const ast_BitOffsetExpr* e);
static ast_Expr** ast_BitOffsetExpr_getRHS2(ast_BitOffsetExpr* e);
static void ast_BitOffsetExpr_setWidth(ast_BitOffsetExpr* e, uint8_t width);
static uint32_t ast_BitOffsetExpr_getWidth(const ast_BitOffsetExpr* e);
static src_loc_SrcLoc ast_BitOffsetExpr_getStartLoc(const ast_BitOffsetExpr* e);
static src_loc_SrcLoc ast_BitOffsetExpr_getEndLoc(const ast_BitOffsetExpr* e);
static void ast_BitOffsetExpr_printLiteral(const ast_BitOffsetExpr* e, string_buffer_Buf* out);
static void ast_BitOffsetExpr_print(const ast_BitOffsetExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_BooleanLiteral_ {
   ast_Expr base;
};

static ast_BooleanLiteral* ast_BooleanLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, bool val);
static ast_Value ast_BooleanLiteral_getValue(const ast_BooleanLiteral* e);
static src_loc_SrcLoc ast_BooleanLiteral_getEndLoc(const ast_BooleanLiteral* e);
static void ast_BooleanLiteral_print(const ast_BooleanLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_BooleanLiteral_printLiteral(const ast_BooleanLiteral* e, string_buffer_Buf* out);
typedef uint8_t ast_BuiltinExprKind;
enum ast_BuiltinExprKind {
   ast_BuiltinExprKind_Sizeof,
   ast_BuiltinExprKind_Elemsof,
   ast_BuiltinExprKind_EnumMin,
   ast_BuiltinExprKind_EnumMax,
   ast_BuiltinExprKind_OffsetOf,
   ast_BuiltinExprKind_ToContainer,
};

struct ast_ToContainerData_ {
   ast_Expr* member;
   ast_Expr* pointer;
};

struct ast_OffsetOfData_ {
   ast_Expr* member;
};

struct ast_BuiltinExpr_ {
   ast_Expr base;
   ast_Expr* inner;
   ast_Value value;
   ast_OffsetOfData offset[0];
   ast_ToContainerData container[0];
};

static const char* ast_builtin_names[6] = { "sizeof", "elemsof", "enum_min", "enum_max", "offsetof", "to_container" };
static ast_BuiltinExpr* ast_BuiltinExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind);
static ast_BuiltinExpr* ast_BuiltinExpr_createOffsetOf(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member);
static ast_BuiltinExpr* ast_BuiltinExpr_createToContainer(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member, ast_Expr* pointer);
static ast_Expr* ast_BuiltinExpr_instantiate(ast_BuiltinExpr* e, ast_Instantiator* inst);
static ast_BuiltinExprKind ast_BuiltinExpr_getKind(const ast_BuiltinExpr* e);
static ast_Value ast_BuiltinExpr_getValue(const ast_BuiltinExpr* e);
static void ast_BuiltinExpr_setValue(ast_BuiltinExpr* e, ast_Value value);
static void ast_BuiltinExpr_setUValue(ast_BuiltinExpr* e, uint64_t val);
static ast_Expr* ast_BuiltinExpr_getInner(const ast_BuiltinExpr* e);
static src_loc_SrcLoc ast_BuiltinExpr_getEndLoc(const ast_BuiltinExpr* e);
static ast_Expr* ast_BuiltinExpr_getOffsetOfMember(const ast_BuiltinExpr* b);
static ast_Expr* ast_BuiltinExpr_getToContainerMember(const ast_BuiltinExpr* b);
static ast_Expr* ast_BuiltinExpr_getToContainerPointer(const ast_BuiltinExpr* b);
static ast_Expr** ast_BuiltinExpr_getToContainerPointer2(ast_BuiltinExpr* b);
static void ast_BuiltinExpr_print(const ast_BuiltinExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_BuiltinExpr_printLiteral(const ast_BuiltinExpr* e, string_buffer_Buf* out);
struct ast_CallExpr_ {
   ast_Expr base;
   src_loc_SrcLoc endLoc;
   uint16_t template_idx;
   uint16_t instance_ast_idx;
   ast_Expr* func;
   ast_Expr* args[0];
};

static ast_CallExpr* ast_CallExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args);
static ast_CallExpr* ast_CallExpr_createTemplate(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, uint32_t ast_idx, const ast_TypeRefHolder* ref);
static ast_Expr* ast_CallExpr_instantiate(ast_CallExpr* e, ast_Instantiator* inst);
static void ast_CallExpr_setCallsTypeFunc(ast_CallExpr* e);
static bool ast_CallExpr_isTypeFunc(const ast_CallExpr* e);
static void ast_CallExpr_setCallsStaticTypeFunc(ast_CallExpr* e);
static bool ast_CallExpr_isStaticTypeFunc(const ast_CallExpr* e);
static bool ast_CallExpr_isTemplateCall(const ast_CallExpr* e);
static ast_TypeRef* ast_CallExpr_getTemplateArg(const ast_CallExpr* e);
static void ast_CallExpr_setTemplateIdx(ast_CallExpr* e, uint32_t idx);
static uint32_t ast_CallExpr_getTemplateIdx(const ast_CallExpr* e);
static uint16_t ast_CallExpr_getInstanceASTIdx(const ast_CallExpr* e);
static void ast_CallExpr_setNoreturn(ast_CallExpr* e);
static bool ast_CallExpr_isNoreturn(const ast_CallExpr* e);
static void ast_CallExpr_setFormatAttr(ast_CallExpr* e, ast_FormatAttr kind);
static ast_FormatAttr ast_CallExpr_getFormatAttr(const ast_CallExpr* e);
static void ast_CallExpr_setHasAutoArgs(ast_CallExpr* e);
static bool ast_CallExpr_hasAutoArgs(const ast_CallExpr* e);
static src_loc_SrcLoc ast_CallExpr_getStartLoc(const ast_CallExpr* e);
static src_loc_SrcLoc ast_CallExpr_getEndLoc(const ast_CallExpr* e);
static ast_Expr* ast_CallExpr_getFunc(const ast_CallExpr* e);
static ast_Expr** ast_CallExpr_getFunc2(ast_CallExpr* e);
static uint32_t ast_CallExpr_getNumArgs(const ast_CallExpr* e);
static ast_Expr** ast_CallExpr_getArgs(ast_CallExpr* e);
static void ast_CallExpr_printLiteral(const ast_CallExpr* e, string_buffer_Buf* out);
static void ast_CallExpr_print(const ast_CallExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_CharLiteral_ {
   ast_Expr base;
};

static ast_CharLiteral* ast_CharLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint8_t val, number_radix_Radix radix);
static ast_Value ast_CharLiteral_getValue(const ast_CharLiteral* e);
static src_loc_SrcLoc ast_CharLiteral_getEndLoc(const ast_CharLiteral* e);
static void ast_CharLiteral_print(const ast_CharLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_CharLiteral_printLiteral(const ast_CharLiteral* e, string_buffer_Buf* out);
struct ast_ConditionalOperator_ {
   ast_Expr base;
   src_loc_SrcLoc colonLoc;
   ast_Expr* cond;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_ConditionalOperator* ast_ConditionalOperator_create(ast_context_Context* c, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_ConditionalOperator_instantiate(ast_ConditionalOperator* e, ast_Instantiator* inst);
static ast_Expr* ast_ConditionalOperator_getCond(const ast_ConditionalOperator* e);
static ast_Expr** ast_ConditionalOperator_getCond2(ast_ConditionalOperator* e);
static ast_Expr* ast_ConditionalOperator_getLHS(const ast_ConditionalOperator* e);
static ast_Expr** ast_ConditionalOperator_getLHS2(ast_ConditionalOperator* e);
static ast_Expr* ast_ConditionalOperator_getRHS(const ast_ConditionalOperator* e);
static ast_Expr** ast_ConditionalOperator_getRHS2(ast_ConditionalOperator* e);
static src_loc_SrcLoc ast_ConditionalOperator_getStartLoc(const ast_ConditionalOperator* e);
static src_loc_SrcLoc ast_ConditionalOperator_getEndLoc(const ast_ConditionalOperator* e);
static void ast_ConditionalOperator_printLiteral(const ast_ConditionalOperator* e, string_buffer_Buf* out);
static void ast_ConditionalOperator_print(const ast_ConditionalOperator* e, string_buffer_Buf* out, uint32_t indent);
struct ast_ExplicitCastExpr_ {
   ast_Expr base;
   ast_Expr* inner;
   ast_QualType dest_type;
   ast_TypeRef dest;
};

static ast_ExplicitCastExpr* ast_ExplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, bool c_style);
static ast_Expr* ast_ExplicitCastExpr_instantiate(ast_ExplicitCastExpr* e, ast_Instantiator* inst);
static void ast_ExplicitCastExpr_setDestType(ast_ExplicitCastExpr* e, ast_QualType qt);
static ast_QualType ast_ExplicitCastExpr_getDestType(const ast_ExplicitCastExpr* e);
static bool ast_ExplicitCastExpr_getCStyle(const ast_ExplicitCastExpr* e);
static ast_Expr* ast_ExplicitCastExpr_getInner(const ast_ExplicitCastExpr* e);
static ast_Expr** ast_ExplicitCastExpr_getInner2(ast_ExplicitCastExpr* e);
static ast_TypeRef* ast_ExplicitCastExpr_getTypeRef(ast_ExplicitCastExpr* e);
static src_loc_SrcLoc ast_ExplicitCastExpr_getEndLoc(const ast_ExplicitCastExpr* e);
static void ast_ExplicitCastExpr_printLiteral(const ast_ExplicitCastExpr* e, string_buffer_Buf* out);
static void ast_ExplicitCastExpr_print(const ast_ExplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_FieldDesignatedInitExpr_ {
   ast_Expr base;
   uint32_t field_name;
   ast_Expr* initValue;
   const ast_FieldInitField* fif;
};

static ast_FieldDesignatedInitExpr* ast_FieldDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue);
static ast_Expr* ast_FieldDesignatedInitExpr_instantiate(ast_FieldDesignatedInitExpr* e, ast_Instantiator* inst);
static uint32_t ast_FieldDesignatedInitExpr_getField(const ast_FieldDesignatedInitExpr* e);
static const char* ast_FieldDesignatedInitExpr_getFieldName(const ast_FieldDesignatedInitExpr* e);
static ast_Expr* ast_FieldDesignatedInitExpr_getInit(const ast_FieldDesignatedInitExpr* e);
static ast_Expr** ast_FieldDesignatedInitExpr_getInit2(ast_FieldDesignatedInitExpr* e);
static src_loc_SrcLoc ast_FieldDesignatedInitExpr_getEndLoc(const ast_FieldDesignatedInitExpr* e);
static void ast_FieldDesignatedInitExpr_setMemberInfo(ast_FieldDesignatedInitExpr* e, const ast_FieldInitField* fif);
static const ast_FieldInitField* ast_FieldDesignatedInitExpr_getMemberInfo(const ast_FieldDesignatedInitExpr* e);
static ast_Decl* ast_FieldDesignatedInitExpr_getDecl(const ast_FieldDesignatedInitExpr* e);
static void ast_FieldDesignatedInitExpr_print(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_FieldDesignatedInitExpr_printLiteral(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out);
struct ast_FloatLiteral_ {
   ast_Expr base;
   double val;
};

typedef uint8_t ast_BuiltinKind;
enum ast_BuiltinKind {
   ast_BuiltinKind_Char,
   ast_BuiltinKind_Int8,
   ast_BuiltinKind_Int16,
   ast_BuiltinKind_Int32,
   ast_BuiltinKind_Int64,
   ast_BuiltinKind_UInt8,
   ast_BuiltinKind_UInt16,
   ast_BuiltinKind_UInt32,
   ast_BuiltinKind_UInt64,
   ast_BuiltinKind_Float32,
   ast_BuiltinKind_Float64,
   ast_BuiltinKind_ISize,
   ast_BuiltinKind_USize,
   ast_BuiltinKind_Bool,
};

static ast_FloatLiteral* ast_FloatLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, double val, number_radix_Radix radix, ast_BuiltinKind kind);
static ast_Value ast_FloatLiteral_getValue(const ast_FloatLiteral* e);
static src_loc_SrcLoc ast_FloatLiteral_getEndLoc(const ast_FloatLiteral* e);
static void ast_FloatLiteral_print(const ast_FloatLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_FloatLiteral_printLiteral(const ast_FloatLiteral* e, string_buffer_Buf* out);
typedef uint8_t ast_IdentifierKind;
enum ast_IdentifierKind {
   ast_IdentifierKind_Unresolved,
   ast_IdentifierKind_Module,
   ast_IdentifierKind_Function,
   ast_IdentifierKind_Type,
   ast_IdentifierKind_Var,
   ast_IdentifierKind_EnumConstant,
   ast_IdentifierKind_StructMember,
   ast_IdentifierKind_Label,
};

struct ast_IdentifierExpr_ {
   ast_Expr base;
   union {
      uint32_t name_idx;
      ast_Decl* decl;
   };
};

static const char* ast_IdentifierKind_str(ast_IdentifierKind k);
static ast_IdentifierExpr* ast_IdentifierExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t name, uint32_t name_len);
static ast_Expr* ast_IdentifierExpr_instantiate(ast_IdentifierExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_IdentifierExpr_asExpr(ast_IdentifierExpr* e);
static void ast_IdentifierExpr_setDecl(ast_IdentifierExpr* e, ast_Decl* decl);
static bool ast_IdentifierExpr_hasDecl(const ast_IdentifierExpr* e);
static ast_Decl* ast_IdentifierExpr_getDecl(const ast_IdentifierExpr* e);
static ast_Ref ast_IdentifierExpr_getRef(const ast_IdentifierExpr* e);
static void ast_IdentifierExpr_setKind(ast_IdentifierExpr* e, ast_IdentifierKind kind);
static ast_IdentifierKind ast_IdentifierExpr_getKind(const ast_IdentifierExpr* e);
static const char* ast_IdentifierExpr_getName(const ast_IdentifierExpr* e);
static src_loc_SrcLoc ast_IdentifierExpr_getEndLoc(const ast_IdentifierExpr* e);
static uint32_t ast_IdentifierExpr_getNameIdx(const ast_IdentifierExpr* e);
static void ast_IdentifierExpr_print(const ast_IdentifierExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_IdentifierExpr_printLiteral(const ast_IdentifierExpr* e, string_buffer_Buf* out);
typedef uint8_t ast_ImplicitCastKind;
enum ast_ImplicitCastKind {
   ast_ImplicitCastKind_ArrayToPointerDecay,
   ast_ImplicitCastKind_LValueToRValue,
   ast_ImplicitCastKind_PointerToBoolean,
   ast_ImplicitCastKind_PointerToInteger,
   ast_ImplicitCastKind_IntegralCast,
   ast_ImplicitCastKind_BitCast,
};

struct ast_ImplicitCastExpr_ {
   ast_Expr base;
   ast_Expr* inner;
};

static const char* ast_implicitCastKind_names[6] = { "ArrayToPointerDecay", "LValueToRValue", "PointerToBoolean", "PointerToInteger", "IntegralCast", "BitCast" };
static ast_ImplicitCastExpr* ast_ImplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_ImplicitCastKind kind, ast_Expr* inner);
static ast_ImplicitCastKind ast_ImplicitCastExpr_getKind(const ast_ImplicitCastExpr* e);
static bool ast_ImplicitCastExpr_isArrayToPointerDecay(const ast_ImplicitCastExpr* e);
static ast_Expr* ast_ImplicitCastExpr_getInner(const ast_ImplicitCastExpr* e);
static void ast_ImplicitCastExpr_setInner(ast_ImplicitCastExpr* e, ast_Expr* inner);
static src_loc_SrcLoc ast_ImplicitCastExpr_getStartLoc(const ast_ImplicitCastExpr* e);
static src_loc_SrcLoc ast_ImplicitCastExpr_getEndLoc(const ast_ImplicitCastExpr* e);
static void ast_ImplicitCastExpr_printLiteral(const ast_ImplicitCastExpr* e, string_buffer_Buf* out);
static void ast_ImplicitCastExpr_print(const ast_ImplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent);
struct ast_InitListExpr_ {
   ast_Expr base;
   src_loc_SrcLoc endLoc;
   uint32_t num_values;
   ast_Expr* values[0];
};

static ast_InitListExpr* ast_InitListExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values);
static ast_Expr* ast_InitListExpr_instantiate(ast_InitListExpr* e, ast_Instantiator* inst);
static bool ast_InitListExpr_isArray(const ast_InitListExpr* e);
static void ast_InitListExpr_setIsArray(ast_InitListExpr* e);
static bool ast_InitListExpr_hasDesignators(const ast_InitListExpr* e);
static void ast_InitListExpr_setHasDesignators(ast_InitListExpr* e);
static uint32_t ast_InitListExpr_getNumValues(const ast_InitListExpr* e);
static ast_Expr** ast_InitListExpr_getValues(ast_InitListExpr* e);
static const ast_Expr** ast_InitListExpr_getValues2(const ast_InitListExpr* e);
static src_loc_SrcLoc ast_InitListExpr_getEndLoc(const ast_InitListExpr* e);
static void ast_InitListExpr_print(const ast_InitListExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_InitListExpr_printLiteral(const ast_InitListExpr* e, string_buffer_Buf* out);
struct ast_IntegerLiteral_ {
   ast_Expr base;
   uint64_t val;
};

static ast_IntegerLiteral* ast_IntegerLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint64_t val, number_radix_Radix radix, ast_BuiltinKind kind);
static ast_Value ast_IntegerLiteral_getValue(const ast_IntegerLiteral* e);
static src_loc_SrcLoc ast_IntegerLiteral_getEndLoc(const ast_IntegerLiteral* e);
static void ast_printBinary(string_buffer_Buf* out, uint64_t value);
static void ast_printOctal(string_buffer_Buf* out, uint64_t value);
static void ast_IntegerLiteral_print(const ast_IntegerLiteral* e, string_buffer_Buf* out, uint32_t indent);
static void ast_IntegerLiteral_printLiteral(const ast_IntegerLiteral* e, string_buffer_Buf* out, bool c_style);
typedef uint8_t ast_MemberConversion;
enum ast_MemberConversion {
   ast_MemberConversion_None,
   ast_MemberConversion_Addr,
   ast_MemberConversion_Deref,
};

union ast_MemberRef_ {
   uint32_t name_idx;
   ast_Decl* decl;
   ast_Expr* expr;
   size_t bits;
};

struct ast_MemberExpr_ {
   ast_Expr base;
   ast_MemberRef refs[2];
};

static ast_MemberExpr* ast_MemberExpr_create(ast_context_Context* c, ast_Expr* base, uint32_t base_name_idx, uint32_t base_len, src_loc_SrcLoc loc, uint32_t member_name_idx);
static ast_Expr* ast_MemberExpr_instantiate(ast_MemberExpr* e, ast_Instantiator* inst);
static bool ast_MemberExpr_hasExpr(const ast_MemberExpr* e);
static ast_Expr* ast_MemberExpr_getBaseExpr(const ast_MemberExpr* e);
static void ast_MemberExpr_setConversion(ast_MemberExpr* e, ast_MemberConversion c);
static ast_MemberConversion ast_MemberExpr_getConversion(const ast_MemberExpr* e);
static const char* ast_MemberExpr_getName(const ast_MemberExpr* e, uint32_t ref_idx);
static uint32_t ast_MemberExpr_getNameIdx(const ast_MemberExpr* e, uint32_t ref_idx);
static src_loc_SrcLoc ast_MemberExpr_getLoc(const ast_MemberExpr* e, uint32_t ref_idx);
static src_loc_SrcLoc ast_MemberExpr_getMemberLoc(const ast_MemberExpr* e);
static src_loc_SrcLoc ast_MemberExpr_getStartLoc(const ast_MemberExpr* e);
static src_loc_SrcLoc ast_MemberExpr_getEndLoc(const ast_MemberExpr* e);
static src_loc_SrcLoc ast_MemberExpr_getBaseEndLoc(const ast_MemberExpr* e);
static src_loc_SrcRange ast_MemberExpr_getBaseRange(const ast_MemberExpr* e);
static ast_Ref ast_MemberExpr_getBaseRef(const ast_MemberExpr* e);
static ast_Ref ast_MemberExpr_getRef(const ast_MemberExpr* e);
static ast_IdentifierKind ast_MemberExpr_getKind(const ast_MemberExpr* e);
static void ast_MemberExpr_setKind(ast_MemberExpr* e, ast_IdentifierKind kind);
static void ast_MemberExpr_setIsTypeFunc(ast_MemberExpr* e);
static bool ast_MemberExpr_isTypeFunc(const ast_MemberExpr* e);
static void ast_MemberExpr_setBitfield(ast_MemberExpr* e);
static bool ast_MemberExpr_isBitfield(const ast_MemberExpr* e);
static void ast_MemberExpr_setIsStaticTypeFunc(ast_MemberExpr* e);
static bool ast_MemberExpr_isStaticTypeFunc(const ast_MemberExpr* e);
static void ast_MemberExpr_setConstBase(ast_MemberExpr* e, bool b);
static bool ast_MemberExpr_isConstBase(const ast_MemberExpr* e);
static void ast_MemberExpr_setVolatileBase(ast_MemberExpr* e, bool b);
static bool ast_MemberExpr_isVolatileBase(const ast_MemberExpr* e);
static ast_Decl* ast_MemberExpr_getBaseDecl(const ast_MemberExpr* e);
static ast_Decl* ast_MemberExpr_getFullDecl(const ast_MemberExpr* e);
static ast_Decl* ast_MemberExpr_getDecl(const ast_MemberExpr* e, uint32_t ref_idx);
static void ast_MemberExpr_setDecl(ast_MemberExpr* e, ast_Decl* d, uint32_t ref_idx);
static ast_QualType ast_MemberExpr_getBaseType(const ast_MemberExpr* m);
static const char* ast_MemberExpr_getMemberName(const ast_MemberExpr* e);
static void ast_MemberExpr_print(const ast_MemberExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_MemberExpr_printLiteral(const ast_MemberExpr* e, string_buffer_Buf* out);
static void ast_MemberExpr_dump(const ast_MemberExpr* m);
struct ast_NamedArgument_ {
   ast_Expr base;
   src_loc_SrcLoc loc;
   uint32_t name;
   ast_Expr* inner;
};

static ast_NamedArgument* ast_NamedArgument_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t name, ast_Expr* inner);
static ast_Expr* ast_NamedArgument_instantiate(ast_NamedArgument* e, ast_Instantiator* inst);
static uint32_t ast_NamedArgument_getNameIdx(const ast_NamedArgument* e);
static ast_Expr* ast_NamedArgument_getInner(const ast_NamedArgument* e);
static ast_Expr** ast_NamedArgument_getInner2(ast_NamedArgument* e);
static src_loc_SrcLoc ast_NamedArgument_getStartLoc(const ast_NamedArgument* e);
static src_loc_SrcLoc ast_NamedArgument_getEndLoc(const ast_NamedArgument* e);
static void ast_NamedArgument_print(const ast_NamedArgument* e, string_buffer_Buf* out, uint32_t indent);
static void ast_NamedArgument_printLiteral(const ast_NamedArgument* e, string_buffer_Buf* out);
struct ast_NilExpr_ {
   ast_Expr base;
};

static ast_NilExpr* ast_NilExpr_create(ast_context_Context* c, src_loc_SrcLoc loc);
static src_loc_SrcLoc ast_NilExpr_getEndLoc(const ast_NilExpr* e);
static void ast_NilExpr_print(const ast_NilExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_NilExpr_printLiteral(const ast_NilExpr* _arg0, string_buffer_Buf* out);
struct ast_ParenExpr_ {
   ast_Expr base;
   ast_Expr* inner;
};

static ast_ParenExpr* ast_ParenExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner);
static ast_Expr* ast_ParenExpr_instantiate(ast_ParenExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_ParenExpr_getInner(const ast_ParenExpr* e);
static ast_Expr** ast_ParenExpr_getInner2(ast_ParenExpr* e);
static void ast_ParenExpr_print(const ast_ParenExpr* e, string_buffer_Buf* out, uint32_t indent);
static src_loc_SrcLoc ast_ParenExpr_getEndLoc(const ast_ParenExpr* e);
static void ast_ParenExpr_printLiteral(const ast_ParenExpr* e, string_buffer_Buf* out);
struct ast_RangeExpr_ {
   ast_Expr base;
   ast_Expr* lhs;
   ast_Expr* rhs;
};

static ast_RangeExpr* ast_RangeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_RangeExpr_instantiate(ast_RangeExpr* e, ast_Instantiator* inst);
static ast_Expr* ast_RangeExpr_getLHS(const ast_RangeExpr* e);
static ast_Expr* ast_RangeExpr_getRHS(const ast_RangeExpr* e);
static src_loc_SrcLoc ast_RangeExpr_getStartLoc(const ast_RangeExpr* e);
static src_loc_SrcLoc ast_RangeExpr_getEndLoc(const ast_RangeExpr* e);
static void ast_RangeExpr_print(const ast_RangeExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_RangeExpr_printLiteral(const ast_RangeExpr* e, string_buffer_Buf* out);
struct ast_StringLiteral_ {
   ast_Expr base;
   uint32_t value;
   uint32_t size;
};

static ast_StringLiteral* ast_StringLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len);
static const char* ast_StringLiteral_getText(const ast_StringLiteral* e);
static uint32_t ast_StringLiteral_getTextIndex(const ast_StringLiteral* e);
static uint32_t ast_StringLiteral_getSize(const ast_StringLiteral* e);
static uint32_t ast_StringLiteral_strlen(const ast_StringLiteral* e);
static src_loc_SrcLoc ast_StringLiteral_getEndLoc(const ast_StringLiteral* e);
static void ast_StringLiteral_printLiteral(const ast_StringLiteral* e, string_buffer_Buf* out);
static void ast_StringLiteral_print(const ast_StringLiteral* e, string_buffer_Buf* out, uint32_t indent);
struct ast_TypeExpr_ {
   ast_Expr base;
   ast_TypeRef typeRef;
};

static ast_TypeExpr* ast_TypeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref);
static ast_Expr* ast_TypeExpr_instantiate(ast_TypeExpr* e, ast_Instantiator* inst);
static ast_TypeRef* ast_TypeExpr_getTypeRef(ast_TypeExpr* e);
static src_loc_SrcLoc ast_TypeExpr_getEndLoc(const ast_TypeExpr* e);
static void ast_TypeExpr_print(const ast_TypeExpr* e, string_buffer_Buf* out, uint32_t indent);
static void ast_TypeExpr_printLiteral(const ast_TypeExpr* e, string_buffer_Buf* out);
typedef uint8_t ast_UnaryOpcode;
enum ast_UnaryOpcode {
   ast_UnaryOpcode_PostInc,
   ast_UnaryOpcode_PostDec,
   ast_UnaryOpcode_PreInc,
   ast_UnaryOpcode_PreDec,
   ast_UnaryOpcode_AddrOf,
   ast_UnaryOpcode_Deref,
   ast_UnaryOpcode_Plus,
   ast_UnaryOpcode_Minus,
   ast_UnaryOpcode_Not,
   ast_UnaryOpcode_LNot,
};

struct ast_UnaryOperator_ {
   ast_Expr base;
   ast_Expr* inner;
};

static const char* ast_unaryOpcode_names[10] = {
   "++",
   "--",
   "++",
   "--",
   "&",
   "*",
   "+",
   "-",
   "~",
   "!"
};
static ast_UnaryOperator* ast_UnaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_UnaryOpcode kind, ast_Expr* inner);
static ast_Expr* ast_UnaryOperator_instantiate(ast_UnaryOperator* e, ast_Instantiator* inst);
static ast_UnaryOpcode ast_UnaryOperator_getOpcode(const ast_UnaryOperator* e);
static ast_Expr* ast_UnaryOperator_getInner(const ast_UnaryOperator* e);
static ast_Expr** ast_UnaryOperator_getInner2(ast_UnaryOperator* e);
static bool ast_UnaryOperator_isBefore(const ast_UnaryOperator* e);
static src_loc_SrcLoc ast_UnaryOperator_getStartLoc(const ast_UnaryOperator* e);
static src_loc_SrcLoc ast_UnaryOperator_getEndLoc(const ast_UnaryOperator* e);
static const char* ast_UnaryOperator_getOpcodeStr(const ast_UnaryOperator* e);
static bool ast_UnaryOperator_isAddrOf(const ast_UnaryOperator* e);
static void ast_UnaryOperator_print(const ast_UnaryOperator* e, string_buffer_Buf* out, uint32_t indent);
static void ast_UnaryOperator_printLiteral(const ast_UnaryOperator* e, string_buffer_Buf* out);
typedef uint8_t ast_TypeKind;
enum ast_TypeKind {
   ast_TypeKind_Builtin,
   ast_TypeKind_Pointer,
   ast_TypeKind_Array,
   ast_TypeKind_Struct,
   ast_TypeKind_Enum,
   ast_TypeKind_Function,
   ast_TypeKind_Void,
   ast_TypeKind_Alias,
   ast_TypeKind_Module,
};

struct ast_TypeBits_ {
   ast_TypeKind kind : 8;
};

struct ast_BuiltinTypeBits_ {
   uint32_t  : 8;
   uint32_t kind : 4;
};

struct ast_ArrayTypeBits_ {
   uint32_t  : 8;
   uint32_t has_size : 1;
   uint32_t is_incremental : 1;
   uint32_t is_enum_index : 1;
};

struct ast_Type_ {
   union {
      ast_TypeBits typeBits;
      ast_BuiltinTypeBits builtinTypeBits;
      ast_ArrayTypeBits arrayTypeBits;
      uint32_t bits;
   };
   uint32_t ptr_pool_idx;
   ast_QualType canonicalType;
};

static const char* ast_typeKind_names[9] = {
   "Builtin",
   "Pointer",
   "Array",
   "Struct",
   "Enum",
   "Function",
   "Void",
   "Alias",
   "Module"
};
#define ast_NumTypeBits 8
static void ast_Type_init(ast_Type* t, ast_TypeKind k);
static ast_TypeKind ast_Type_getKind(const ast_Type* t);
static ast_QualType ast_Type_getCanonicalType(const ast_Type* t);
static void ast_Type_setCanonicalType(ast_Type* t, ast_QualType canon);
static uint32_t ast_Type_getIndex(const ast_Type* t);
static bool ast_Type_isBuiltinType(const ast_Type* t);
static bool ast_Type_isArrayType(const ast_Type* t);
static bool ast_Type_isStructType(const ast_Type* t);
static bool ast_Type_isPointerType(const ast_Type* t);
static bool ast_Type_isFunctionType(const ast_Type* t);
static bool ast_Type_isEnumType(const ast_Type* t);
static bool ast_Type_isVoidType(const ast_Type* t);
static void ast_Type_dump(const ast_Type* t);
static uint32_t ast_Type_getAlignment(const ast_Type* t);
static uint32_t ast_Type_getSize(const ast_Type* t, bool deref_ptr);
static void ast_Type_print(const ast_Type* t, string_buffer_Buf* out);
static void ast_Type_fullPrint(const ast_Type* t, string_buffer_Buf* out, uint32_t indent);
struct ast_AliasType_ {
   ast_Type base;
   ast_AliasTypeDecl* decl;
};

static ast_AliasType* ast_AliasType_create(ast_context_Context* c, ast_AliasTypeDecl* decl);
static ast_AliasTypeDecl* ast_AliasType_getDecl(const ast_AliasType* t);
static void ast_AliasType_print(const ast_AliasType* t, string_buffer_Buf* out);
static void ast_AliasType_fullPrint(const ast_AliasType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_ArrayType_ {
   ast_Type base;
   ast_QualType elem;
   uint32_t size;
   ast_QualType index_type[0];
};

static ast_ArrayType* ast_ArrayType_create(ast_context_Context* c, ast_QualType elem, bool has_size, uint32_t length, bool is_enum_index, ast_QualType index_type);
static ast_ArrayType* ast_ArrayType_createIncremental(ast_context_Context* c, ast_QualType elem);
static ast_QualType ast_ArrayType_getElemType(const ast_ArrayType* t);
static uint32_t ast_ArrayType_hasSize(const ast_ArrayType* t);
static uint32_t ast_ArrayType_getSize(const ast_ArrayType* t);
static void ast_ArrayType_setSize(ast_ArrayType* t, uint32_t size);
static bool ast_ArrayType_isEnumIndex(const ast_ArrayType* t);
static ast_QualType ast_ArrayType_getIndexType(const ast_ArrayType* t);
static void ast_ArrayType_printPreName(const ast_ArrayType* t, string_buffer_Buf* out);
static void ast_ArrayType_printPostName(const ast_ArrayType* t, string_buffer_Buf* out);
static void ast_ArrayType_print(const ast_ArrayType* t, string_buffer_Buf* out);
static void ast_ArrayType_fullPrint(const ast_ArrayType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_BuiltinType_ {
   ast_Type base;
};

static const char* ast_builtinType_names[14] = {
   [ast_BuiltinKind_Char] = "char",
   [ast_BuiltinKind_Int8] = "i8",
   [ast_BuiltinKind_Int16] = "i16",
   [ast_BuiltinKind_Int32] = "i32",
   [ast_BuiltinKind_Int64] = "i64",
   [ast_BuiltinKind_UInt8] = "u8",
   [ast_BuiltinKind_UInt16] = "u16",
   [ast_BuiltinKind_UInt32] = "u32",
   [ast_BuiltinKind_UInt64] = "u64",
   [ast_BuiltinKind_Float32] = "f32",
   [ast_BuiltinKind_Float64] = "f64",
   [ast_BuiltinKind_ISize] = "isize",
   [ast_BuiltinKind_USize] = "usize",
   [ast_BuiltinKind_Bool] = "bool"
};
static const bool ast_BuiltinType_promotable[14] = {
   [ast_BuiltinKind_Char] = true,
   [ast_BuiltinKind_Int8] = true,
   [ast_BuiltinKind_Int16] = true,
   [ast_BuiltinKind_Int32] = false,
   [ast_BuiltinKind_Int64] = false,
   [ast_BuiltinKind_UInt8] = true,
   [ast_BuiltinKind_UInt16] = true,
   [ast_BuiltinKind_UInt32] = false,
   [ast_BuiltinKind_UInt64] = false,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = false,
   [ast_BuiltinKind_ISize] = false,
   [ast_BuiltinKind_USize] = false,
   [ast_BuiltinKind_Bool] = true
};
static const bool ast_BuiltinType_signed[14] = {
   [ast_BuiltinKind_Char] = false,
   [ast_BuiltinKind_Int8] = true,
   [ast_BuiltinKind_Int16] = true,
   [ast_BuiltinKind_Int32] = true,
   [ast_BuiltinKind_Int64] = true,
   [ast_BuiltinKind_UInt8] = false,
   [ast_BuiltinKind_UInt16] = false,
   [ast_BuiltinKind_UInt32] = false,
   [ast_BuiltinKind_UInt64] = false,
   [ast_BuiltinKind_Float32] = true,
   [ast_BuiltinKind_Float64] = true,
   [ast_BuiltinKind_ISize] = true,
   [ast_BuiltinKind_USize] = false,
   [ast_BuiltinKind_Bool] = false
};
static const bool ast_BuiltinType_unsigned[14] = {
   [ast_BuiltinKind_Char] = true,
   [ast_BuiltinKind_Int8] = false,
   [ast_BuiltinKind_Int16] = false,
   [ast_BuiltinKind_Int32] = false,
   [ast_BuiltinKind_Int64] = false,
   [ast_BuiltinKind_UInt8] = true,
   [ast_BuiltinKind_UInt16] = true,
   [ast_BuiltinKind_UInt32] = true,
   [ast_BuiltinKind_UInt64] = true,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = false,
   [ast_BuiltinKind_ISize] = false,
   [ast_BuiltinKind_USize] = true,
   [ast_BuiltinKind_Bool] = false
};
static const bool ast_BuiltinType_integer[14] = {
   [ast_BuiltinKind_Char] = true,
   [ast_BuiltinKind_Int8] = true,
   [ast_BuiltinKind_Int16] = true,
   [ast_BuiltinKind_Int32] = true,
   [ast_BuiltinKind_Int64] = true,
   [ast_BuiltinKind_UInt8] = true,
   [ast_BuiltinKind_UInt16] = true,
   [ast_BuiltinKind_UInt32] = true,
   [ast_BuiltinKind_UInt64] = true,
   [ast_BuiltinKind_Float32] = false,
   [ast_BuiltinKind_Float64] = false,
   [ast_BuiltinKind_ISize] = true,
   [ast_BuiltinKind_USize] = true,
   [ast_BuiltinKind_Bool] = false
};
static const uint32_t ast_BuiltinType_default_sizes[14] = {
   [ast_BuiltinKind_Char] = 1,
   [ast_BuiltinKind_Int8] = 1,
   [ast_BuiltinKind_Int16] = 2,
   [ast_BuiltinKind_Int32] = 4,
   [ast_BuiltinKind_Int64] = 8,
   [ast_BuiltinKind_UInt8] = 1,
   [ast_BuiltinKind_UInt16] = 2,
   [ast_BuiltinKind_UInt32] = 4,
   [ast_BuiltinKind_UInt64] = 8,
   [ast_BuiltinKind_Float32] = 4,
   [ast_BuiltinKind_Float64] = 8,
   [ast_BuiltinKind_ISize] = 8,
   [ast_BuiltinKind_USize] = 8,
   [ast_BuiltinKind_Bool] = 1
};
static const uint32_t ast_BuiltinType_default_widths[14] = {
   [ast_BuiltinKind_Char] = 8,
   [ast_BuiltinKind_Int8] = 8,
   [ast_BuiltinKind_Int16] = 16,
   [ast_BuiltinKind_Int32] = 32,
   [ast_BuiltinKind_Int64] = 64,
   [ast_BuiltinKind_UInt8] = 8,
   [ast_BuiltinKind_UInt16] = 16,
   [ast_BuiltinKind_UInt32] = 32,
   [ast_BuiltinKind_UInt64] = 64,
   [ast_BuiltinKind_Float32] = 0,
   [ast_BuiltinKind_Float64] = 0,
   [ast_BuiltinKind_ISize] = 64,
   [ast_BuiltinKind_USize] = 64,
   [ast_BuiltinKind_Bool] = 1
};
static const char* ast_BuiltinKind_str(ast_BuiltinKind kind);
static ast_BuiltinType* ast_BuiltinType_create(ast_context_Context* c, ast_BuiltinKind kind);
static ast_BuiltinKind ast_BuiltinType_getKind(const ast_BuiltinType* b);
static ast_BuiltinKind ast_BuiltinType_getBaseKind(const ast_BuiltinType* b);
static ast_BuiltinKind ast_BuiltinType_getBuiltinKind(const ast_BuiltinType* b);
static bool ast_BuiltinType_isInt32(const ast_BuiltinType* b);
static bool ast_BuiltinType_isBool(const ast_BuiltinType* b);
static const char* ast_BuiltinType_kind2str(const ast_BuiltinType* b);
static bool ast_BuiltinType_isPromotableIntegerType(const ast_BuiltinType* b);
static bool ast_BuiltinType_isInteger(const ast_BuiltinType* b);
static bool ast_BuiltinType_isIntegerOrBool(const ast_BuiltinType* b);
static bool ast_BuiltinType_isFloatingPoint(const ast_BuiltinType* b);
static bool ast_BuiltinType_isSigned(const ast_BuiltinType* b);
static bool ast_BuiltinType_isUnsigned(const ast_BuiltinType* b);
static uint32_t ast_BuiltinType_getAlignment(const ast_BuiltinType* b);
static uint32_t ast_BuiltinType_getWidth(const ast_BuiltinType* b);
static void ast_BuiltinType_print(const ast_BuiltinType* b, string_buffer_Buf* out);
static void ast_BuiltinType_fullPrint(const ast_BuiltinType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_EnumType_ {
   ast_Type base;
   ast_EnumTypeDecl* decl;
};

static ast_EnumType* ast_EnumType_create(ast_context_Context* c, ast_EnumTypeDecl* decl);
static ast_EnumTypeDecl* ast_EnumType_getDecl(const ast_EnumType* t);
static ast_QualType ast_EnumType_getImplType(const ast_EnumType* t);
static const char* ast_EnumType_getName(const ast_EnumType* t);
static void ast_EnumType_print(const ast_EnumType* t, string_buffer_Buf* out);
static void ast_EnumType_fullPrint(const ast_EnumType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_FunctionType_ {
   ast_Type base;
   ast_FunctionDecl* decl;
};

static ast_FunctionType* ast_FunctionType_create(ast_context_Context* c, ast_FunctionDecl* decl);
static ast_FunctionDecl* ast_FunctionType_getDecl(const ast_FunctionType* t);
static ast_Type* ast_FunctionType_asType(ast_FunctionType* t);
static void ast_FunctionType_print(const ast_FunctionType* t, string_buffer_Buf* out);
static void ast_FunctionType_fullPrint(const ast_FunctionType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_ModuleType_ {
   ast_Type base;
   ast_Module* mod;
};

static ast_ModuleType* ast_ModuleType_create(ast_context_Context* c, ast_Module* mod);
static ast_Module* ast_ModuleType_getModule(const ast_ModuleType* t);
static void ast_ModuleType_print(const ast_ModuleType* t, string_buffer_Buf* out);
static void ast_ModuleType_fullPrint(const ast_ModuleType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_PointerType_ {
   ast_Type base;
   ast_QualType inner;
};

static ast_PointerType* ast_PointerType_create(ast_context_Context* c, ast_QualType inner);
static ast_QualType ast_PointerType_getInner(const ast_PointerType* t);
static void ast_PointerType_print(const ast_PointerType* t, string_buffer_Buf* out);
static void ast_PointerType_fullPrint(const ast_PointerType* t, string_buffer_Buf* out, uint32_t indent);
#define ast_QualType_Const 0x1
#define ast_QualType_Volatile 0x2
#define ast_QualType_Mask 0x3
static ast_QualType ast_QualType_create(ast_Type* t);
static void ast_QualType_set(ast_QualType* qt, ast_Type* t);
static void ast_QualType_setConst(ast_QualType* qt);
static void ast_QualType_unsetConst(ast_QualType* qt);
static bool ast_QualType_isConst(const ast_QualType qt);
static bool ast_QualType_isVolatile(const ast_QualType qt);
static void ast_QualType_setVolatile(ast_QualType* qt);
static uint32_t ast_QualType_getQuals(const ast_QualType qt);
static void ast_QualType_copyQuals(ast_QualType* qt, ast_QualType other);
static void ast_QualType_clearQuals(ast_QualType* qt);
static bool ast_QualType_isConstant(const ast_QualType qt);
static bool ast_QualType_isValid(const ast_QualType qt);
static bool ast_QualType_isInvalid(const ast_QualType qt);
static uint32_t ast_QualType_getBitFieldWidth(const ast_QualType qt, bool precise);
static bool ast_QualType_isScalar(const ast_QualType qt);
static ast_Type* ast_QualType_getType(const ast_QualType qt);
static ast_Type* ast_QualType_getTypeOrNil(const ast_QualType qt);
static bool ast_QualType_hasCanonicalType(const ast_QualType qt);
static ast_QualType ast_QualType_getCanonicalType(const ast_QualType qt);
static void ast_QualType_setCanonicalType(ast_QualType* qt, ast_QualType canon);
static ast_QualType ast_QualType_getImplType(const ast_QualType* qt);
static ast_TypeKind ast_QualType_getKind(const ast_QualType qt);
static uint32_t ast_QualType_getIndex(const ast_QualType qt);
static uint32_t ast_QualType_getAlignment(const ast_QualType qt);
static uint32_t ast_QualType_getSize(const ast_QualType qt, bool deref_ptr);
static bool ast_QualType_isBool(const ast_QualType qt);
static bool ast_QualType_isBuiltin(const ast_QualType qt);
static bool ast_QualType_isArray(const ast_QualType qt);
static bool ast_QualType_isStruct(const ast_QualType qt);
static bool ast_QualType_isInteger(const ast_QualType qt);
static bool ast_QualType_isFloat(const ast_QualType qt);
static bool ast_QualType_isFloat32(const ast_QualType qt);
static ast_BuiltinKind ast_QualType_getBuiltinKind(const ast_QualType* qt);
static bool ast_QualType_isCharPointer(const ast_QualType qt);
static bool ast_QualType_isEmbedType(const ast_QualType qt, bool* is_char);
static bool ast_QualType_isPointer(const ast_QualType qt);
static bool ast_QualType_isPointerOrFunction(const ast_QualType qt);
static ast_QualType ast_QualType_getPointerBaseType(const ast_QualType qt);
static bool ast_QualType_isFunction(const ast_QualType qt);
static bool ast_QualType_isEnum(const ast_QualType qt);
static bool ast_QualType_isVoid(const ast_QualType qt);
static bool ast_QualType_isVoidPtr(const ast_QualType qt);
static ast_BuiltinType* ast_QualType_getBuiltin(const ast_QualType qt);
static ast_BuiltinType* ast_QualType_getBuiltinTypeOrNil(const ast_QualType qt);
static ast_StructType* ast_QualType_getStructType(const ast_QualType qt);
static ast_PointerType* ast_QualType_getPointerType(const ast_QualType qt);
static ast_FunctionType* ast_QualType_getFunctionType(const ast_QualType qt);
static ast_ArrayType* ast_QualType_getArrayType(const ast_QualType qt);
static ast_EnumType* ast_QualType_getEnum(const ast_QualType qt);
static ast_FunctionType* ast_QualType_getFunctionTypeOrNil(const ast_QualType qt);
static ast_StructType* ast_QualType_getStructTypeOrNil(const ast_QualType qt);
static ast_ArrayType* ast_QualType_getArrayTypeOrNil(const ast_QualType qt);
static ast_EnumType* ast_QualType_getEnumType(const ast_QualType qt);
static ast_EnumType* ast_QualType_getEnumTypeOrNil(const ast_QualType qt);
static bool ast_QualType_isCharCompatible(const ast_QualType qt);
static bool ast_QualType_isChar(const ast_QualType qt);
static bool ast_QualType_isUInt8(const ast_QualType qt);
static bool ast_QualType_promotesToInt32(const ast_QualType qt);
static bool ast_QualType_needsCtvInit(const ast_QualType qt);
static const char* ast_QualType_diagName(const ast_QualType qt);
static const char* ast_QualType_diagNameBare(const ast_QualType qt);
static void ast_QualType_dump(const ast_QualType qt);
static void ast_QualType_dump_full(const ast_QualType qt);
static void ast_QualType_printQuoted(const ast_QualType qt, string_buffer_Buf* out);
static void ast_QualType_print(const ast_QualType qt, string_buffer_Buf* out);
static void ast_QualType_printInner(const ast_QualType qt, string_buffer_Buf* out, bool printCanon, bool printModifiers, bool print_error);
static void ast_QualType_fullPrint(const ast_QualType qt, string_buffer_Buf* out, uint32_t indent);
struct ast_StructType_ {
   ast_Type base;
   ast_StructTypeDecl* decl;
};

static ast_StructType* ast_StructType_create(ast_context_Context* c, ast_StructTypeDecl* decl);
static ast_StructTypeDecl* ast_StructType_getDecl(const ast_StructType* t);
static ast_Type* ast_StructType_asType(ast_StructType* t);
static void ast_StructType_print(const ast_StructType* t, string_buffer_Buf* out);
static void ast_StructType_fullPrint(const ast_StructType* t, string_buffer_Buf* out, uint32_t indent);
typedef uint8_t ast_TypeRefKind;
enum ast_TypeRefKind {
   ast_TypeRefKind_Builtin,
   ast_TypeRefKind_Void,
   ast_TypeRefKind_User,
   ast_TypeRefKind_Function,
};

struct ast_TypeRefHolder_ {
   uint64_t ref;
   ast_Ref user;
   ast_Ref prefix;
   ast_Expr* arrays[3];
};

static const char* ast_TypeRefKind_str(ast_TypeRefKind k);
static const char* ast_Ref_getName(const ast_Ref* r);
static void ast_TypeRefHolder_init(ast_TypeRefHolder* h);
static uint32_t ast_TypeRefHolder_getExtraSize(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_setQualifiers(ast_TypeRefHolder* h, uint32_t qualifiers);
static void ast_TypeRefHolder_setConst(ast_TypeRefHolder* h);
static void ast_TypeRefHolder_setVolatile(ast_TypeRefHolder* h);
static bool ast_TypeRefHolder_isPointer(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_addPointer(ast_TypeRefHolder* h);
static bool ast_TypeRefHolder_isIncrArray(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_setIncrArray(ast_TypeRefHolder* h);
static uint32_t ast_TypeRefHolder_getNumArrays(const ast_TypeRefHolder* h);
static bool ast_TypeRefHolder_isArray(const ast_TypeRefHolder* h);
static void ast_TypeRefHolder_addArray(ast_TypeRefHolder* h, ast_Expr* array);
static void ast_TypeRefHolder_setBuiltin(ast_TypeRefHolder* h, ast_BuiltinKind kind, src_loc_SrcLoc loc);
static void ast_TypeRefHolder_setVoid(ast_TypeRefHolder* h, src_loc_SrcLoc loc);
static void ast_TypeRefHolder_setUser(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx);
static void ast_TypeRefHolder_setFunction(ast_TypeRefHolder* h, ast_Decl* fd);
static void ast_TypeRefHolder_setPrefix(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx);
static void ast_TypeRefHolder_dump(const ast_TypeRefHolder* h);
static void ast_TypeRef_init(ast_TypeRef* dest, const ast_TypeRefHolder* h);
static bool ast_TypeRef_matchesTemplate(const ast_TypeRef* r, uint32_t template_arg);
static void ast_TypeRef_instantiate(ast_TypeRef* r, const ast_TypeRef* r1, ast_Instantiator* inst);
static void ast_TypeRef_setDest(ast_TypeRef* r, uint32_t dest);
static uint32_t ast_TypeRef_getExtraSize(const ast_TypeRef* r);
static void* ast_TypeRef_getPointerAfter(const ast_TypeRef* r);
static bool ast_TypeRef_isConst(const ast_TypeRef* r);
static bool ast_TypeRef_isVolatile(const ast_TypeRef* r);
static bool ast_TypeRef_isUser(const ast_TypeRef* r);
static bool ast_TypeRef_isBuiltin(const ast_TypeRef* r);
static bool ast_TypeRef_isFunction(const ast_TypeRef* r);
static bool ast_TypeRef_isVoid(const ast_TypeRef* r);
static bool ast_TypeRef_isConstCharPtr(const ast_TypeRef* r);
static bool ast_TypeRef_isU32(const ast_TypeRef* r);
static bool ast_TypeRef_hasPrefix(const ast_TypeRef* r);
static bool ast_TypeRef_isIncrArray(const ast_TypeRef* r);
static bool ast_TypeRef_isPointerTo(const ast_TypeRef* r, uint32_t ptr_idx);
static ast_BuiltinKind ast_TypeRef_getBuiltinKind(const ast_TypeRef* r);
static ast_TypeRefKind ast_TypeRef_getKind(const ast_TypeRef* r);
static src_loc_SrcLoc ast_TypeRef_getLoc(const ast_TypeRef* r);
static bool ast_TypeRef_isPointer(const ast_TypeRef* r);
static uint32_t ast_TypeRef_getNumPointers(const ast_TypeRef* r);
static const ast_Ref* ast_TypeRef_getUser(const ast_TypeRef* r);
static const ast_Ref* ast_TypeRef_getStructMemberType(const ast_TypeRef* r);
static const ast_Decl* ast_TypeRef_getUserDecl(const ast_TypeRef* r);
static const ast_Ref* ast_TypeRef_getPrefix(const ast_TypeRef* r);
static void ast_TypeRef_setPrefix(ast_TypeRef* r, ast_Decl* d);
static void ast_TypeRef_setUser(ast_TypeRef* r, ast_Decl* d);
static bool ast_TypeRef_isArray(const ast_TypeRef* r);
static uint32_t ast_TypeRef_getNumArrays(const ast_TypeRef* r);
static ast_Expr* ast_TypeRef_getArray(const ast_TypeRef* r, uint32_t idx);
static ast_Expr** ast_TypeRef_getArray2(ast_TypeRef* r, uint32_t idx);
static void ast_TypeRef_printLiteral(const ast_TypeRef* r, string_buffer_Buf* out, bool print_prefix);
static void ast_TypeRef_print(const ast_TypeRef* r, string_buffer_Buf* out, bool filled);
static void ast_TypeRef_dump(const ast_TypeRef* r);
static void ast_TypeRef_dump_full(const ast_TypeRef* r);
static const char* ast_TypeRef_diagName(const ast_TypeRef* r);
struct ast_VoidType_ {
   ast_Type base;
};

static ast_VoidType* ast_VoidType_create(ast_context_Context* c);
static void ast_VoidType_print(const ast_VoidType* b, string_buffer_Buf* out);
static void ast_VoidType_fullPrint(const ast_VoidType* t, string_buffer_Buf* out, uint32_t indent);
struct ast_ArrayValueList_ {
   uint32_t count;
   uint32_t capacity;
   ast_ArrayValue** values;
};

static void ast_ArrayValueList_init(ast_ArrayValueList* l, uint32_t initial_size);
static void ast_ArrayValueList_free(ast_ArrayValueList* l);
static void ast_ArrayValueList_add(ast_ArrayValueList* l, ast_ArrayValue* v);
static uint32_t ast_ArrayValueList_getCount(const ast_ArrayValueList* l);
static ast_ArrayValue** ast_ArrayValueList_get(ast_ArrayValueList* l);
struct ast_ImportDeclList_ {
   uint32_t count;
   uint32_t capacity;
   ast_ImportDecl** decls;
};

struct ast_DeclList_ {
   uint32_t count;
   uint32_t capacity;
   ast_Decl** decls;
   ast_Decl* stash[4];
};

struct ast_FunctionDeclList_ {
   uint32_t count;
   uint32_t capacity;
   ast_FunctionDecl** decls;
};

struct ast_StaticAssertList_ {
   uint32_t count;
   uint32_t capacity;
   ast_StaticAssert** asserts;
};

struct ast_AST_ {
   ast_Module* mod;
   string_pool_Pool* auxPool;
   void* ptr;
   uint32_t name;
   uint32_t idx;
   bool is_interface;
   bool is_generated;
   ast_ImportDeclList imports;
   ast_DeclList types;
   ast_DeclList variables;
   ast_FunctionDeclList functions;
   ast_StaticAssertList static_asserts;
   ast_ArrayValueList array_values;
   attr_table_Table* attrs;
};

typedef void (*ast_ImportVisitor)(void* arg, ast_ImportDecl* d);

typedef void (*ast_ArrayValueVisitor)(void* arg, ast_ArrayValue* avd);

typedef void (*ast_FunctionVisitor)(void* arg, ast_FunctionDecl* d);

typedef void (*ast_TypeDeclVisitor)(void* arg, ast_Decl* d);

typedef void (*ast_VarDeclVisitor)(void* arg, ast_VarDecl* d);

typedef void (*ast_StaticAssertVisitor)(void* arg, ast_StaticAssert* d);

typedef void (*ast_DeclVisitor)(void* arg, ast_Decl* d);

static ast_AST* ast_AST_create(string_pool_Pool* auxPool, uint32_t name, ast_Module* mod, bool is_interface, bool is_generated);
static void ast_AST_free(ast_AST* a);
static const char* ast_AST_getFilename(const ast_AST* a);
static uint32_t ast_AST_getIdx(const ast_AST* a);
static const char* ast_AST_getName(const ast_AST* a);
static uint32_t ast_AST_getNameIdx(const ast_AST* a);
static src_loc_SrcLoc ast_AST_getLoc(const ast_AST* a);
static void ast_AST_setPtr(ast_AST* a, void* ptr);
static void* ast_AST_getPtr(const ast_AST* a);
static ast_Module* ast_AST_getMod(const ast_AST* a);
static void ast_AST_addImport(ast_AST* a, ast_ImportDecl* d);
static ast_ImportDecl* ast_AST_findImport(const ast_AST* a, uint32_t name);
static bool ast_AST_isGenerated(const ast_AST* a);
static bool ast_AST_isInterface(const ast_AST* a);
static void ast_AST_addFunc(ast_AST* a, ast_FunctionDecl* d);
static void ast_AST_addTypeDecl(ast_AST* a, ast_Decl* d);
static void ast_AST_addVarDecl(ast_AST* a, ast_Decl* d);
static void ast_AST_addStaticAssert(ast_AST* a, ast_StaticAssert* s);
static void ast_AST_addArrayValue(ast_AST* a, ast_ArrayValue* v);
static void ast_AST_visitImports(const ast_AST* a, ast_ImportVisitor visitor, void* arg);
static const ast_ImportDeclList* ast_AST_getImports(const ast_AST* a);
static void ast_AST_visitArrayValues(ast_AST* a, ast_ArrayValueVisitor visitor, void* arg);
static void ast_AST_visitTypeFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg);
static void ast_AST_visitFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg);
static void ast_AST_visitTypeDecls(const ast_AST* a, ast_TypeDeclVisitor visitor, void* arg);
static void ast_AST_visitVarDecls(const ast_AST* a, ast_VarDeclVisitor visitor, void* arg);
static void ast_AST_visitStaticAsserts(ast_AST* a, ast_StaticAssertVisitor visitor, void* arg);
static void ast_AST_visitDecls(const ast_AST* a, ast_DeclVisitor visitor, void* arg);
static void ast_AST_visitDeclsWithoutImports(const ast_AST* a, ast_DeclVisitor visitor, void* arg);
static ast_Decl* ast_AST_findType(const ast_AST* a, uint32_t name_idx);
static void ast_AST_storeAttr(ast_AST* a, ast_Decl* d, const attr_Attr* at);
static const attr_Attr* ast_AST_getAttr(const ast_AST* a, const ast_Decl* d, attr_AttrKind kind);
static void ast_AST_print(const ast_AST* a, string_buffer_Buf* out, bool show_funcs);
static void ast_AST_setExported(ast_AST* a);
static void ast_DeclList_init(ast_DeclList* l);
static void ast_DeclList_free(ast_DeclList* l);
static void ast_DeclList_add(ast_DeclList* l, ast_Decl* d);
static void ast_DeclList_clear(ast_DeclList* l);
static uint32_t ast_DeclList_size(const ast_DeclList* l);
static ast_Decl* ast_DeclList_get(const ast_DeclList* l, uint32_t idx);
static ast_Decl** ast_DeclList_getDecls(const ast_DeclList* l);
struct ast_ExprList_ {
   uint32_t count;
   uint32_t capacity;
   ast_Expr** exprs;
   ast_Expr* stash[4];
};

static void ast_ExprList_init(ast_ExprList* l);
static void ast_ExprList_free(ast_ExprList* l);
static void ast_ExprList_add(ast_ExprList* l, ast_Expr* d);
static uint32_t ast_ExprList_size(const ast_ExprList* l);
static ast_Expr** ast_ExprList_getExprs(const ast_ExprList* l);
static void ast_FunctionDeclList_init(ast_FunctionDeclList* l);
static void ast_FunctionDeclList_free(ast_FunctionDeclList* l);
static void ast_FunctionDeclList_clear(ast_FunctionDeclList* l);
static void ast_FunctionDeclList_add(ast_FunctionDeclList* l, ast_FunctionDecl* d);
static uint32_t ast_FunctionDeclList_size(const ast_FunctionDeclList* l);
static ast_FunctionDecl** ast_FunctionDeclList_getDecls(const ast_FunctionDeclList* l);
static ast_FunctionDecl* ast_FunctionDeclList_find(const ast_FunctionDeclList* l, uint32_t name_idx);
static void ast_ImportDeclList_init(ast_ImportDeclList* l);
static void ast_ImportDeclList_free(ast_ImportDeclList* l);
static void ast_ImportDeclList_add(ast_ImportDeclList* l, ast_ImportDecl* d);
static uint32_t ast_ImportDeclList_size(const ast_ImportDeclList* l);
static ast_ImportDecl** ast_ImportDeclList_getDecls(const ast_ImportDeclList* l);
static ast_ImportDecl* ast_ImportDeclList_find(const ast_ImportDeclList* l, uint32_t name_idx);
static ast_ImportDecl* ast_ImportDeclList_findAny(const ast_ImportDeclList* l, uint32_t name_idx);
struct ast_TemplateInstance_ {
   ast_QualType qt;
   ast_FunctionDecl* instance;
};

struct ast_TemplateFunction_ {
   const ast_FunctionDecl* fd;
   uint16_t count;
   uint16_t capacity;
   ast_TemplateInstance* instances;
};

struct ast_InstanceTable_ {
   uint32_t count;
   uint32_t capacity;
   ast_TemplateFunction* funcs;
};

static void ast_TemplateFunction_init(ast_TemplateFunction* f, const ast_FunctionDecl* fd);
static void ast_TemplateFunction_resize(ast_TemplateFunction* f, uint16_t capacity);
static uint16_t ast_TemplateFunction_add(ast_TemplateFunction* f, ast_QualType qt, ast_FunctionDecl* instance);
static ast_FunctionDecl* ast_TemplateFunction_find(const ast_TemplateFunction* f, ast_QualType qt);
static ast_FunctionDecl* ast_TemplateFunction_get(const ast_TemplateFunction* f, uint32_t idx);
static void ast_InstanceTable_init(ast_InstanceTable* t);
static void ast_InstanceTable_free(ast_InstanceTable* t);
static void ast_InstanceTable_resize(ast_InstanceTable* t, uint32_t capacity);
static ast_TemplateFunction* ast_InstanceTable_findFunc(const ast_InstanceTable* t, const ast_FunctionDecl* fd);
static ast_FunctionDecl* ast_InstanceTable_find(const ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt);
static ast_FunctionDecl* ast_InstanceTable_get(const ast_InstanceTable* t, const ast_FunctionDecl* fd, uint32_t idx);
static uint16_t ast_InstanceTable_add(ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance);
typedef void (*ast_OpaqueErrorfn)(void* arg, src_loc_SrcLoc loc, ast_Decl* decl);

struct ast_Instantiator_ {
   ast_context_Context* c;
   const ast_TypeRef* ref;
   uint32_t template_name;
   uint16_t instance_ast_idx;
   bool used_opaque;
   void* arg;
   ast_OpaqueErrorfn on_error;
};

static void ast_Instantiator_on_opaque(ast_Instantiator* inst, src_loc_SrcLoc loc, ast_Decl* decl);
struct ast_SymbolTable_ {
   uint32_t num_public;
   uint32_t num_private;
   uint32_t capacity;
   uint32_t* symbols;
   ast_Decl** decls;
};

struct ast_Module_ {
   uint32_t name_idx;
   uint32_t is_used : 1;
   uint32_t is_external : 1;
   uint32_t is_foreign : 1;
   uint32_t is_exported : 1;
   uint32_t is_loaded : 1;
   uint32_t is_private : 1;
   ast_ModuleType* mt;
   ast_AST** files;
   uint32_t num_files;
   uint32_t max_files;
   ast_SymbolTable symbols;
   ast_InstanceTable instances;
};

typedef void (*ast_ASTVisitor)(void* arg, ast_AST* d);

static ast_Module* ast_Module_create(ast_context_Context* c, uint32_t name_idx, bool is_external);
static void ast_Module_free(ast_Module* m);
static void ast_Module_setUsed(ast_Module* m);
static bool ast_Module_isUsed(const ast_Module* m);
static bool ast_Module_isExternal(const ast_Module* m);
static void ast_Module_setForeign(ast_Module* m, bool is_foreign);
static bool ast_Module_isForeign(const ast_Module* m);
static void ast_Module_setLoaded(ast_Module* m);
static bool ast_Module_isLoaded(const ast_Module* m);
static void ast_Module_setExported(ast_Module* m);
static bool ast_Module_isExported(const ast_Module* m);
static void ast_Module_setPrivate(ast_Module* m, bool is_private);
static bool ast_Module_isPrivate(const ast_Module* m);
static const ast_SymbolTable* ast_Module_getSymbols(const ast_Module* m);
static ast_ModuleType* ast_Module_getType(const ast_Module* m);
static const char* ast_Module_getFirstFilename(const ast_Module* m);
static void ast_Module_visitASTs(const ast_Module* m, ast_ASTVisitor visitor, void* arg);
static void ast_Module_visitImports(const ast_Module* m, ast_ImportVisitor visitor, void* arg);
static void ast_Module_visitArrayValues(const ast_Module* m, ast_ArrayValueVisitor visitor, void* arg);
static void ast_Module_visitTypeFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg);
static void ast_Module_visitFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg);
static void ast_Module_visitTypeDecls(const ast_Module* m, ast_TypeDeclVisitor visitor, void* arg);
static void ast_Module_visitVarDecls(const ast_Module* m, ast_VarDeclVisitor visitor, void* arg);
static void ast_Module_visitStaticAsserts(const ast_Module* m, ast_StaticAssertVisitor visitor, void* arg);
static void ast_Module_visitDecls(const ast_Module* m, ast_DeclVisitor visitor, void* arg);
static void ast_Module_visitDeclsWithoutImports(const ast_Module* m, ast_DeclVisitor visitor, void* arg);
static ast_Decl* ast_Module_findType(const ast_Module* m, uint32_t name_idx);
static const char* ast_Module_getName(const ast_Module* m);
static uint32_t ast_Module_getNameIdx(const ast_Module* m);
static void ast_Module_resizeFiles(ast_Module* m, uint32_t cap);
static ast_AST* ast_Module_add(ast_Module* m, string_pool_Pool* auxPool, uint32_t filename, bool is_interface, bool is_generated);
static void ast_Module_addSymbol(ast_Module* m, uint32_t name_idx, ast_Decl* d);
static ast_Decl* ast_Module_findSymbol(const ast_Module* m, uint32_t name_idx);
static ast_Decl* ast_Module_findPublicSymbol(const ast_Module* m, uint32_t name_idx);
static ast_Decl* ast_Module_findPrivateSymbol(const ast_Module* m, uint32_t name_idx);
static ast_FunctionDecl* ast_Module_findInstance(const ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt);
static uint16_t ast_Module_addInstance(ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance);
static ast_FunctionDecl* ast_Module_getInstance(const ast_Module* m, ast_FunctionDecl* fd, uint32_t idx);
static void ast_Module_print(const ast_Module* m, string_buffer_Buf* out, bool show_funcs);
struct ast_PointerPoolSlot_ {
   ast_Type* ptrs[4];
};

struct ast_PointerPool_ {
   ast_context_Context* context;
   uint32_t count;
   uint32_t capacity;
   ast_PointerPoolSlot* slots;
};

static void ast_PointerPool_init(ast_PointerPool* p, ast_context_Context* c);
static void ast_PointerPool_clear(ast_PointerPool* p);
static void ast_PointerPool_resize(ast_PointerPool* p, uint32_t cap);
static ast_Type* ast_PointerPool_getPointer(ast_PointerPool* p, ast_QualType qt);
static void ast_StaticAssertList_init(ast_StaticAssertList* l, uint32_t initial_size);
static void ast_StaticAssertList_free(ast_StaticAssertList* l);
static void ast_StaticAssertList_add(ast_StaticAssertList* l, ast_StaticAssert* v);
static uint32_t ast_StaticAssertList_getCount(const ast_StaticAssertList* l);
static ast_StaticAssert* ast_StaticAssertList_getAt(const ast_StaticAssertList* l, uint32_t idx);
static ast_StaticAssert** ast_StaticAssertList_get(ast_StaticAssertList* l);
struct ast_StringTypeSlot_ {
   uint32_t len;
   ast_Type* type_;
};

struct ast_StringTypePool_ {
   uint32_t count;
   uint32_t capacity;
   ast_StringTypeSlot* slots;
   ast_context_Context* context;
};

static void ast_StringTypePool_init(ast_StringTypePool* p, ast_context_Context* c);
static void ast_StringTypePool_clear(ast_StringTypePool* p);
static void ast_StringTypePool_resize(ast_StringTypePool* p, uint32_t cap);
static ast_QualType ast_StringTypePool_get(ast_StringTypePool* p, uint32_t len);
static void ast_SymbolTable_init(ast_SymbolTable* t, uint32_t initial);
static void ast_SymbolTable_free(ast_SymbolTable* t);
static uint32_t ast_SymbolTable_size(const ast_SymbolTable* t);
static ast_Decl** ast_SymbolTable_getDecls(const ast_SymbolTable* t);
static void ast_SymbolTable_resize(ast_SymbolTable* t, uint32_t capacity);
static void ast_SymbolTable_add(ast_SymbolTable* t, uint32_t name_idx, ast_Decl* d);
static ast_Decl* ast_SymbolTable_find(const ast_SymbolTable* t, uint32_t name_idx);
static ast_Decl* ast_SymbolTable_findPublic(const ast_SymbolTable* t, uint32_t name_idx);
static ast_Decl* ast_SymbolTable_findPrivate(const ast_SymbolTable* t, uint32_t name_idx);
static void ast_SymbolTable_print(const ast_SymbolTable* t, string_buffer_Buf* out);
static void ast_SymbolTable_dump(const ast_SymbolTable* t);
struct ast_Globals_ {
   ast_QualType builtins[14];
   ast_QualType void_type;
   ast_QualType void_ptr_type;
   string_pool_Pool* names_pool;
   ast_PointerPool pointers;
   ast_StringTypePool string_types;
   uint32_t wordsize;
   bool use_color;
   uint32_t ast_count;
   uint32_t ast_capacity;
   ast_AST** ast_list;
   uint32_t builtinType_sizes[14];
   uint32_t builtinType_width[14];
   ast_BuiltinKind builtinType_baseTypes[14];
   string_buffer_Buf* dump_buf;
};

typedef bool (*ast_AttrHandlerFn)(void* arg, ast_Decl* d, const attr_Attr* a);

static const ast_QualType ast_QualType_Invalid = { };
static ast_Globals* ast_globals = NULL;
static color_Color ast_col_Stmt = color_Color_Bmagenta;
static color_Color ast_col_Decl = color_Color_Bgreen;
static color_Color ast_col_Expr = color_Color_Bmagenta;
static color_Color ast_col_Attr = color_Color_Blue;
static color_Color ast_col_Template = color_Color_Green;
static color_Color ast_col_Type = color_Color_Green;
static color_Color ast_col_Value = color_Color_Bcyan;
static color_Color ast_col_Error = color_Color_Red;
static color_Color ast_col_Calc = color_Color_Yellow;
static color_Color ast_col_Normal = color_Color_Normal;
static ast_Globals* ast_getGlobals(void);
static void ast_setGlobals(ast_Globals* g);
static void ast_initialize(ast_context_Context* c, string_pool_Pool* astPool, uint32_t wordsize, bool use_color);
static void ast_deinit(bool print_stats);
static uint32_t ast_getWordSize(void);
static bool ast_useColor(void);
static ast_QualType ast_getStringType(uint32_t len);
static const char* ast_idx2name(uint32_t idx);
static ast_QualType ast_getVoidPtr(void);
static ast_Type* ast_getPointerType(ast_QualType inner);
static ast_QualType ast_getVoidQT(void);
static ast_QualType ast_getBuiltinQT(ast_BuiltinKind kind);
static uint32_t ast_addAST(ast_AST* ast_);
static ast_AST* ast_idx2ast(uint32_t idx);
static string_buffer_Buf* ast_getDumpBuf(void);
static void ast_flushDumpBuf(string_buffer_Buf* out);
static void ast_setTypePublicUsed(ast_QualType qt);
static ast_BuiltinKind ast_getNativeKind(void);
struct ast_Evaluator_ {
   ast_Evaluator* prev;
   ast_FunctionDecl* fd;
   uint32_t depth;
   uint32_t complexity;
   uint32_t num_args;
   ast_Value result;
   ast_Value args[16];
};

typedef int32_t (*ast_FunII)(int32_t a);

typedef int64_t (*ast_FunDD)(double a);

union ast_Fun_ {
   void* address;
   ast_FunII funII;
   ast_FunDD funDD;
};

typedef uint8_t ast_Cont;
enum ast_Cont {
   ast_Cont_Normal,
   ast_Cont_Continue,
   ast_Cont_Break,
   ast_Cont_Return,
   ast_Cont_Goto,
   ast_Cont_Abort,
   ast_Cont_Error,
};

#define ast_Max_depth 100
#define ast_Max_complexity 1000000
static ast_Value ast_Evaluator_get_value(ast_Evaluator* eval, const ast_Expr* e);
static ast_Value ast_Evaluator_get_binaryop_value(ast_Evaluator* eval, const ast_BinaryOperator* e);
static ast_Value ast_Evaluator_get_unaryop_value(ast_Evaluator* eval, const ast_UnaryOperator* e);
static ast_Value ast_Evaluator_get_decl_value(ast_Evaluator* eval, const ast_Decl* d);
static ast_Value ast_Evaluator_eval_call(ast_Evaluator* caller, const ast_CallExpr* c);
static ast_FunctionDecl* ast_expr2function(ast_Expr* e);
static ast_Value ast_evalExpr(const ast_Expr* e);
static ast_Cont ast_Evaluator_error(ast_Evaluator* sf, const char* msg);
static ast_Cont ast_Stmt_eval(ast_Stmt* s, ast_Evaluator* sf);
static ast_Cont ast_ReturnStmt_eval(ast_ReturnStmt* r, ast_Evaluator* sf);
static ast_Cont ast_Expr_eval(ast_Expr* e, ast_Evaluator* sf);
static ast_Cont ast_IfStmt_eval(ast_IfStmt* s, ast_Evaluator* sf);
static ast_Cont ast_WhileStmt_eval(ast_WhileStmt* s, ast_Evaluator* sf);
static ast_Cont ast_ForStmt_eval(ast_ForStmt* s, ast_Evaluator* sf);
static ast_Cont ast_SwitchStmt_eval(ast_SwitchStmt* s, ast_Evaluator* sf);
static ast_Cont ast_BreakStmt_eval(ast_BreakStmt* s, ast_Evaluator* sf);
static ast_Cont ast_ContinueStmt_eval(ast_ContinueStmt* s, ast_Evaluator* sf);
static ast_Cont ast_FallthroughStmt_eval(ast_FallthroughStmt* s, ast_Evaluator* sf);
static ast_Cont ast_LabelStmt_eval(ast_LabelStmt* s, ast_Evaluator* sf);
static ast_Cont ast_GotoStmt_eval(ast_GotoStmt* s, ast_Evaluator* sf);
static ast_Cont ast_CompoundStmt_eval(ast_CompoundStmt* body, ast_Evaluator* sf);
static ast_Cont ast_DeclStmt_eval(ast_DeclStmt* s, ast_Evaluator* sf);
static ast_Cont ast_AsmStmt_eval(ast_AsmStmt* s, ast_Evaluator* sf);
static ast_Cont ast_AssertStmt_eval(ast_AssertStmt* s, ast_Evaluator* sf);

static void ast_Decl_init(ast_Decl* d, ast_DeclKind k, uint32_t name_idx, src_loc_SrcLoc loc, bool is_public, ast_QualType qt, uint32_t ast_idx)
{
   d->bits = 0;
   d->declBits.kind = k;
   d->declBits.is_public = is_public;
   d->loc = loc;
   d->name_idx = name_idx;
   d->ast_idx = (uint16_t)ast_idx;
   d->offset = 0;
   d->qt = qt;
}

static bool ast_Decl_hasGenIdx(const ast_Decl* d)
{
   return d->declBits.has_gen_idx;
}

static void ast_Decl_setGenIdx(ast_Decl* d, uint32_t idx)
{
   d->declBits.has_gen_idx = 1;
   d->gen_idx = idx;
}

static uint32_t ast_Decl_getGenIdx(const ast_Decl* d)
{
   if (d->declBits.has_gen_idx) return d->gen_idx;
   return 0;
}

static ast_DeclKind ast_Decl_getKind(const ast_Decl* d)
{
   return (ast_DeclKind)d->declBits.kind;
}

static ast_DeclCheckState ast_Decl_getCheckState(const ast_Decl* d)
{
   return (ast_DeclCheckState)d->declBits.check_state;
}

static bool ast_Decl_isChecked(const ast_Decl* d)
{
   return ast_Decl_getCheckState(d) == ast_DeclCheckState_Checked;
}

static bool ast_Decl_isCheckInProgress(const ast_Decl* d)
{
   return ast_Decl_getCheckState(d) == ast_DeclCheckState_InProgress;
}

static void ast_Decl_setChecked(ast_Decl* d)
{
   d->declBits.check_state = ast_DeclCheckState_Checked;
}

static void ast_Decl_setCheckInProgress(ast_Decl* d)
{
   d->declBits.check_state = ast_DeclCheckState_InProgress;
}

static void ast_Decl_setHasAttr(ast_Decl* d)
{
   d->declBits.has_attr = 1;
}

static bool ast_Decl_hasAttr(const ast_Decl* d)
{
   return d->declBits.has_attr;
}

static void ast_Decl_setAttrExport(ast_Decl* d)
{
   d->declBits.attr_export = 1;
}

static void ast_Decl_setExportedIfPublic(ast_Decl* d)
{
   if (d->declBits.is_public) d->declBits.attr_export = 1;
}

static bool ast_Decl_isExported(const ast_Decl* d)
{
   return d->declBits.attr_export;
}

static bool ast_Decl_isGlobal(const ast_Decl* d)
{
   if (!ast_Decl_isVarDecl(d)) return true;
   const ast_VarDecl* vd = (ast_VarDecl*)d;
   return ast_VarDecl_isGlobal(vd) || ast_VarDecl_isStructMember(vd);
}

static bool ast_Decl_isBitfield(const ast_Decl* d)
{
   if (!ast_Decl_isVarDecl(d)) return false;
   const ast_VarDecl* vd = (ast_VarDecl*)d;
   return ast_VarDecl_isBitField(vd);
}

static void ast_Decl_setAttrUnused(ast_Decl* d)
{
   d->declBits.attr_unused = 1;
}

static bool ast_Decl_hasAttrUnused(const ast_Decl* d)
{
   return d->declBits.attr_unused;
}

static bool ast_Decl_isStructType(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_StructType;
}

static bool ast_Decl_isImport(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_Import;
}

static bool ast_Decl_isEnum(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_EnumType;
}

static bool ast_Decl_isEnumConstant(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_EnumConstant;
}

static bool ast_Decl_isFunction(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_Function;
}

static bool ast_Decl_isVariable(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_Variable;
}

static const char* ast_Decl_getName(const ast_Decl* d)
{
   return ast_idx2name(d->name_idx);
}

static uint32_t ast_Decl_getNameIdx(const ast_Decl* d)
{
   return d->name_idx;
}

static const char* ast_Decl_getModuleName(const ast_Decl* d)
{
   const ast_AST* a = ast_Decl_getAST(d);
   if (!a) return NULL;
   const ast_Module* mod = ast_AST_getMod(a);
   return ast_Module_getName(mod);
}

static src_loc_SrcLoc ast_Decl_getLoc(const ast_Decl* d)
{
   return d->loc;
}

static ast_QualType ast_Decl_getType(const ast_Decl* d)
{
   return d->qt;
}

static void ast_Decl_setType(ast_Decl* d, ast_QualType qt)
{
   d->qt = qt;
}

static ast_AST* ast_Decl_getAST(const ast_Decl* d)
{
   return ast_idx2ast(d->ast_idx);
}

static uint32_t ast_Decl_getASTIdx(const ast_Decl* d)
{
   return d->ast_idx;
}

static ast_Module* ast_Decl_getModule(const ast_Decl* d)
{
   const ast_AST* a = ast_Decl_getAST(d);
   if (!a) return NULL;
   return ast_AST_getMod(a);
}

static bool ast_Decl_isPublic(const ast_Decl* d)
{
   return d->declBits.is_public;
}

static bool ast_Decl_isUsed(const ast_Decl* d)
{
   return d->declBits.is_used;
}

static bool ast_Decl_isUsedPublic(const ast_Decl* d)
{
   return d->declBits.is_used_public;
}

static void ast_Decl_setUsed(ast_Decl* d)
{
   d->declBits.is_used = true;
}

static void ast_Decl_clearUsed(ast_Decl* d)
{
   d->declBits.is_used = false;
}

static void ast_Decl_setUsedPublic(ast_Decl* d)
{
   d->declBits.is_used_public = true;
}

static bool ast_Decl_isExternal(const ast_Decl* d)
{
   return d->declBits.is_external;
}

static void ast_Decl_setExternal(ast_Decl* d)
{
   d->declBits.is_external = 1;
}

static bool ast_Decl_isGenerated(const ast_Decl* d)
{
   return d->declBits.is_generated;
}

static void ast_Decl_setGenerated(ast_Decl* d)
{
   d->declBits.is_generated = 1;
}

static void ast_Decl_clearGenerated(ast_Decl* d)
{
   d->declBits.is_generated = 0;
}

static void ast_Decl_dump(const ast_Decl* d)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_Decl_print(d, out, 0);
   ast_flushDumpBuf(out);
}

static bool ast_Decl_isTypeDecl(const ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      return true;
   case ast_DeclKind_EnumType:
      return true;
   case ast_DeclKind_EnumConstant:
      break;
   case ast_DeclKind_FunctionType:
      return true;
   case ast_DeclKind_AliasType:
      return true;
   case ast_DeclKind_Variable:
      break;
   }
   return false;
}

static bool ast_Decl_isVarDecl(const ast_Decl* d)
{
   return ast_Decl_getKind(d) == ast_DeclKind_Variable;
}

static const char* ast_Decl_getKindName(const ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      return "function";
   case ast_DeclKind_Import:
      return "import";
   case ast_DeclKind_StructType:
      return "type";
   case ast_DeclKind_EnumType:
      return "type";
   case ast_DeclKind_EnumConstant:
      return "enum constant";
   case ast_DeclKind_FunctionType:
      return "type";
   case ast_DeclKind_AliasType:
      return "type";
   case ast_DeclKind_Variable:
      return "variable";
   }
   return "";
}

static const char* ast_Decl_getCName(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return NULL;
   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Attr* cname = ast_AST_getAttr(a, d, attr_AttrKind_CName);
   if (cname) return ast_idx2name(cname->value.text);
   return NULL;
}

static bool ast_Decl_hasCName(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return false;
   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Attr* cname = ast_AST_getAttr(a, d, attr_AttrKind_CName);
   return cname;
}

static const char* ast_Decl_getCDef(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return NULL;
   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Attr* cdef = ast_AST_getAttr(a, d, attr_AttrKind_CDef);
   if (cdef) return ast_idx2name(cdef->value.text);
   return NULL;
}

static const char* ast_Decl_getSection(const ast_Decl* d)
{
   if (!ast_Decl_hasAttr(d)) return NULL;
   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Attr* section = ast_AST_getAttr(a, d, attr_AttrKind_Section);
   if (section) return ast_idx2name(section->value.text);
   return NULL;
}

static const char* ast_Decl_getFullName(const ast_Decl* d)
{
   static char tmp_buf[4][128];
   static uint32_t tmp_id = 0;
   uint32_t tmp_size = 128;
   char* tmp = tmp_buf[tmp_id++ & 3];
   const char* modname = ast_Decl_getModuleName(d);
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function: {
      const ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
      if (ast_FunctionDecl_hasPrefix(fd)) {
         snprintf(tmp, tmp_size, "%s.%s.%s", modname, ast_FunctionDecl_getPrefixName(fd), ast_Decl_getName(d));
      } else {
         snprintf(tmp, tmp_size, "%s.%s", modname, ast_Decl_getName(d));
      }
      break;
   }
   case ast_DeclKind_Import:
      snprintf(tmp, tmp_size, "%s", ast_Decl_getName(d));
      break;
   case ast_DeclKind_EnumConstant: {
      ast_QualType qt = ast_Decl_getType(d);
      ast_EnumType* et = ast_QualType_getEnumType(qt);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_Decl* ed = (ast_Decl*)etd;
      snprintf(tmp, tmp_size, "%s.%s.%s", modname, ast_Decl_getName(ed), ast_Decl_getName(d));
      break;
   }
   default:
      snprintf(tmp, tmp_size, "%s.%s", modname, ast_Decl_getName(d));
      break;
   }
   return tmp;
}

static void ast_Decl_print(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      ast_FunctionDecl_print((ast_FunctionDecl*)d, out, indent);
      break;
   case ast_DeclKind_Import:
      ast_ImportDecl_print((ast_ImportDecl*)d, out, indent);
      break;
   case ast_DeclKind_StructType:
      ast_StructTypeDecl_print((ast_StructTypeDecl*)d, out, indent);
      break;
   case ast_DeclKind_EnumType:
      ast_EnumTypeDecl_print((ast_EnumTypeDecl*)d, out, indent);
      break;
   case ast_DeclKind_EnumConstant:
      ast_EnumConstantDecl_print((ast_EnumConstantDecl*)d, out, indent);
      break;
   case ast_DeclKind_FunctionType:
      ast_FunctionTypeDecl_print((ast_FunctionTypeDecl*)d, out, indent);
      break;
   case ast_DeclKind_AliasType:
      ast_AliasTypeDecl_print((ast_AliasTypeDecl*)d, out, indent);
      break;
   case ast_DeclKind_Variable:
      ast_VarDecl_print((ast_VarDecl*)d, out, indent);
      break;
   }
}

static void ast_Decl_printKind(const ast_Decl* d, string_buffer_Buf* out, uint32_t indent, bool print_type)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, ast_declKind_names[ast_Decl_getKind(d)]);
   if (print_type) {
      string_buffer_Buf_space(out);
      ast_QualType_printQuoted(d->qt, out);
   }
}

static void ast_Decl_printName(const ast_Decl* d, string_buffer_Buf* out)
{
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   if (d->name_idx) {
      string_buffer_Buf_add(out, ast_Decl_getName(d));
   } else {
      string_buffer_Buf_add(out, "(nil)");
   }
}

static void ast_Decl_printBits(const ast_Decl* d, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Attr);
   if (ast_Decl_isPublic(d)) string_buffer_Buf_add(out, " public");
   ast_DeclCheckState cs = ast_Decl_getCheckState(d);
   if (cs != ast_DeclCheckState_Checked) {
      string_buffer_Buf_space(out);
      string_buffer_Buf_add(out, ast_declCheckState_names[cs]);
   }
   if (d->declBits.attr_unused) {
      string_buffer_Buf_add(out, " unused");
   }
   if (d->declBits.has_attr) string_buffer_Buf_add(out, " attr");
   if (d->declBits.attr_export) string_buffer_Buf_add(out, " export");
   if (!ast_Decl_isUsed(d)) {
      string_buffer_Buf_color(out, ast_col_Expr);
      string_buffer_Buf_add(out, " unused");
   }
}

static void ast_Decl_printAttrs(const ast_Decl* d, string_buffer_Buf* out)
{
   if (!ast_Decl_hasAttr(d)) return;
   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Attr* cname = ast_AST_getAttr(a, d, attr_AttrKind_CName);
   if (cname) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_print(out, " cname='%s'", ast_idx2name(cname->value.text));
   }
   const attr_Attr* cdef = ast_AST_getAttr(a, d, attr_AttrKind_CDef);
   if (cdef) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_print(out, " cdef='%s'", ast_idx2name(cdef->value.text));
   }
   const attr_Attr* section = ast_AST_getAttr(a, d, attr_AttrKind_Section);
   if (section) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_print(out, " section='%s'", ast_idx2name(section->value.text));
   }
   const attr_Attr* embed = ast_AST_getAttr(a, d, attr_AttrKind_Embed);
   if (embed) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_print(out, " embed='%s'", ast_idx2name(embed->value.text));
   }
}

static void ast_Decl_printUsed(const ast_Decl* d, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_print(out, " used=%d/%d", ast_Decl_isUsed(d), ast_Decl_isUsedPublic(d));
}

static ast_AliasTypeDecl* ast_AliasTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* ref)
{
   uint32_t size = 32 + ast_TypeRefHolder_getExtraSize(ref);
   ast_AliasTypeDecl* d = ast_context_Context_alloc(c, size);
   ast_AliasType* at = ast_AliasType_create(c, d);
   ast_Decl_init(&d->base, ast_DeclKind_AliasType, name, loc, is_public, ast_QualType_create((ast_Type*)at), ast_idx);
   ast_TypeRef_init(&d->typeRef, ref);
   return d;
}

static ast_Decl* ast_AliasTypeDecl_asDecl(ast_AliasTypeDecl* d)
{
   return &d->base;
}

static ast_TypeRef* ast_AliasTypeDecl_getTypeRef(ast_AliasTypeDecl* d)
{
   return &d->typeRef;
}

static void ast_AliasTypeDecl_print(const ast_AliasTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   ast_Decl_printAttrs(&d->base, out);
   ast_Decl_printName(&d->base, out);
   if (ast_QualType_isInvalid(d->base.qt)) {
      string_buffer_Buf_space(out);
      ast_TypeRef_print(&d->typeRef, out, true);
      string_buffer_Buf_newline(out);
   }
}

static ast_ArrayValue* ast_ArrayValue_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value)
{
   ast_ArrayValue* d = ast_context_Context_alloc(c, 16);
   d->name_idx = name;
   d->loc = loc;
   d->value = value;
   return d;
}

static uint32_t ast_ArrayValue_getNameIdx(const ast_ArrayValue* d)
{
   return d->name_idx;
}

static src_loc_SrcLoc ast_ArrayValue_getLoc(const ast_ArrayValue* d)
{
   return d->loc;
}

static ast_Expr* ast_ArrayValue_getValue(const ast_ArrayValue* d)
{
   return d->value;
}

static void ast_ArrayValue_print(const ast_ArrayValue* d, string_buffer_Buf* out)
{
}

static ast_DeclStmt* ast_DeclStmt_create(ast_context_Context* c, ast_VarDecl** decl, uint32_t count)
{
   uint32_t size = 8 + 8 * count;
   ast_DeclStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Decl, ast_Decl_getLoc(ast_VarDecl_asDecl(decl[0])));
   s->base.declStmtBits.count = count;
   memcpy(s->decl, decl, 8 * count);
   return s;
}

static ast_Stmt* ast_DeclStmt_instantiate(ast_DeclStmt* s, ast_Instantiator* inst)
{
   uint32_t count = s->base.declStmtBits.count;
   ast_DeclStmt* s2 = ast_DeclStmt_create(inst->c, s->decl, count);
   for (uint32_t i = 0; i < count; i++) s2->decl[i] = ast_VarDecl_instantiate(s->decl[i], inst);
   return (ast_Stmt*)s2;
}

static ast_VarDecl* ast_DeclStmt_getDecl(const ast_DeclStmt* d, uint32_t i)
{
   return d->decl[i];
}

static uint32_t ast_DeclStmt_getDeclCount(const ast_DeclStmt* d)
{
   return d->base.declStmtBits.count;
}

static void ast_DeclStmt_print(const ast_DeclStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   uint32_t count = s->base.declStmtBits.count;
   for (uint32_t i = 0; i < count; i++) ast_VarDecl_print(s->decl[i], out, indent + 1);
}

static ast_EnumConstantDecl* ast_EnumConstantDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, ast_Expr* initValue)
{
   uint32_t size = 40;
   if (initValue) size += 8;
   ast_EnumConstantDecl* d = ast_context_Context_alloc(c, size);
   ast_Decl_init(&d->base, ast_DeclKind_EnumConstant, name, loc, is_public, ast_QualType_Invalid, ast_idx);
   ast_Value_setUnsigned(&d->value, 0);
   if (initValue) {
      d->base.enumConstantDeclBits.has_init = 1;
      d->init[0] = initValue;
   }
   return d;
}

static ast_Decl* ast_EnumConstantDecl_asDecl(ast_EnumConstantDecl* d)
{
   return &d->base;
}

static ast_Value ast_EnumConstantDecl_getValue(const ast_EnumConstantDecl* d)
{
   return d->value;
}

static void ast_EnumConstantDecl_setValue(ast_EnumConstantDecl* d, ast_Value value)
{
   d->value = value;
}

static void ast_EnumConstantDecl_setIndex(ast_EnumConstantDecl* d, uint32_t index)
{
   d->base.enumConstantDeclBits.enum_index = index;
}

static uint32_t ast_EnumConstantDecl_getIndex(const ast_EnumConstantDecl* d)
{
   return d->base.enumConstantDeclBits.enum_index;
}

static ast_Expr* ast_EnumConstantDecl_getInit(const ast_EnumConstantDecl* d)
{
   if (d->base.enumConstantDeclBits.has_init) return d->init[0];
   return NULL;
}

static ast_Expr** ast_EnumConstantDecl_getInit2(ast_EnumConstantDecl* d)
{
   if (d->base.enumConstantDeclBits.has_init) return &d->init[0];
   return NULL;
}

static void ast_EnumConstantDecl_print(const ast_EnumConstantDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   ast_Decl_printName(&d->base, out);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, " [%u] %s", ast_EnumConstantDecl_getIndex(d), ast_Value_str(&d->value));
   string_buffer_Buf_newline(out);
   if (d->base.enumConstantDeclBits.has_init) ast_Expr_print(d->init[0], out, indent + 1);
}

static ast_EnumTypeDecl* ast_EnumTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, ast_QualType implType, bool is_incremental, ast_EnumConstantDecl** constants, uint32_t num_constants)
{
   uint32_t size = 48 + num_constants * 8;
   if (is_incremental) size += 8;
   ast_EnumTypeDecl* d = ast_context_Context_alloc(c, size);
   ast_EnumType* etype = ast_EnumType_create(c, d);
   ast_QualType qt = ast_QualType_create((ast_Type*)etype);
   ast_Decl_init(&d->base, ast_DeclKind_EnumType, name, loc, is_public, qt, ast_idx);
   d->base.enumTypeDeclBits.is_incremental = is_incremental;
   d->base.enumTypeDeclBits.num_constants = num_constants;
   d->implType = implType;
   d->num_enum_functions = 0;
   d->enum_functions = NULL;
   if (is_incremental) {
      ;//assert(num_constants == 0);
      d->incr_constants[0] = NULL;
   } else {
      memcpy(d->constants, constants, num_constants * 8);
      for (uint32_t i = 0; i < num_constants; i++) {
         ast_Decl_setType(ast_EnumConstantDecl_asDecl(constants[i]), qt);
      }
   }
   return d;
}

static void ast_EnumTypeDecl_setRegular(ast_EnumTypeDecl* d)
{
   d->base.enumTypeDeclBits.is_regular = true;
}

static bool ast_EnumTypeDecl_isRegular(const ast_EnumTypeDecl* d)
{
   return d->base.enumTypeDeclBits.is_regular;
}

static ast_QualType ast_EnumTypeDecl_getImplType(const ast_EnumTypeDecl* d)
{
   return d->implType;
}

static ast_Decl* ast_EnumTypeDecl_asDecl(ast_EnumTypeDecl* d)
{
   return &d->base;
}

static bool ast_EnumTypeDecl_isIncremental(const ast_EnumTypeDecl* d)
{
   return d->base.enumTypeDeclBits.is_incremental;
}

static uint32_t ast_EnumTypeDecl_getNumConstants(const ast_EnumTypeDecl* d)
{
   return d->base.enumTypeDeclBits.num_constants;
}

static ast_EnumConstantDecl** ast_EnumTypeDecl_getConstants(ast_EnumTypeDecl* d)
{
   if (ast_EnumTypeDecl_isIncremental(d)) {
      return d->incr_constants[0];
   }
   return d->constants;
}

static void ast_EnumTypeDecl_setIncrConstants(ast_EnumTypeDecl* d, ast_context_Context* c, ast_IdentifierExpr** constants, uint32_t count)
{
   ;//assert(count);
   const uint32_t size = count * 8;
   ast_EnumConstantDecl** decls = ast_context_Context_alloc(c, size);
   ast_QualType qt = ast_Decl_getType(&d->base);
   for (uint32_t i = 0; i < count; i++) {
      ast_IdentifierExpr* id = constants[i];
      decls[i] = ast_EnumConstantDecl_create(c, ast_IdentifierExpr_getNameIdx(id), ast_Expr_getLoc(ast_IdentifierExpr_asExpr(id)), ast_Decl_isPublic(&d->base), d->base.ast_idx, NULL);
      ast_Decl_setType(ast_EnumConstantDecl_asDecl(decls[i]), qt);
   }
   d->incr_constants[0] = decls;
   d->base.enumTypeDeclBits.num_constants = count;
}

static ast_EnumConstantDecl* ast_EnumTypeDecl_findConstant(ast_EnumTypeDecl* d, uint32_t name_idx)
{
   ast_EnumConstantDecl** constants = d->constants;
   if (ast_EnumTypeDecl_isIncremental(d)) constants = d->incr_constants[0];
   for (uint32_t i = 0; i < ast_EnumTypeDecl_getNumConstants(d); i++) {
      ast_EnumConstantDecl* ecd = constants[i];
      ast_Decl* ed = (ast_Decl*)ecd;
      if (ast_Decl_getNameIdx(ed) == name_idx) return ecd;
   }
   return NULL;
}

static ast_EnumConstantDecl* ast_EnumTypeDecl_getConstant(const ast_EnumTypeDecl* d, uint32_t idx)
{
   if (ast_EnumTypeDecl_isIncremental(d)) return d->incr_constants[0][idx];
   return d->constants[idx];
}

static void ast_EnumTypeDecl_setEnumFunctions(ast_EnumTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count)
{
   const uint32_t size = count * 8;
   ast_FunctionDecl** dest = ast_context_Context_alloc(c, size);
   memcpy(dest, funcs, size);
   d->enum_functions = dest;
   d->num_enum_functions = count;
}

static ast_Decl* ast_EnumTypeDecl_findFunction(const ast_EnumTypeDecl* d, uint32_t name_idx)
{
   for (uint32_t i = 0; i < d->num_enum_functions; i++) {
      ast_Decl* ef = (ast_Decl*)d->enum_functions[i];
      if (ast_Decl_getNameIdx(ef) == name_idx) return ef;
   }
   return NULL;
}

static void ast_EnumTypeDecl_print(ast_EnumTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   string_buffer_Buf_color(out, ast_col_Attr);
   if (ast_EnumTypeDecl_isIncremental(d)) string_buffer_Buf_add(out, " incremental");
   if (ast_EnumTypeDecl_isRegular(d)) string_buffer_Buf_add(out, " regular");
   ast_Decl_printAttrs(&d->base, out);
   ast_Decl_printName(&d->base, out);
   string_buffer_Buf_space(out);
   ast_QualType_print(d->implType, out);
   string_buffer_Buf_newline(out);
   ast_EnumConstantDecl** constants = d->constants;
   if (ast_EnumTypeDecl_isIncremental(d)) constants = d->incr_constants[0];
   for (uint32_t i = 0; i < d->base.enumTypeDeclBits.num_constants; i++) {
      ast_EnumConstantDecl_print(constants[i], out, indent + 1);
   }
}

static ast_FunctionDecl* ast_FunctionDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, bool is_variadic, ast_DefKind def_kind)
{
   uint32_t size = 80 + num_params * 8 + ast_TypeRefHolder_getExtraSize(rtype);
   ast_FunctionDecl* d = ast_context_Context_alloc(c, size);
   ast_FunctionType* ftype = ast_FunctionType_create(c, d);
   ast_QualType qt = ast_QualType_create(ast_FunctionType_asType(ftype));
   ast_Decl_init(&d->base, ast_DeclKind_Function, name, loc, is_public, qt, ast_idx);
   d->base.functionDeclBits.is_variadic = is_variadic;
   d->base.functionDeclBits.call_kind = prefix ? ast_CallKind_StaticTypeFunc : ast_CallKind_Normal;
   d->base.functionDeclBits.def_kind = def_kind;
   d->body = NULL;
   d->rt = ast_QualType_Invalid;
   d->num_params = (uint8_t)num_params;
   d->attr_format_arg = 0;
   d->instance_idx = 0;
   d->template_name = 0;
   d->template_loc = 0;
   d->flagBits = 0;
   d->prefix = (ast_Ref){ };
   ast_TypeRef_init(&d->rtype, rtype);
   if (prefix) {
      d->base.functionDeclBits.has_prefix = 1;
      d->prefix = *prefix;
   }
   if (num_params) {
      ast_VarDecl** tail = ast_TypeRef_getPointerAfter(&d->rtype);
      memcpy(tail, params, num_params * 8);
   }
   return d;
}

static ast_FunctionDecl* ast_FunctionDecl_createTemplate(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, bool is_variadic)
{
   uint32_t size = 80 + num_params * 8 + ast_TypeRefHolder_getExtraSize(rtype);
   ast_FunctionDecl* d = ast_context_Context_alloc(c, size);
   ast_FunctionType* ftype = ast_FunctionType_create(c, d);
   ast_QualType qt = ast_QualType_create(ast_FunctionType_asType(ftype));
   ast_Decl_init(&d->base, ast_DeclKind_Function, name, loc, is_public, qt, ast_idx);
   d->base.functionDeclBits.is_variadic = is_variadic;
   d->base.functionDeclBits.call_kind = ast_CallKind_Normal;
   d->base.functionDeclBits.def_kind = ast_DefKind_Template;
   d->body = NULL;
   d->rt = ast_QualType_Invalid;
   d->num_params = (uint8_t)num_params;
   d->attr_format_arg = 0;
   d->instance_idx = 0;
   d->template_name = template_name;
   d->template_loc = template_loc;
   d->flagBits = 0;
   d->prefix = (ast_Ref){ };
   ast_TypeRef_init(&d->rtype, rtype);
   if (num_params) {
      ast_VarDecl** tail = ast_TypeRef_getPointerAfter(&d->rtype);
      memcpy(tail, params, num_params * 8);
   }
   return d;
}

static ast_FunctionDecl* ast_FunctionDecl_instantiate(const ast_FunctionDecl* fd, ast_Instantiator* inst)
{
   bool rtype_matches = ast_TypeRef_matchesTemplate(&fd->rtype, fd->template_name);
   uint32_t extra = rtype_matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&fd->rtype);
   uint32_t num_params = fd->num_params;
   uint32_t size = 80 + num_params * 8 + extra;
   ast_FunctionDecl* fd2 = ast_context_Context_alloc(inst->c, size);
   fd2->base = fd->base;
   fd2->base.functionDeclBits.def_kind = ast_DefKind_Global;
   ast_FunctionType* ftype = ast_FunctionType_create(inst->c, fd2);
   fd2->base.qt = ast_QualType_create(ast_FunctionType_asType(ftype));
   fd2->body = fd->body;
   if (fd->base.functionDeclBits.has_body) fd2->body = ast_CompoundStmt_instantiate(fd->body, inst);
   fd2->rt = ast_QualType_Invalid;
   fd2->num_params = fd->num_params;
   fd2->attr_format_arg = fd->attr_format_arg;
   fd2->instance_idx = 0;
   fd2->template_name = 0;
   fd2->template_loc = fd->template_loc;
   fd2->flagBits = fd->flagBits;
   fd2->flags.instance_ast_idx = (uint16_t)inst->instance_ast_idx;
   fd2->prefix = fd->prefix;
   ast_TypeRef_instantiate(&fd2->rtype, &fd->rtype, inst);
   ast_VarDecl** src = ast_TypeRef_getPointerAfter(&fd->rtype);
   ast_VarDecl** dst = ast_TypeRef_getPointerAfter(&fd2->rtype);
   for (uint32_t i = 0; i < num_params; i++) {
      dst[i] = ast_VarDecl_instantiate(src[i], inst);
   }
   return fd2;
}

static void ast_FunctionDecl_setBody(ast_FunctionDecl* d, ast_CompoundStmt* body)
{
   d->base.functionDeclBits.has_body = 1;
   d->body = body;
}

static bool ast_FunctionDecl_hasBody(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.has_body;
}

static ast_CompoundStmt* ast_FunctionDecl_getBody(const ast_FunctionDecl* d)
{
   if (d->base.functionDeclBits.has_body) return d->body;
   return NULL;
}

static void ast_FunctionDecl_setAddress(ast_FunctionDecl* d, void* address)
{
   d->base.functionDeclBits.has_body = 0;
   d->address = address;
}

static ast_CompoundStmt* ast_FunctionDecl_getAddress(const ast_FunctionDecl* d)
{
   if (d->base.functionDeclBits.has_body) return NULL;
   return d->address;
}

static bool ast_FunctionDecl_isInline(const ast_FunctionDecl* d)
{
   if (!ast_FunctionDecl_getBody(d)) return false;
   if (!ast_FunctionDecl_hasAttrInline(d)) return false;
   if (!ast_Decl_isPublic(&d->base)) return false;
   return true;
}

static bool ast_FunctionDecl_canBeNil(const ast_FunctionDecl* d)
{
   switch (ast_FunctionDecl_getDefKind(d)) {
   case ast_DefKind_Global:
      break;
   case ast_DefKind_Type:
   case ast_DefKind_StructMember:
   case ast_DefKind_Param:
      return true;
   case ast_DefKind_Template:
      break;
   }
   return ast_FunctionDecl_hasAttrWeak(d);
}

static void ast_FunctionDecl_setRType(ast_FunctionDecl* d, ast_QualType rt)
{
   if (!ast_QualType_isVoid(rt)) d->base.functionDeclBits.has_return = 1;
   d->rt = rt;
}

static ast_QualType ast_FunctionDecl_getRType(const ast_FunctionDecl* d)
{
   return d->rt;
}

static bool ast_FunctionDecl_hasReturn(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.has_return;
}

static ast_Decl* ast_FunctionDecl_asDecl(ast_FunctionDecl* d)
{
   return &d->base;
}

static ast_TypeRef* ast_FunctionDecl_getReturnTypeRef(ast_FunctionDecl* d)
{
   return &d->rtype;
}

static bool ast_FunctionDecl_hasPrefix(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.has_prefix;
}

static bool ast_FunctionDecl_isType(const ast_FunctionDecl* d)
{
   return ast_FunctionDecl_getDefKind(d) == ast_DefKind_Type;
}

static bool ast_FunctionDecl_isTemplate(const ast_FunctionDecl* d)
{
   return ast_FunctionDecl_getDefKind(d) == ast_DefKind_Template;
}

static bool ast_FunctionDecl_isMemberType(const ast_FunctionDecl* d)
{
   return ast_FunctionDecl_getDefKind(d) == ast_DefKind_StructMember;
}

static bool ast_FunctionDecl_isParam(const ast_FunctionDecl* d)
{
   return ast_FunctionDecl_getDefKind(d) == ast_DefKind_Param;
}

static ast_DefKind ast_FunctionDecl_getDefKind(const ast_FunctionDecl* d)
{
   return (ast_DefKind)d->base.functionDeclBits.def_kind;
}

static uint32_t ast_FunctionDecl_getTemplateNameIdx(const ast_FunctionDecl* d)
{
   return d->template_name;
}

static src_loc_SrcLoc ast_FunctionDecl_getTemplateLoc(const ast_FunctionDecl* d)
{
   return d->template_loc;
}

static void ast_FunctionDecl_setTemplateInstanceIdx(ast_FunctionDecl* d, uint16_t idx)
{
   d->instance_idx = idx;
}

static uint16_t ast_FunctionDecl_getTemplateInstanceIdx(const ast_FunctionDecl* d)
{
   return d->instance_idx;
}

static void ast_FunctionDecl_setInstanceName(ast_FunctionDecl* d, uint32_t name_idx)
{
   d->base.name_idx = name_idx;
}

static ast_Module* ast_FunctionDecl_getInstanceModule(ast_FunctionDecl* d)
{
   if (d->flags.instance_ast_idx) return ast_AST_getMod(ast_idx2ast(d->flags.instance_ast_idx));
   return NULL;
}

static ast_Ref* ast_FunctionDecl_getPrefix(ast_FunctionDecl* d)
{
   if (ast_FunctionDecl_hasPrefix(d)) return &d->prefix;
   return NULL;
}

static const char* ast_FunctionDecl_getCName(const ast_FunctionDecl* d)
{
   const char* cname = ast_Decl_getCName(&d->base);
   if (!cname) cname = ast_Decl_getName(&d->base);
   return cname;
}

static const char* ast_FunctionDecl_getPrefixName(const ast_FunctionDecl* d)
{
   if (!ast_FunctionDecl_hasPrefix(d)) return NULL;
   return ast_Ref_getName(&d->prefix);
}

static void ast_FunctionDecl_setCallKind(ast_FunctionDecl* d, ast_CallKind kind)
{
   d->base.functionDeclBits.call_kind = kind;
}

static bool ast_FunctionDecl_isTypeFunc(const ast_FunctionDecl* d)
{
   ast_CallKind ck = ast_FunctionDecl_getCallKind(d);
   return ck >= ast_CallKind_TypeFunc;
}

static ast_CallKind ast_FunctionDecl_getCallKind(const ast_FunctionDecl* d)
{
   return (ast_CallKind)d->base.functionDeclBits.call_kind;
}

static bool ast_FunctionDecl_isVariadic(const ast_FunctionDecl* d)
{
   return d->base.functionDeclBits.is_variadic;
}

static uint32_t ast_FunctionDecl_getNumParams(const ast_FunctionDecl* d)
{
   return d->num_params;
}

static ast_VarDecl** ast_FunctionDecl_getParams(const ast_FunctionDecl* d)
{
   return ast_TypeRef_getPointerAfter(&d->rtype);
}

static uint32_t ast_FunctionDecl_getNumAutoArgs(const ast_FunctionDecl* d)
{
   return d->flags.num_auto_args;
}

static void ast_FunctionDecl_setNumAutoArgs(ast_FunctionDecl* d, uint32_t num)
{
   ;//assert(num < 16);
   d->flags.num_auto_args = num;
}

static void ast_FunctionDecl_setAttrUnusedParams(ast_FunctionDecl* d)
{
   d->flags.attr_unused_params = 1;
}

static bool ast_FunctionDecl_hasAttrUnusedParams(const ast_FunctionDecl* d)
{
   return d->flags.attr_unused_params;
}

static void ast_FunctionDecl_setAttrNoReturn(ast_FunctionDecl* d)
{
   d->flags.attr_noreturn = 1;
}

static bool ast_FunctionDecl_hasAttrNoReturn(const ast_FunctionDecl* d)
{
   return d->flags.attr_noreturn;
}

static void ast_FunctionDecl_setAttrInline(ast_FunctionDecl* d)
{
   d->flags.attr_inline = 1;
}

static bool ast_FunctionDecl_hasAttrInline(const ast_FunctionDecl* d)
{
   return d->flags.attr_inline;
}

static void ast_FunctionDecl_setAttrWeak(ast_FunctionDecl* d)
{
   d->flags.attr_weak = 1;
}

static bool ast_FunctionDecl_hasAttrWeak(const ast_FunctionDecl* d)
{
   return d->flags.attr_weak;
}

static void ast_FunctionDecl_setAttrConstructor(ast_FunctionDecl* d)
{
   d->flags.attr_constructor = 1;
}

static bool ast_FunctionDecl_hasAttrConstructor(const ast_FunctionDecl* d)
{
   return d->flags.attr_constructor;
}

static void ast_FunctionDecl_setAttrDestructor(ast_FunctionDecl* d)
{
   d->flags.attr_destructor = 1;
}

static bool ast_FunctionDecl_hasAttrDestructor(const ast_FunctionDecl* d)
{
   return d->flags.attr_destructor;
}

static void ast_FunctionDecl_setAttrPure(ast_FunctionDecl* d)
{
   d->flags.attr_pure = 1;
}

static bool ast_FunctionDecl_hasAttrPure(const ast_FunctionDecl* d)
{
   return d->flags.attr_pure;
}

static void ast_FunctionDecl_setFormatAttr(ast_FunctionDecl* d, ast_FormatAttr format_attr, uint8_t format_arg)
{
   d->flags.format_attr = format_attr;
   d->attr_format_arg = format_arg;
}

static ast_FormatAttr ast_FunctionDecl_getFormatAttr(const ast_FunctionDecl* d, uint8_t* format_arg_ptr)
{
   *format_arg_ptr = d->attr_format_arg;
   return (ast_FormatAttr)d->flags.format_attr;
}

static void ast_FunctionDecl_setAttrDeprecated(ast_FunctionDecl* d)
{
   d->flags.attr_deprecated = 1;
}

static bool ast_FunctionDecl_hasAttrDeprecated(const ast_FunctionDecl* d)
{
   return d->flags.attr_deprecated;
}

static const char* ast_FunctionDecl_getDiagKind(const ast_FunctionDecl* d)
{
   ast_CallKind ck = ast_FunctionDecl_getCallKind(d);
   if (ck == ast_CallKind_TypeFunc) return "type-";
   return "";
}

static void ast_FunctionDecl_print(const ast_FunctionDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   bool valid_type = ast_QualType_isValid(d->base.qt);
   ast_Decl_printKind(&d->base, out, indent, valid_type);
   if (!valid_type) {
      string_buffer_Buf_space(out);
      ast_TypeRef_print(&d->rtype, out, true);
   }
   ast_Decl_printBits(&d->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, ast_callKind_names[ast_FunctionDecl_getCallKind(d)]);
   ast_Decl_printAttrs(&d->base, out);
   string_buffer_Buf_add(out, " def:");
   string_buffer_Buf_add(out, ast_defKind_names[ast_FunctionDecl_getDefKind(d)]);
   string_buffer_Buf_color(out, ast_col_Expr);
   if (ast_FunctionDecl_hasAttrUnusedParams(d)) string_buffer_Buf_add(out, " unused-params");
   if (ast_FunctionDecl_hasAttrNoReturn(d)) string_buffer_Buf_add(out, " noreturn");
   if (ast_FunctionDecl_hasAttrInline(d)) string_buffer_Buf_add(out, " inline");
   if (ast_FunctionDecl_hasAttrWeak(d)) string_buffer_Buf_add(out, " weak");
   uint8_t format_arg = 0;
   switch (ast_FunctionDecl_getFormatAttr(d, &format_arg)) {
   case ast_FormatAttr_None:
      break;
   case ast_FormatAttr_Printf:
      string_buffer_Buf_print(out, " printf_format=%d", format_arg);
      break;
   case ast_FormatAttr_Scanf:
      string_buffer_Buf_print(out, " scanf_format=%d", format_arg);
      break;
   }
   if (ast_FunctionDecl_hasAttrConstructor(d)) string_buffer_Buf_add(out, " constructor");
   if (ast_FunctionDecl_hasAttrDestructor(d)) string_buffer_Buf_add(out, " destructor");
   if (ast_FunctionDecl_hasAttrPure(d)) string_buffer_Buf_add(out, " pure");
   if (ast_FunctionDecl_hasAttrDeprecated(d)) {
      const ast_Decl* dd = &d->base;
      const ast_AST* a = ast_Decl_getAST(dd);
      const attr_Attr* deprecated = ast_AST_getAttr(a, dd, attr_AttrKind_Deprecated);
      const char* msg = ast_idx2name(deprecated->value.text);
      string_buffer_Buf_print(out, " deprecated=\"%s\"", msg);
   }
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   if (ast_FunctionDecl_hasPrefix(d)) {
      string_buffer_Buf_add(out, ast_Ref_getName(&d->prefix));
      string_buffer_Buf_add1(out, '.');
   }
   const char* name = ast_Decl_getName(&d->base);
   if (name) string_buffer_Buf_add(out, name);
   else string_buffer_Buf_add(out, "<unnamed>");
   string_buffer_Buf_newline(out);
   if (ast_FunctionDecl_getDefKind(d) == ast_DefKind_Template) {
      string_buffer_Buf_indent(out, indent + 1);
      string_buffer_Buf_color(out, ast_col_Template);
      string_buffer_Buf_print(out, "template %s\n", ast_idx2name(d->template_name));
   }
   ast_VarDecl** params = ast_FunctionDecl_getParams(d);
   for (uint32_t i = 0; i < d->num_params; i++) {
      ast_VarDecl_print(params[i], out, indent + 1);
   }
   if (d->base.functionDeclBits.has_body && d->body) {
      ast_CompoundStmt_print(d->body, out, indent + 1);
   }
}

static void ast_FunctionDecl_printType(const ast_FunctionDecl* d, string_buffer_Buf* out)
{
   if (ast_FunctionDecl_isType(d)) {
      string_buffer_Buf_add(out, ast_Decl_getName(&d->base));
      return;
   }
   if (ast_QualType_isValid(d->rt)) {
      ast_QualType_print(d->rt, out);
   } else {
      ast_TypeRef_print(&d->rtype, out, true);
   }
   string_buffer_Buf_add(out, " (");
   ast_VarDecl** params = ast_FunctionDecl_getParams(d);
   for (uint32_t i = 0; i < d->num_params; i++) {
      if (i != 0) string_buffer_Buf_add(out, ", ");
      ast_VarDecl_printType(params[i], out);
   }
   if (d->base.functionDeclBits.is_variadic) string_buffer_Buf_add(out, ", ...");
   string_buffer_Buf_rparen(out);
}

static ast_FunctionTypeDecl* ast_FunctionTypeDecl_create(ast_context_Context* c, ast_FunctionDecl* func)
{
   ast_FunctionTypeDecl* ftd = ast_context_Context_alloc(c, 32);
   ast_Decl* d = ast_FunctionDecl_asDecl(func);
   ast_Decl_init(&ftd->base, ast_DeclKind_FunctionType, ast_Decl_getNameIdx(d), ast_Decl_getLoc(d), ast_Decl_isPublic(d), ast_Decl_getType(d), ast_Decl_getASTIdx(d));
   ftd->func = func;
   return ftd;
}

static ast_Decl* ast_FunctionTypeDecl_asDecl(ast_FunctionTypeDecl* t)
{
   return &t->base;
}

static ast_FunctionDecl* ast_FunctionTypeDecl_getDecl(const ast_FunctionTypeDecl* d)
{
   return d->func;
}

static void ast_FunctionTypeDecl_print(const ast_FunctionTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, "FunctionTypeDecl");
   ast_Decl_printAttrs(&d->base, out);
   string_buffer_Buf_newline(out);
   ast_FunctionDecl_print(d->func, out, indent + 1);
}

static ast_ImportDecl* ast_ImportDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, uint32_t ast_idx, bool is_local)
{
   ast_ImportDecl* d = ast_context_Context_alloc(c, 40);
   ast_Decl_init(&d->base, ast_DeclKind_Import, name, loc, false, ast_QualType_Invalid, ast_idx);
   d->base.importDeclBits.is_local = is_local;
   d->alias_idx = alias_name;
   d->alias_loc = alias_loc;
   d->dest = NULL;
   return d;
}

static ast_Decl* ast_ImportDecl_asDecl(ast_ImportDecl* d)
{
   return &d->base;
}

static const char* ast_ImportDecl_getAliasName(const ast_ImportDecl* d)
{
   return ast_idx2name(d->alias_idx);
}

static uint32_t ast_ImportDecl_getAliasNameIdx(const ast_ImportDecl* d)
{
   return d->alias_idx;
}

static uint32_t ast_ImportDecl_getImportNameIdx(const ast_ImportDecl* d)
{
   if (d->alias_idx) return d->alias_idx;
   return d->base.name_idx;
}

static src_loc_SrcLoc ast_ImportDecl_getLoc(const ast_ImportDecl* d)
{
   if (d->alias_idx) return d->alias_loc;
   return ast_Decl_getLoc(&d->base);
}

static void ast_ImportDecl_setDest(ast_ImportDecl* d, ast_Module* mod)
{
   d->dest = mod;
}

static ast_Module* ast_ImportDecl_getDest(const ast_ImportDecl* d)
{
   return d->dest;
}

static bool ast_ImportDecl_isLocal(const ast_ImportDecl* d)
{
   return d->base.importDeclBits.is_local;
}

static void ast_ImportDecl_print(const ast_ImportDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, "ImportDecl");
   ast_Decl_printUsed(&d->base, out);
   string_buffer_Buf_add(out, " module=");
   if (d->dest) {
      string_buffer_Buf_add(out, ast_Module_getName(d->dest));
   } else {
      string_buffer_Buf_add(out, "<nil>");
   }
   if (d->base.importDeclBits.is_local) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " local");
   }
   ast_Decl_printName(&d->base, out);
   if (d->alias_idx) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " as ");
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_add(out, ast_idx2name(d->alias_idx));
   }
   string_buffer_Buf_newline(out);
}

static ast_StaticAssert* ast_StaticAssert_create(ast_context_Context* c, uint32_t ast_idx, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_StaticAssert* d = ast_context_Context_alloc(c, 24);
   d->ast_idx = ast_idx;
   d->loc = loc;
   d->lhs = lhs;
   d->rhs = rhs;
   return d;
}

static ast_AST* ast_StaticAssert_getAST(const ast_StaticAssert* d)
{
   return ast_idx2ast(d->ast_idx);
}

static ast_Expr* ast_StaticAssert_getLhs(const ast_StaticAssert* d)
{
   return d->lhs;
}

static ast_Expr* ast_StaticAssert_getRhs(const ast_StaticAssert* d)
{
   return d->rhs;
}

static void ast_StaticAssert_print(const ast_StaticAssert* d, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Decl);
   string_buffer_Buf_add(out, "StaticAssert\n");
   ast_Expr_print(d->lhs, out, indent + 1);
   ast_Expr_print(d->rhs, out, indent + 1);
}

static bool ast_FieldInitField_isZeroSizeBitfield(const ast_FieldInitField* f)
{
   return f->is_bitfield && f->bitfield_width == 0;
}

static void ast_FieldInitField_print(const ast_FieldInitField* f, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, "offset=%u  idx=%u", f->offset, f->member_idx);
   if (f->is_bitfield) {
      string_buffer_Buf_print(out, " bitfield(%d, %d, %d %d)", f->bitfield_offset, f->bitfield_width, f->bitfield_signed, f->bitfield_base_size);
   }
}

static const ast_FieldInitField* ast_FieldInitInfo_find(const ast_FieldInitInfo* fi, uint32_t name)
{
   for (uint32_t i = 0; i < fi->num_fields; i++) {
      if (fi->fields[i].name_idx == name) return &fi->fields[i];
   }
   return NULL;
}

static ast_StructTypeDecl* ast_StructTypeDecl_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, uint32_t ast_idx, bool is_struct, bool is_global, ast_Decl** members, uint32_t num_members)
{
   uint32_t size = 48 + num_members * 8;
   size += 12;
   size += num_members * 12;
   ast_StructTypeDecl* d = ast_context_Context_alloc(c, size);
   ast_StructType* stype = ast_StructType_create(c, d);
   ast_QualType qt = ast_QualType_create(ast_StructType_asType(stype));
   ast_Type_setCanonicalType(ast_StructType_asType(stype), qt);
   ast_Decl_init(&d->base, ast_DeclKind_StructType, name, loc, is_public, qt, ast_idx);
   d->base.structTypeDeclBits.is_struct = is_struct;
   d->base.structTypeDeclBits.is_global = is_global;
   if (!is_global) ast_Decl_setUsed(&d->base);
   d->num_members = num_members;
   d->num_struct_functions = 0;
   d->struct_functions = NULL;
   d->field_info = NULL;
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(d);
   layout->size = 0;
   layout->alignment = 0;
   layout->attr_alignment = 1;
   if (num_members) {
      memcpy(d->members, members, num_members * 8);
      memset(layout->members, 0, num_members * 12);
   }
   return d;
}

static ast_Decl* ast_StructTypeDecl_asDecl(ast_StructTypeDecl* d)
{
   return &d->base;
}

static uint32_t ast_StructTypeDecl_getNumMembers(const ast_StructTypeDecl* d)
{
   return d->num_members;
}

static ast_Decl** ast_StructTypeDecl_getMembers(ast_StructTypeDecl* d)
{
   return d->members;
}

static bool ast_StructTypeDecl_isStruct(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.is_struct;
}

static bool ast_StructTypeDecl_isUnion(const ast_StructTypeDecl* d)
{
   return !d->base.structTypeDeclBits.is_struct;
}

static const ast_FunctionDecl** ast_StructTypeDecl_getStructFunctions(const ast_StructTypeDecl* d)
{
   return (const ast_FunctionDecl**)d->struct_functions;
}

static uint32_t ast_StructTypeDecl_getNumStructFunctions(const ast_StructTypeDecl* d)
{
   return d->num_struct_functions;
}

static ast_StructLayout* ast_StructTypeDecl_getLayout(const ast_StructTypeDecl* d)
{
   return (ast_StructLayout*)&d->members[d->num_members];
}

static uint32_t ast_StructTypeDecl_getSize(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(d);
   return layout->size;
}

static uint32_t ast_StructTypeDecl_getAlignment(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(d);
   return layout->alignment;
}

static uint32_t ast_StructTypeDecl_getAttrAlignment(const ast_StructTypeDecl* d)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(d);
   return layout->attr_alignment;
}

static void ast_StructTypeDecl_setAttrAlignment(ast_StructTypeDecl* d, uint32_t alignment)
{
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(d);
   layout->attr_alignment = alignment;
}

static void ast_StructTypeDecl_setPacked(ast_StructTypeDecl* d)
{
   d->base.structTypeDeclBits.attr_packed = 1;
}

static bool ast_StructTypeDecl_isPacked(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.attr_packed;
}

static void ast_StructTypeDecl_setOpaque(ast_StructTypeDecl* d)
{
   d->base.structTypeDeclBits.attr_opaque = 1;
}

static bool ast_StructTypeDecl_isOpaque(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.attr_opaque;
}

static bool ast_StructTypeDecl_isGlobal(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.is_global;
}

static void ast_StructTypeDecl_setAttrNoTypeDef(ast_StructTypeDecl* d)
{
   d->base.structTypeDeclBits.attr_notypedef = 1;
}

static bool ast_StructTypeDecl_hasAttrNoTypeDef(const ast_StructTypeDecl* d)
{
   return d->base.structTypeDeclBits.attr_notypedef;
}

static void ast_StructTypeDecl_setStructFunctions(ast_StructTypeDecl* d, ast_context_Context* c, ast_FunctionDecl** funcs, uint32_t count)
{
   const uint32_t size = count * 8;
   ast_FunctionDecl** dest = ast_context_Context_alloc(c, size);
   memcpy(dest, funcs, size);
   d->struct_functions = dest;
   d->num_struct_functions = count;
}

static ast_Decl* ast_StructTypeDecl_findAny(const ast_StructTypeDecl* s, uint32_t name_idx)
{
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
   uint32_t count = num_members;
   for (uint32_t i = 0; i < num_members; i++) {
      ast_Decl* d = s->members[i];
      uint32_t member_name = ast_Decl_getNameIdx(d);
      if (member_name == name_idx) {
         return d;
      }
      if (member_name == 0 && ast_Decl_isStructType(d)) {
         ast_StructTypeDecl* sub = (ast_StructTypeDecl*)d;
         d = ast_StructTypeDecl_findAny(sub, name_idx);
         if (d) {
            return d;
         }
      }
   }
   if (s->base.structTypeDeclBits.is_global) {
      for (uint32_t i = 0; i < s->num_struct_functions; i++) {
         ast_Decl* sf = (ast_Decl*)s->struct_functions[i];
         if (ast_Decl_getNameIdx(sf) == name_idx) return sf;
      }
   }
   return NULL;
}

static ast_Decl* ast_StructTypeDecl_findMember(const ast_StructTypeDecl* s, uint32_t name_idx, uint32_t* offset)
{
   uint32_t count = ast_StructTypeDecl_getNumMembers(s);
   for (uint32_t i = 0; i < count; i++) {
      ast_Decl* d = s->members[i];
      uint32_t member_name = ast_Decl_getNameIdx(d);
      if (member_name == name_idx) {
         if (offset) {
            const ast_StructLayout* layout = ast_StructTypeDecl_getLayout(s);
            *offset += layout->members[i].offset;
         }
         return d;
      }
      if (member_name == 0 && ast_Decl_isStructType(d)) {
         ast_StructTypeDecl* sub = (ast_StructTypeDecl*)d;
         d = ast_StructTypeDecl_findMember(sub, name_idx, offset);
         if (d) {
            if (offset) {
               const ast_StructLayout* layout = ast_StructTypeDecl_getLayout(s);
               *offset += layout->members[i].offset;
            }
            return d;
         }
      }
   }
   return NULL;
}

static ast_FieldInitInfo* ast_StructTypeDecl_createFieldInfo(ast_StructTypeDecl* d, ast_context_Context* c)
{
   uint32_t count = ast_StructTypeDecl_getDesigMemberCount(d);
   d->field_info = ast_context_Context_alloc(c, 8 + count * 24);
   d->field_info->num_fields = count;
   return d->field_info;
}

static const ast_FieldInitInfo* ast_StructTypeDecl_getFieldInfo(const ast_StructTypeDecl* d)
{
   return d->field_info;
}

static uint32_t ast_StructTypeDecl_getDesigMemberCount(const ast_StructTypeDecl* d)
{
   if (d->field_info) return d->field_info->num_fields;
   uint32_t count = d->num_members;
   for (uint32_t i = 0; i < d->num_members; i++) {
      ast_Decl* m = d->members[i];
      uint32_t member_name = ast_Decl_getNameIdx(m);
      if (member_name == 0) {
         count--;
         if (ast_Decl_isStructType(m)) {
            ast_StructTypeDecl* sub = (ast_StructTypeDecl*)m;
            count += ast_StructTypeDecl_getDesigMemberCount(sub);
         }
      }
   }
   return count;
}

static bool ast_StructTypeDecl_hasFieldInfo(const ast_StructTypeDecl* d)
{
   return d->field_info != NULL;
}

static void ast_StructTypeDecl_print(const ast_StructTypeDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   ast_Decl_printKind(&d->base, out, indent, true);
   ast_Decl_printBits(&d->base, out);
   bool is_global = d->base.structTypeDeclBits.is_global;
   if (is_global) string_buffer_Buf_add(out, " global");
   if (d->base.structTypeDeclBits.is_struct) string_buffer_Buf_add(out, " struct");
   else string_buffer_Buf_add(out, " union");
   if (ast_StructTypeDecl_isPacked(d)) string_buffer_Buf_add(out, " packed");
   if (ast_StructTypeDecl_isOpaque(d)) string_buffer_Buf_add(out, " opaque");
   if (ast_StructTypeDecl_hasAttrNoTypeDef(d)) string_buffer_Buf_add(out, " notypedef");
   if (is_global) ast_Decl_printAttrs(&d->base, out);
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(d);
   if (layout->size != 0) {
      string_buffer_Buf_color(out, ast_col_Calc);
      string_buffer_Buf_print(out, " size=%u align=%u", layout->size, layout->alignment);
   }
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   if (ast_Decl_getName(&d->base)) string_buffer_Buf_add(out, ast_Decl_getName(&d->base));
   else string_buffer_Buf_add(out, "<anonymous>");
   string_buffer_Buf_newline(out);
   for (uint32_t i = 0; i < d->num_members; i++) {
      string_buffer_Buf_indent(out, indent + 1);
      string_buffer_Buf_color(out, ast_col_Calc);
      const ast_StructMemberLayout* ml = &layout->members[i];
      string_buffer_Buf_print(out, "offset=%u size=%u", ml->offset, ml->size);
      if (ml->is_bitfield) {
         string_buffer_Buf_print(out, " bitfield(%d, %d, %d)", ml->bitfield_offset, ml->bitfield_width, ml->bitfield_signed);
      }
      string_buffer_Buf_newline(out);
      ast_Decl_print(d->members[i], out, indent + 1);
   }
   if (d->field_info) {
      string_buffer_Buf_indent(out, indent + 1);
      string_buffer_Buf_color(out, ast_col_Calc);
      const ast_FieldInitInfo* fif = d->field_info;
      string_buffer_Buf_print(out, "field info (%u fields, %u indexes)\n", fif->num_fields, fif->num_indexes);
      for (uint32_t i = 0; i < fif->num_fields; i++) {
         const ast_FieldInitField* f = &fif->fields[i];
         string_buffer_Buf_indent(out, indent + 2);
         string_buffer_Buf_color(out, ast_col_Value);
         string_buffer_Buf_add(out, ast_idx2name(f->name_idx));
         string_buffer_Buf_space(out);
         ast_FieldInitField_print(f, out);
         string_buffer_Buf_newline(out);
      }
   }
}

static ast_Value ast_Value_createUnsigned(uint64_t uvalue)
{
   ast_Value result = { .kind = ast_ValueKind_Integer, .uvalue = uvalue };
   return result;
}

static ast_Value ast_Value_createSigned(int64_t svalue)
{
   if (svalue < 0) {
      ast_Value result = { .kind = ast_ValueKind_Integer, .negative = true, .uvalue = ~svalue + 1 };
      return result;
   } else {
      ast_Value result = { .kind = ast_ValueKind_Integer, .uvalue = (uint64_t)svalue };
      return result;
   }
}

static ast_Value ast_Value_createBool(bool value)
{
   ast_Value result = { .kind = ast_ValueKind_Integer, .uvalue = value };
   return result;
}

static ast_Value ast_Value_createFloat(double fvalue)
{
   ast_Value result = { .kind = ast_ValueKind_Float, .fvalue = fvalue };
   return result;
}

static ast_Value ast_Value_error(const char* msg)
{
   ast_Value result = { .kind = ast_ValueKind_Error, .error_msg = msg };
   return result;
}

static void ast_Value_setUnsigned(ast_Value* v, uint64_t uvalue)
{
   v->kind = ast_ValueKind_Integer;
   v->overflow = false;
   v->negative = false;
   v->uvalue = uvalue;
}

static void ast_Value_setSigned(ast_Value* v, int64_t svalue)
{
   v->kind = ast_ValueKind_Integer;
   v->overflow = false;
   if (svalue < 0) {
      v->negative = true;
      v->uvalue = ~svalue + 1;
   } else {
      v->negative = false;
      v->uvalue = (uint64_t)svalue;
   }
}

static void ast_Value_setFloat(ast_Value* v, double fvalue)
{
   v->kind = ast_ValueKind_Float;
   v->overflow = false;
   v->negative = false;
   v->fvalue = fvalue;
}

static bool ast_Value_isNegative(const ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      return v->negative;
   case ast_ValueKind_Float:
      return v->fvalue < 0;
   default:
      break;
   }
   return false;
}

static bool ast_Value_isFloat(const ast_Value* v)
{
   return v->kind == ast_ValueKind_Float;
}

static bool ast_Value_isDecimal(const ast_Value* v)
{
   return v->kind == ast_ValueKind_Integer;
}

static bool ast_Value_isError(const ast_Value* v)
{
   return v->kind == ast_ValueKind_Error;
}

static bool ast_Value_isZero(const ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      return !v->negative && v->uvalue == 0;
   case ast_ValueKind_Float:
      return v->fvalue == 0;
   default:
      break;
   }
   return false;
}

static double ast_Value_toFloat(const ast_Value* v)
{
   if (v->kind == ast_ValueKind_Integer) {
      double f = (double)v->uvalue;
      return (v->negative) ? -f : f;
   } else {
      return v->fvalue;
   }
}

static uint8_t ast_Value_as_u8(const ast_Value* v)
{
   ;//assert(v->kind == ast_ValueKind_Integer);
   uint64_t res = v->uvalue;
   if (v->negative) res = ~res + 1;
   return (uint8_t)res;
}

static uint16_t ast_Value_as_u16(const ast_Value* v)
{
   ;//assert(v->kind == ast_ValueKind_Integer);
   uint64_t res = v->uvalue;
   if (v->negative) res = ~res + 1;
   return (uint16_t)res;
}

static int32_t ast_Value_as_i32(const ast_Value* v)
{
   uint64_t res = 0;
   if (v->kind == ast_ValueKind_Integer) {
      res = v->uvalue;
      if (v->negative) res = ~res + 1;
   }
   return (int32_t)res;
}

static uint32_t ast_Value_as_u32(const ast_Value* v)
{
   uint64_t res = 0;
   if (v->kind == ast_ValueKind_Integer) {
      res = v->uvalue;
      if (v->negative) res = ~res + 1;
   }
   return (uint32_t)res;
}

static uint64_t ast_Value_as_u64(const ast_Value* v)
{
   uint64_t res = 0;
   if (v->kind == ast_ValueKind_Integer) {
      res = v->uvalue;
      if (v->negative) res = ~res + 1;
   }
   return res;
}

static uint8_t ast_Value_getWidth(const ast_Value* v)
{
   if (v->kind != ast_ValueKind_Integer) {
      return 64;
   }
   if (v->uvalue == 0) return 0;
   uint64_t value = v->uvalue - v->negative;
   uint32_t width = v->negative;
   if (value) {
      width += 1;
      for (uint32_t shift = 32; shift; shift >>= 1) {
         if (value >= ((uint64_t)1 << shift)) {
            value >>= shift;
            width += shift;
         }
      }
   }
   return (uint8_t)width;
}

static bool ast_Value_checkRange(const ast_Value* v, int64_t min, uint64_t max)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      if (v->negative) return (v->uvalue <= (uint64_t)~min + 1);
      else return (v->uvalue <= max);
   case ast_ValueKind_Float:
      return (v->fvalue >= (double)min && v->fvalue < (double)max + 1);
   default:
      break;
   }
   return false;
}

static ast_Value ast_Value_negate(const ast_Value* v)
{
   ast_Value result = *v;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      if (result.uvalue) {
         result.negative = !result.negative;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue = -result.fvalue;
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_bitnot(const ast_Value* v)
{
   ast_Value result = *v;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      if (result.negative) {
         result.uvalue = ~result.uvalue + 1;
         result.uvalue = ~result.uvalue;
         result.negative = false;
      } else {
         result.uvalue = ~result.uvalue;
         result.uvalue = ~result.uvalue + 1;
         result.negative = true;
      }
      break;
   case ast_ValueKind_Float:
      result = ast_Value_error("invalid operand for '~'");
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_lnot(const ast_Value* v)
{
   ast_Value result = ast_Value_createBool(ast_Value_isZero(v));
   result.overflow = v->overflow;
   return result;
}

static ast_Value ast_Value_minus(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value tmp = ast_Value_negate(v2);
   return ast_Value_add(v1, &tmp);
}

static ast_Value ast_Value_add(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (result.negative != v2->negative) {
            if (result.uvalue > v2->uvalue) {
               result.uvalue -= v2->uvalue;
            } else {
               result.uvalue = v2->uvalue - result.uvalue;
               result.negative = v2->negative && result.uvalue;
            }
         } else {
            if (result.uvalue > c2_max_u64 - v2->uvalue) {
               result.overflow = true;
            }
            result.uvalue += v2->uvalue;
         }
         break;
      case ast_ValueKind_Float:
         result.fvalue = ast_Value_toFloat(&result) + v2->fvalue;
         result.kind = ast_ValueKind_Float;
         break;
      default:
         result = *v2;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue += ast_Value_toFloat(v2);
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_multiply(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (result.uvalue) {
            if (!v2->uvalue) result.negative = false;
            else result.negative ^= v2->negative;
            if (c2_max_u64 / result.uvalue > v2->uvalue) result.overflow = true;
            result.uvalue *= v2->uvalue;
         }
         break;
      case ast_ValueKind_Float:
         result.fvalue = ast_Value_toFloat(&result) * v2->fvalue;
         result.kind = ast_ValueKind_Float;
         break;
      default:
         result = *v2;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue *= ast_Value_toFloat(v2);
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_divide(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v2->uvalue == 0) {
            result.overflow = true;
            result.uvalue = c2_max_u64;
         } else {
            result.uvalue /= v2->uvalue;
            result.negative = result.uvalue && result.negative != v2->negative;
         }
         break;
      case ast_ValueKind_Float:
         result.fvalue = ast_Value_toFloat(&result) / v2->fvalue;
         result.kind = ast_ValueKind_Float;
         break;
      default:
         result = *v2;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result.fvalue /= ast_Value_toFloat(v2);
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_remainder(const ast_Value* v1, const ast_Value* v2)
{
   ;//assert(ast_Value_isDecimal(v1));
   ;//assert(ast_Value_isDecimal(v2));
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   if (v2->uvalue == 0) {
      result.overflow = true;
      result.uvalue = 0;
   } else {
      result.uvalue %= v2->uvalue;
      if (result.uvalue == 0) result.negative = false;
   }
   return result;
}

static void ast_Value_left_shift2(ast_Value* v, uint32_t shift)
{
   if (v->negative) {
      v->uvalue = ~v->uvalue + 1;
      v->uvalue <<= shift;
      v->uvalue = ~v->uvalue + 1;
      if (v->uvalue == 0) v->negative = false;
   } else {
      v->uvalue <<= shift;
   }
}

static ast_Value ast_Value_left_shift(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (!v2->negative) {
            uint8_t shift = v2->uvalue & 63;
            ast_Value_left_shift2(&result, shift);
         }
         break;
      case ast_ValueKind_Float:
         result = ast_Value_error("invalid argument type");
         break;
      default:
         result = *v2;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result = ast_Value_error("invalid argument type");
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_right_shift(const ast_Value* v1, const ast_Value* v2)
{
   ast_Value result = *v1;
   result.overflow |= v2->overflow;
   switch (result.kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (!v2->negative) {
            uint8_t shift = v2->uvalue & 63;
            if (result.negative) {
               uint64_t mask = 0;
               result.uvalue = ~result.uvalue + 1;
               result.uvalue >>= shift;
               result.uvalue |= ~(~mask >> shift);
               result.uvalue = ~result.uvalue + 1;
            } else {
               result.uvalue >>= shift;
            }
         }
         break;
      case ast_ValueKind_Float:
         result = ast_Value_error("invalid argument type");
         break;
      default:
         result = *v2;
         break;
      }
      break;
   case ast_ValueKind_Float:
      result = ast_Value_error("invalid argument type");
      break;
   default:
      break;
   }
   return result;
}

static ast_Value ast_Value_and(const ast_Value* v1, const ast_Value* v2)
{
   ;//assert(ast_Value_isDecimal(v1));
   ;//assert(ast_Value_isDecimal(v2));
   ast_Value result = *v1;
   ast_Value r2 = *v2;
   if (result.negative) result.uvalue = ~result.uvalue + 1;
   if (r2.negative) r2.uvalue = ~r2.uvalue + 1;
   result.overflow |= v2->overflow;
   result.negative &= r2.negative;
   result.uvalue &= r2.uvalue;
   if (result.negative) result.uvalue = ~result.uvalue + 1;
   return result;
}

static ast_Value ast_Value_or(const ast_Value* v1, const ast_Value* v2)
{
   ;//assert(ast_Value_isDecimal(v1));
   ;//assert(ast_Value_isDecimal(v2));
   ast_Value result = *v1;
   ast_Value r2 = *v2;
   if (result.negative) result.uvalue = ~result.uvalue + 1;
   if (r2.negative) r2.uvalue = ~r2.uvalue + 1;
   result.overflow |= v2->overflow;
   result.negative |= r2.negative;
   result.uvalue |= r2.uvalue;
   if (result.negative) result.uvalue = ~result.uvalue + 1;
   return result;
}

static ast_Value ast_Value_xor(const ast_Value* v1, const ast_Value* v2)
{
   ;//assert(ast_Value_isDecimal(v1));
   ;//assert(ast_Value_isDecimal(v2));
   ast_Value result = *v1;
   ast_Value r2 = *v2;
   if (result.negative) result.uvalue = ~result.uvalue + 1;
   if (r2.negative) r2.uvalue = ~r2.uvalue + 1;
   result.overflow |= v2->overflow;
   result.negative ^= r2.negative;
   result.uvalue ^= r2.uvalue;
   if (result.negative) result.uvalue = ~result.uvalue + 1;
   return result;
}

static ast_Value ast_Value_toBool(const ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      return ast_Value_createBool(v->negative || v->uvalue != 0);
   case ast_ValueKind_Float:
      return ast_Value_createBool(v->fvalue != 0);
   default:
      break;
   }
   return *v;
}

static bool ast_Value_is_equal(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         return v1->negative == v2->negative && v1->uvalue == v2->uvalue;
      case ast_ValueKind_Float:
         return ast_Value_toFloat(v1) == v2->fvalue;
      default:
         break;
      }
      break;
   case ast_ValueKind_Float:
      return v1->fvalue == ast_Value_toFloat(v2);
   default:
      break;
   }
   return false;
}

static bool ast_Value_is_less(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return !v2->negative || v1->uvalue > v2->uvalue;
         else return !v2->negative && v1->uvalue < v2->uvalue;
      case ast_ValueKind_Float:
         return ast_Value_toFloat(v1) < v2->fvalue;
      default:
         break;
      }
      break;
   case ast_ValueKind_Float:
      return v1->fvalue < ast_Value_toFloat(v2);
   default:
      break;
   }
   return false;
}

static bool ast_Value_is_less_equal(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return !v2->negative || v1->uvalue >= v2->uvalue;
         else return !v2->negative && v1->uvalue <= v2->uvalue;
      case ast_ValueKind_Float:
         return ast_Value_toFloat(v1) <= v2->fvalue;
      default:
         break;
      }
      break;
   case ast_ValueKind_Float:
      return v1->fvalue <= ast_Value_toFloat(v2);
   default:
      break;
   }
   return false;
}

static bool ast_Value_is_greater(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return v2->negative && v1->uvalue < v2->uvalue;
         else return v2->negative || v1->uvalue > v2->uvalue;
      case ast_ValueKind_Float:
         return ast_Value_toFloat(v1) > v2->fvalue;
      default:
         break;
      }
      break;
   case ast_ValueKind_Float:
      return v1->fvalue > ast_Value_toFloat(v2);
   default:
      break;
   }
   return false;
}

static bool ast_Value_is_greater_equal(const ast_Value* v1, const ast_Value* v2)
{
   switch (v1->kind) {
   case ast_ValueKind_Integer:
      switch (v2->kind) {
      case ast_ValueKind_Integer:
         if (v1->negative) return v2->negative && v1->uvalue <= v2->uvalue;
         else return v2->negative || v1->uvalue >= v2->uvalue;
      case ast_ValueKind_Float:
         return ast_Value_toFloat(v1) >= v2->fvalue;
      default:
         break;
      }
      break;
   case ast_ValueKind_Float:
      return v1->fvalue >= ast_Value_toFloat(v2);
   default:
      break;
   }
   return false;
}

static bool ast_Value_isNext(const ast_Value* v1, const ast_Value* v2)
{
   if (v1->kind != ast_ValueKind_Integer || v2->kind != ast_ValueKind_Integer) return false;
   if (v1->negative || v2->negative) return false;
   return v1->uvalue - 1 == v2->uvalue;
}

static void ast_Value_mask(ast_Value* v, uint32_t width)
{
   if (v->negative) {
      v->uvalue = ~v->uvalue + 1;
      v->negative = false;
   }
   if (width < 64) {
      uint64_t one = 1;
      v->uvalue &= (one << width) - 1;
   }
}

static void ast_Value_truncate(ast_Value* orig, uint32_t width, bool is_signed)
{
   ;//assert(ast_Value_isDecimal(orig));
   uint64_t uvalue = ast_Value_as_u64(orig);
   if (is_signed) {
      uint64_t sbit = (uint64_t)1 << (width - 1);
      uint64_t mask = sbit - 1;
      if (uvalue & sbit) ast_Value_setSigned(orig, (int64_t)((uvalue & mask) - sbit));
      else ast_Value_setUnsigned(orig, uvalue & mask);
   } else {
      uint64_t mask = (uint64_t)~(uint64_t)0 >> (64 - width);
      ast_Value_setUnsigned(orig, uvalue & mask);
   }
}

static void ast_Value_incr(ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      if (v->negative) {
         if (v->uvalue == 1) v->negative = false;
         v->uvalue--;
      } else {
         if (v->uvalue == c2_max_u64) v->overflow = true;
         v->uvalue++;
      }
      break;
   case ast_ValueKind_Float:
      v->fvalue += 1;
      break;
   default:
      break;
   }
}

static void ast_Value_decr(ast_Value* v)
{
   switch (v->kind) {
   case ast_ValueKind_Integer:
      if (v->negative) {
         if (v->uvalue == c2_max_u64) v->overflow = true;
         v->uvalue++;
      } else {
         if (v->uvalue == 0) {
            v->negative = true;
            v->uvalue = 1;
         } else {
            v->uvalue--;
         }
      }
      break;
   case ast_ValueKind_Float:
      v->fvalue -= 1;
      break;
   default:
      break;
   }
}

static ast_Value ast_Value_castAs(const ast_Value* v, ast_QualType qt)
{
   ast_Value result = *v;
   if (result.kind == ast_ValueKind_Error) return result;
   qt = ast_QualType_getCanonicalType(qt);
   if (ast_QualType_isEnum(qt)) qt = ast_EnumType_getImplType(ast_QualType_getEnum(qt));
   if (ast_QualType_isPointer(qt)) return result;
   ;//assert(ast_QualType_isBuiltin(qt));
   ast_BuiltinType* bi = ast_QualType_getBuiltin(qt);
   uint32_t width = ast_BuiltinType_getWidth(bi);
   switch (result.kind) {
   case ast_ValueKind_Integer:
      if (ast_QualType_isFloat(qt)) {
         ast_Value_setFloat(&result, ast_Value_toFloat(&result));
         if (width == 32) {
            result.fvalue = (float)result.fvalue;
         }
      } else if (ast_QualType_isBool(qt)) {
         ast_Value_setUnsigned(&result, !ast_Value_isZero(&result));
      } else {
         ast_Value_truncate(&result, width, ast_BuiltinType_isSigned(bi));
      }
      break;
   case ast_ValueKind_Float:
      if (ast_QualType_isFloat(qt)) {
         if (width == 32) {
            result.fvalue = (float)result.fvalue;
         }
      } else if (ast_QualType_isBool(qt)) {
         ast_Value_setUnsigned(&result, !ast_Value_isZero(&result));
      } else {
         if (ast_BuiltinType_isSigned(bi)) {
            ast_Value_setSigned(&result, (int64_t)result.fvalue);
         } else {
            ast_Value_setUnsigned(&result, (uint64_t)result.fvalue);
         }
         ast_Value_truncate(&result, width, ast_BuiltinType_isSigned(bi));
      }
      break;
   default:
      break;
   }
   return result;
}

static bool ast_isfinite(double d)
{
   ast_FP64 u = { .d = d };
   return ((u.bits >> 52) & 0x7ff) != 0x7ff;
}

static int32_t ast_signbit(double d)
{
   ast_FP64 u = { .d = d };
   return (u.bits >> 63) & 1;
}

static double ast_fabs(double d)
{
   ast_FP64 u = { .d = d };
   u.bits = u.bits << 1 >> 1;
   return u.d;
}

static char* ast_ftoa(char* dest, size_t size, double d)
{
   char buf[32];
   size_t pos = 0;
   if (size < 2) {
      if (size) *dest = '\0';
      return dest;
   }
   if (!ast_isfinite(d)) {
      snprintf(dest, size, "%f", d);
      return dest;
   }
   if (ast_signbit(d)) {
      dest[pos++] = '-';
      d = ast_fabs(d);
   }
   if (!d) {
      snprintf(dest + pos, size - pos, "0.0");
      return dest;
   }
   if (d < 0.0001 || d > 1000000) {
      for (int32_t prec = 14; prec < 17; prec++) {
         snprintf(buf, 32, "%.*e", prec, d);
         if (atof(buf) == d) break;
      }
   } else {
      for (int32_t prec = 17 - 4; prec < 17 + 4; prec++) {
         snprintf(buf, 32, "%.*f", prec, d);
         if (atof(buf) == d) break;
      }
   }
   char* dot = buf + 1;
   while (*dot && *dot != '.') dot++;
   char* exp = dot;
   while (*exp && *exp != 'e') exp++;
   char* decimals = exp;
   while (decimals > dot + 2 && decimals[-1] == '0') decimals--;
   size_t len = size - 1;
   for (char* p = buf; p < decimals && pos < len; p++) {
      dest[pos++] = *p;
   }
   for (char* p = exp; *p && pos < len; p++) {
      dest[pos++] = *p;
   }
   dest[pos] = '\0';
   return dest;
}

static const char* ast_Value_str(const ast_Value* v)
{
   static char text[4][64];
   static uint8_t index = 0;
   char* out = text[index];
   index = (index + 1) % 4;
   switch (v->kind) {
   case ast_ValueKind_Integer:
      *out = '-';
      snprintf(out + v->negative, 64 - 1, "%lu", v->uvalue);
      break;
   case ast_ValueKind_Float:
      ast_ftoa(out, 64, v->fvalue);
      break;
   default:
      return "<<invalid>>";
   }
   return out;
}

static ast_VarDecl* ast_VarDecl_create(ast_context_Context* c, ast_VarDeclKind kind, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, src_loc_SrcLoc assignLoc, bool has_embed, ast_Expr* initValue)
{
   uint32_t size = 32 + ast_TypeRefHolder_getExtraSize(ref);
   if (initValue || ast_TypeRefHolder_isIncrArray(ref) || has_embed) size += 16;
   ;//assert(kind != ast_VarDeclKind_StructMember);
   ast_VarDecl* d = ast_context_Context_alloc(c, size);
   ast_Decl_init(&d->base, ast_DeclKind_Variable, name, loc, is_public, ast_QualType_Invalid, ast_idx);
   d->base.varDeclBits.kind = kind;
   ast_TypeRef_init(&d->typeRef, ref);
   if (initValue || has_embed) {
      d->base.varDeclBits.has_init = 1;
      ast_VarDeclInit* init = ast_TypeRef_getPointerAfter(&d->typeRef);
      init->expr = initValue;
      init->loc = assignLoc;
   }
   return d;
}

static ast_VarDecl* ast_VarDecl_createStructMember(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, uint32_t ast_idx, ast_Expr* bitfield)
{
   uint32_t size = 32 + ast_TypeRefHolder_getExtraSize(ref);
   if (bitfield) size += 16;
   ast_VarDecl* d = ast_context_Context_alloc(c, size);
   ast_Decl_init(&d->base, ast_DeclKind_Variable, name, loc, is_public, ast_QualType_Invalid, ast_idx);
   d->base.varDeclBits.kind = ast_VarDeclKind_StructMember;
   if (name == 0) ast_Decl_setUsed(&d->base);
   ast_TypeRef_init(&d->typeRef, ref);
   if (bitfield) {
      d->base.varDeclBits.is_bitfield = 1;
      ast_BitFieldInfo* info = ast_TypeRef_getPointerAfter(&d->typeRef);
      info->expr = bitfield;
      info->loc = loc;
      info->layout.bit_width = 0;
      info->layout.bit_offset = 0;
   }
   return d;
}

static ast_VarDecl* ast_VarDecl_instantiate(const ast_VarDecl* vd, ast_Instantiator* inst)
{
   bool matches = ast_TypeRef_matchesTemplate(&vd->typeRef, inst->template_name);
   uint32_t extra = matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&vd->typeRef);
   if (vd->base.varDeclBits.has_init) extra += 16;
   if (vd->base.varDeclBits.is_bitfield) extra += 16;
   uint32_t size = 32 + extra;
   ast_VarDecl* vd2 = ast_context_Context_alloc(inst->c, size);
   vd2->base = vd->base;
   ast_TypeRef_instantiate(&vd2->typeRef, &vd->typeRef, inst);
   if (vd->base.varDeclBits.has_init) {
      ast_VarDeclInit* init1 = ast_TypeRef_getPointerAfter(&vd->typeRef);
      ast_VarDeclInit* init2 = ast_TypeRef_getPointerAfter(&vd2->typeRef);
      init2->loc = init1->loc;
      init2->expr = ast_Expr_instantiate(init1->expr, inst);
   }
   if (vd->base.varDeclBits.is_bitfield) {
      ast_BitFieldInfo* info1 = ast_TypeRef_getPointerAfter(&vd->typeRef);
      ast_BitFieldInfo* info2 = ast_TypeRef_getPointerAfter(&vd2->typeRef);
      info2->loc = info1->loc;
      info2->expr = ast_Expr_instantiate(info1->expr, inst);
   }
   return vd2;
}

static const char* ast_VarDecl_getName(const ast_VarDecl* d)
{
   return ast_idx2name(d->base.name_idx);
}

static ast_Decl* ast_VarDecl_asDecl(ast_VarDecl* d)
{
   return &d->base;
}

static uint32_t ast_VarDecl_getOffset(const ast_VarDecl* d)
{
   return d->base.offset;
}

static void ast_VarDecl_setOffset(ast_VarDecl* d, uint32_t offset)
{
   d->base.offset = (uint16_t)offset;
}

static ast_VarDeclKind ast_VarDecl_getKind(const ast_VarDecl* d)
{
   return (ast_VarDeclKind)d->base.varDeclBits.kind;
}

static bool ast_VarDecl_isGlobal(const ast_VarDecl* d)
{
   return ast_VarDecl_getKind(d) == ast_VarDeclKind_GlobalVar;
}

static bool ast_VarDecl_isLocal(const ast_VarDecl* d)
{
   return ast_VarDecl_getKind(d) == ast_VarDeclKind_LocalVar;
}

static bool ast_VarDecl_isParameter(const ast_VarDecl* d)
{
   return ast_VarDecl_getKind(d) == ast_VarDeclKind_FunctionParam;
}

static bool ast_VarDecl_isStructMember(const ast_VarDecl* d)
{
   return ast_VarDecl_getKind(d) == ast_VarDeclKind_StructMember;
}

static bool ast_VarDecl_isBitField(const ast_VarDecl* d)
{
   return d->base.varDeclBits.is_bitfield;
}

static bool ast_VarDecl_isAddrUsed(const ast_VarDecl* d)
{
   return d->base.varDeclBits.addr_used;
}

static void ast_VarDecl_setAddrUsed(ast_VarDecl* d)
{
   d->base.varDeclBits.addr_used = 1;
}

static ast_TypeRef* ast_VarDecl_getTypeRef(ast_VarDecl* d)
{
   return &d->typeRef;
}

static src_loc_SrcLoc ast_VarDecl_getAssignLoc(const ast_VarDecl* d)
{
   if (d->base.varDeclBits.has_init) {
      ast_VarDeclInit* init = ast_TypeRef_getPointerAfter(&d->typeRef);
      return init->loc;
   }
   return 0;
}

static bool ast_VarDecl_hasInit(const ast_VarDecl* d)
{
   return d->base.varDeclBits.has_init;
}

static ast_Expr* ast_VarDecl_getInit(const ast_VarDecl* d)
{
   if (d->base.varDeclBits.has_init) {
      ast_VarDeclInit* init = ast_TypeRef_getPointerAfter(&d->typeRef);
      return init->expr;
   }
   return NULL;
}

static ast_Expr** ast_VarDecl_getInit2(ast_VarDecl* d)
{
   if (d->base.varDeclBits.has_init) {
      ast_VarDeclInit* init = ast_TypeRef_getPointerAfter(&d->typeRef);
      return &init->expr;
   }
   return NULL;
}

static void ast_VarDecl_setInit(ast_VarDecl* d, ast_Expr* initValue)
{
   d->base.varDeclBits.has_init = 1;
   ast_VarDeclInit* init = ast_TypeRef_getPointerAfter(&d->typeRef);
   init->expr = initValue;
}

static ast_BitFieldInfo* ast_VarDecl_getBitFieldInfo(const ast_VarDecl* d)
{
   if (d->base.varDeclBits.is_bitfield) return ast_TypeRef_getPointerAfter(&d->typeRef);
   return NULL;
}

static ast_Expr* ast_VarDecl_getBitfield(const ast_VarDecl* d)
{
   ast_BitFieldInfo* info = ast_VarDecl_getBitFieldInfo(d);
   if (info) return info->expr;
   return NULL;
}

static void ast_VarDecl_setBitfieldWidth(ast_VarDecl* d, uint8_t width)
{
   ast_BitFieldInfo* info = ast_VarDecl_getBitFieldInfo(d);
   info->layout.bit_width = width;
}

static ast_BitFieldLayout* ast_VarDecl_getBitfieldLayout(const ast_VarDecl* d)
{
   ast_BitFieldInfo* info = ast_VarDecl_getBitFieldInfo(d);
   if (info) return &info->layout;
   return NULL;
}

static bool ast_VarDecl_hasLocalQualifier(const ast_VarDecl* d)
{
   return d->base.varDeclBits.has_local;
}

static void ast_VarDecl_setLocal(ast_VarDecl* d, bool has_local)
{
   d->base.varDeclBits.has_local = has_local;
}

static void ast_VarDecl_setInitCall(ast_VarDecl* d, bool has_init_call)
{
   d->base.varDeclBits.has_init_call = has_init_call;
}

static bool ast_VarDecl_hasInitCall(const ast_VarDecl* d)
{
   return d->base.varDeclBits.has_init_call;
}

static void ast_VarDecl_setAttrWeak(ast_VarDecl* d)
{
   d->base.varDeclBits.attr_weak = 1;
}

static bool ast_VarDecl_hasAttrWeak(const ast_VarDecl* d)
{
   return d->base.varDeclBits.attr_weak;
}

static ast_AutoAttr ast_VarDecl_getAutoAttr(const ast_VarDecl* d)
{
   return (ast_AutoAttr)d->base.varDeclBits.auto_attr;
}

static void ast_VarDecl_setAttrAutoFile(ast_VarDecl* d)
{
   d->base.varDeclBits.auto_attr = ast_AutoAttr_File;
}

static bool ast_VarDecl_hasAttrAutoFile(const ast_VarDecl* d)
{
   return ast_VarDecl_getAutoAttr(d) == ast_AutoAttr_File;
}

static void ast_VarDecl_setAttrAutoLine(ast_VarDecl* d)
{
   d->base.varDeclBits.auto_attr = ast_AutoAttr_Line;
}

static bool ast_VarDecl_hasAttrAutoLine(const ast_VarDecl* d)
{
   return ast_VarDecl_getAutoAttr(d) == ast_AutoAttr_Line;
}

static void ast_VarDecl_setAttrAutoFunc(ast_VarDecl* d)
{
   d->base.varDeclBits.auto_attr = ast_AutoAttr_Func;
}

static bool ast_VarDecl_hasAttrAutoFunc(const ast_VarDecl* d)
{
   return ast_VarDecl_getAutoAttr(d) == ast_AutoAttr_Func;
}

static bool ast_VarDecl_hasAutoAttr(const ast_VarDecl* d)
{
   return ast_VarDecl_getAutoAttr(d) != ast_AutoAttr_None;
}

static void ast_VarDecl_setFormatAttr(ast_VarDecl* d, ast_FormatAttr kind)
{
   d->base.varDeclBits.format_attr = kind;
}

static ast_FormatAttr ast_VarDecl_getFormatAttr(const ast_VarDecl* d)
{
   return (ast_FormatAttr)d->base.varDeclBits.format_attr;
}

static void ast_VarDecl_print(const ast_VarDecl* d, string_buffer_Buf* out, uint32_t indent)
{
   bool valid_type = ast_QualType_isValid(d->base.qt);
   ast_Decl_printKind(&d->base, out, indent, valid_type);
   if (!valid_type) {
      string_buffer_Buf_space(out);
      ast_TypeRef_print(&d->typeRef, out, true);
   }
   string_buffer_Buf_color(out, ast_col_Attr);
   ast_VarDeclKind k = ast_VarDecl_getKind(d);
   string_buffer_Buf_add(out, ast_varDeclNames[k]);
   if (d->base.varDeclBits.is_bitfield) {
      ast_BitFieldLayout* layout = ast_VarDecl_getBitfieldLayout(d);
      string_buffer_Buf_print(out, " bitfield(%d, %d)", layout->bit_offset, layout->bit_width);
   }
   if (ast_VarDecl_hasLocalQualifier(d)) string_buffer_Buf_add(out, " (local)");
   if (d->base.varDeclBits.attr_weak) string_buffer_Buf_add(out, " weak");
   if (d->base.varDeclBits.addr_used) string_buffer_Buf_add(out, " addr_used");
   switch ((ast_AutoAttr)d->base.varDeclBits.auto_attr) {
   case ast_AutoAttr_None:
      break;
   case ast_AutoAttr_File:
      string_buffer_Buf_add(out, " auto_file");
      break;
   case ast_AutoAttr_Line:
      string_buffer_Buf_add(out, " auto_line");
      break;
   case ast_AutoAttr_Func:
      string_buffer_Buf_add(out, " auto_func");
      break;
   }
   switch (ast_VarDecl_getFormatAttr(d)) {
   case ast_FormatAttr_None:
      break;
   case ast_FormatAttr_Printf:
      string_buffer_Buf_add(out, " printf_format");
      break;
   case ast_FormatAttr_Scanf:
      string_buffer_Buf_add(out, " scanf_format");
      break;
   }
   if (d->base.varDeclBits.has_init_call) string_buffer_Buf_add(out, " init_call");
   ast_Decl_printBits(&d->base, out);
   ast_Decl_printAttrs(&d->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_Decl_printName(&d->base, out);
   string_buffer_Buf_newline(out);
   if (d->base.varDeclBits.has_init) {
      ast_Expr* i = ast_VarDecl_getInit(d);
      ast_Expr_print(i, out, indent + 1);
   }
}

static void ast_VarDecl_printType(const ast_VarDecl* d, string_buffer_Buf* out)
{
   if (ast_QualType_isValid(d->base.qt)) {
      ast_QualType_printQuoted(d->base.qt, out);
   } else {
      ast_TypeRef_print(&d->typeRef, out, true);
   }
}

static void ast_Stmt_init(ast_Stmt* s, ast_StmtKind k, src_loc_SrcLoc loc)
{
   s->bits = 0;
   s->stmtBits.kind = k;
   s->loc = loc;
}

static ast_Stmt* ast_Stmt_instantiate(ast_Stmt* s, ast_Instantiator* inst)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      return ast_ReturnStmt_instantiate((ast_ReturnStmt*)s, inst);
   case ast_StmtKind_Expr:
      return (ast_Stmt*)ast_Expr_instantiate((ast_Expr*)s, inst);
   case ast_StmtKind_If:
      return ast_IfStmt_instantiate((ast_IfStmt*)s, inst);
   case ast_StmtKind_While:
      return ast_WhileStmt_instantiate((ast_WhileStmt*)s, inst);
   case ast_StmtKind_For:
      return ast_ForStmt_instantiate((ast_ForStmt*)s, inst);
   case ast_StmtKind_Switch:
      return ast_SwitchStmt_instantiate((ast_SwitchStmt*)s, inst);
   case ast_StmtKind_Break:
   case ast_StmtKind_Continue:
   case ast_StmtKind_Fallthrough:
      return s;
   case ast_StmtKind_Label:
      return ast_LabelStmt_instantiate((ast_LabelStmt*)s, inst);
   case ast_StmtKind_Goto:
      return s;
   case ast_StmtKind_Compound:
      return (ast_Stmt*)ast_CompoundStmt_instantiate((ast_CompoundStmt*)s, inst);
   case ast_StmtKind_Decl:
      return ast_DeclStmt_instantiate((ast_DeclStmt*)s, inst);
   case ast_StmtKind_Asm:
      return ast_AsmStmt_instantiate((ast_AsmStmt*)s, inst);
   case ast_StmtKind_Assert:
      return ast_AssertStmt_instantiate((ast_AssertStmt*)s, inst);
   }
   ast_Stmt_dump(s);
   ;//assert(0);
   return NULL;
}

static ast_StmtKind ast_Stmt_getKind(const ast_Stmt* s)
{
   return (ast_StmtKind)s->stmtBits.kind;
}

static bool ast_Stmt_isExpr(const ast_Stmt* s)
{
   return ast_Stmt_getKind(s) == ast_StmtKind_Expr;
}

static bool ast_Stmt_isCompound(const ast_Stmt* s)
{
   return ast_Stmt_getKind(s) == ast_StmtKind_Compound;
}

static bool ast_Stmt_isFallthrough(const ast_Stmt* s)
{
   return ast_Stmt_getKind(s) == ast_StmtKind_Fallthrough;
}

static bool ast_Stmt_isDecl(const ast_Stmt* s)
{
   return ast_Stmt_getKind(s) == ast_StmtKind_Decl;
}

static bool ast_Stmt_isLabel(const ast_Stmt* s)
{
   return ast_Stmt_getKind(s) == ast_StmtKind_Label;
}

static src_loc_SrcLoc ast_Stmt_getLoc(const ast_Stmt* s)
{
   return s->loc;
}

static void ast_Stmt_dump(const ast_Stmt* s)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_Stmt_print(s, out, 0);
   ast_flushDumpBuf(out);
}

static void ast_Stmt_print(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      ast_ReturnStmt_print((ast_ReturnStmt*)s, out, indent);
      break;
   case ast_StmtKind_Expr:
      ast_Expr_print((ast_Expr*)s, out, indent);
      break;
   case ast_StmtKind_If:
      ast_IfStmt_print((ast_IfStmt*)s, out, indent);
      break;
   case ast_StmtKind_While:
      ast_WhileStmt_print((ast_WhileStmt*)s, out, indent);
      break;
   case ast_StmtKind_For:
      ast_ForStmt_print((ast_ForStmt*)s, out, indent);
      break;
   case ast_StmtKind_Switch:
      ast_SwitchStmt_print((ast_SwitchStmt*)s, out, indent);
      break;
   case ast_StmtKind_Break:
      ast_BreakStmt_print((ast_BreakStmt*)s, out, indent);
      break;
   case ast_StmtKind_Continue:
      ast_ContinueStmt_print((ast_ContinueStmt*)s, out, indent);
      break;
   case ast_StmtKind_Fallthrough:
      ast_FallthroughStmt_print((ast_FallthroughStmt*)s, out, indent);
      break;
   case ast_StmtKind_Label:
      ast_LabelStmt_print((ast_LabelStmt*)s, out, indent);
      break;
   case ast_StmtKind_Goto:
      ast_GotoStmt_print((ast_GotoStmt*)s, out, indent);
      break;
   case ast_StmtKind_Compound:
      ast_CompoundStmt_print((ast_CompoundStmt*)s, out, indent);
      break;
   case ast_StmtKind_Decl:
      ast_DeclStmt_print((ast_DeclStmt*)s, out, indent);
      break;
   case ast_StmtKind_Asm:
      ast_AsmStmt_print((ast_AsmStmt*)s, out, indent);
      break;
   case ast_StmtKind_Assert:
      ast_AssertStmt_print((ast_AssertStmt*)s, out, indent);
      break;
   }
}

static void ast_Stmt_printKind(const ast_Stmt* s, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Stmt);
   string_buffer_Buf_add(out, ast_stmtKind_names[ast_Stmt_getKind(s)]);
}

static ast_AsmStmt* ast_AsmStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, bool is_basic, bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* str)
{
   uint32_t size = 24;
   size += (ast_ExprList_size(constraints) * 8);
   size += (ast_ExprList_size(exprs) * 8);
   size += (ast_ExprList_size(clobbers) * 8);
   size += (num_inputs + num_outputs) * 4;
   ast_AsmStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Asm, loc);
   s->base.asmStmtBits.is_basic = is_basic;
   s->base.asmStmtBits.is_volatile = is_volatile;
   s->num_outputs = (uint8_t)num_outputs;
   s->num_inputs = (uint8_t)num_inputs;
   s->num_constraints = (uint8_t)ast_ExprList_size(constraints);
   s->num_exprs = (uint8_t)ast_ExprList_size(exprs);
   s->num_clobbers = (uint8_t)ast_ExprList_size(clobbers);
   s->asm_string = (ast_StringLiteral*)str;
   uint8_t* tail = (uint8_t*)s->constraints;
   if (s->num_constraints) {
      uint32_t sz = s->num_constraints * 8;
      memcpy(tail, ast_ExprList_getExprs(constraints), sz);
      tail += sz;
   }
   if (s->num_exprs) {
      uint32_t sz = s->num_exprs * 8;
      memcpy(tail, ast_ExprList_getExprs(exprs), sz);
      tail += sz;
   }
   if (s->num_clobbers) {
      uint32_t sz = s->num_clobbers * 8;
      memcpy(tail, ast_ExprList_getExprs(clobbers), sz);
      tail += sz;
   }
   uint32_t num_names = num_outputs + num_inputs;
   if (num_names) {
      memcpy(tail, names, num_names * 4);
   }
   return s;
}

static ast_Stmt* ast_AsmStmt_instantiate(ast_AsmStmt* s, ast_Instantiator* inst)
{
   return (ast_Stmt*)s;
}

static bool ast_AsmStmt_isVolatile(const ast_AsmStmt* s)
{
   return s->base.asmStmtBits.is_volatile;
}

static uint32_t ast_AsmStmt_getNumConstraints(const ast_AsmStmt* s)
{
   return s->num_constraints;
}

static uint32_t ast_AsmStmt_getNumClobbers(const ast_AsmStmt* s)
{
   return s->num_clobbers;
}

static uint32_t ast_AsmStmt_getNumExprs(const ast_AsmStmt* s)
{
   return s->num_exprs;
}

static uint32_t ast_AsmStmt_getNumOutputs(const ast_AsmStmt* s)
{
   return s->num_outputs;
}

static uint32_t ast_AsmStmt_getNumInputs(const ast_AsmStmt* s)
{
   return s->num_inputs;
}

static ast_StringLiteral* ast_AsmStmt_getString(const ast_AsmStmt* s)
{
   return s->asm_string;
}

static const ast_Expr** ast_AsmStmt_getConstraints(const ast_AsmStmt* s)
{
   return (const ast_Expr**)s->constraints;
}

static ast_Expr** ast_AsmStmt_getExprs(const ast_AsmStmt* s)
{
   uint8_t* tail = (uint8_t*)s->constraints;
   tail += s->num_constraints * 8;
   return (ast_Expr**)tail;
}

static ast_Expr** ast_AsmStmt_getClobbers(const ast_AsmStmt* s)
{
   uint8_t* tail = (uint8_t*)s->constraints;
   tail += s->num_constraints * 8;
   tail += s->num_exprs * 8;
   return (ast_Expr**)tail;
}

static uint32_t* ast_AsmStmt_getNames(const ast_AsmStmt* s)
{
   uint8_t* tail = (uint8_t*)s->constraints;
   tail += s->num_constraints * 8;
   tail += s->num_exprs * 8;
   tail += s->num_clobbers * 8;
   return (uint32_t*)tail;
}

static void ast_AsmStmt_print(const ast_AsmStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, indent);
   ast_StringLiteral_print(s->asm_string, out, 0);
   if (s->num_outputs) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "outputs\n");
      const uint32_t* names = ast_AsmStmt_getNames(s);
      const ast_Expr** constraints = ast_AsmStmt_getConstraints(s);
      ast_Expr** exprs = ast_AsmStmt_getExprs(s);
      for (uint32_t i = 0; i < s->num_outputs; i++) {
         string_buffer_Buf_indent(out, indent + 1);
         if (names[i]) {
            string_buffer_Buf_color(out, ast_col_Value);
            string_buffer_Buf_add(out, ast_idx2name(names[i]));
            string_buffer_Buf_space(out);
         }
         string_buffer_Buf_color(out, ast_col_Value);
         const ast_StringLiteral* sl = (ast_StringLiteral*)constraints[i];
         ast_StringLiteral_printLiteral(sl, out);
         string_buffer_Buf_newline(out);
         const ast_Expr* e = exprs[i];
         ast_Expr_print(e, out, indent + 1);
      }
   }
   if (s->num_inputs) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "inputs\n");
      const uint32_t* names = ast_AsmStmt_getNames(s);
      const ast_Expr** constraints = ast_AsmStmt_getConstraints(s);
      ast_Expr** exprs = ast_AsmStmt_getExprs(s);
      for (uint32_t i = 0; i < s->num_inputs; i++) {
         string_buffer_Buf_indent(out, indent + 1);
         if (names[i + s->num_outputs]) {
            string_buffer_Buf_color(out, ast_col_Value);
            string_buffer_Buf_add(out, ast_idx2name(names[i + s->num_outputs]));
            string_buffer_Buf_space(out);
         }
         string_buffer_Buf_color(out, ast_col_Value);
         const ast_StringLiteral* sl = (ast_StringLiteral*)constraints[i + s->num_outputs];
         ast_StringLiteral_printLiteral(sl, out);
         string_buffer_Buf_newline(out);
         const ast_Expr* e = exprs[i + s->num_outputs];
         ast_Expr_print(e, out, indent + 1);
      }
   }
   if (s->num_clobbers) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "clobbers: ");
      ast_Expr** clobbers = ast_AsmStmt_getClobbers(s);
      for (uint32_t i = 0; i < s->num_clobbers; i++) {
         if (i != 0) string_buffer_Buf_space(out);
         ast_Expr_print(clobbers[i], out, indent + 1);
      }
   }
}

static ast_AssertStmt* ast_AssertStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* inner)
{
   ast_AssertStmt* s = ast_context_Context_alloc(c, 16);
   ast_Stmt_init(&s->base, ast_StmtKind_Assert, loc);
   s->inner = inner;
   return s;
}

static ast_Stmt* ast_AssertStmt_instantiate(ast_AssertStmt* s, ast_Instantiator* inst)
{
   return (ast_Stmt*)ast_AssertStmt_create(inst->c, s->base.loc, ast_Expr_instantiate(s->inner, inst));
}

static ast_Expr* ast_AssertStmt_getInner(const ast_AssertStmt* s)
{
   return s->inner;
}

static ast_Expr** ast_AssertStmt_getInner2(ast_AssertStmt* s)
{
   return &s->inner;
}

static void ast_AssertStmt_print(const ast_AssertStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_Expr_print(s->inner, out, indent + 1);
}

static ast_BreakStmt* ast_BreakStmt_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_BreakStmt* s = ast_context_Context_alloc(c, 8);
   ast_Stmt_init(&s->base, ast_StmtKind_Break, loc);
   return s;
}

static void ast_BreakStmt_print(const ast_BreakStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
}

static ast_CompoundStmt* ast_CompoundStmt_create(ast_context_Context* c, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count)
{
   ;//assert(count < 65556);
   uint32_t size = 8 + count * 8;
   ast_CompoundStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Compound, endLoc);
   s->base.compoundStmtBits.count = count;
   if (count) {
      memcpy(s->stmts, stmts, count * 8);
   }
   return s;
}

static ast_CompoundStmt* ast_CompoundStmt_instantiate(ast_CompoundStmt* s, ast_Instantiator* inst)
{
   const uint32_t count = s->base.compoundStmtBits.count;
   uint32_t size = 8 + count * 8;
   ast_CompoundStmt* s2 = ast_context_Context_alloc(inst->c, size);
   s2->base = s->base;
   for (uint32_t i = 0; i < count; i++) {
      s2->stmts[i] = ast_Stmt_instantiate(s->stmts[i], inst);
   }
   return s2;
}

static uint32_t ast_CompoundStmt_getCount(const ast_CompoundStmt* s)
{
   return s->base.compoundStmtBits.count;
}

static ast_Stmt** ast_CompoundStmt_getStmts(ast_CompoundStmt* s)
{
   if (ast_CompoundStmt_getCount(s)) return s->stmts;
   return NULL;
}

static src_loc_SrcLoc ast_CompoundStmt_getEndLoc(const ast_CompoundStmt* e)
{
   return e->base.loc + 1;
}

static void ast_CompoundStmt_print(const ast_CompoundStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   const uint32_t count = s->base.compoundStmtBits.count;
   for (uint32_t i = 0; i < count; i++) {
      ast_Stmt_print(s->stmts[i], out, indent + 1);
   }
}

static ast_ContinueStmt* ast_ContinueStmt_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_ContinueStmt* s = ast_context_Context_alloc(c, 8);
   ast_Stmt_init(&s->base, ast_StmtKind_Continue, loc);
   return s;
}

static void ast_ContinueStmt_print(const ast_ContinueStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
}

static ast_FallthroughStmt* ast_FallthroughStmt_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_FallthroughStmt* s = ast_context_Context_alloc(c, 8);
   ast_Stmt_init(&s->base, ast_StmtKind_Fallthrough, loc);
   return s;
}

static void ast_FallthroughStmt_print(const ast_FallthroughStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
}

static ast_ForStmt* ast_ForStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* cont, ast_Stmt* body)
{
   ast_ForStmt* s = ast_context_Context_alloc(c, 40);
   ast_Stmt_init(&s->base, ast_StmtKind_For, loc);
   s->init = init;
   s->cond = cond;
   s->cont = cont;
   s->body = body;
   return s;
}

static ast_Stmt* ast_ForStmt_instantiate(ast_ForStmt* s, ast_Instantiator* inst)
{
   ast_Stmt* init2 = s->init ? ast_Stmt_instantiate(s->init, inst) : NULL;
   ast_Expr* cond2 = s->cond ? ast_Expr_instantiate(s->cond, inst) : NULL;
   ast_Expr* cont2 = s->cont ? ast_Expr_instantiate(s->cont, inst) : NULL;
   ast_Stmt* body2 = s->body ? ast_Stmt_instantiate(s->body, inst) : NULL;
   return (ast_Stmt*)ast_ForStmt_create(inst->c, s->base.loc, init2, cond2, cont2, body2);
}

static ast_Stmt* ast_ForStmt_getInit(const ast_ForStmt* s)
{
   return s->init;
}

static ast_Expr* ast_ForStmt_getCond(const ast_ForStmt* s)
{
   return s->cond;
}

static ast_Expr* ast_ForStmt_getCont(const ast_ForStmt* s)
{
   return s->cont;
}

static ast_Stmt* ast_ForStmt_getBody(const ast_ForStmt* s)
{
   return s->body;
}

static ast_Stmt** ast_ForStmt_getInit2(ast_ForStmt* s)
{
   return s->init ? &s->init : NULL;
}

static ast_Expr** ast_ForStmt_getCond2(ast_ForStmt* s)
{
   return s->cond ? &s->cond : NULL;
}

static ast_Expr** ast_ForStmt_getCont2(ast_ForStmt* s)
{
   return s->cont ? &s->cont : NULL;
}

static void ast_ForStmt_print(const ast_ForStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   if (s->init) ast_Stmt_print(s->init, out, indent + 1);
   if (s->cond) ast_Expr_print(s->cond, out, indent + 1);
   if (s->cont) ast_Expr_print(s->cont, out, indent + 1);
   if (s->body) ast_Stmt_print(s->body, out, indent + 1);
}

static ast_GotoStmt* ast_GotoStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc)
{
   ast_GotoStmt* s = ast_context_Context_alloc(c, 12);
   ast_Stmt_init(&s->base, ast_StmtKind_Goto, loc);
   s->name = name;
   return s;
}

static const char* ast_GotoStmt_getName(const ast_GotoStmt* g)
{
   return ast_idx2name(g->name);
}

static uint32_t ast_GotoStmt_getNameIdx(const ast_GotoStmt* g)
{
   return g->name;
}

static void ast_GotoStmt_print(const ast_GotoStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_print(out, " %s\n", ast_idx2name(s->name));
}

static ast_IfStmt* ast_IfStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt)
{
   uint32_t size = 24;
   if (else_stmt) size += 8;
   ast_IfStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_If, loc);
   s->cond = cond;
   s->then = then;
   if (else_stmt) {
      s->base.ifStmtBits.has_else = 1;
      s->else_stmt[0] = else_stmt;
   }
   return s;
}

static ast_Stmt* ast_IfStmt_instantiate(ast_IfStmt* s, ast_Instantiator* inst)
{
   ast_Stmt* cond2 = ast_Stmt_instantiate(s->cond, inst);
   ast_Stmt* then2 = ast_Stmt_instantiate(s->then, inst);
   ast_Stmt* else2 = NULL;
   if (s->base.ifStmtBits.has_else) else2 = ast_Stmt_instantiate(s->else_stmt[0], inst);
   return (ast_Stmt*)ast_IfStmt_create(inst->c, s->base.loc, cond2, then2, else2);
}

static ast_Stmt* ast_IfStmt_getCond(const ast_IfStmt* s)
{
   return s->cond;
}

static ast_Stmt** ast_IfStmt_getCond2(ast_IfStmt* s)
{
   return &s->cond;
}

static ast_Stmt* ast_IfStmt_getThen(const ast_IfStmt* s)
{
   return s->then;
}

static ast_Stmt* ast_IfStmt_getElse(const ast_IfStmt* s)
{
   if (s->base.ifStmtBits.has_else) return s->else_stmt[0];
   return NULL;
}

static void ast_IfStmt_print(const ast_IfStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_Stmt_print(s->cond, out, indent + 1);
   ast_Stmt_print(s->then, out, indent + 1);
   if (s->base.ifStmtBits.has_else) ast_Stmt_print(s->else_stmt[0], out, indent + 1);
}

static ast_LabelStmt* ast_LabelStmt_create(ast_context_Context* c, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt)
{
   ast_LabelStmt* s = ast_context_Context_alloc(c, 24);
   ast_Stmt_init(&s->base, ast_StmtKind_Label, loc);
   s->name = name;
   s->stmt = stmt;
   return s;
}

static ast_Stmt* ast_LabelStmt_instantiate(ast_LabelStmt* s, ast_Instantiator* inst)
{
   if (!s->stmt) return (ast_Stmt*)s;
   return (ast_Stmt*)ast_LabelStmt_create(inst->c, s->name, s->base.loc, ast_Stmt_instantiate(s->stmt, inst));
}

static void ast_LabelStmt_setUsed(ast_LabelStmt* s)
{
   s->base.labelStmtBits.is_used = true;
}

static bool ast_LabelStmt_isUsed(const ast_LabelStmt* s)
{
   return s->base.labelStmtBits.is_used;
}

static const char* ast_LabelStmt_getName(const ast_LabelStmt* s)
{
   return ast_idx2name(s->name);
}

static uint32_t ast_LabelStmt_getNameIdx(const ast_LabelStmt* s)
{
   return s->name;
}

static ast_Stmt* ast_LabelStmt_getStmt(const ast_LabelStmt* s)
{
   return s->stmt;
}

static void ast_LabelStmt_print(const ast_LabelStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_idx2name(s->name));
   if (!ast_LabelStmt_isUsed(s)) {
      string_buffer_Buf_space(out);
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, "unused");
   }
   string_buffer_Buf_newline(out);
   if (s->stmt) ast_Stmt_print(s->stmt, out, indent + 1);
}

static ast_ReturnStmt* ast_ReturnStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* value)
{
   uint32_t size = 8;
   if (value) size += 8;
   ast_ReturnStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Return, loc);
   if (value) {
      s->base.returnStmtBits.has_value = 1;
      s->value[0] = value;
   }
   return s;
}

static ast_Stmt* ast_ReturnStmt_instantiate(ast_ReturnStmt* s, ast_Instantiator* inst)
{
   if (!s->base.returnStmtBits.has_value) return (ast_Stmt*)s;
   return (ast_Stmt*)ast_ReturnStmt_create(inst->c, s->base.loc, ast_Expr_instantiate(s->value[0], inst));
}

static ast_Expr* ast_ReturnStmt_getValue(const ast_ReturnStmt* s)
{
   if (s->base.returnStmtBits.has_value) return s->value[0];
   return NULL;
}

static ast_Expr** ast_ReturnStmt_getValue2(ast_ReturnStmt* s)
{
   if (s->base.returnStmtBits.has_value) return &s->value[0];
   return NULL;
}

static void ast_ReturnStmt_print(const ast_ReturnStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   if (s->base.returnStmtBits.has_value) {
      ast_Expr_print(s->value[0], out, indent + 1);
   }
}

static ast_SwitchCase* ast_SwitchCase_create(ast_context_Context* c, src_loc_SrcLoc loc, bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts)
{
   ;//assert(num_stmts < 1024);
   ;//assert(num_conds < 256);
   uint32_t size = 8 + num_conds * 8 + num_stmts * 8;
   ast_SwitchCase* s = ast_context_Context_alloc(c, size);
   s->allbits = 0;
   s->bits.num_conds = num_conds;
   s->bits.num_stmts = num_stmts;
   s->bits.is_default = is_default;
   s->loc = loc;
   memcpy(s->conds, conds, num_conds * 8);
   ast_Stmt** dst_stmts = ast_SwitchCase_getStmts(s);
   memcpy(dst_stmts, stmts, num_stmts * 8);
   return s;
}

static ast_SwitchCase* ast_SwitchCase_instantiate(ast_SwitchCase* src, ast_Instantiator* inst)
{
   uint32_t num_conds = src->bits.num_conds;
   uint32_t num_stmts = src->bits.num_stmts;
   uint32_t size = 8 + num_conds * 8 + num_stmts * 8;
   ast_SwitchCase* dst = ast_context_Context_alloc(inst->c, size);
   dst->allbits = src->allbits;
   dst->loc = src->loc;
   for (uint32_t i = 0; i < num_conds; i++) {
      dst->conds[i] = ast_Expr_instantiate(src->conds[i], inst);
   }
   ast_Stmt** src_stmts = ast_SwitchCase_getStmts(src);
   ast_Stmt** dst_stmts = ast_SwitchCase_getStmts(dst);
   for (uint32_t i = 0; i < num_stmts; i++) {
      dst_stmts[i] = ast_Stmt_instantiate(src_stmts[i], inst);
   }
   return dst;
}

static uint32_t ast_SwitchCase_getNumConds(const ast_SwitchCase* s)
{
   return s->bits.num_conds;
}

static ast_Expr* ast_SwitchCase_getCond(ast_SwitchCase* s, uint32_t index)
{
   return index < s->bits.num_conds ? s->conds[index] : NULL;
}

static uint32_t ast_SwitchCase_getNumStmts(const ast_SwitchCase* s)
{
   return s->bits.num_stmts;
}

static ast_Stmt** ast_SwitchCase_getStmts(ast_SwitchCase* s)
{
   return (ast_Stmt**)&s->conds[s->bits.num_conds];
}

static ast_Stmt* ast_SwitchCase_getStmt(const ast_SwitchCase* s, uint32_t n)
{
   if (n < s->bits.num_stmts) {
      ast_Stmt** stmts = (ast_Stmt**)&s->conds[s->bits.num_conds];
      return stmts[n];
   }
   return NULL;
}

static bool ast_SwitchCase_isDefault(const ast_SwitchCase* s)
{
   return s->bits.is_default;
}

static bool ast_SwitchCase_hasDecls(const ast_SwitchCase* s)
{
   return s->bits.has_decls;
}

static void ast_SwitchCase_setHasDecls(ast_SwitchCase* s)
{
   s->bits.has_decls = 1;
}

static void ast_SwitchCase_setHasFallthrough(ast_SwitchCase* s)
{
   s->bits.has_fallthrough = 1;
}

static bool ast_SwitchCase_hasFallthrough(const ast_SwitchCase* s)
{
   return s->bits.has_fallthrough;
}

static src_loc_SrcLoc ast_SwitchCase_getLoc(const ast_SwitchCase* s)
{
   return s->loc;
}

static void ast_SwitchCase_print(const ast_SwitchCase* s, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Stmt);
   string_buffer_Buf_add(out, "SwitchCase");
   if (s->bits.is_default) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " default");
   }
   if (s->bits.has_decls) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " decls");
   }
   if (s->bits.num_conds > 1) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " multi");
   }
   if (s->bits.has_fallthrough) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " fallthrough");
   }
   string_buffer_Buf_newline(out);
   for (uint32_t i = 0; i < s->bits.num_conds; i++) {
      if (i != 0) string_buffer_Buf_add(out, ", ");
      ast_Expr_print(s->conds[i], out, indent + 1);
   }
   for (uint32_t i = 0; i < s->bits.num_stmts; i++) {
      ast_Stmt_print(ast_SwitchCase_getStmt(s, i), out, indent + 2);
   }
}

static ast_SwitchStmt* ast_SwitchStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_SwitchCase** cases, uint32_t numCases, bool has_default)
{
   uint32_t size = 16 + numCases * 8;
   ast_SwitchStmt* s = ast_context_Context_alloc(c, size);
   ast_Stmt_init(&s->base, ast_StmtKind_Switch, loc);
   s->base.switchStmtBits.has_default = has_default;
   s->base.switchStmtBits.num_cases = numCases;
   s->cond = cond;
   memcpy(s->cases, cases, numCases * 8);
   return s;
}

static ast_Stmt* ast_SwitchStmt_instantiate(ast_SwitchStmt* s, ast_Instantiator* inst)
{
   uint32_t numCases = ast_SwitchStmt_getNumCases(s);
   uint32_t size = 16 + numCases * 8;
   ast_SwitchStmt* s2 = ast_context_Context_alloc(inst->c, size);
   s2->base = s->base;
   s2->cond = ast_Stmt_instantiate(s->cond, inst);
   for (uint32_t i = 0; i < numCases; i++) {
      s2->cases[i] = ast_SwitchCase_instantiate(s->cases[i], inst);
   }
   return (ast_Stmt*)s2;
}

static ast_Stmt* ast_SwitchStmt_getCond(const ast_SwitchStmt* s)
{
   return s->cond;
}

static ast_Stmt** ast_SwitchStmt_getCond2(ast_SwitchStmt* s)
{
   return s->cond ? &s->cond : NULL;
}

static bool ast_SwitchStmt_isString(const ast_SwitchStmt* s)
{
   return s->base.switchStmtBits.is_string;
}

static void ast_SwitchStmt_setString(ast_SwitchStmt* s)
{
   s->base.switchStmtBits.is_string = true;
}

static bool ast_SwitchStmt_hasDefault(const ast_SwitchStmt* s)
{
   return s->base.switchStmtBits.has_default;
}

static uint32_t ast_SwitchStmt_getNumCases(const ast_SwitchStmt* s)
{
   return s->base.switchStmtBits.num_cases;
}

static ast_SwitchCase** ast_SwitchStmt_getCases(ast_SwitchStmt* s)
{
   return s->cases;
}

static void ast_SwitchStmt_print(const ast_SwitchStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   if (ast_SwitchStmt_isString(s)) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " string");
   }
   if (ast_SwitchStmt_hasDefault(s)) {
      string_buffer_Buf_color(out, ast_col_Attr);
      string_buffer_Buf_add(out, " has_default");
   }
   string_buffer_Buf_newline(out);
   ast_Stmt_print(s->cond, out, indent + 1);
   for (uint32_t i = 0; i < s->base.switchStmtBits.num_cases; i++) {
      ast_SwitchCase_print(s->cases[i], out, indent + 1);
   }
}

static ast_WhileStmt* ast_WhileStmt_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* body)
{
   ast_WhileStmt* s = ast_context_Context_alloc(c, 24);
   ast_Stmt_init(&s->base, ast_StmtKind_While, loc);
   s->cond = cond;
   s->body = body;
   return s;
}

static ast_Stmt* ast_WhileStmt_instantiate(ast_WhileStmt* s, ast_Instantiator* inst)
{
   ast_Stmt* cond2 = ast_Stmt_instantiate(s->cond, inst);
   ast_Stmt* body2 = ast_Stmt_instantiate(s->body, inst);
   return (ast_Stmt*)ast_WhileStmt_create(inst->c, s->base.loc, cond2, body2);
}

static void ast_WhileStmt_print(const ast_WhileStmt* s, string_buffer_Buf* out, uint32_t indent)
{
   ast_Stmt_printKind(&s->base, out, indent);
   string_buffer_Buf_newline(out);
   ast_Stmt_print(s->cond, out, indent + 1);
   ast_Stmt_print(s->body, out, indent + 1);
}

static ast_Stmt* ast_WhileStmt_getCond(const ast_WhileStmt* s)
{
   return s->cond;
}

static ast_Stmt** ast_WhileStmt_getCond2(ast_WhileStmt* s)
{
   return &s->cond;
}

static ast_Stmt* ast_WhileStmt_getBody(const ast_WhileStmt* s)
{
   return s->body;
}

static void ast_Expr_init(ast_Expr* e, ast_ExprKind k, src_loc_SrcLoc loc, bool ctv, bool ctc, bool has_effect, ast_ValType valtype)
{
   ast_Stmt_init(&e->base, ast_StmtKind_Expr, loc);
   e->base.exprBits.kind = k;
   e->base.exprBits.is_ctv = ctv;
   e->base.exprBits.is_ctc = ctc;
   e->base.exprBits.has_effect = has_effect;
   e->base.exprBits.valtype = valtype;
   e->qt.ptr = 0;
}

static ast_Expr* ast_Expr_instantiate(ast_Expr* e, ast_Instantiator* inst)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
      return e;
   case ast_ExprKind_Identifier:
      return ast_IdentifierExpr_instantiate((ast_IdentifierExpr*)e, inst);
   case ast_ExprKind_Type:
      return ast_TypeExpr_instantiate((ast_TypeExpr*)e, inst);
   case ast_ExprKind_Call:
      return ast_CallExpr_instantiate((ast_CallExpr*)e, inst);
   case ast_ExprKind_InitList:
      return ast_InitListExpr_instantiate((ast_InitListExpr*)e, inst);
   case ast_ExprKind_FieldDesignatedInit:
      return ast_FieldDesignatedInitExpr_instantiate((ast_FieldDesignatedInitExpr*)e, inst);
   case ast_ExprKind_ArrayDesignatedInit:
      return ast_ArrayDesignatedInitExpr_instantiate((ast_ArrayDesignatedInitExpr*)e, inst);
   case ast_ExprKind_BinaryOperator:
      return ast_BinaryOperator_instantiate((ast_BinaryOperator*)e, inst);
   case ast_ExprKind_UnaryOperator:
      return ast_UnaryOperator_instantiate((ast_UnaryOperator*)e, inst);
   case ast_ExprKind_ConditionalOperator:
      return ast_ConditionalOperator_instantiate((ast_ConditionalOperator*)e, inst);
   case ast_ExprKind_Builtin:
      return ast_BuiltinExpr_instantiate((ast_BuiltinExpr*)e, inst);
   case ast_ExprKind_ArraySubscript:
      return ast_ArraySubscriptExpr_instantiate((ast_ArraySubscriptExpr*)e, inst);
   case ast_ExprKind_Member:
      return ast_MemberExpr_instantiate((ast_MemberExpr*)e, inst);
   case ast_ExprKind_Paren:
      return ast_ParenExpr_instantiate((ast_ParenExpr*)e, inst);
   case ast_ExprKind_BitOffset:
      return ast_BitOffsetExpr_instantiate((ast_BitOffsetExpr*)e, inst);
   case ast_ExprKind_ExplicitCast:
      return ast_ExplicitCastExpr_instantiate((ast_ExplicitCastExpr*)e, inst);
   case ast_ExprKind_ImplicitCast:
      break;
   case ast_ExprKind_Range:
      return ast_RangeExpr_instantiate((ast_RangeExpr*)e, inst);
   case ast_ExprKind_NamedArgument:
      return ast_NamedArgument_instantiate((ast_NamedArgument*)e, inst);
   case ast_ExprKind_Alternate:
      return ast_AlternateExpr_instantiate((ast_AlternateExpr*)e, inst);
   }
   ast_Expr_dump(e);
   ;//assert(0);
   return NULL;
}

static ast_Stmt* ast_Expr_asStmt(ast_Expr* e)
{
   return &e->base;
}

static ast_ExprKind ast_Expr_getKind(const ast_Expr* e)
{
   return (ast_ExprKind)e->base.exprBits.kind;
}

static bool ast_Expr_isStringLiteral(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_StringLiteral;
}

static bool ast_Expr_isNil(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Nil;
}

static bool ast_Expr_isIdentifier(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Identifier;
}

static bool ast_Expr_isCall(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Call;
}

static bool ast_Expr_isUnaryOp(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_UnaryOperator;
}

static bool ast_Expr_isImplicitCast(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_ImplicitCast;
}

static bool ast_Expr_isType(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Type;
}

static bool ast_Expr_isInitList(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_InitList;
}

static bool ast_Expr_isTilde(const ast_Expr* e)
{
   while (ast_Expr_isParen(e)) {
      const ast_ParenExpr* p = (ast_ParenExpr*)e;
      e = ast_ParenExpr_getInner(p);
   }
   if (ast_Expr_getKind(e) == ast_ExprKind_UnaryOperator) {
      const ast_UnaryOperator* u = (ast_UnaryOperator*)e;
      return (ast_UnaryOperator_getOpcode(u) == ast_UnaryOpcode_Not);
   }
   return false;
}

static bool ast_Expr_isBinaryOperator(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_BinaryOperator;
}

static bool ast_Expr_isMember(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Member;
}

static bool ast_Expr_isFieldDesignatedInit(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_FieldDesignatedInit;
}

static bool ast_Expr_isArrayDesignatedInit(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_ArrayDesignatedInit;
}

static bool ast_Expr_isBitOffset(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_BitOffset;
}

static bool ast_Expr_isParen(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Paren;
}

static bool ast_Expr_isRange(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_Range;
}

static bool ast_Expr_isAssignment(const ast_Expr* e)
{
   return ast_Expr_isBinaryOperator(e) && ast_BinaryOperator_getOpcode(((ast_BinaryOperator*)e)) == ast_BinaryOpcode_Assign;
}

static bool ast_Expr_isInitlistAssignment(const ast_Expr* e)
{
   return ast_Expr_isAssignment(e) && ast_Expr_isInitList(ast_BinaryOperator_getRHS(((ast_BinaryOperator*)e)));
}

static bool ast_Expr_isNamedArgument(const ast_Expr* e)
{
   return ast_Expr_getKind(e) == ast_ExprKind_NamedArgument;
}

static bool ast_Expr_isCtv(const ast_Expr* e)
{
   return e->base.exprBits.is_ctv;
}

static bool ast_Expr_isCtc(const ast_Expr* e)
{
   return e->base.exprBits.is_ctc;
}

static void ast_Expr_setCtv(ast_Expr* e)
{
   e->base.exprBits.is_ctv = true;
}

static void ast_Expr_setCtc(ast_Expr* e)
{
   e->base.exprBits.is_ctc = true;
}

static void ast_Expr_copyCtcFlags(ast_Expr* e, const ast_Expr* other)
{
   e->base.exprBits.is_ctc = other->base.exprBits.is_ctc;
}

static void ast_Expr_copyConstantFlags(ast_Expr* e, const ast_Expr* other)
{
   e->base.exprBits.is_ctc = other->base.exprBits.is_ctc;
   e->base.exprBits.is_ctv = other->base.exprBits.is_ctv;
}

static void ast_Expr_combineConstantFlags(ast_Expr* e, const ast_Expr* lhs, const ast_Expr* rhs)
{
   e->base.exprBits.is_ctc = lhs->base.exprBits.is_ctc & rhs->base.exprBits.is_ctc;
   e->base.exprBits.is_ctv = lhs->base.exprBits.is_ctv & rhs->base.exprBits.is_ctv;
}

static bool ast_Expr_hasEffect(const ast_Expr* e)
{
   return e->base.exprBits.has_effect;
}

static ast_ValType ast_Expr_getValType(const ast_Expr* e)
{
   return (ast_ValType)e->base.exprBits.valtype;
}

static bool ast_Expr_isNValue(const ast_Expr* e)
{
   return ast_Expr_getValType(e) == ast_ValType_NValue;
}

static bool ast_Expr_isLValue(const ast_Expr* e)
{
   return ast_Expr_getValType(e) == ast_ValType_LValue;
}

static void ast_Expr_setLValue(ast_Expr* e)
{
   e->base.exprBits.valtype = ast_ValType_LValue;
}

static void ast_Expr_setRValue(ast_Expr* e)
{
   e->base.exprBits.valtype = ast_ValType_RValue;
}

static void ast_Expr_copyValType(ast_Expr* e, const ast_Expr* other)
{
   e->base.exprBits.valtype = other->base.exprBits.valtype;
}

static bool ast_Expr_isBitfield(const ast_Expr* e)
{
   if (!ast_Expr_isMember(e)) return false;
   const ast_MemberExpr* m = (ast_MemberExpr*)e;
   return ast_MemberExpr_isBitfield(m);
}

static bool ast_Expr_isPositiveOrUB(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
      return true;
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
   case ast_ExprKind_Identifier:
   case ast_ExprKind_Type:
   case ast_ExprKind_Call:
   case ast_ExprKind_InitList:
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator: {
      ast_BinaryOperator* b = (ast_BinaryOperator*)e;
      switch (ast_BinaryOperator_getOpcode(b)) {
      case ast_BinaryOpcode_Multiply:
      case ast_BinaryOpcode_Divide:
      case ast_BinaryOpcode_Remainder:
      case ast_BinaryOpcode_Add:
      case ast_BinaryOpcode_Subtract:
         return ast_Expr_isPositiveOrUB(ast_BinaryOperator_getLHS(b)) && ast_Expr_isPositiveOrUB(ast_BinaryOperator_getRHS(b));
      case ast_BinaryOpcode_ShiftLeft:
      case ast_BinaryOpcode_ShiftRight:
      case ast_BinaryOpcode_LessThan:
      case ast_BinaryOpcode_GreaterThan:
      case ast_BinaryOpcode_LessEqual:
      case ast_BinaryOpcode_GreaterEqual:
      case ast_BinaryOpcode_Equal:
      case ast_BinaryOpcode_NotEqual:
      case ast_BinaryOpcode_And:
      case ast_BinaryOpcode_Xor:
      case ast_BinaryOpcode_Or:
      case ast_BinaryOpcode_LAnd:
      case ast_BinaryOpcode_LOr:
         return true;
      default:
         break;
      }
      break;
   }
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* u = (ast_UnaryOperator*)e;
      switch (ast_UnaryOperator_getOpcode(u)) {
      case ast_UnaryOpcode_Plus:
         return ast_Expr_isPositiveOrUB(ast_UnaryOperator_getInner(u));
      case ast_UnaryOpcode_Minus:
         return false;
      case ast_UnaryOpcode_Not:
      case ast_UnaryOpcode_LNot:
         return true;
      default:
         break;
      }
      break;
   }
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = (ast_ConditionalOperator*)e;
      return ast_Expr_isPositiveOrUB(ast_ConditionalOperator_getLHS(c)) && ast_Expr_isPositiveOrUB(ast_ConditionalOperator_getRHS(c));
   }
   case ast_ExprKind_Builtin:
      return true;
   case ast_ExprKind_ArraySubscript:
   case ast_ExprKind_Member:
      break;
   case ast_ExprKind_Paren:
      return ast_Expr_isPositiveOrUB(ast_ParenExpr_getInner(((ast_ParenExpr*)e)));
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast:
   case ast_ExprKind_ImplicitCast:
      return ast_Expr_isPositiveOrUB(ast_ImplicitCastExpr_getInner(((ast_ImplicitCastExpr*)e)));
   case ast_ExprKind_Range:
   case ast_ExprKind_NamedArgument:
      break;
   case ast_ExprKind_Alternate:
      return ast_Expr_isPositiveOrUB(ast_AlternateExpr_getOriginal(((ast_AlternateExpr*)e)));
   }
   return false;
}

static src_loc_SrcLoc ast_Expr_getLoc(const ast_Expr* e)
{
   return e->base.loc;
}

static src_loc_SrcLoc ast_Expr_getStartLoc(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
   case ast_ExprKind_Identifier:
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      return ast_CallExpr_getStartLoc(((ast_CallExpr*)e));
   case ast_ExprKind_InitList:
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return ast_BinaryOperator_getStartLoc(((ast_BinaryOperator*)e));
   case ast_ExprKind_UnaryOperator:
      return ast_UnaryOperator_getStartLoc(((ast_UnaryOperator*)e));
   case ast_ExprKind_ConditionalOperator:
      return ast_ConditionalOperator_getStartLoc(((ast_ConditionalOperator*)e));
   case ast_ExprKind_Builtin:
      break;
   case ast_ExprKind_ArraySubscript:
      return ast_ArraySubscriptExpr_getStartLoc(((ast_ArraySubscriptExpr*)e));
   case ast_ExprKind_Member:
      return ast_MemberExpr_getStartLoc(((ast_MemberExpr*)e));
   case ast_ExprKind_Paren:
      break;
   case ast_ExprKind_BitOffset:
      return ast_BitOffsetExpr_getStartLoc(((ast_BitOffsetExpr*)e));
   case ast_ExprKind_ExplicitCast:
      break;
   case ast_ExprKind_ImplicitCast:
      return ast_ImplicitCastExpr_getStartLoc(((ast_ImplicitCastExpr*)e));
   case ast_ExprKind_Range:
      return ast_RangeExpr_getStartLoc(((ast_RangeExpr*)e));
   case ast_ExprKind_NamedArgument:
      return ast_NamedArgument_getStartLoc(((ast_NamedArgument*)e));
   case ast_ExprKind_Alternate:
      return ast_AlternateExpr_getStartLoc(((ast_AlternateExpr*)e));
   }
   return e->base.loc;
}

static src_loc_SrcLoc ast_Expr_getEndLoc(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      return ast_IntegerLiteral_getEndLoc(((ast_IntegerLiteral*)e));
   case ast_ExprKind_FloatLiteral:
      return ast_FloatLiteral_getEndLoc(((ast_FloatLiteral*)e));
   case ast_ExprKind_BooleanLiteral:
      return ast_BooleanLiteral_getEndLoc(((ast_BooleanLiteral*)e));
   case ast_ExprKind_CharLiteral:
      return ast_CharLiteral_getEndLoc(((ast_CharLiteral*)e));
   case ast_ExprKind_StringLiteral:
      return ast_StringLiteral_getEndLoc(((ast_StringLiteral*)e));
   case ast_ExprKind_Nil:
      return ast_NilExpr_getEndLoc(((ast_NilExpr*)e));
   case ast_ExprKind_Identifier:
      return ast_IdentifierExpr_getEndLoc(((ast_IdentifierExpr*)e));
   case ast_ExprKind_Type:
      return ast_TypeExpr_getEndLoc(((ast_TypeExpr*)e));
   case ast_ExprKind_Call:
      return ast_CallExpr_getEndLoc(((ast_CallExpr*)e));
   case ast_ExprKind_InitList:
      return ast_InitListExpr_getEndLoc(((ast_InitListExpr*)e));
   case ast_ExprKind_FieldDesignatedInit:
      return ast_FieldDesignatedInitExpr_getEndLoc(((ast_FieldDesignatedInitExpr*)e));
   case ast_ExprKind_ArrayDesignatedInit:
      return ast_ArrayDesignatedInitExpr_getEndLoc(((ast_ArrayDesignatedInitExpr*)e));
   case ast_ExprKind_BinaryOperator:
      return ast_BinaryOperator_getEndLoc(((ast_BinaryOperator*)e));
   case ast_ExprKind_UnaryOperator:
      return ast_UnaryOperator_getEndLoc(((ast_UnaryOperator*)e));
   case ast_ExprKind_ConditionalOperator:
      return ast_ConditionalOperator_getEndLoc(((ast_ConditionalOperator*)e));
   case ast_ExprKind_Builtin:
      return ast_BuiltinExpr_getEndLoc(((ast_BuiltinExpr*)e));
   case ast_ExprKind_ArraySubscript:
      return ast_ArraySubscriptExpr_getEndLoc(((ast_ArraySubscriptExpr*)e));
   case ast_ExprKind_Member:
      return ast_MemberExpr_getEndLoc(((ast_MemberExpr*)e));
   case ast_ExprKind_Paren:
      return ast_ParenExpr_getEndLoc(((ast_ParenExpr*)e));
   case ast_ExprKind_BitOffset:
      return ast_BitOffsetExpr_getEndLoc(((ast_BitOffsetExpr*)e));
   case ast_ExprKind_ExplicitCast:
      return ast_ExplicitCastExpr_getEndLoc(((ast_ExplicitCastExpr*)e));
   case ast_ExprKind_ImplicitCast:
      return ast_ImplicitCastExpr_getEndLoc(((ast_ImplicitCastExpr*)e));
   case ast_ExprKind_Range:
      return ast_RangeExpr_getEndLoc(((ast_RangeExpr*)e));
   case ast_ExprKind_NamedArgument:
      return ast_NamedArgument_getEndLoc(((ast_NamedArgument*)e));
   case ast_ExprKind_Alternate:
      return ast_AlternateExpr_getEndLoc(((ast_AlternateExpr*)e));
   }
   return e->base.loc;
}

static src_loc_SrcRange ast_Expr_getRange(const ast_Expr* e)
{
   src_loc_SrcRange range = { ast_Expr_getStartLoc(e), ast_Expr_getEndLoc(e) };
   return range;
}

static void ast_Expr_setType(ast_Expr* e, ast_QualType qt)
{
   e->qt = qt;
}

static ast_QualType ast_Expr_getType(const ast_Expr* e)
{
   return e->qt;
}

static bool ast_Expr_needsSemi(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
   case ast_ExprKind_Identifier:
   case ast_ExprKind_Type:
   case ast_ExprKind_Call:
      return true;
   case ast_ExprKind_InitList:
      return false;
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      ;//assert(0);
      break;
   case ast_ExprKind_BinaryOperator: {
      const ast_BinaryOperator* binop = (ast_BinaryOperator*)e;
      const ast_Expr* rhs = ast_BinaryOperator_getRHS(binop);
      return ast_Expr_needsSemi(rhs);
   }
   case ast_ExprKind_UnaryOperator:
   case ast_ExprKind_ConditionalOperator:
   case ast_ExprKind_Builtin:
   case ast_ExprKind_ArraySubscript:
   case ast_ExprKind_Member:
   case ast_ExprKind_Paren:
   case ast_ExprKind_BitOffset:
   case ast_ExprKind_ExplicitCast:
   case ast_ExprKind_ImplicitCast:
   case ast_ExprKind_Range:
      break;
   case ast_ExprKind_NamedArgument: {
      const ast_NamedArgument* n = (ast_NamedArgument*)e;
      return ast_Expr_needsSemi(ast_NamedArgument_getInner(n));
   }
   case ast_ExprKind_Alternate: {
      const ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      return ast_Expr_needsSemi(ast_AlternateExpr_getOriginal(n));
   }
   }
   return true;
}

static void ast_Expr_dump(const ast_Expr* e)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_Expr_print(e, out, 0);
   ast_flushDumpBuf(out);
}

static void ast_Expr_print(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      ast_IntegerLiteral_print((ast_IntegerLiteral*)e, out, indent);
      break;
   case ast_ExprKind_FloatLiteral:
      ast_FloatLiteral_print((ast_FloatLiteral*)e, out, indent);
      break;
   case ast_ExprKind_BooleanLiteral:
      ast_BooleanLiteral_print((ast_BooleanLiteral*)e, out, indent);
      break;
   case ast_ExprKind_CharLiteral:
      ast_CharLiteral_print((ast_CharLiteral*)e, out, indent);
      break;
   case ast_ExprKind_StringLiteral:
      ast_StringLiteral_print((ast_StringLiteral*)e, out, indent);
      break;
   case ast_ExprKind_Nil:
      ast_NilExpr_print((ast_NilExpr*)e, out, indent);
      break;
   case ast_ExprKind_Identifier:
      ast_IdentifierExpr_print((ast_IdentifierExpr*)e, out, indent);
      break;
   case ast_ExprKind_Type:
      ast_TypeExpr_print((ast_TypeExpr*)e, out, indent);
      break;
   case ast_ExprKind_Call:
      ast_CallExpr_print((ast_CallExpr*)e, out, indent);
      break;
   case ast_ExprKind_InitList:
      ast_InitListExpr_print((ast_InitListExpr*)e, out, indent);
      break;
   case ast_ExprKind_FieldDesignatedInit:
      ast_FieldDesignatedInitExpr_print((ast_FieldDesignatedInitExpr*)e, out, indent);
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      ast_ArrayDesignatedInitExpr_print((ast_ArrayDesignatedInitExpr*)e, out, indent);
      break;
   case ast_ExprKind_BinaryOperator:
      ast_BinaryOperator_print((ast_BinaryOperator*)e, out, indent);
      break;
   case ast_ExprKind_UnaryOperator:
      ast_UnaryOperator_print((ast_UnaryOperator*)e, out, indent);
      break;
   case ast_ExprKind_ConditionalOperator:
      ast_ConditionalOperator_print((ast_ConditionalOperator*)e, out, indent);
      break;
   case ast_ExprKind_Builtin:
      ast_BuiltinExpr_print((ast_BuiltinExpr*)e, out, indent);
      break;
   case ast_ExprKind_ArraySubscript:
      ast_ArraySubscriptExpr_print((ast_ArraySubscriptExpr*)e, out, indent);
      break;
   case ast_ExprKind_Member:
      ast_MemberExpr_print((ast_MemberExpr*)e, out, indent);
      break;
   case ast_ExprKind_Paren:
      ast_ParenExpr_print((ast_ParenExpr*)e, out, indent);
      break;
   case ast_ExprKind_BitOffset:
      ast_BitOffsetExpr_print((ast_BitOffsetExpr*)e, out, indent);
      break;
   case ast_ExprKind_ExplicitCast:
      ast_ExplicitCastExpr_print((ast_ExplicitCastExpr*)e, out, indent);
      break;
   case ast_ExprKind_ImplicitCast:
      ast_ImplicitCastExpr_print((ast_ImplicitCastExpr*)e, out, indent);
      break;
   case ast_ExprKind_Range:
      ast_RangeExpr_print((ast_RangeExpr*)e, out, indent);
      break;
   case ast_ExprKind_NamedArgument:
      ast_NamedArgument_print((ast_NamedArgument*)e, out, indent);
      break;
   case ast_ExprKind_Alternate:
      ast_AlternateExpr_print((ast_AlternateExpr*)e, out, indent);
      break;
   }
}

static void ast_Expr_printLiteral(const ast_Expr* e, string_buffer_Buf* out)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
      ast_IntegerLiteral_printLiteral((ast_IntegerLiteral*)e, out, false);
      return;
   case ast_ExprKind_FloatLiteral:
      ast_FloatLiteral_printLiteral((ast_FloatLiteral*)e, out);
      return;
   case ast_ExprKind_BooleanLiteral:
      ast_BooleanLiteral_printLiteral((ast_BooleanLiteral*)e, out);
      return;
   case ast_ExprKind_CharLiteral:
      ast_CharLiteral_printLiteral((ast_CharLiteral*)e, out);
      return;
   case ast_ExprKind_StringLiteral:
      ast_StringLiteral_printLiteral((ast_StringLiteral*)e, out);
      return;
   case ast_ExprKind_Nil:
      ast_NilExpr_printLiteral((ast_NilExpr*)e, out);
      return;
   case ast_ExprKind_Identifier:
      ast_IdentifierExpr_printLiteral((ast_IdentifierExpr*)e, out);
      return;
   case ast_ExprKind_Type:
      ast_TypeExpr_printLiteral((ast_TypeExpr*)e, out);
      return;
   case ast_ExprKind_Call:
      ast_CallExpr_printLiteral((ast_CallExpr*)e, out);
      return;
   case ast_ExprKind_InitList:
      ast_InitListExpr_printLiteral((ast_InitListExpr*)e, out);
      return;
   case ast_ExprKind_FieldDesignatedInit:
      ast_FieldDesignatedInitExpr_printLiteral((ast_FieldDesignatedInitExpr*)e, out);
      return;
   case ast_ExprKind_ArrayDesignatedInit:
      ast_ArrayDesignatedInitExpr_printLiteral((ast_ArrayDesignatedInitExpr*)e, out);
      return;
   case ast_ExprKind_BinaryOperator:
      ast_BinaryOperator_printLiteral((ast_BinaryOperator*)e, out);
      return;
   case ast_ExprKind_UnaryOperator:
      ast_UnaryOperator_printLiteral((ast_UnaryOperator*)e, out);
      return;
   case ast_ExprKind_ConditionalOperator:
      ast_ConditionalOperator_printLiteral((ast_ConditionalOperator*)e, out);
      return;
   case ast_ExprKind_Builtin:
      ast_BuiltinExpr_printLiteral((ast_BuiltinExpr*)e, out);
      return;
   case ast_ExprKind_ArraySubscript:
      ast_ArraySubscriptExpr_printLiteral((ast_ArraySubscriptExpr*)e, out);
      return;
   case ast_ExprKind_Member:
      ast_MemberExpr_printLiteral((ast_MemberExpr*)e, out);
      return;
   case ast_ExprKind_Paren:
      ast_ParenExpr_printLiteral((ast_ParenExpr*)e, out);
      return;
   case ast_ExprKind_BitOffset:
      ast_BitOffsetExpr_printLiteral((ast_BitOffsetExpr*)e, out);
      return;
   case ast_ExprKind_ExplicitCast:
      ast_ExplicitCastExpr_printLiteral((ast_ExplicitCastExpr*)e, out);
      return;
   case ast_ExprKind_ImplicitCast:
      ast_ImplicitCastExpr_printLiteral((ast_ImplicitCastExpr*)e, out);
      return;
   case ast_ExprKind_Range:
      ast_RangeExpr_printLiteral((ast_RangeExpr*)e, out);
      return;
   case ast_ExprKind_NamedArgument:
      ast_NamedArgument_printLiteral((ast_NamedArgument*)e, out);
      return;
   case ast_ExprKind_Alternate:
      ast_AlternateExpr_printLiteral((ast_AlternateExpr*)e, out);
      return;
   }
   string_buffer_Buf_print(out, "<<kind=%d>>", ast_Expr_getKind(e));
}

static void ast_Expr_printKind(const ast_Expr* e, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_color(out, ast_col_Expr);
   string_buffer_Buf_add(out, ast_exprKind_names[ast_Expr_getKind(e)]);
}

static void ast_Expr_printTypeBits(const ast_Expr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_space(out);
   ast_QualType_printQuoted(e->qt, out);
   string_buffer_Buf_color(out, ast_col_Attr);
   if (e->base.exprBits.is_ctc) string_buffer_Buf_add(out, " CTC");
   if (e->base.exprBits.is_ctv) string_buffer_Buf_add(out, " CTV");
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_valType_names[ast_Expr_getValType(e)]);
}

static ast_AlternateExpr* ast_AlternateExpr_create(ast_context_Context* c, ast_Expr* original, ast_Expr* generated)
{
   ast_AlternateExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_Alternate, ast_Expr_getLoc(original), 0, 0, 0, ast_ValType_NValue);
   e->original = original;
   e->generated = generated;
   ast_Expr_setType(&e->base, ast_Expr_getType(original));
   return e;
}

static ast_Expr* ast_AlternateExpr_instantiate(ast_AlternateExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_AlternateExpr_create(inst->c, ast_Expr_instantiate(e->original, inst), ast_Expr_instantiate(e->generated, inst));
}

static ast_Expr* ast_AlternateExpr_getOriginal(const ast_AlternateExpr* e)
{
   return e->original;
}

static ast_Expr* ast_AlternateExpr_getGenerated(const ast_AlternateExpr* e)
{
   return e->generated;
}

static void ast_AlternateExpr_print(const ast_AlternateExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->original, out, indent + 1);
   ast_Expr_print(e->generated, out, indent + 1);
}

static src_loc_SrcLoc ast_AlternateExpr_getStartLoc(const ast_AlternateExpr* e)
{
   return ast_Expr_getStartLoc(e->original);
}

static src_loc_SrcLoc ast_AlternateExpr_getEndLoc(const ast_AlternateExpr* e)
{
   return ast_Expr_getEndLoc(e->original);
}

static void ast_AlternateExpr_printLiteral(const ast_AlternateExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_lparen(out);
   ast_Expr_printLiteral(e->original, out);
   string_buffer_Buf_rparen(out);
}

static ast_ArrayDesignatedInitExpr* ast_ArrayDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue)
{
   ast_ArrayDesignatedInitExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_ArrayDesignatedInit, loc, 0, 0, 0, ast_ValType_RValue);
   e->designator = designator;
   e->initValue = initValue;
   return e;
}

static ast_Expr* ast_ArrayDesignatedInitExpr_instantiate(ast_ArrayDesignatedInitExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_ArrayDesignatedInitExpr_create(inst->c, e->base.base.loc, ast_Expr_instantiate(e->designator, inst), ast_Expr_instantiate(e->initValue, inst));
}

static ast_Expr* ast_ArrayDesignatedInitExpr_getDesignator(const ast_ArrayDesignatedInitExpr* e)
{
   return e->designator;
}

static ast_Expr** ast_ArrayDesignatedInitExpr_getDesignator2(ast_ArrayDesignatedInitExpr* e)
{
   return &e->designator;
}

static ast_Expr* ast_ArrayDesignatedInitExpr_getInit(const ast_ArrayDesignatedInitExpr* e)
{
   return e->initValue;
}

static ast_Expr** ast_ArrayDesignatedInitExpr_getInit2(ast_ArrayDesignatedInitExpr* e)
{
   return &e->initValue;
}

static src_loc_SrcLoc ast_ArrayDesignatedInitExpr_getEndLoc(const ast_ArrayDesignatedInitExpr* e)
{
   return ast_Expr_getEndLoc(e->initValue);
}

static void ast_ArrayDesignatedInitExpr_print(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->designator, out, indent + 1);
   ast_Expr_print(e->initValue, out, indent + 1);
}

static void ast_ArrayDesignatedInitExpr_printLiteral(const ast_ArrayDesignatedInitExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '[');
   ast_Expr_printLiteral(ast_ArrayDesignatedInitExpr_getDesignator(e), out);
   string_buffer_Buf_add(out, "] = ");
   ast_Expr_printLiteral(ast_ArrayDesignatedInitExpr_getInit(e), out);
}

static ast_ArraySubscriptExpr* ast_ArraySubscriptExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* lhs, ast_Expr* idx)
{
   ast_ArraySubscriptExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_ArraySubscript, loc, 0, 0, 0, ast_ValType_LValue);
   e->base.base.arraySubscriptExprBits.src_len = src_len;
   e->lhs = lhs;
   e->idx = idx;
   return e;
}

static ast_Expr* ast_ArraySubscriptExpr_instantiate(ast_ArraySubscriptExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_ArraySubscriptExpr_create(inst->c, e->base.base.loc, e->base.base.arraySubscriptExprBits.src_len, ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->idx, inst));
}

static ast_Expr* ast_ArraySubscriptExpr_getBase(const ast_ArraySubscriptExpr* e)
{
   return e->lhs;
}

static ast_Expr** ast_ArraySubscriptExpr_getBase2(ast_ArraySubscriptExpr* e)
{
   return &e->lhs;
}

static ast_Expr* ast_ArraySubscriptExpr_getIndex(const ast_ArraySubscriptExpr* e)
{
   return e->idx;
}

static ast_Expr** ast_ArraySubscriptExpr_getIndex2(ast_ArraySubscriptExpr* e)
{
   return &e->idx;
}

static src_loc_SrcLoc ast_ArraySubscriptExpr_getStartLoc(const ast_ArraySubscriptExpr* e)
{
   return ast_Expr_getStartLoc(ast_ArraySubscriptExpr_getBase(e));
}

static src_loc_SrcLoc ast_ArraySubscriptExpr_getEndLoc(const ast_ArraySubscriptExpr* e)
{
   return e->base.base.loc + e->base.base.arraySubscriptExprBits.src_len;
}

static void ast_ArraySubscriptExpr_printLiteral(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add1(out, '[');
   ast_Expr_printLiteral(e->idx, out);
   string_buffer_Buf_add1(out, ']');
}

static void ast_ArraySubscriptExpr_print(const ast_ArraySubscriptExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->lhs, out, indent + 1);
   ast_Expr_print(e->idx, out, indent + 1);
}

static bool ast_BinaryOpcode_isComparison(ast_BinaryOpcode opcode)
{
   return opcode >= ast_BinaryOpcode_LessThan && opcode <= ast_BinaryOpcode_NotEqual;
}

static const char* ast_BinaryOpcode_str(ast_BinaryOpcode opcode)
{
   return ast_binaryOpcode_names[opcode];
}

static ast_BinaryOperator* ast_BinaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_BinaryOpcode kind, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_BinaryOperator* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_BinaryOperator, loc, 0, 0, kind >= ast_BinaryOpcode_Assign, ast_ValType_RValue);
   e->base.base.binaryOperatorBits.kind = kind;
   e->lhs = lhs;
   e->rhs = rhs;
   return e;
}

static ast_Expr* ast_BinaryOperator_instantiate(ast_BinaryOperator* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_BinaryOperator_create(inst->c, e->base.base.loc, ast_BinaryOperator_getOpcode(e), ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst));
}

static ast_BinaryOpcode ast_BinaryOperator_getOpcode(const ast_BinaryOperator* e)
{
   return (ast_BinaryOpcode)e->base.base.binaryOperatorBits.kind;
}

static ast_Expr* ast_BinaryOperator_getLHS(const ast_BinaryOperator* e)
{
   return e->lhs;
}

static ast_Expr** ast_BinaryOperator_getLHS2(ast_BinaryOperator* e)
{
   return &e->lhs;
}

static ast_Expr* ast_BinaryOperator_getRHS(const ast_BinaryOperator* e)
{
   return e->rhs;
}

static ast_Expr** ast_BinaryOperator_getRHS2(ast_BinaryOperator* e)
{
   return &e->rhs;
}

static const char* ast_BinaryOperator_getOpcodeStr(const ast_BinaryOperator* e)
{
   return ast_binaryOpcode_names[ast_BinaryOperator_getOpcode(e)];
}

static src_loc_SrcLoc ast_BinaryOperator_getStartLoc(const ast_BinaryOperator* e)
{
   return ast_Expr_getStartLoc(ast_BinaryOperator_getLHS(e));
}

static src_loc_SrcLoc ast_BinaryOperator_getEndLoc(const ast_BinaryOperator* e)
{
   return ast_Expr_getEndLoc(ast_BinaryOperator_getRHS(e));
}

static void ast_BinaryOperator_print(const ast_BinaryOperator* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_add(out, ast_binaryOpcode_names[ast_BinaryOperator_getOpcode(e)]);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->lhs, out, indent + 1);
   ast_Expr_print(e->rhs, out, indent + 1);
}

static void ast_BinaryOperator_printLiteral(const ast_BinaryOperator* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_binaryOpcode_names[ast_BinaryOperator_getOpcode(e)]);
   string_buffer_Buf_space(out);
   ast_Expr_printLiteral(e->rhs, out);
}

static ast_BitOffsetExpr* ast_BitOffsetExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_BitOffsetExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_BitOffset, loc, 0, 0, 0, ast_ValType_RValue);
   e->lhs = lhs;
   e->rhs = rhs;
   return e;
}

static ast_Expr* ast_BitOffsetExpr_instantiate(ast_BitOffsetExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_BitOffsetExpr_create(inst->c, e->base.base.loc, ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst));
}

static ast_Expr* ast_BitOffsetExpr_getLHS(const ast_BitOffsetExpr* e)
{
   return e->lhs;
}

static ast_Expr** ast_BitOffsetExpr_getLHS2(ast_BitOffsetExpr* e)
{
   return &e->lhs;
}

static ast_Expr* ast_BitOffsetExpr_getRHS(const ast_BitOffsetExpr* e)
{
   return e->rhs;
}

static ast_Expr** ast_BitOffsetExpr_getRHS2(ast_BitOffsetExpr* e)
{
   return &e->rhs;
}

static void ast_BitOffsetExpr_setWidth(ast_BitOffsetExpr* e, uint8_t width)
{
   e->base.base.bitOffsetBits.width = width;
}

static uint32_t ast_BitOffsetExpr_getWidth(const ast_BitOffsetExpr* e)
{
   return e->base.base.bitOffsetBits.width;
}

static src_loc_SrcLoc ast_BitOffsetExpr_getStartLoc(const ast_BitOffsetExpr* e)
{
   return ast_Expr_getStartLoc(e->lhs);
}

static src_loc_SrcLoc ast_BitOffsetExpr_getEndLoc(const ast_BitOffsetExpr* e)
{
   return ast_Expr_getEndLoc(e->rhs);
}

static void ast_BitOffsetExpr_printLiteral(const ast_BitOffsetExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add1(out, ':');
   ast_Expr_printLiteral(e->rhs, out);
}

static void ast_BitOffsetExpr_print(const ast_BitOffsetExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, "%u", e->base.base.bitOffsetBits.width);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->lhs, out, indent + 1);
   ast_Expr_print(e->rhs, out, indent + 1);
}

static ast_BooleanLiteral* ast_BooleanLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, bool val)
{
   ast_BooleanLiteral* e = ast_context_Context_alloc(c, 16);
   ast_Expr_init(&e->base, ast_ExprKind_BooleanLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   e->base.base.booleanLiteralBits.value = val;
   ast_Expr_setType(&e->base, ast_getBuiltinQT(ast_BuiltinKind_Bool));
   return e;
}

static ast_Value ast_BooleanLiteral_getValue(const ast_BooleanLiteral* e)
{
   return ast_Value_createUnsigned(e->base.base.booleanLiteralBits.value);
}

static src_loc_SrcLoc ast_BooleanLiteral_getEndLoc(const ast_BooleanLiteral* e)
{
   return e->base.base.loc + (e->base.base.booleanLiteralBits.value ? 4 : 5);
}

static void ast_BooleanLiteral_print(const ast_BooleanLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_add(out, e->base.base.booleanLiteralBits.value ? "true" : "false");
   string_buffer_Buf_newline(out);
}

static void ast_BooleanLiteral_printLiteral(const ast_BooleanLiteral* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, e->base.base.booleanLiteralBits.value ? "true" : "false");
}

static ast_BuiltinExpr* ast_BuiltinExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind)
{
   const uint32_t size = 40;
   ast_BuiltinExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Builtin, loc, true, true, false, ast_ValType_RValue);
   e->base.base.builtinExprBits.kind = kind;
   e->base.base.builtinExprBits.src_len = src_len;
   e->inner = inner;
   ast_Value_setUnsigned(&e->value, 0);
   return e;
}

static ast_BuiltinExpr* ast_BuiltinExpr_createOffsetOf(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member)
{
   const uint32_t size = 40 + 8;
   ast_BuiltinExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Builtin, loc, true, true, false, ast_ValType_RValue);
   e->base.base.builtinExprBits.kind = ast_BuiltinExprKind_OffsetOf;
   e->base.base.builtinExprBits.src_len = src_len;
   e->inner = typeExpr;
   ast_Value_setUnsigned(&e->value, 0);
   e->offset[0].member = member;
   return e;
}

static ast_BuiltinExpr* ast_BuiltinExpr_createToContainer(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* typeExpr, ast_Expr* member, ast_Expr* pointer)
{
   const uint32_t size = 40 + 16;
   ast_BuiltinExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Builtin, loc, false, false, false, ast_ValType_RValue);
   e->base.base.builtinExprBits.kind = ast_BuiltinExprKind_ToContainer;
   e->base.base.builtinExprBits.src_len = src_len;
   e->inner = typeExpr;
   ast_Value_setUnsigned(&e->value, 0);
   e->container[0].member = member;
   e->container[0].pointer = pointer;
   return e;
}

static ast_Expr* ast_BuiltinExpr_instantiate(ast_BuiltinExpr* e, ast_Instantiator* inst)
{
   switch (ast_BuiltinExpr_getKind(e)) {
   case ast_BuiltinExprKind_Sizeof:
   case ast_BuiltinExprKind_Elemsof:
   case ast_BuiltinExprKind_EnumMin:
   case ast_BuiltinExprKind_EnumMax:
      return (ast_Expr*)ast_BuiltinExpr_create(inst->c, e->base.base.loc, e->base.base.builtinExprBits.src_len, ast_Expr_instantiate(e->inner, inst), ast_BuiltinExpr_getKind(e));
   case ast_BuiltinExprKind_OffsetOf:
      return (ast_Expr*)ast_BuiltinExpr_createOffsetOf(inst->c, e->base.base.loc, e->base.base.builtinExprBits.src_len, ast_Expr_instantiate(e->inner, inst), ast_Expr_instantiate(e->offset[0].member, inst));
   case ast_BuiltinExprKind_ToContainer:
      return (ast_Expr*)ast_BuiltinExpr_createToContainer(inst->c, e->base.base.loc, e->base.base.builtinExprBits.src_len, ast_Expr_instantiate(e->inner, inst), ast_Expr_instantiate(e->container[0].member, inst), ast_Expr_instantiate(e->container[0].pointer, inst));
   }
   return NULL;
}

static ast_BuiltinExprKind ast_BuiltinExpr_getKind(const ast_BuiltinExpr* e)
{
   return (ast_BuiltinExprKind)e->base.base.builtinExprBits.kind;
}

static ast_Value ast_BuiltinExpr_getValue(const ast_BuiltinExpr* e)
{
   return e->value;
}

static void ast_BuiltinExpr_setValue(ast_BuiltinExpr* e, ast_Value value)
{
   e->value = value;
}

static void ast_BuiltinExpr_setUValue(ast_BuiltinExpr* e, uint64_t val)
{
   ast_Value_setUnsigned(&e->value, val);
}

static ast_Expr* ast_BuiltinExpr_getInner(const ast_BuiltinExpr* e)
{
   return e->inner;
}

static src_loc_SrcLoc ast_BuiltinExpr_getEndLoc(const ast_BuiltinExpr* e)
{
   return e->base.base.loc + e->base.base.builtinExprBits.src_len;
}

static ast_Expr* ast_BuiltinExpr_getOffsetOfMember(const ast_BuiltinExpr* b)
{
   ;//assert(ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_OffsetOf);
   return b->offset[0].member;
}

static ast_Expr* ast_BuiltinExpr_getToContainerMember(const ast_BuiltinExpr* b)
{
   ;//assert(ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_ToContainer);
   return b->container[0].member;
}

static ast_Expr* ast_BuiltinExpr_getToContainerPointer(const ast_BuiltinExpr* b)
{
   ;//assert(ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_ToContainer);
   return b->container[0].pointer;
}

static ast_Expr** ast_BuiltinExpr_getToContainerPointer2(ast_BuiltinExpr* b)
{
   ;//assert(ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_ToContainer);
   return &b->container[0].pointer;
}

static void ast_BuiltinExpr_print(const ast_BuiltinExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_print(out, " %s", ast_builtin_names[ast_BuiltinExpr_getKind(e)]);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_print(out, " %s", ast_Value_str(&e->value));
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, indent + 1);
   switch (ast_BuiltinExpr_getKind(e)) {
   case ast_BuiltinExprKind_Sizeof:
      break;
   case ast_BuiltinExprKind_Elemsof:
      break;
   case ast_BuiltinExprKind_EnumMin:
      break;
   case ast_BuiltinExprKind_EnumMax:
      break;
   case ast_BuiltinExprKind_OffsetOf:
      ast_Expr_print(e->offset[0].member, out, indent + 1);
      break;
   case ast_BuiltinExprKind_ToContainer:
      ast_Expr_print(e->container[0].member, out, indent + 1);
      ast_Expr_print(e->container[0].pointer, out, indent + 1);
      break;
   }
}

static void ast_BuiltinExpr_printLiteral(const ast_BuiltinExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_builtin_names[ast_BuiltinExpr_getKind(e)]);
   string_buffer_Buf_lparen(out);
   switch (ast_BuiltinExpr_getKind(e)) {
   case ast_BuiltinExprKind_Sizeof:
      ast_Expr_printLiteral(e->inner, out);
      break;
   case ast_BuiltinExprKind_Elemsof:
   case ast_BuiltinExprKind_EnumMin:
   case ast_BuiltinExprKind_EnumMax:
      ast_Expr_printLiteral(e->inner, out);
      break;
   case ast_BuiltinExprKind_OffsetOf:
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->offset[0].member, out);
      break;
   case ast_BuiltinExprKind_ToContainer:
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->container[0].member, out);
      string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->container[0].pointer, out);
      break;
   }
   string_buffer_Buf_rparen(out);
}

static ast_CallExpr* ast_CallExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args)
{
   uint32_t size = 32 + num_args * 8;
   ast_CallExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Call, loc, 0, 0, 1, ast_ValType_RValue);
   e->base.base.callExprBits.num_args = (uint8_t)num_args;
   e->endLoc = endLoc;
   e->template_idx = 0;
   e->instance_ast_idx = 0;
   e->func = func;
   memcpy(e->args, args, num_args * 8);
   return e;
}

static ast_CallExpr* ast_CallExpr_createTemplate(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, uint32_t ast_idx, const ast_TypeRefHolder* ref)
{
   uint32_t size = 32 + num_args * 8;
   size += 8 + ast_TypeRefHolder_getExtraSize(ref);
   ast_CallExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Call, loc, 0, 0, 1, ast_ValType_RValue);
   e->base.base.callExprBits.is_template_call = 1;
   e->base.base.callExprBits.num_args = (uint8_t)num_args;
   e->endLoc = endLoc;
   e->template_idx = 0;
   e->instance_ast_idx = (uint16_t)ast_idx;
   e->func = func;
   memcpy(e->args, args, num_args * 8);
   ast_TypeRef* destRef = (ast_TypeRef*)&e->args[num_args];
   ast_TypeRef_init(destRef, ref);
   return e;
}

static ast_Expr* ast_CallExpr_instantiate(ast_CallExpr* e, ast_Instantiator* inst)
{
   ;//assert(!ast_CallExpr_isTemplateCall(e));
   uint32_t num_args = e->base.base.callExprBits.num_args;
   uint32_t size = 32 + num_args * 8;
   ast_CallExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   e2->endLoc = e->endLoc;
   e2->template_idx = 0;
   e2->instance_ast_idx = e->instance_ast_idx;
   e2->func = ast_Expr_instantiate(e->func, inst);
   for (uint32_t i = 0; i < num_args; i++) {
      e2->args[i] = ast_Expr_instantiate(e->args[i], inst);
   }
   return (ast_Expr*)e2;
}

static void ast_CallExpr_setCallsTypeFunc(ast_CallExpr* e)
{
   e->base.base.callExprBits.calls_type_func = 1;
}

static bool ast_CallExpr_isTypeFunc(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.calls_type_func;
}

static void ast_CallExpr_setCallsStaticTypeFunc(ast_CallExpr* e)
{
   e->base.base.callExprBits.calls_static_sf = 1;
}

static bool ast_CallExpr_isStaticTypeFunc(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.calls_static_sf;
}

static bool ast_CallExpr_isTemplateCall(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.is_template_call;
}

static ast_TypeRef* ast_CallExpr_getTemplateArg(const ast_CallExpr* e)
{
   if (ast_CallExpr_isTemplateCall(e)) return (ast_TypeRef*)&e->args[e->base.base.callExprBits.num_args];
   return NULL;
}

static void ast_CallExpr_setTemplateIdx(ast_CallExpr* e, uint32_t idx)
{
   e->template_idx = (uint16_t)idx;
}

static uint32_t ast_CallExpr_getTemplateIdx(const ast_CallExpr* e)
{
   return e->template_idx;
}

static uint16_t ast_CallExpr_getInstanceASTIdx(const ast_CallExpr* e)
{
   return e->instance_ast_idx;
}

static void ast_CallExpr_setNoreturn(ast_CallExpr* e)
{
   e->base.base.callExprBits.is_noreturn = 1;
}

static bool ast_CallExpr_isNoreturn(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.is_noreturn;
}

static void ast_CallExpr_setFormatAttr(ast_CallExpr* e, ast_FormatAttr kind)
{
   e->base.base.callExprBits.format_attr = kind;
}

static ast_FormatAttr ast_CallExpr_getFormatAttr(const ast_CallExpr* e)
{
   return (ast_FormatAttr)e->base.base.callExprBits.format_attr;
}

static void ast_CallExpr_setHasAutoArgs(ast_CallExpr* e)
{
   e->base.base.callExprBits.has_auto_args = 1;
}

static bool ast_CallExpr_hasAutoArgs(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.has_auto_args;
}

static src_loc_SrcLoc ast_CallExpr_getStartLoc(const ast_CallExpr* e)
{
   return ast_Expr_getStartLoc(e->func);
}

static src_loc_SrcLoc ast_CallExpr_getEndLoc(const ast_CallExpr* e)
{
   return e->endLoc;
}

static ast_Expr* ast_CallExpr_getFunc(const ast_CallExpr* e)
{
   return e->func;
}

static ast_Expr** ast_CallExpr_getFunc2(ast_CallExpr* e)
{
   return &e->func;
}

static uint32_t ast_CallExpr_getNumArgs(const ast_CallExpr* e)
{
   return e->base.base.callExprBits.num_args;
}

static ast_Expr** ast_CallExpr_getArgs(ast_CallExpr* e)
{
   return e->args;
}

static void ast_CallExpr_printLiteral(const ast_CallExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->func, out);
   string_buffer_Buf_lparen(out);
   for (uint32_t i = 0; i < ast_CallExpr_getNumArgs(e); i++) {
      if (i) string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->args[i], out);
   }
   string_buffer_Buf_rparen(out);
}

static void ast_CallExpr_print(const ast_CallExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   if (e->base.base.callExprBits.calls_type_func) string_buffer_Buf_add(out, " TF");
   if (e->base.base.callExprBits.calls_static_sf) string_buffer_Buf_add(out, " STF");
   if (e->base.base.callExprBits.is_noreturn) string_buffer_Buf_add(out, " noreturn");
   switch (ast_CallExpr_getFormatAttr(e)) {
   case ast_FormatAttr_None:
      break;
   case ast_FormatAttr_Printf:
      string_buffer_Buf_print(out, " printf");
      break;
   case ast_FormatAttr_Scanf:
      string_buffer_Buf_print(out, " scanf");
      break;
   }
   if (ast_CallExpr_hasAutoArgs(e)) string_buffer_Buf_add(out, " auto-args");
   string_buffer_Buf_newline(out);
   if (e->base.base.callExprBits.is_template_call) {
      string_buffer_Buf_indent(out, indent + 1);
      string_buffer_Buf_color(out, ast_col_Template);
      string_buffer_Buf_add(out, "template ");
      ast_TypeRef* ref = (ast_TypeRef*)&e->args[e->base.base.callExprBits.num_args];
      ast_TypeRef_print(ref, out, true);
      string_buffer_Buf_newline(out);
   }
   ast_Expr_print(e->func, out, indent + 1);
   for (uint32_t i = 0; i < ast_CallExpr_getNumArgs(e); i++) {
      ast_Expr_print(e->args[i], out, indent + 1);
   }
}

static ast_CharLiteral* ast_CharLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint8_t val, number_radix_Radix radix)
{
   ast_CharLiteral* e = ast_context_Context_alloc(c, 16);
   ast_Expr_init(&e->base, ast_ExprKind_CharLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   e->base.base.charLiteralBits.value = val;
   e->base.base.charLiteralBits.radix = radix;
   e->base.base.charLiteralBits.src_len = src_len;
   ast_Expr_setType(&e->base, ast_getBuiltinQT(ast_BuiltinKind_Char));
   return e;
}

static ast_Value ast_CharLiteral_getValue(const ast_CharLiteral* e)
{
   return ast_Value_createUnsigned(e->base.base.charLiteralBits.value);
}

static src_loc_SrcLoc ast_CharLiteral_getEndLoc(const ast_CharLiteral* e)
{
   return e->base.base.loc + e->base.base.charLiteralBits.src_len;
}

static void ast_CharLiteral_print(const ast_CharLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_CharLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static void ast_CharLiteral_printLiteral(const ast_CharLiteral* e, string_buffer_Buf* out)
{
   uint8_t c = (uint8_t)e->base.base.charLiteralBits.value;
   switch (e->base.base.charLiteralBits.radix) {
   case number_radix_Radix_Octal:
      string_buffer_Buf_print(out, "'\\%o'", c);
      return;
   case number_radix_Radix_Hex:
      string_buffer_Buf_print(out, "'\\x%02x'", c);
      return;
   default: {
      string_buffer_Buf_add1(out, '\'');
      char cc = c;
      string_buffer_Buf_encodeBytes(out, &cc, 1, '\'');
      string_buffer_Buf_add1(out, '\'');
      return;
   }
   }
}

static ast_ConditionalOperator* ast_ConditionalOperator_create(ast_context_Context* c, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_ConditionalOperator* e = ast_context_Context_alloc(c, 48);
   ast_Expr_init(&e->base, ast_ExprKind_ConditionalOperator, questionLoc, 0, 1, 1, ast_ValType_RValue);
   e->colonLoc = colonLoc;
   e->cond = cond;
   e->lhs = lhs;
   e->rhs = rhs;
   return e;
}

static ast_Expr* ast_ConditionalOperator_instantiate(ast_ConditionalOperator* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_ConditionalOperator_create(inst->c, e->base.base.loc, e->colonLoc, ast_Expr_instantiate(e->cond, inst), ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst));
}

static ast_Expr* ast_ConditionalOperator_getCond(const ast_ConditionalOperator* e)
{
   return e->cond;
}

static ast_Expr** ast_ConditionalOperator_getCond2(ast_ConditionalOperator* e)
{
   return &e->cond;
}

static ast_Expr* ast_ConditionalOperator_getLHS(const ast_ConditionalOperator* e)
{
   return e->lhs;
}

static ast_Expr** ast_ConditionalOperator_getLHS2(ast_ConditionalOperator* e)
{
   return &e->lhs;
}

static ast_Expr* ast_ConditionalOperator_getRHS(const ast_ConditionalOperator* e)
{
   return e->rhs;
}

static ast_Expr** ast_ConditionalOperator_getRHS2(ast_ConditionalOperator* e)
{
   return &e->rhs;
}

static src_loc_SrcLoc ast_ConditionalOperator_getStartLoc(const ast_ConditionalOperator* e)
{
   return ast_Expr_getStartLoc(ast_ConditionalOperator_getCond(e));
}

static src_loc_SrcLoc ast_ConditionalOperator_getEndLoc(const ast_ConditionalOperator* e)
{
   return ast_Expr_getEndLoc(ast_ConditionalOperator_getRHS(e));
}

static void ast_ConditionalOperator_printLiteral(const ast_ConditionalOperator* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->cond, out);
   string_buffer_Buf_add(out, " ? ");
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add(out, " : ");
   ast_Expr_printLiteral(e->rhs, out);
}

static void ast_ConditionalOperator_print(const ast_ConditionalOperator* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->cond, out, indent + 1);
   ast_Expr_print(e->lhs, out, indent + 1);
   ast_Expr_print(e->rhs, out, indent + 1);
}

static ast_ExplicitCastExpr* ast_ExplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, bool c_style)
{
   uint32_t size = 40 + ast_TypeRefHolder_getExtraSize(ref);
   ast_ExplicitCastExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_ExplicitCast, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.explicitCastExprBits.c_style = c_style;
   e->base.base.explicitCastExprBits.src_len = src_len;
   e->inner = inner;
   e->dest_type = ast_QualType_Invalid;
   ast_TypeRef_init(&e->dest, ref);
   return e;
}

static ast_Expr* ast_ExplicitCastExpr_instantiate(ast_ExplicitCastExpr* e, ast_Instantiator* inst)
{
   bool matches = ast_TypeRef_matchesTemplate(&e->dest, inst->template_name);
   uint32_t extra = matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&e->dest);
   uint32_t size = 40 + extra;
   ast_ExplicitCastExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   e2->inner = ast_Expr_instantiate(e->inner, inst);
   e2->dest_type = ast_QualType_Invalid;
   ast_TypeRef_instantiate(&e2->dest, &e->dest, inst);
   return (ast_Expr*)e2;
}

static void ast_ExplicitCastExpr_setDestType(ast_ExplicitCastExpr* e, ast_QualType qt)
{
   e->dest_type = qt;
}

static ast_QualType ast_ExplicitCastExpr_getDestType(const ast_ExplicitCastExpr* e)
{
   return e->dest_type;
}

static bool ast_ExplicitCastExpr_getCStyle(const ast_ExplicitCastExpr* e)
{
   return e->base.base.explicitCastExprBits.c_style;
}

static ast_Expr* ast_ExplicitCastExpr_getInner(const ast_ExplicitCastExpr* e)
{
   return e->inner;
}

static ast_Expr** ast_ExplicitCastExpr_getInner2(ast_ExplicitCastExpr* e)
{
   return &e->inner;
}

static ast_TypeRef* ast_ExplicitCastExpr_getTypeRef(ast_ExplicitCastExpr* e)
{
   return &e->dest;
}

static src_loc_SrcLoc ast_ExplicitCastExpr_getEndLoc(const ast_ExplicitCastExpr* e)
{
   return e->base.base.loc + e->base.base.explicitCastExprBits.src_len;
}

static void ast_ExplicitCastExpr_printLiteral(const ast_ExplicitCastExpr* e, string_buffer_Buf* out)
{
   if (e->base.base.explicitCastExprBits.c_style) {
      string_buffer_Buf_add1(out, '(');
      ast_TypeRef_print(&e->dest, out, true);
      string_buffer_Buf_add1(out, ')');
      ast_Expr_printLiteral(e->inner, out);
   } else {
      string_buffer_Buf_add(out, "cast<");
      ast_TypeRef_print(&e->dest, out, true);
      string_buffer_Buf_add(out, ">(");
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add1(out, ')');
   }
}

static void ast_ExplicitCastExpr_print(const ast_ExplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_add(out, " -> ");
   if (ast_QualType_isValid(e->dest_type)) {
      ast_QualType_printQuoted(e->dest_type, out);
   } else {
      ast_TypeRef_print(&e->dest, out, true);
   }
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, indent + 1);
}

static ast_FieldDesignatedInitExpr* ast_FieldDesignatedInitExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue)
{
   ast_FieldDesignatedInitExpr* e = ast_context_Context_alloc(c, 40);
   ast_Expr_init(&e->base, ast_ExprKind_FieldDesignatedInit, loc, 0, 0, 0, ast_ValType_RValue);
   e->field_name = field;
   e->initValue = initValue;
   e->fif = NULL;
   return e;
}

static ast_Expr* ast_FieldDesignatedInitExpr_instantiate(ast_FieldDesignatedInitExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_FieldDesignatedInitExpr_create(inst->c, e->base.base.loc, e->field_name, ast_Expr_instantiate(e->initValue, inst));
}

static uint32_t ast_FieldDesignatedInitExpr_getField(const ast_FieldDesignatedInitExpr* e)
{
   return e->field_name;
}

static const char* ast_FieldDesignatedInitExpr_getFieldName(const ast_FieldDesignatedInitExpr* e)
{
   return ast_idx2name(e->field_name);
}

static ast_Expr* ast_FieldDesignatedInitExpr_getInit(const ast_FieldDesignatedInitExpr* e)
{
   return e->initValue;
}

static ast_Expr** ast_FieldDesignatedInitExpr_getInit2(ast_FieldDesignatedInitExpr* e)
{
   return &e->initValue;
}

static src_loc_SrcLoc ast_FieldDesignatedInitExpr_getEndLoc(const ast_FieldDesignatedInitExpr* e)
{
   return ast_Expr_getEndLoc(e->initValue);
}

static void ast_FieldDesignatedInitExpr_setMemberInfo(ast_FieldDesignatedInitExpr* e, const ast_FieldInitField* fif)
{
   e->fif = fif;
}

static const ast_FieldInitField* ast_FieldDesignatedInitExpr_getMemberInfo(const ast_FieldDesignatedInitExpr* e)
{
   return e->fif;
}

static ast_Decl* ast_FieldDesignatedInitExpr_getDecl(const ast_FieldDesignatedInitExpr* e)
{
   if (e->fif) return e->fif->decl;
   return NULL;
}

static void ast_FieldDesignatedInitExpr_print(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_print(out, " %s", ast_FieldDesignatedInitExpr_getFieldName(e));
   string_buffer_Buf_space(out);
   if (e->fif) {
      ast_FieldInitField_print(e->fif, out);
   } else {
      string_buffer_Buf_color(out, ast_col_Error);
      string_buffer_Buf_add(out, "??");
   }
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->initValue, out, indent + 1);
}

static void ast_FieldDesignatedInitExpr_printLiteral(const ast_FieldDesignatedInitExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_FieldDesignatedInitExpr_getFieldName(e));
   string_buffer_Buf_add(out, " = ");
   ast_Expr_printLiteral(ast_FieldDesignatedInitExpr_getInit(e), out);
}

static ast_FloatLiteral* ast_FloatLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, double val, number_radix_Radix radix, ast_BuiltinKind kind)
{
   ast_FloatLiteral* i = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&i->base, ast_ExprKind_FloatLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   i->base.base.floatLiteralBits.radix = radix;
   i->base.base.floatLiteralBits.src_len = src_len;
   i->val = val;
   ast_Expr_setType(&i->base, ast_getBuiltinQT(kind));
   return i;
}

static ast_Value ast_FloatLiteral_getValue(const ast_FloatLiteral* e)
{
   return ast_Value_createFloat(e->val);
}

static src_loc_SrcLoc ast_FloatLiteral_getEndLoc(const ast_FloatLiteral* e)
{
   return e->base.base.loc + e->base.base.floatLiteralBits.src_len;
}

static void ast_FloatLiteral_print(const ast_FloatLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   ast_FloatLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static void ast_FloatLiteral_printLiteral(const ast_FloatLiteral* e, string_buffer_Buf* out)
{
   switch (e->base.base.floatLiteralBits.radix) {
   case number_radix_Radix_Hex:
      string_buffer_Buf_print(out, "%a", e->val);
      break;
   default: {
      char buf[32];
      string_buffer_Buf_add(out, ast_ftoa(buf, 32, e->val));
      break;
   }
   }
   ast_QualType qt = ast_Expr_getType(&e->base);
   if (ast_QualType_isFloat32(qt)) string_buffer_Buf_add1(out, 'F');
}

static const char* ast_IdentifierKind_str(ast_IdentifierKind k)
{
   switch (k) {
   case ast_IdentifierKind_Unresolved:
      return "Unresolved";
   case ast_IdentifierKind_Module:
      return "Module";
   case ast_IdentifierKind_Function:
      return "Function";
   case ast_IdentifierKind_Type:
      return "Type";
   case ast_IdentifierKind_Var:
      return "Var";
   case ast_IdentifierKind_EnumConstant:
      return "EnumConstant";
   case ast_IdentifierKind_StructMember:
      return "StructMember";
   case ast_IdentifierKind_Label:
      return "Label";
   }
   return "";
}

static ast_IdentifierExpr* ast_IdentifierExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t name, uint32_t name_len)
{
   ast_IdentifierExpr* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_Identifier, loc, 0, 0, 0, ast_ValType_NValue);
   e->name_idx = name;
   e->base.base.identifierExprBits.name_len = name_len;
   return e;
}

static ast_Expr* ast_IdentifierExpr_instantiate(ast_IdentifierExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_IdentifierExpr_create(inst->c, e->base.base.loc, e->name_idx, e->base.base.identifierExprBits.name_len);
}

static ast_Expr* ast_IdentifierExpr_asExpr(ast_IdentifierExpr* e)
{
   return &e->base;
}

static void ast_IdentifierExpr_setDecl(ast_IdentifierExpr* e, ast_Decl* decl)
{
   e->decl = decl;
   e->base.base.identifierExprBits.has_decl = true;
}

static bool ast_IdentifierExpr_hasDecl(const ast_IdentifierExpr* e)
{
   return e->base.base.identifierExprBits.has_decl;
}

static ast_Decl* ast_IdentifierExpr_getDecl(const ast_IdentifierExpr* e)
{
   if (!e->base.base.identifierExprBits.has_decl) return NULL;
   return e->decl;
}

static ast_Ref ast_IdentifierExpr_getRef(const ast_IdentifierExpr* e)
{
   ast_Ref ref = { e->base.base.loc, ast_IdentifierExpr_getNameIdx(e), ast_IdentifierExpr_getDecl(e) };
   return ref;
}

static void ast_IdentifierExpr_setKind(ast_IdentifierExpr* e, ast_IdentifierKind kind)
{
   e->base.base.identifierExprBits.kind = kind;
}

static ast_IdentifierKind ast_IdentifierExpr_getKind(const ast_IdentifierExpr* e)
{
   return (ast_IdentifierKind)e->base.base.identifierExprBits.kind;
}

static const char* ast_IdentifierExpr_getName(const ast_IdentifierExpr* e)
{
   if (e->base.base.identifierExprBits.has_decl) return ast_Decl_getName(e->decl);
   return ast_idx2name(e->name_idx);
}

static src_loc_SrcLoc ast_IdentifierExpr_getEndLoc(const ast_IdentifierExpr* e)
{
   return e->base.base.loc + e->base.base.identifierExprBits.name_len;
}

static uint32_t ast_IdentifierExpr_getNameIdx(const ast_IdentifierExpr* e)
{
   if (e->base.base.identifierExprBits.has_decl) return ast_Decl_getNameIdx(e->decl);
   return e->name_idx;
}

static void ast_IdentifierExpr_print(const ast_IdentifierExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   ast_IdentifierKind kind = ast_IdentifierExpr_getKind(e);
   if (kind == ast_IdentifierKind_Unresolved) string_buffer_Buf_color(out, ast_col_Error);
   else string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, ast_IdentifierKind_str(kind));
   string_buffer_Buf_space(out);
   if (e->base.base.identifierExprBits.has_decl) {
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_add(out, ast_Decl_getName(e->decl));
   } else {
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_add(out, ast_idx2name(e->name_idx));
   }
   string_buffer_Buf_newline(out);
}

static void ast_IdentifierExpr_printLiteral(const ast_IdentifierExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_IdentifierExpr_getName(e));
}

static ast_ImplicitCastExpr* ast_ImplicitCastExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_ImplicitCastKind kind, ast_Expr* inner)
{
   ast_ImplicitCastExpr* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_ImplicitCast, loc, 0, 0, 0, ast_ValType_RValue);
   e->base.base.implicitCastBits.kind = kind;
   e->inner = inner;
   ast_Expr_copyConstantFlags(&e->base, inner);
   switch (kind) {
   case ast_ImplicitCastKind_ArrayToPointerDecay:
      ast_Expr_copyValType(&e->base, inner);
      e->base.base.exprBits.is_ctv = false;
      break;
   case ast_ImplicitCastKind_LValueToRValue:
      e->base.base.exprBits.is_ctc = false;
      break;
   case ast_ImplicitCastKind_PointerToBoolean:
      ast_Expr_copyValType(&e->base, inner);
      break;
   case ast_ImplicitCastKind_PointerToInteger:
      ast_Expr_copyValType(&e->base, inner);
      break;
   case ast_ImplicitCastKind_IntegralCast:
      ast_Expr_copyValType(&e->base, inner);
      break;
   case ast_ImplicitCastKind_BitCast:
      e->base.base.exprBits.is_ctc = false;
      break;
   }
   return e;
}

static ast_ImplicitCastKind ast_ImplicitCastExpr_getKind(const ast_ImplicitCastExpr* e)
{
   return (ast_ImplicitCastKind)e->base.base.implicitCastBits.kind;
}

static bool ast_ImplicitCastExpr_isArrayToPointerDecay(const ast_ImplicitCastExpr* e)
{
   return ast_ImplicitCastExpr_getKind(e) == ast_ImplicitCastKind_ArrayToPointerDecay;
}

static ast_Expr* ast_ImplicitCastExpr_getInner(const ast_ImplicitCastExpr* e)
{
   return e->inner;
}

static void ast_ImplicitCastExpr_setInner(ast_ImplicitCastExpr* e, ast_Expr* inner)
{
   e->inner = inner;
}

static src_loc_SrcLoc ast_ImplicitCastExpr_getStartLoc(const ast_ImplicitCastExpr* e)
{
   return ast_Expr_getStartLoc(ast_ImplicitCastExpr_getInner(e));
}

static src_loc_SrcLoc ast_ImplicitCastExpr_getEndLoc(const ast_ImplicitCastExpr* e)
{
   return ast_Expr_getEndLoc(ast_ImplicitCastExpr_getInner(e));
}

static void ast_ImplicitCastExpr_printLiteral(const ast_ImplicitCastExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->inner, out);
}

static void ast_ImplicitCastExpr_print(const ast_ImplicitCastExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Calc);
   string_buffer_Buf_add(out, ast_implicitCastKind_names[ast_ImplicitCastExpr_getKind(e)]);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, indent + 1);
}

static ast_InitListExpr* ast_InitListExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values)
{
   uint32_t size = 24 + num_values * 8;
   ast_InitListExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_InitList, loc, 0, 0, 0, ast_ValType_RValue);
   e->endLoc = endLoc;
   e->num_values = num_values;
   if (num_values) {
      memcpy(e->values, values, num_values * 8);
   }
   return e;
}

static ast_Expr* ast_InitListExpr_instantiate(ast_InitListExpr* e, ast_Instantiator* inst)
{
   uint32_t num_values = ast_InitListExpr_getNumValues(e);
   uint32_t size = 24 + num_values * 8;
   ast_InitListExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   e2->endLoc = e->endLoc;
   e2->num_values = num_values;
   for (uint32_t i = 0; i < num_values; i++) {
      e2->values[i] = ast_Expr_instantiate(e->values[i], inst);
   }
   return (ast_Expr*)e2;
}

static bool ast_InitListExpr_isArray(const ast_InitListExpr* e)
{
   return e->base.base.initListExprBits.is_array;
}

static void ast_InitListExpr_setIsArray(ast_InitListExpr* e)
{
   e->base.base.initListExprBits.is_array = 1;
}

static bool ast_InitListExpr_hasDesignators(const ast_InitListExpr* e)
{
   return e->base.base.initListExprBits.has_designators;
}

static void ast_InitListExpr_setHasDesignators(ast_InitListExpr* e)
{
   e->base.base.initListExprBits.has_designators = 1;
}

static uint32_t ast_InitListExpr_getNumValues(const ast_InitListExpr* e)
{
   return e->num_values;
}

static ast_Expr** ast_InitListExpr_getValues(ast_InitListExpr* e)
{
   return e->values;
}

static const ast_Expr** ast_InitListExpr_getValues2(const ast_InitListExpr* e)
{
   return (const ast_Expr**)e->values;
}

static src_loc_SrcLoc ast_InitListExpr_getEndLoc(const ast_InitListExpr* e)
{
   return e->endLoc;
}

static void ast_InitListExpr_print(const ast_InitListExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   if (ast_InitListExpr_isArray(e)) string_buffer_Buf_add(out, " array");
   else string_buffer_Buf_add(out, " struct");
   if (ast_InitListExpr_hasDesignators(e)) string_buffer_Buf_add(out, " designators");
   string_buffer_Buf_newline(out);
   for (uint32_t i = 0; i < e->num_values; i++) {
      ast_Expr_print(e->values[i], out, indent + 1);
   }
}

static void ast_InitListExpr_printLiteral(const ast_InitListExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "{ ");
   for (uint32_t i = 0; i < e->num_values; i++) {
      if (i != 0) string_buffer_Buf_add(out, ", ");
      ast_Expr_printLiteral(e->values[i], out);
   }
   string_buffer_Buf_add1(out, '}');
}

static ast_IntegerLiteral* ast_IntegerLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint64_t val, number_radix_Radix radix, ast_BuiltinKind kind)
{
   ast_IntegerLiteral* i = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&i->base, ast_ExprKind_IntegerLiteral, loc, 1, 1, 0, ast_ValType_RValue);
   i->base.base.integerLiteralBits.radix = radix;
   i->base.base.integerLiteralBits.src_len = src_len;
   i->val = val;
   ast_Expr_setType(&i->base, ast_getBuiltinQT(kind));
   return i;
}

static ast_Value ast_IntegerLiteral_getValue(const ast_IntegerLiteral* e)
{
   return ast_Value_createUnsigned(e->val);
}

static src_loc_SrcLoc ast_IntegerLiteral_getEndLoc(const ast_IntegerLiteral* e)
{
   return e->base.base.loc + e->base.base.integerLiteralBits.src_len;
}

static void ast_printBinary(string_buffer_Buf* out, uint64_t value)
{
   char tmp[34];
   char* cp = &tmp[34 - 1];
   *cp = '\0';
   for (;;) {
      *--cp = '0' + (value & 0x1);
      value /= 2;
      if (value == 0) break;
   }
   *--cp = 'b';
   *--cp = '0';
   string_buffer_Buf_add(out, cp);
}

static void ast_printOctal(string_buffer_Buf* out, uint64_t value)
{
   char tmp[24];
   char* cp = &tmp[24 - 1];
   *cp = '\0';
   while (value) {
      *--cp = '0' + (value & 0x7);
      value /= 8;
   }
   *--cp = '0';
   string_buffer_Buf_add(out, cp);
}

static void ast_IntegerLiteral_print(const ast_IntegerLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_space(out);
   ast_IntegerLiteral_printLiteral(e, out, false);
   string_buffer_Buf_newline(out);
}

static void ast_IntegerLiteral_printLiteral(const ast_IntegerLiteral* e, string_buffer_Buf* out, bool c_style)
{
   switch (e->base.base.integerLiteralBits.radix) {
   case number_radix_Radix_Default:
      string_buffer_Buf_print(out, "%lu", e->val);
      break;
   case number_radix_Radix_Hex:
      string_buffer_Buf_print(out, "0x%lx", e->val);
      break;
   case number_radix_Radix_Octal:
      ast_printOctal(out, e->val);
      break;
   case number_radix_Radix_Binary:
      ast_printBinary(out, e->val);
      break;
   }
   if (c_style) {
      ast_QualType qt = ast_Expr_getType(&e->base);
      ast_BuiltinKind kind = ast_QualType_getBuiltinKind(&qt);
      if (kind == ast_BuiltinKind_UInt32 || kind == ast_BuiltinKind_UInt64) string_buffer_Buf_add1(out, 'U');
      if (kind == ast_BuiltinKind_Int64 || kind == ast_BuiltinKind_UInt64) string_buffer_Buf_add1(out, 'L');
   }
}

static ast_MemberExpr* ast_MemberExpr_create(ast_context_Context* c, ast_Expr* base, uint32_t base_name_idx, uint32_t base_len, src_loc_SrcLoc loc, uint32_t member_name_idx)
{
   uint32_t size = 32;
   ast_MemberExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Member, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.memberExprBits.base_len = base_len;
   e->refs[0].bits = 0;
   e->refs[0].name_idx = base_name_idx;
   if (base) {
      e->refs[0].expr = base;
      e->base.base.memberExprBits.has_expr = 1;
   }
   e->refs[1].bits = 0;
   e->refs[1].name_idx = member_name_idx;
   return e;
}

static ast_Expr* ast_MemberExpr_instantiate(ast_MemberExpr* e, ast_Instantiator* inst)
{
   uint32_t size = 32;
   ast_MemberExpr* e2 = ast_context_Context_alloc(inst->c, size);
   memcpy(e2, e, size);
   if (ast_MemberExpr_hasExpr(e2)) e2->refs[0].expr = ast_Expr_instantiate(e2->refs[0].expr, inst);
   return (ast_Expr*)e2;
}

static bool ast_MemberExpr_hasExpr(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.has_expr;
}

static ast_Expr* ast_MemberExpr_getBaseExpr(const ast_MemberExpr* e)
{
   if (ast_MemberExpr_hasExpr(e)) return e->refs[0].expr;
   return NULL;
}

static void ast_MemberExpr_setConversion(ast_MemberExpr* e, ast_MemberConversion c)
{
   e->base.base.memberExprBits.conversion = c;
}

static ast_MemberConversion ast_MemberExpr_getConversion(const ast_MemberExpr* e)
{
   return (ast_MemberConversion)e->base.base.memberExprBits.conversion;
}

static const char* ast_MemberExpr_getName(const ast_MemberExpr* e, uint32_t ref_idx)
{
   {
      uint32_t name_idx = ast_MemberExpr_getNameIdx(e, ref_idx);
      if (name_idx) return ast_idx2name(name_idx);
   }
   return NULL;
}

static uint32_t ast_MemberExpr_getNameIdx(const ast_MemberExpr* e, uint32_t ref_idx)
{
   if (ref_idx == 0 && ast_MemberExpr_hasExpr(e)) {
      ast_Expr* base = ast_MemberExpr_getBaseExpr(e);
      if (ast_Expr_isIdentifier(base)) return ast_IdentifierExpr_getNameIdx(((ast_IdentifierExpr*)base));
      return 0;
   }
   const ast_MemberRef* ref = &e->refs[ref_idx];
   if (e->base.base.memberExprBits.num_decls > ref_idx) {
      ast_Decl* d = ref->decl;
      if (ast_Decl_isImport(d)) {
         const ast_ImportDecl* id = (ast_ImportDecl*)d;
         uint32_t alias_idx = ast_ImportDecl_getAliasNameIdx(id);
         if (alias_idx) return alias_idx;
      }
      return ast_Decl_getNameIdx(d);
   }
   return ref->name_idx;
}

static src_loc_SrcLoc ast_MemberExpr_getLoc(const ast_MemberExpr* e, uint32_t ref_idx)
{
   src_loc_SrcLoc loc = ast_Expr_getLoc(&e->base);
   if (ref_idx) return loc;
   if (ast_MemberExpr_hasExpr(e)) return ast_Expr_getLoc(ast_MemberExpr_getBaseExpr(e));
   return loc - 1 - e->base.base.memberExprBits.base_len;
}

static src_loc_SrcLoc ast_MemberExpr_getMemberLoc(const ast_MemberExpr* e)
{
   return ast_Expr_getLoc(&e->base);
}

static src_loc_SrcLoc ast_MemberExpr_getStartLoc(const ast_MemberExpr* e)
{
   if (ast_MemberExpr_hasExpr(e)) return ast_Expr_getStartLoc(e->refs[0].expr);
   return ast_Expr_getLoc(&e->base) - 1 - e->base.base.memberExprBits.base_len;
}

static src_loc_SrcLoc ast_MemberExpr_getEndLoc(const ast_MemberExpr* e)
{
   return ast_Expr_getLoc(&e->base) + (uint32_t)strlen(ast_MemberExpr_getName(e, 1));
}

static src_loc_SrcLoc ast_MemberExpr_getBaseEndLoc(const ast_MemberExpr* e)
{
   if (ast_MemberExpr_hasExpr(e)) return ast_Expr_getEndLoc(ast_MemberExpr_getBaseExpr(e));
   return ast_Expr_getLoc(&e->base) - 1;
}

static src_loc_SrcRange ast_MemberExpr_getBaseRange(const ast_MemberExpr* e)
{
   return (src_loc_SrcRange){ ast_MemberExpr_getStartLoc(e), ast_MemberExpr_getBaseEndLoc(e) };
}

static ast_Ref ast_MemberExpr_getBaseRef(const ast_MemberExpr* e)
{
   ast_Ref ref;
   ref.loc = ast_MemberExpr_getStartLoc(e);
   ref.name_idx = ast_MemberExpr_getNameIdx(e, 0);
   ref.decl = ast_MemberExpr_getDecl(e, 0);
   return ref;
}

static ast_Ref ast_MemberExpr_getRef(const ast_MemberExpr* e)
{
   ast_Ref ref;
   ref.loc = ast_MemberExpr_getLoc(e, 1);
   ref.name_idx = ast_MemberExpr_getNameIdx(e, 1);
   ref.decl = ast_MemberExpr_getDecl(e, 1);
   return ref;
}

static ast_IdentifierKind ast_MemberExpr_getKind(const ast_MemberExpr* e)
{
   return (ast_IdentifierKind)e->base.base.memberExprBits.kind;
}

static void ast_MemberExpr_setKind(ast_MemberExpr* e, ast_IdentifierKind kind)
{
   e->base.base.memberExprBits.kind = kind;
}

static void ast_MemberExpr_setIsTypeFunc(ast_MemberExpr* e)
{
   e->base.base.memberExprBits.is_struct_func = 1;
}

static bool ast_MemberExpr_isTypeFunc(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_struct_func;
}

static void ast_MemberExpr_setBitfield(ast_MemberExpr* e)
{
   e->base.base.memberExprBits.is_bitfield = 1;
}

static bool ast_MemberExpr_isBitfield(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_bitfield;
}

static void ast_MemberExpr_setIsStaticTypeFunc(ast_MemberExpr* e)
{
   e->base.base.memberExprBits.is_static_sf = 1;
}

static bool ast_MemberExpr_isStaticTypeFunc(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_static_sf;
}

static void ast_MemberExpr_setConstBase(ast_MemberExpr* e, bool b)
{
   e->base.base.memberExprBits.is_const_base = b;
}

static bool ast_MemberExpr_isConstBase(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_const_base;
}

static void ast_MemberExpr_setVolatileBase(ast_MemberExpr* e, bool b)
{
   e->base.base.memberExprBits.is_volatile_base = b;
}

static bool ast_MemberExpr_isVolatileBase(const ast_MemberExpr* e)
{
   return e->base.base.memberExprBits.is_volatile_base;
}

static ast_Decl* ast_MemberExpr_getBaseDecl(const ast_MemberExpr* e)
{
   if (ast_MemberExpr_hasExpr(e)) {
      ast_Expr* base = ast_MemberExpr_getBaseExpr(e);
      if (ast_Expr_isIdentifier(base)) return ast_IdentifierExpr_getDecl(((ast_IdentifierExpr*)base));
      if (ast_Expr_isMember(base)) return ast_MemberExpr_getFullDecl(((ast_MemberExpr*)base));
      return NULL;
   }
   if (e->base.base.memberExprBits.num_decls < 1) return NULL;
   return e->refs[0].decl;
}

static ast_Decl* ast_MemberExpr_getFullDecl(const ast_MemberExpr* e)
{
   if (e->base.base.memberExprBits.num_decls < 2) return NULL;
   return e->refs[1].decl;
}

static ast_Decl* ast_MemberExpr_getDecl(const ast_MemberExpr* e, uint32_t ref_idx)
{
   if (e->base.base.memberExprBits.num_decls <= ref_idx) return NULL;
   return e->refs[ref_idx].decl;
}

static void ast_MemberExpr_setDecl(ast_MemberExpr* e, ast_Decl* d, uint32_t ref_idx)
{
   e->base.base.memberExprBits.num_decls = ref_idx + 1;
   e->refs[ref_idx].decl = d;
}

static ast_QualType ast_MemberExpr_getBaseType(const ast_MemberExpr* m)
{
   if (ast_MemberExpr_hasExpr(m)) return ast_Expr_getType(m->refs[0].expr);
   ast_QualType qt = ast_Decl_getType(m->refs[0].decl);
   if (ast_MemberExpr_isConstBase(m)) ast_QualType_setConst(&qt);
   if (ast_MemberExpr_isVolatileBase(m)) ast_QualType_setVolatile(&qt);
   return qt;
}

static const char* ast_MemberExpr_getMemberName(const ast_MemberExpr* e)
{
   return ast_MemberExpr_getName(e, 1);
}

static void ast_MemberExpr_print(const ast_MemberExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   ast_IdentifierKind kind = ast_MemberExpr_getKind(e);
   if (kind == ast_IdentifierKind_Unresolved) string_buffer_Buf_color(out, ast_col_Error);
   else string_buffer_Buf_color(out, ast_col_Attr);
   string_buffer_Buf_add(out, ast_IdentifierKind_str(kind));
   string_buffer_Buf_color(out, ast_col_Attr);
   if (ast_MemberExpr_isBitfield(e)) string_buffer_Buf_add(out, " bitfield");
   if (ast_MemberExpr_isTypeFunc(e)) string_buffer_Buf_add(out, " TF");
   if (ast_MemberExpr_isStaticTypeFunc(e)) string_buffer_Buf_add(out, " STF");
   if (ast_MemberExpr_isConstBase(e)) string_buffer_Buf_add(out, " const-base");
   if (ast_MemberExpr_isVolatileBase(e)) string_buffer_Buf_add(out, " volatile-base");
   switch (ast_MemberExpr_getConversion(e)) {
   case ast_MemberConversion_None:
      break;
   case ast_MemberConversion_Addr:
      string_buffer_Buf_add(out, " Addr");
      break;
   case ast_MemberConversion_Deref:
      string_buffer_Buf_add(out, " Deref");
      break;
   }
   string_buffer_Buf_print(out, " refs=%u/2 ", e->base.base.memberExprBits.num_decls);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_MemberExpr_printLiteral(e, out);
   string_buffer_Buf_newline(out);
   if (ast_MemberExpr_hasExpr(e)) ast_Expr_print(e->refs[0].expr, out, indent + 1);
}

static void ast_MemberExpr_printLiteral(const ast_MemberExpr* e, string_buffer_Buf* out)
{
   if (ast_MemberExpr_hasExpr(e)) {
      ast_Expr_printLiteral(e->refs[0].expr, out);
   } else {
      string_buffer_Buf_add(out, ast_MemberExpr_getName(e, 0));
   }
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_MemberExpr_getName(e, 1));
}

static void ast_MemberExpr_dump(const ast_MemberExpr* m)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   string_buffer_Buf_color(out, ast_col_Expr);
   string_buffer_Buf_print(out, "MemberExpr loc %u expr %d decl %u/2\n", ast_Expr_getLoc(&m->base), ast_MemberExpr_hasExpr(m), m->base.base.memberExprBits.num_decls);
   const ast_MemberExprBits* bits = &m->base.base.memberExprBits;
   ast_IdentifierKind k = (ast_IdentifierKind)bits->kind;
   string_buffer_Buf_print(out, "  bits: kind %s, sf %u, ssf %u, conv %u, bitf %u\n", ast_IdentifierKind_str(k), bits->is_struct_func, bits->is_static_sf, bits->conversion, bits->is_bitfield);
   uint32_t start = 0;
   if (ast_MemberExpr_hasExpr(m)) {
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_color(out, ast_col_Value);
      string_buffer_Buf_add(out, "<expr>\n");
      ast_Expr* e = ast_MemberExpr_getBaseExpr(m);
      ast_Expr_print(e, out, 1);
      start = 1;
   }
   for (uint32_t i = start; i < 2; i++) {
      const ast_MemberRef* ref = &m->refs[i];
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_color(out, ast_col_Expr);
      if (m->base.base.memberExprBits.num_decls > i) {
         string_buffer_Buf_print(out, "[%u]\n", i);
         ast_Decl_print(ref->decl, out, 1);
      } else {
         string_buffer_Buf_print(out, "[%u] %s\n", i, ast_idx2name(ref->name_idx));
      }
   }
   ast_flushDumpBuf(out);
}

static ast_NamedArgument* ast_NamedArgument_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t name, ast_Expr* inner)
{
   ast_NamedArgument* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_NamedArgument, loc, 0, 0, false, ast_ValType_RValue);
   e->name = name;
   e->inner = inner;
   return e;
}

static ast_Expr* ast_NamedArgument_instantiate(ast_NamedArgument* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_NamedArgument_create(inst->c, e->base.base.loc, e->name, ast_Expr_instantiate(e->inner, inst));
}

static uint32_t ast_NamedArgument_getNameIdx(const ast_NamedArgument* e)
{
   return e->name;
}

static ast_Expr* ast_NamedArgument_getInner(const ast_NamedArgument* e)
{
   return e->inner;
}

static ast_Expr** ast_NamedArgument_getInner2(ast_NamedArgument* e)
{
   return &e->inner;
}

static src_loc_SrcLoc ast_NamedArgument_getStartLoc(const ast_NamedArgument* e)
{
   return ast_Expr_getStartLoc(e->inner);
}

static src_loc_SrcLoc ast_NamedArgument_getEndLoc(const ast_NamedArgument* e)
{
   return ast_Expr_getEndLoc(e->inner);
}

static void ast_NamedArgument_print(const ast_NamedArgument* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_add(out, ast_idx2name(e->name));
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, indent + 1);
}

static void ast_NamedArgument_printLiteral(const ast_NamedArgument* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_idx2name(e->name));
   string_buffer_Buf_add(out, ": ");
   ast_Expr_printLiteral(e->inner, out);
}

static ast_NilExpr* ast_NilExpr_create(ast_context_Context* c, src_loc_SrcLoc loc)
{
   ast_NilExpr* e = ast_context_Context_alloc(c, 16);
   ast_Expr_init(&e->base, ast_ExprKind_Nil, loc, 1, 1, 0, ast_ValType_RValue);
   ast_Expr_setType(&e->base, ast_getVoidPtr());
   return e;
}

static src_loc_SrcLoc ast_NilExpr_getEndLoc(const ast_NilExpr* e)
{
   return e->base.base.loc + 3;
}

static void ast_NilExpr_print(const ast_NilExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
}

static void ast_NilExpr_printLiteral(const ast_NilExpr* _arg0, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "nil");
}

static ast_ParenExpr* ast_ParenExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner)
{
   ast_ParenExpr* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_Paren, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.parenExprBits.src_len = src_len;
   e->inner = inner;
   return e;
}

static ast_Expr* ast_ParenExpr_instantiate(ast_ParenExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_ParenExpr_create(inst->c, e->base.base.loc, e->base.base.parenExprBits.src_len, ast_Expr_instantiate(e->inner, inst));
}

static ast_Expr* ast_ParenExpr_getInner(const ast_ParenExpr* e)
{
   return e->inner;
}

static ast_Expr** ast_ParenExpr_getInner2(ast_ParenExpr* e)
{
   return &e->inner;
}

static void ast_ParenExpr_print(const ast_ParenExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, indent + 1);
}

static src_loc_SrcLoc ast_ParenExpr_getEndLoc(const ast_ParenExpr* e)
{
   return e->base.base.loc + e->base.base.parenExprBits.src_len;
}

static void ast_ParenExpr_printLiteral(const ast_ParenExpr* e, string_buffer_Buf* out)
{
   string_buffer_Buf_lparen(out);
   ast_Expr_printLiteral(e->inner, out);
   string_buffer_Buf_rparen(out);
}

static ast_RangeExpr* ast_RangeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_RangeExpr* e = ast_context_Context_alloc(c, 32);
   ast_Expr_init(&e->base, ast_ExprKind_Range, loc, 0, 0, false, ast_ValType_RValue);
   e->lhs = lhs;
   e->rhs = rhs;
   return e;
}

static ast_Expr* ast_RangeExpr_instantiate(ast_RangeExpr* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_RangeExpr_create(inst->c, e->base.base.loc, ast_Expr_instantiate(e->lhs, inst), ast_Expr_instantiate(e->rhs, inst));
}

static ast_Expr* ast_RangeExpr_getLHS(const ast_RangeExpr* e)
{
   return e->lhs;
}

static ast_Expr* ast_RangeExpr_getRHS(const ast_RangeExpr* e)
{
   return e->rhs;
}

static src_loc_SrcLoc ast_RangeExpr_getStartLoc(const ast_RangeExpr* e)
{
   return ast_Expr_getStartLoc(ast_RangeExpr_getLHS(e));
}

static src_loc_SrcLoc ast_RangeExpr_getEndLoc(const ast_RangeExpr* e)
{
   return ast_Expr_getEndLoc(ast_RangeExpr_getRHS(e));
}

static void ast_RangeExpr_print(const ast_RangeExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->lhs, out, indent + 1);
   ast_Expr_print(e->rhs, out, indent + 1);
}

static void ast_RangeExpr_printLiteral(const ast_RangeExpr* e, string_buffer_Buf* out)
{
   ast_Expr_printLiteral(e->lhs, out);
   string_buffer_Buf_add(out, " ... ");
   ast_Expr_printLiteral(e->rhs, out);
}

static ast_StringLiteral* ast_StringLiteral_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len)
{
   ast_StringLiteral* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_StringLiteral, loc, 0, 1, 0, ast_ValType_LValue);
   e->base.base.stringLiteralBits.src_len = src_len;
   e->value = value;
   e->size = len + 1;
   ast_Expr_setType(&e->base, ast_getStringType(len + 1));
   return e;
}

static const char* ast_StringLiteral_getText(const ast_StringLiteral* e)
{
   return ast_idx2name(e->value);
}

static uint32_t ast_StringLiteral_getTextIndex(const ast_StringLiteral* e)
{
   return e->value;
}

static uint32_t ast_StringLiteral_getSize(const ast_StringLiteral* e)
{
   return e->size;
}

static uint32_t ast_StringLiteral_strlen(const ast_StringLiteral* e)
{
   return e->size - 1;
}

static src_loc_SrcLoc ast_StringLiteral_getEndLoc(const ast_StringLiteral* e)
{
   return e->base.base.loc + e->base.base.stringLiteralBits.src_len;
}

static void ast_StringLiteral_printLiteral(const ast_StringLiteral* e, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '"');
   string_buffer_Buf_encodeBytes(out, ast_idx2name(e->value), e->size - 1, '"');
   string_buffer_Buf_add1(out, '"');
}

static void ast_StringLiteral_print(const ast_StringLiteral* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   ast_StringLiteral_printLiteral(e, out);
   string_buffer_Buf_newline(out);
}

static ast_TypeExpr* ast_TypeExpr_create(ast_context_Context* c, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref)
{
   uint32_t size = 24 + ast_TypeRefHolder_getExtraSize(ref);
   ast_TypeExpr* e = ast_context_Context_alloc(c, size);
   ast_Expr_init(&e->base, ast_ExprKind_Type, loc, 0, 0, 0, ast_ValType_NValue);
   e->base.base.typeExprBits.src_len = src_len;
   ast_TypeRef_init(&e->typeRef, ref);
   return e;
}

static ast_Expr* ast_TypeExpr_instantiate(ast_TypeExpr* e, ast_Instantiator* inst)
{
   bool matches = ast_TypeRef_matchesTemplate(&e->typeRef, inst->template_name);
   uint32_t extra = matches ? ast_TypeRef_getExtraSize(inst->ref) : ast_TypeRef_getExtraSize(&e->typeRef);
   uint32_t size = 24 + extra;
   ast_TypeExpr* e2 = ast_context_Context_alloc(inst->c, size);
   e2->base = e->base;
   ast_TypeRef_instantiate(&e2->typeRef, &e->typeRef, inst);
   return (ast_Expr*)e2;
}

static ast_TypeRef* ast_TypeExpr_getTypeRef(ast_TypeExpr* e)
{
   return &e->typeRef;
}

static src_loc_SrcLoc ast_TypeExpr_getEndLoc(const ast_TypeExpr* e)
{
   return e->base.base.loc + e->base.base.typeExprBits.src_len;
}

static void ast_TypeExpr_print(const ast_TypeExpr* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   ast_TypeRef_print(&e->typeRef, out, true);
   string_buffer_Buf_newline(out);
}

static void ast_TypeExpr_printLiteral(const ast_TypeExpr* e, string_buffer_Buf* out)
{
   ast_TypeRef_printLiteral(&e->typeRef, out, true);
}

static ast_UnaryOperator* ast_UnaryOperator_create(ast_context_Context* c, src_loc_SrcLoc loc, ast_UnaryOpcode kind, ast_Expr* inner)
{
   ast_UnaryOperator* e = ast_context_Context_alloc(c, 24);
   ast_Expr_init(&e->base, ast_ExprKind_UnaryOperator, loc, 0, 0, kind <= ast_UnaryOpcode_PreDec, kind == ast_UnaryOpcode_Deref ? ast_ValType_LValue : ast_ValType_RValue);
   e->base.base.unaryOperatorBits.kind = kind;
   e->inner = inner;
   return e;
}

static ast_Expr* ast_UnaryOperator_instantiate(ast_UnaryOperator* e, ast_Instantiator* inst)
{
   return (ast_Expr*)ast_UnaryOperator_create(inst->c, e->base.base.loc, ast_UnaryOperator_getOpcode(e), ast_Expr_instantiate(e->inner, inst));
}

static ast_UnaryOpcode ast_UnaryOperator_getOpcode(const ast_UnaryOperator* e)
{
   return (ast_UnaryOpcode)e->base.base.unaryOperatorBits.kind;
}

static ast_Expr* ast_UnaryOperator_getInner(const ast_UnaryOperator* e)
{
   return e->inner;
}

static ast_Expr** ast_UnaryOperator_getInner2(ast_UnaryOperator* e)
{
   return &e->inner;
}

static bool ast_UnaryOperator_isBefore(const ast_UnaryOperator* e)
{
   switch (ast_UnaryOperator_getOpcode(e)) {
   case ast_UnaryOpcode_PostInc:
   case ast_UnaryOpcode_PostDec:
      return false;
   case ast_UnaryOpcode_PreInc:
   case ast_UnaryOpcode_PreDec:
   case ast_UnaryOpcode_AddrOf:
   case ast_UnaryOpcode_Deref:
   case ast_UnaryOpcode_Plus:
   case ast_UnaryOpcode_Minus:
   case ast_UnaryOpcode_Not:
   case ast_UnaryOpcode_LNot:
      return true;
   }
   return true;
}

static src_loc_SrcLoc ast_UnaryOperator_getStartLoc(const ast_UnaryOperator* e)
{
   if (ast_UnaryOperator_isBefore(e)) return ast_Expr_getLoc(&e->base);
   return ast_Expr_getStartLoc(e->inner);
}

static src_loc_SrcLoc ast_UnaryOperator_getEndLoc(const ast_UnaryOperator* e)
{
   if (ast_UnaryOperator_isBefore(e)) return ast_Expr_getEndLoc(e->inner);
   return ast_Expr_getLoc(&e->base) + 2;
}

static const char* ast_UnaryOperator_getOpcodeStr(const ast_UnaryOperator* e)
{
   return ast_unaryOpcode_names[ast_UnaryOperator_getOpcode(e)];
}

static bool ast_UnaryOperator_isAddrOf(const ast_UnaryOperator* e)
{
   return ast_UnaryOperator_getOpcode(e) == ast_UnaryOpcode_AddrOf;
}

static void ast_UnaryOperator_print(const ast_UnaryOperator* e, string_buffer_Buf* out, uint32_t indent)
{
   ast_Expr_printKind(&e->base, out, indent);
   ast_Expr_printTypeBits(&e->base, out);
   string_buffer_Buf_space(out);
   string_buffer_Buf_color(out, ast_col_Value);
   string_buffer_Buf_add(out, ast_unaryOpcode_names[ast_UnaryOperator_getOpcode(e)]);
   string_buffer_Buf_newline(out);
   ast_Expr_print(e->inner, out, indent + 1);
}

static void ast_UnaryOperator_printLiteral(const ast_UnaryOperator* e, string_buffer_Buf* out)
{
   const char* opcode = ast_unaryOpcode_names[ast_UnaryOperator_getOpcode(e)];
   if (ast_UnaryOperator_isBefore(e)) {
      string_buffer_Buf_add(out, opcode);
      ast_Expr_printLiteral(e->inner, out);
   } else {
      ast_Expr_printLiteral(e->inner, out);
      string_buffer_Buf_add(out, opcode);
   }
}

static void ast_Type_init(ast_Type* t, ast_TypeKind k)
{
   t->bits = 0;
   t->typeBits.kind = k;
   t->ptr_pool_idx = 0;
   t->canonicalType.ptr = 0;
}

static ast_TypeKind ast_Type_getKind(const ast_Type* t)
{
   return t->typeBits.kind;
}

static ast_QualType ast_Type_getCanonicalType(const ast_Type* t)
{
   return t->canonicalType;
}

static void ast_Type_setCanonicalType(ast_Type* t, ast_QualType canon)
{
   t->canonicalType = canon;
}

static uint32_t ast_Type_getIndex(const ast_Type* t)
{
   return t->ptr_pool_idx;
}

static bool ast_Type_isBuiltinType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Builtin);
}

static bool ast_Type_isArrayType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Array);
}

static bool ast_Type_isStructType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Struct);
}

static bool ast_Type_isPointerType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Pointer);
}

static bool ast_Type_isFunctionType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Function);
}

static bool ast_Type_isEnumType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Enum);
}

static bool ast_Type_isVoidType(const ast_Type* t)
{
   return (ast_Type_getKind(t) == ast_TypeKind_Void);
}

static void ast_Type_dump(const ast_Type* t)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_Type_print(t, out);
   string_buffer_Buf_newline(out);
   ast_flushDumpBuf(out);
}

static uint32_t ast_Type_getAlignment(const ast_Type* t)
{
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin: {
      const ast_BuiltinType* bi = (ast_BuiltinType*)t;
      return ast_BuiltinType_getAlignment(bi);
   }
   case ast_TypeKind_Pointer:
      break;
   case ast_TypeKind_Array: {
      const ast_ArrayType* at = (ast_ArrayType*)t;
      ast_QualType elem = ast_ArrayType_getElemType(at);
      return ast_QualType_getAlignment(elem);
   }
   case ast_TypeKind_Struct: {
      const ast_StructType* s = (ast_StructType*)t;
      const ast_StructTypeDecl* std = ast_StructType_getDecl(s);
      return ast_StructTypeDecl_getAlignment(std);
   }
   case ast_TypeKind_Enum: {
      const ast_EnumType* e = (ast_EnumType*)t;
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(e);
      ast_QualType it = ast_EnumTypeDecl_getImplType(etd);
      return ast_Type_getAlignment(ast_QualType_getTypeOrNil(it));
   }
   case ast_TypeKind_Function:
      break;
   case ast_TypeKind_Void:
      return 0;
   case ast_TypeKind_Alias: {
      ast_QualType canon = ast_Type_getCanonicalType(t);
      return ast_QualType_getAlignment(canon);
   }
   case ast_TypeKind_Module:
      return 0;
   }
   return ast_getWordSize();
}

static uint32_t ast_Type_getSize(const ast_Type* t, bool deref_ptr)
{
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin: {
      const ast_BuiltinType* bi = (ast_BuiltinType*)t;
      return ast_BuiltinType_getAlignment(bi);
   }
   case ast_TypeKind_Pointer:
      if (deref_ptr) {
         const ast_PointerType* pt = (ast_PointerType*)t;
         ast_QualType inner = ast_PointerType_getInner(pt);
         return ast_QualType_getSize(inner, deref_ptr);
      }
      break;
   case ast_TypeKind_Array: {
      const ast_ArrayType* at = (ast_ArrayType*)t;
      ast_QualType elem = ast_ArrayType_getElemType(at);
      return ast_ArrayType_getSize(at) * ast_QualType_getSize(elem, false);
   }
   case ast_TypeKind_Struct: {
      const ast_StructType* s = (ast_StructType*)t;
      const ast_StructTypeDecl* std = ast_StructType_getDecl(s);
      return ast_StructTypeDecl_getSize(std);
   }
   case ast_TypeKind_Enum: {
      const ast_EnumType* e = (ast_EnumType*)t;
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(e);
      ast_QualType it = ast_EnumTypeDecl_getImplType(etd);
      return ast_Type_getSize(ast_QualType_getTypeOrNil(it), false);
   }
   case ast_TypeKind_Function:
      break;
   case ast_TypeKind_Void:
      return 0;
   case ast_TypeKind_Alias: {
      ast_QualType canon = ast_Type_getCanonicalType(t);
      return ast_QualType_getAlignment(canon);
   }
   case ast_TypeKind_Module:
      return 0;
   }
   return ast_getWordSize();
}

static void ast_Type_print(const ast_Type* t, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Type);
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      ast_BuiltinType_print((ast_BuiltinType*)t, out);
      break;
   case ast_TypeKind_Pointer:
      ast_PointerType_print((ast_PointerType*)t, out);
      break;
   case ast_TypeKind_Array:
      ast_ArrayType_print((ast_ArrayType*)t, out);
      break;
   case ast_TypeKind_Struct:
      ast_StructType_print((ast_StructType*)t, out);
      break;
   case ast_TypeKind_Enum:
      ast_EnumType_print((ast_EnumType*)t, out);
      break;
   case ast_TypeKind_Function:
      ast_FunctionType_print((ast_FunctionType*)t, out);
      break;
   case ast_TypeKind_Void:
      ast_VoidType_print((ast_VoidType*)t, out);
      break;
   case ast_TypeKind_Alias:
      ast_AliasType_print((ast_AliasType*)t, out);
      break;
   case ast_TypeKind_Module:
      ast_ModuleType_print((ast_ModuleType*)t, out);
      break;
   }
}

static void ast_Type_fullPrint(const ast_Type* t, string_buffer_Buf* out, uint32_t indent)
{
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      ast_BuiltinType_fullPrint((ast_BuiltinType*)t, out, indent);
      break;
   case ast_TypeKind_Pointer:
      ast_PointerType_fullPrint((ast_PointerType*)t, out, indent);
      break;
   case ast_TypeKind_Array:
      ast_ArrayType_fullPrint((ast_ArrayType*)t, out, indent);
      break;
   case ast_TypeKind_Struct:
      ast_StructType_fullPrint((ast_StructType*)t, out, indent);
      break;
   case ast_TypeKind_Enum:
      ast_EnumType_fullPrint((ast_EnumType*)t, out, indent);
      break;
   case ast_TypeKind_Function:
      ast_FunctionType_fullPrint((ast_FunctionType*)t, out, indent);
      break;
   case ast_TypeKind_Void:
      ast_VoidType_fullPrint((ast_VoidType*)t, out, indent);
      break;
   case ast_TypeKind_Alias:
      ast_AliasType_fullPrint((ast_AliasType*)t, out, indent);
      break;
   case ast_TypeKind_Module:
      ast_ModuleType_fullPrint((ast_ModuleType*)t, out, indent);
      break;
   }
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_add(out, "canonical=");
   ast_Type* canon = ast_QualType_getTypeOrNil(t->canonicalType);
   if (canon) {
      if (canon == t) {
         string_buffer_Buf_add(out, "this\n");
      } else {
         ast_Type_fullPrint(canon, out, indent + 1);
      }
   } else {
      string_buffer_Buf_add(out, "NIL\n");
   }
}

static ast_AliasType* ast_AliasType_create(ast_context_Context* c, ast_AliasTypeDecl* decl)
{
   ast_AliasType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Alias);
   t->decl = decl;
   return t;
}

static ast_AliasTypeDecl* ast_AliasType_getDecl(const ast_AliasType* t)
{
   return t->decl;
}

static void ast_AliasType_print(const ast_AliasType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "(alias)");
   string_buffer_Buf_add(out, ast_Decl_getModuleName(&t->decl->base));
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_Decl_getName(&t->decl->base));
}

static void ast_AliasType_fullPrint(const ast_AliasType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "AliasType [%p] %s\n", t, ast_Decl_getName(ast_AliasTypeDecl_asDecl(t->decl)));
}

static ast_ArrayType* ast_ArrayType_create(ast_context_Context* c, ast_QualType elem, bool has_size, uint32_t length, bool is_enum_index, ast_QualType index_type)
{
   uint32_t size = 32 + is_enum_index * 8;
   ast_ArrayType* t = ast_context_Context_alloc(c, size);
   ast_Type_init(&t->base, ast_TypeKind_Array);
   t->base.arrayTypeBits.is_incremental = false;
   t->base.arrayTypeBits.has_size = has_size;
   t->elem = elem;
   t->size = length;
   if (is_enum_index) {
      t->base.arrayTypeBits.is_enum_index = true;
      t->index_type[0] = index_type;
   }
   return t;
}

static ast_ArrayType* ast_ArrayType_createIncremental(ast_context_Context* c, ast_QualType elem)
{
   ast_ArrayType* t = ast_context_Context_alloc(c, 32);
   ast_Type_init(&t->base, ast_TypeKind_Array);
   t->base.arrayTypeBits.is_incremental = true;
   t->base.arrayTypeBits.has_size = false;
   t->elem = elem;
   t->size = 0;
   return t;
}

static ast_QualType ast_ArrayType_getElemType(const ast_ArrayType* t)
{
   return t->elem;
}

static uint32_t ast_ArrayType_hasSize(const ast_ArrayType* t)
{
   return t->base.arrayTypeBits.has_size;
}

static uint32_t ast_ArrayType_getSize(const ast_ArrayType* t)
{
   return t->size;
}

static void ast_ArrayType_setSize(ast_ArrayType* t, uint32_t size)
{
   t->base.arrayTypeBits.has_size = true;
   t->size = size;
}

static bool ast_ArrayType_isEnumIndex(const ast_ArrayType* t)
{
   return t->base.arrayTypeBits.is_enum_index;
}

static ast_QualType ast_ArrayType_getIndexType(const ast_ArrayType* t)
{
   if (t->base.arrayTypeBits.is_enum_index) return t->index_type[0];
   return ast_QualType_Invalid;
}

static void ast_ArrayType_printPreName(const ast_ArrayType* t, string_buffer_Buf* out)
{
   ast_QualType_print(t->elem, out);
}

static void ast_ArrayType_printPostName(const ast_ArrayType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_add1(out, '[');
   if (t->base.arrayTypeBits.is_incremental) {
      string_buffer_Buf_add1(out, '+');
   } else {
      string_buffer_Buf_print(out, "%u", t->size);
   }
   string_buffer_Buf_add1(out, ']');
}

static void ast_ArrayType_print(const ast_ArrayType* t, string_buffer_Buf* out)
{
   ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(t->elem);
   if (at) ast_ArrayType_printPreName(at, out);
   else ast_QualType_printInner(t->elem, out, false, true, true);
   ast_ArrayType_printPostName(t, out);
   if (at) ast_ArrayType_printPostName(at, out);
}

static void ast_ArrayType_fullPrint(const ast_ArrayType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "ArrayType [%p]", t);
   if (t->base.arrayTypeBits.has_size) string_buffer_Buf_print(out, " size=%u", t->size);
   string_buffer_Buf_newline(out);
   ast_QualType_fullPrint(t->elem, out, indent + 1);
}

static const char* ast_BuiltinKind_str(ast_BuiltinKind kind)
{
   return ast_builtinType_names[kind];
}

static ast_BuiltinType* ast_BuiltinType_create(ast_context_Context* c, ast_BuiltinKind kind)
{
   ast_BuiltinType* b = ast_context_Context_alloc(c, 16);
   ast_Type_init(&b->base, ast_TypeKind_Builtin);
   b->base.builtinTypeBits.kind = kind;
   ast_Type_setCanonicalType(&b->base, ast_QualType_create(&b->base));
   return b;
}

static ast_BuiltinKind ast_BuiltinType_getKind(const ast_BuiltinType* b)
{
   return (ast_BuiltinKind)b->base.builtinTypeBits.kind;
}

static ast_BuiltinKind ast_BuiltinType_getBaseKind(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_baseTypes[ast_BuiltinType_getKind(b)];
}

static ast_BuiltinKind ast_BuiltinType_getBuiltinKind(const ast_BuiltinType* b)
{
   return (ast_BuiltinKind)b->base.builtinTypeBits.kind;
}

static bool ast_BuiltinType_isInt32(const ast_BuiltinType* b)
{
   return ast_BuiltinType_getBuiltinKind(b) == ast_BuiltinKind_Int32;
}

static bool ast_BuiltinType_isBool(const ast_BuiltinType* b)
{
   return ast_BuiltinType_getBuiltinKind(b) == ast_BuiltinKind_Bool;
}

static const char* ast_BuiltinType_kind2str(const ast_BuiltinType* b)
{
   return ast_builtinType_names[ast_BuiltinType_getKind(b)];
}

static bool ast_BuiltinType_isPromotableIntegerType(const ast_BuiltinType* b)
{
   return ast_BuiltinType_promotable[ast_BuiltinType_getKind(b)];
}

static bool ast_BuiltinType_isInteger(const ast_BuiltinType* b)
{
   return ast_BuiltinType_integer[ast_BuiltinType_getKind(b)];
}

static bool ast_BuiltinType_isIntegerOrBool(const ast_BuiltinType* b)
{
   return ast_BuiltinType_isInteger(b) || ast_BuiltinType_getKind(b) == ast_BuiltinKind_Bool;
}

static bool ast_BuiltinType_isFloatingPoint(const ast_BuiltinType* b)
{
   return (ast_BuiltinType_getKind(b) == ast_BuiltinKind_Float32 || ast_BuiltinType_getKind(b) == ast_BuiltinKind_Float64);
}

static bool ast_BuiltinType_isSigned(const ast_BuiltinType* b)
{
   return ast_BuiltinType_signed[ast_BuiltinType_getKind(b)];
}

static bool ast_BuiltinType_isUnsigned(const ast_BuiltinType* b)
{
   return ast_BuiltinType_unsigned[ast_BuiltinType_getKind(b)];
}

static uint32_t ast_BuiltinType_getAlignment(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_sizes[ast_BuiltinType_getKind(b)];
}

static uint32_t ast_BuiltinType_getWidth(const ast_BuiltinType* b)
{
   return ast_globals->builtinType_width[ast_BuiltinType_getKind(b)];
}

static void ast_BuiltinType_print(const ast_BuiltinType* b, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_builtinType_names[ast_BuiltinType_getKind(b)]);
}

static void ast_BuiltinType_fullPrint(const ast_BuiltinType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "BuiltinType [%p] %s\n", t, ast_BuiltinType_kind2str(t));
}

static ast_EnumType* ast_EnumType_create(ast_context_Context* c, ast_EnumTypeDecl* decl)
{
   ast_EnumType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Enum);
   t->decl = decl;
   ast_Type_setCanonicalType(&t->base, ast_QualType_create((ast_Type*)t));
   return t;
}

static ast_EnumTypeDecl* ast_EnumType_getDecl(const ast_EnumType* t)
{
   return t->decl;
}

static ast_QualType ast_EnumType_getImplType(const ast_EnumType* t)
{
   return ast_EnumTypeDecl_getImplType(t->decl);
}

static const char* ast_EnumType_getName(const ast_EnumType* t)
{
   return ast_Decl_getName(&t->decl->base);
}

static void ast_EnumType_print(const ast_EnumType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, ast_Decl_getModuleName(&t->decl->base));
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_Decl_getName(&t->decl->base));
}

static void ast_EnumType_fullPrint(const ast_EnumType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "EnumType [%p] %s\n", t, ast_Decl_getName(ast_EnumTypeDecl_asDecl(t->decl)));
}

static ast_FunctionType* ast_FunctionType_create(ast_context_Context* c, ast_FunctionDecl* decl)
{
   ast_FunctionType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Function);
   t->decl = decl;
   ast_Type_setCanonicalType(&t->base, ast_QualType_create(&t->base));
   return t;
}

static ast_FunctionDecl* ast_FunctionType_getDecl(const ast_FunctionType* t)
{
   return t->decl;
}

static ast_Type* ast_FunctionType_asType(ast_FunctionType* t)
{
   return &t->base;
}

static void ast_FunctionType_print(const ast_FunctionType* t, string_buffer_Buf* out)
{
   ast_FunctionDecl_printType(t->decl, out);
}

static void ast_FunctionType_fullPrint(const ast_FunctionType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "FunctionType [%p] %s\n", t, ast_Decl_getName(ast_FunctionDecl_asDecl(t->decl)));
}

static ast_ModuleType* ast_ModuleType_create(ast_context_Context* c, ast_Module* mod)
{
   ast_ModuleType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Module);
   t->mod = mod;
   ast_Type_setCanonicalType(&t->base, ast_QualType_create(&t->base));
   return t;
}

static ast_Module* ast_ModuleType_getModule(const ast_ModuleType* t)
{
   return t->mod;
}

static void ast_ModuleType_print(const ast_ModuleType* t, string_buffer_Buf* out)
{
   string_buffer_Buf_print(out, "Module %s", ast_Module_getName(t->mod));
}

static void ast_ModuleType_fullPrint(const ast_ModuleType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "ModuleType %s\n", ast_Module_getName(t->mod));
}

static ast_PointerType* ast_PointerType_create(ast_context_Context* c, ast_QualType inner)
{
   ast_PointerType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Pointer);
   t->inner = inner;
   return t;
}

static ast_QualType ast_PointerType_getInner(const ast_PointerType* t)
{
   return t->inner;
}

static void ast_PointerType_print(const ast_PointerType* t, string_buffer_Buf* out)
{
   ast_QualType_printInner(t->inner, out, false, true, true);
   string_buffer_Buf_add1(out, '*');
}

static void ast_PointerType_fullPrint(const ast_PointerType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "PointerType [%p]\n", t);
   ast_QualType_fullPrint(t->inner, out, indent + 1);
}

static ast_QualType ast_QualType_create(ast_Type* t)
{
   ast_QualType qt = { (size_t)t };
   return qt;
}

static void ast_QualType_set(ast_QualType* qt, ast_Type* t)
{
   qt->ptr = (size_t)t;
}

static void ast_QualType_setConst(ast_QualType* qt)
{
   qt->ptr |= ast_QualType_Const;
}

static void ast_QualType_unsetConst(ast_QualType* qt)
{
   qt->ptr &= ~ast_QualType_Const;
}

static bool ast_QualType_isConst(const ast_QualType qt)
{
   return (qt.ptr & ast_QualType_Const) != 0;
}

static bool ast_QualType_isVolatile(const ast_QualType qt)
{
   return (qt.ptr & ast_QualType_Volatile) != 0;
}

static void ast_QualType_setVolatile(ast_QualType* qt)
{
   qt->ptr |= ast_QualType_Volatile;
}

static uint32_t ast_QualType_getQuals(const ast_QualType qt)
{
   return qt.ptr & ast_QualType_Mask;
}

static void ast_QualType_copyQuals(ast_QualType* qt, ast_QualType other)
{
   qt->ptr &= ~ast_QualType_Mask;
   qt->ptr |= (other.ptr & ast_QualType_Mask);
}

static void ast_QualType_clearQuals(ast_QualType* qt)
{
   qt->ptr &= ~ast_QualType_Mask;
}

static bool ast_QualType_isConstant(const ast_QualType qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(canon);
   if (ast_QualType_isConst(canon)) return true;
   if (ast_Type_isArrayType(t)) {
      const ast_ArrayType* at = (ast_ArrayType*)t;
      canon = ast_ArrayType_getElemType(at);
      return ast_QualType_isConstant(canon);
   }
   return false;
}

static bool ast_QualType_isValid(const ast_QualType qt)
{
   return qt.ptr != 0;
}

static bool ast_QualType_isInvalid(const ast_QualType qt)
{
   return qt.ptr == 0;
}

static uint32_t ast_QualType_getBitFieldWidth(const ast_QualType qt, bool precise)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(canon);
   if (ast_Type_isBuiltinType(t)) {
      ast_BuiltinType* bi = (ast_BuiltinType*)t;
      return ast_BuiltinType_getWidth(bi);
   }
   if (ast_Type_isEnumType(t)) {
      ast_EnumTypeDecl* d = ast_EnumType_getDecl(((ast_EnumType*)t));
      if (ast_EnumTypeDecl_isRegular(d) && precise) {
         uint32_t n = ast_EnumTypeDecl_getNumConstants(d) - 1;
         uint32_t bits = 1;
         for (uint32_t i = 16; i != 0; i >>= 1) {
            {
               uint32_t m = n >> i;
               if (m) {
                  n = m;
                  bits += i;
               }
            }
         }
         return bits;
      }
      ast_QualType impl = ast_EnumTypeDecl_getImplType(d);
      return ast_QualType_getBitFieldWidth(impl, precise);
   }
   return 0;
}

static bool ast_QualType_isScalar(const ast_QualType qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(canon);
   if (ast_Type_isBuiltinType(t)) {
      return true;
   }
   if (ast_QualType_isPointer(canon)) return true;
   if (ast_QualType_isFunction(canon)) return true;
   if (ast_QualType_isEnum(canon)) return true;
   return false;
}

static ast_Type* ast_QualType_getType(const ast_QualType qt)
{
   size_t t = qt.ptr & ~ast_QualType_Mask;
   ;//assert(t);
   return (ast_Type*)t;
}

static ast_Type* ast_QualType_getTypeOrNil(const ast_QualType qt)
{
   size_t temp = qt.ptr & ~ast_QualType_Mask;
   return (ast_Type*)temp;
}

static bool ast_QualType_hasCanonicalType(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return t->canonicalType.ptr != 0;
}

static ast_QualType ast_QualType_getCanonicalType(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   ast_QualType canon = t->canonicalType;
   ast_QualType_copyQuals(&canon, qt);
   return canon;
}

static void ast_QualType_setCanonicalType(ast_QualType* qt, ast_QualType canon)
{
   ast_Type* t = ast_QualType_getType(*qt);
   ast_Type_setCanonicalType(t, canon);
}

static ast_QualType ast_QualType_getImplType(const ast_QualType* qt)
{
   const ast_Type* t = ast_QualType_getType(*qt);
   ast_QualType canon = t->canonicalType;
   t = ast_QualType_getType(canon);
   if (ast_Type_isEnumType(t)) {
      ast_EnumType* et = (ast_EnumType*)t;
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      canon = ast_EnumTypeDecl_getImplType(etd);
   }
   ast_QualType_copyQuals(&canon, *qt);
   return canon;
}

static ast_TypeKind ast_QualType_getKind(const ast_QualType qt)
{
   ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getKind(t);
}

static uint32_t ast_QualType_getIndex(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getIndex(t);
}

static uint32_t ast_QualType_getAlignment(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getAlignment(t);
}

static uint32_t ast_QualType_getSize(const ast_QualType qt, bool deref_ptr)
{
   const ast_Type* t = ast_QualType_getType(qt);
   return ast_Type_getSize(t, deref_ptr);
}

static bool ast_QualType_isBool(const ast_QualType qt)
{
   const ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(qt);
   return (bi && ast_BuiltinType_isBool(bi));
}

static bool ast_QualType_isBuiltin(const ast_QualType qt)
{
   return ast_Type_isBuiltinType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isArray(const ast_QualType qt)
{
   return ast_Type_isArrayType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isStruct(const ast_QualType qt)
{
   return ast_Type_isStructType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isInteger(const ast_QualType qt)
{
   const ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(qt);
   return (bi && ast_BuiltinType_isInteger(bi));
}

static bool ast_QualType_isFloat(const ast_QualType qt)
{
   const ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(qt);
   return (bi && ast_BuiltinType_isFloatingPoint(bi));
}

static bool ast_QualType_isFloat32(const ast_QualType qt)
{
   const ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(qt);
   return (bi && ast_BuiltinType_getKind(bi) == ast_BuiltinKind_Float32);
}

static ast_BuiltinKind ast_QualType_getBuiltinKind(const ast_QualType* qt)
{
   const ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(*qt);
   ;//assert(bi);
   return ast_BuiltinType_getKind(bi);
}

static bool ast_QualType_isCharPointer(const ast_QualType qt)
{
   if (!ast_QualType_isPointer(qt)) return false;
   const ast_PointerType* pt = ast_QualType_getPointerType(qt);
   ast_QualType inner = ast_PointerType_getInner(pt);
   inner = ast_QualType_getCanonicalType(inner);
   return ast_QualType_isChar(inner);
}

static bool ast_QualType_isEmbedType(const ast_QualType qt, bool* is_char)
{
   if (!ast_QualType_isArray(qt)) return false;
   ast_ArrayType* at = ast_QualType_getArrayType(qt);
   if (ast_ArrayType_hasSize(at)) return false;
   ast_QualType elem = ast_ArrayType_getElemType(at);
   if (!ast_QualType_isConst(elem)) return false;
   *is_char = ast_QualType_isChar(elem);
   if (*is_char) return true;
   return ast_QualType_isUInt8(elem);
}

static bool ast_QualType_isPointer(const ast_QualType qt)
{
   return ast_Type_isPointerType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isPointerOrFunction(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   return ast_Type_isPointerType(t) || ast_Type_isFunctionType(t);
}

static ast_QualType ast_QualType_getPointerBaseType(const ast_QualType qt)
{
   const ast_PointerType* pt = ast_QualType_getPointerType(qt);
   return ast_PointerType_getInner(pt);
}

static bool ast_QualType_isFunction(const ast_QualType qt)
{
   return ast_Type_isFunctionType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isEnum(const ast_QualType qt)
{
   return ast_Type_isEnumType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isVoid(const ast_QualType qt)
{
   return ast_Type_isVoidType(ast_QualType_getTypeOrNil(qt));
}

static bool ast_QualType_isVoidPtr(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (!ast_Type_isPointerType(t)) return false;
   const ast_PointerType* pt = (ast_PointerType*)t;
   ast_QualType inner = ast_PointerType_getInner(pt);
   return ast_QualType_isVoid(inner);
}

static ast_BuiltinType* ast_QualType_getBuiltin(const ast_QualType qt)
{
   return (ast_BuiltinType*)ast_QualType_getTypeOrNil(qt);
}

static ast_BuiltinType* ast_QualType_getBuiltinTypeOrNil(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t && ast_Type_isBuiltinType(t)) return (ast_BuiltinType*)t;
   return NULL;
}

static ast_StructType* ast_QualType_getStructType(const ast_QualType qt)
{
   return (ast_StructType*)ast_QualType_getTypeOrNil(qt);
}

static ast_PointerType* ast_QualType_getPointerType(const ast_QualType qt)
{
   return (ast_PointerType*)ast_QualType_getTypeOrNil(qt);
}

static ast_FunctionType* ast_QualType_getFunctionType(const ast_QualType qt)
{
   return (ast_FunctionType*)ast_QualType_getTypeOrNil(qt);
}

static ast_ArrayType* ast_QualType_getArrayType(const ast_QualType qt)
{
   return (ast_ArrayType*)ast_QualType_getTypeOrNil(qt);
}

static ast_EnumType* ast_QualType_getEnum(const ast_QualType qt)
{
   return (ast_EnumType*)ast_QualType_getTypeOrNil(qt);
}

static ast_FunctionType* ast_QualType_getFunctionTypeOrNil(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t && ast_Type_isFunctionType(t)) return (ast_FunctionType*)t;
   return NULL;
}

static ast_StructType* ast_QualType_getStructTypeOrNil(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t && ast_Type_isStructType(t)) return (ast_StructType*)t;
   return NULL;
}

static ast_ArrayType* ast_QualType_getArrayTypeOrNil(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t && ast_Type_isArrayType(t)) return (ast_ArrayType*)t;
   return NULL;
}

static ast_EnumType* ast_QualType_getEnumType(const ast_QualType qt)
{
   return (ast_EnumType*)ast_QualType_getTypeOrNil(qt);
}

static ast_EnumType* ast_QualType_getEnumTypeOrNil(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (ast_Type_isEnumType(t)) return (ast_EnumType*)t;
   return NULL;
}

static bool ast_QualType_isCharCompatible(const ast_QualType qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(canon);
   if (!ast_Type_isBuiltinType(t)) return false;
   const ast_BuiltinType* bi = (ast_BuiltinType*)t;
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   return kind == ast_BuiltinKind_Char || kind == ast_BuiltinKind_Int8 || kind == ast_BuiltinKind_UInt8;
}

static bool ast_QualType_isChar(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (!ast_Type_isBuiltinType(t)) return false;
   const ast_BuiltinType* bi = (ast_BuiltinType*)t;
   return ast_BuiltinType_getKind(bi) == ast_BuiltinKind_Char;
}

static bool ast_QualType_isUInt8(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (!ast_Type_isBuiltinType(t)) return false;
   const ast_BuiltinType* bi = (ast_BuiltinType*)t;
   return ast_BuiltinType_getKind(bi) == ast_BuiltinKind_UInt8;
}

static bool ast_QualType_promotesToInt32(const ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (!ast_Type_isBuiltinType(t)) return false;
   const ast_BuiltinType* bi = (ast_BuiltinType*)t;
   return ast_BuiltinType_getKind(bi) == ast_BuiltinKind_Int32 || ast_BuiltinType_isPromotableIntegerType(bi);
}

static bool ast_QualType_needsCtvInit(const ast_QualType qt)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   const ast_Type* t = ast_QualType_getTypeOrNil(canon);
   if (!t) {
      printf("MISSING CANONICAL\n");
      ast_QualType_dump_full(qt);
      return false;
   }
   ;//assert(t);
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
      return true;
   case ast_TypeKind_Pointer:
      return false;
   case ast_TypeKind_Array:
      return true;
   case ast_TypeKind_Struct:
      return true;
   case ast_TypeKind_Enum:
      return true;
   case ast_TypeKind_Function:
      return false;
   case ast_TypeKind_Void:
      return true;
   case ast_TypeKind_Alias:
      return false;
   case ast_TypeKind_Module:
      return false;
   }
   return false;
}

static const char* ast_QualType_diagName(const ast_QualType qt)
{
   static char msgs[4][128];
   static uint32_t msg_id = 0;
   char* msg = msgs[msg_id];
   msg_id = (msg_id + 1) % 4;
   string_buffer_Buf buf; string_buffer_Buf_init(&buf, msg, 128, false, false, 0);
   ast_QualType_printInner(qt, &buf, true, true, true);
   return string_buffer_Buf_str(&buf);
}

static const char* ast_QualType_diagNameBare(const ast_QualType qt)
{
   static char msgs[4][128];
   static uint32_t msg_id = 0;
   char* msg = msgs[msg_id];
   msg_id = (msg_id + 1) % 4;
   string_buffer_Buf buf; string_buffer_Buf_init(&buf, msg, 128, false, false, 0);
   ast_QualType_printInner(qt, &buf, true, false, true);
   return string_buffer_Buf_str(&buf);
}

static void ast_QualType_dump(const ast_QualType qt)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_QualType_printInner(qt, out, false, true, false);
   ast_flushDumpBuf(out);
}

static void ast_QualType_dump_full(const ast_QualType qt)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_QualType_fullPrint(qt, out, 0);
   ast_flushDumpBuf(out);
}

static void ast_QualType_printQuoted(const ast_QualType qt, string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Type);
   ast_QualType_printInner(qt, out, true, true, true);
   string_buffer_Buf_color(out, ast_col_Type);
}

static void ast_QualType_print(const ast_QualType qt, string_buffer_Buf* out)
{
   ast_QualType_printInner(qt, out, true, true, true);
}

static void ast_QualType_printInner(const ast_QualType qt, string_buffer_Buf* out, bool printCanon, bool printModifiers, bool print_error)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t) {
      uint32_t quals = ast_QualType_getQuals(qt);
      if (ast_QualType_isPointer(qt)) {
         ast_Type_print(t, out);
         if (printModifiers) {
            if (quals & ast_QualType_Const) string_buffer_Buf_add(out, " const");
            if (quals & ast_QualType_Volatile) string_buffer_Buf_add(out, " volatile");
         }
      } else {
         if (printModifiers) {
            if (quals) string_buffer_Buf_color(out, ast_col_Type);
            if (quals & ast_QualType_Const) string_buffer_Buf_add(out, "const ");
            if (quals & ast_QualType_Volatile) string_buffer_Buf_add(out, "volatile ");
         }
         ast_Type_print(t, out);
      }
      if (printCanon) {
         ast_QualType qt2 = ast_QualType_getCanonicalType(qt);
         const ast_Type* canon = ast_QualType_getTypeOrNil(qt2);
         if (canon && canon != t) {
            string_buffer_Buf_add(out, " => ");
            ast_QualType_printInner(qt2, out, false, true, true);
         }
      }
   } else {
      if (print_error) {
         string_buffer_Buf_color(out, ast_col_Error);
         string_buffer_Buf_add(out, "??");
      } else {
         string_buffer_Buf_add(out, "QualType(nil)");
      }
   }
}

static void ast_QualType_fullPrint(const ast_QualType qt, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_add(out, "QualType");
   uint32_t quals = ast_QualType_getQuals(qt);
   if (quals & ast_QualType_Const) string_buffer_Buf_add(out, " const");
   if (quals & ast_QualType_Volatile) string_buffer_Buf_add(out, " volatile");
   const ast_Type* t = ast_QualType_getTypeOrNil(qt);
   if (t) {
      string_buffer_Buf_newline(out);
      ast_Type_fullPrint(t, out, indent + 1);
   } else string_buffer_Buf_add(out, " type=nil\n");
}

static ast_StructType* ast_StructType_create(ast_context_Context* c, ast_StructTypeDecl* decl)
{
   ast_StructType* t = ast_context_Context_alloc(c, 24);
   ast_Type_init(&t->base, ast_TypeKind_Struct);
   t->decl = decl;
   return t;
}

static ast_StructTypeDecl* ast_StructType_getDecl(const ast_StructType* t)
{
   return t->decl;
}

static ast_Type* ast_StructType_asType(ast_StructType* t)
{
   return &t->base;
}

static void ast_StructType_print(const ast_StructType* t, string_buffer_Buf* out)
{
   if (ast_StructTypeDecl_isGlobal(t->decl)) {
      string_buffer_Buf_add(out, ast_Decl_getModuleName(&t->decl->base));
      string_buffer_Buf_add1(out, '.');
   }
   const char* name = ast_Decl_getName(&t->decl->base);
   if (name) string_buffer_Buf_add(out, name);
   else string_buffer_Buf_add(out, "<anonymous>");
}

static void ast_StructType_fullPrint(const ast_StructType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "StructType [%p] %s\n", t, ast_Decl_getName(ast_StructTypeDecl_asDecl(t->decl)));
}

static const char* ast_TypeRefKind_str(ast_TypeRefKind k)
{
   switch (k) {
   case ast_TypeRefKind_Builtin:
      return "builtin";
   case ast_TypeRefKind_Void:
      return "void";
   case ast_TypeRefKind_User:
      return "user";
   case ast_TypeRefKind_Function:
      return "function";
   }
   return NULL;
}

static const char* ast_Ref_getName(const ast_Ref* r)
{
   return ast_idx2name(r->name_idx);
}

static void ast_TypeRefHolder_init(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flagBits = 0;
   r->dest = 0;
}

static uint32_t ast_TypeRefHolder_getExtraSize(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   return ast_TypeRef_getExtraSize(r);
}

static void ast_TypeRefHolder_setQualifiers(ast_TypeRefHolder* h, uint32_t qualifiers)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   if (qualifiers & ast_QualType_Volatile) r->flags.is_volatile = 1;
   if (qualifiers & ast_QualType_Const) r->flags.is_const = 1;
}

static void ast_TypeRefHolder_setConst(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.is_const = 1;
}

static void ast_TypeRefHolder_setVolatile(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.is_volatile = 1;
}

static bool ast_TypeRefHolder_isPointer(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   return r->flags.num_ptrs != 0;
}

static void ast_TypeRefHolder_addPointer(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   ;//assert(r->flags.num_ptrs != 3);
   r->flags.num_ptrs++;
}

static bool ast_TypeRefHolder_isIncrArray(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   return r->flags.incr_array;
}

static void ast_TypeRefHolder_setIncrArray(ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.incr_array = 1;
}

static uint32_t ast_TypeRefHolder_getNumArrays(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   return ast_TypeRef_getNumArrays(r);
}

static bool ast_TypeRefHolder_isArray(const ast_TypeRefHolder* h)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   return r->flags.num_arrays != 0;
}

static void ast_TypeRefHolder_addArray(ast_TypeRefHolder* h, ast_Expr* array)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   ;//assert(r->flags.num_arrays != 3);
   h->arrays[r->flags.num_arrays] = array;
   r->flags.num_arrays++;
}

static void ast_TypeRefHolder_setBuiltin(ast_TypeRefHolder* h, ast_BuiltinKind kind, src_loc_SrcLoc loc)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.builtin_kind = kind;
   r->loc = loc;
}

static void ast_TypeRefHolder_setVoid(ast_TypeRefHolder* h, src_loc_SrcLoc loc)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.kind = ast_TypeRefKind_Void;
   r->loc = loc;
}

static void ast_TypeRefHolder_setUser(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.kind = ast_TypeRefKind_User;
   h->user.loc = loc;
   h->user.name_idx = name_idx;
   h->user.decl = NULL;
}

static void ast_TypeRefHolder_setFunction(ast_TypeRefHolder* h, ast_Decl* fd)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   r->flags.kind = ast_TypeRefKind_Function;
   h->user.loc = 0;
   h->user.name_idx = 0;
   h->user.decl = fd;
}

static void ast_TypeRefHolder_setPrefix(ast_TypeRefHolder* h, src_loc_SrcLoc loc, uint32_t name_idx)
{
   ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   h->prefix = h->user;
   r->flags.has_prefix = 1;
   h->user.loc = loc;
   h->user.name_idx = name_idx;
   h->user.decl = NULL;
}

static void ast_TypeRefHolder_dump(const ast_TypeRefHolder* h)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   const ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   ast_TypeRef_print(r, out, false);
   for (uint32_t i = 0; i < ast_TypeRef_getNumArrays(r); i++) {
      string_buffer_Buf_add1(out, '[');
      ast_Expr* size = h->arrays[i];
      if (size) ast_Expr_printLiteral(h->arrays[i], out);
      string_buffer_Buf_add1(out, ']');
   }
   ast_flushDumpBuf(out);
}

static void ast_TypeRef_init(ast_TypeRef* dest, const ast_TypeRefHolder* h)
{
   const ast_TypeRef* r = (ast_TypeRef*)&h->ref;
   *dest = *r;
   switch (ast_TypeRef_getKind(r)) {
   case ast_TypeRefKind_Builtin:
   case ast_TypeRefKind_Void:
      break;
   case ast_TypeRefKind_User:
      dest->refs[0] = h->user;
      if (ast_TypeRef_hasPrefix(r)) dest->refs[1] = h->prefix;
      break;
   case ast_TypeRefKind_Function:
      dest->refs[0] = h->user;
      break;
   }
   for (uint32_t i = 0; i < r->flags.num_arrays; i++) {
      ast_Expr** a = ast_TypeRef_getArray2(dest, i);
      *a = h->arrays[i];
   }
}

static bool ast_TypeRef_matchesTemplate(const ast_TypeRef* r, uint32_t template_arg)
{
   if (r->flags.kind != ast_TypeRefKind_User || r->flags.has_prefix) return false;
   return r->refs[0].name_idx == template_arg;
}

static void ast_TypeRef_instantiate(ast_TypeRef* r, const ast_TypeRef* r1, ast_Instantiator* inst)
{
   const ast_TypeRef* r2 = inst->ref;
   if (ast_TypeRef_matchesTemplate(r1, inst->template_name)) {
      r->flagBits = r2->flagBits;
      r->dest = r2->dest;
      if (r2->flags.kind == ast_TypeRefKind_User) {
         r->refs[0].name_idx = r2->refs[0].name_idx;
         r->refs[0].loc = r1->refs[0].loc;
         r->refs[0].decl = r2->refs[0].decl;
         if (r2->flags.has_prefix) {
            r->refs[1].name_idx = r2->refs[1].name_idx;
            r->refs[1].loc = r2->refs[1].loc;
            r->refs[1].decl = r2->refs[1].decl;
         }
      }
      r->flags.is_const |= r1->flags.is_const;
      r->flags.is_volatile |= r1->flags.is_volatile;
      r->flags.num_ptrs += r1->flags.num_ptrs;
      if (inst->used_opaque && r->flags.num_ptrs == 0) {
         ast_Instantiator_on_opaque(inst, r->refs[0].loc, r->refs[0].decl);
      }
   } else {
      memcpy(r, r1, 8 + ast_TypeRef_getExtraSize(r1));
   }
}

static void ast_TypeRef_setDest(ast_TypeRef* r, uint32_t dest)
{
   ;//assert(ast_TypeRef_isUser(r));
   r->dest = dest;
}

static uint32_t ast_TypeRef_getExtraSize(const ast_TypeRef* r)
{
   uint32_t numrefs = (r->flags.kind != ast_TypeRefKind_Builtin) + r->flags.has_prefix;
   uint32_t extra = numrefs * 16;
   extra += r->flags.num_arrays * 8;
   return extra;
}

static void* ast_TypeRef_getPointerAfter(const ast_TypeRef* r)
{
   return (uint8_t*)r + 8 + ast_TypeRef_getExtraSize(r);
}

static bool ast_TypeRef_isConst(const ast_TypeRef* r)
{
   return r->flags.is_const;
}

static bool ast_TypeRef_isVolatile(const ast_TypeRef* r)
{
   return r->flags.is_volatile;
}

static bool ast_TypeRef_isUser(const ast_TypeRef* r)
{
   return r->flags.kind == ast_TypeRefKind_User;
}

static bool ast_TypeRef_isBuiltin(const ast_TypeRef* r)
{
   return r->flags.kind == ast_TypeRefKind_Builtin;
}

static bool ast_TypeRef_isFunction(const ast_TypeRef* r)
{
   return r->flags.kind == ast_TypeRefKind_Function;
}

static bool ast_TypeRef_isVoid(const ast_TypeRef* r)
{
   return r->flags.kind == ast_TypeRefKind_Void;
}

static bool ast_TypeRef_isConstCharPtr(const ast_TypeRef* r)
{
   return r->flags.is_const && ast_TypeRef_isBuiltin(r) && r->flags.num_ptrs == 1 && r->flags.num_arrays == 0 && ast_TypeRef_getBuiltinKind(r) == ast_BuiltinKind_Char;
}

static bool ast_TypeRef_isU32(const ast_TypeRef* r)
{
   return ast_TypeRef_isBuiltin(r) && r->flags.num_ptrs == 0 && r->flags.num_arrays == 0 && ast_TypeRef_getBuiltinKind(r) == ast_BuiltinKind_UInt32;
}

static bool ast_TypeRef_hasPrefix(const ast_TypeRef* r)
{
   return r->flags.has_prefix;
}

static bool ast_TypeRef_isIncrArray(const ast_TypeRef* r)
{
   return r->flags.incr_array;
}

static bool ast_TypeRef_isPointerTo(const ast_TypeRef* r, uint32_t ptr_idx)
{
   if (r->dest != ptr_idx || ptr_idx == 0) return false;
   return (r->flags.num_ptrs == 1 && r->flags.num_arrays == 0 && ast_TypeRef_isUser(r));
}

static ast_BuiltinKind ast_TypeRef_getBuiltinKind(const ast_TypeRef* r)
{
   return (ast_BuiltinKind)r->flags.builtin_kind;
}

static ast_TypeRefKind ast_TypeRef_getKind(const ast_TypeRef* r)
{
   return (ast_TypeRefKind)r->flags.kind;
}

static src_loc_SrcLoc ast_TypeRef_getLoc(const ast_TypeRef* r)
{
   switch (ast_TypeRef_getKind(r)) {
   case ast_TypeRefKind_Builtin:
   case ast_TypeRefKind_Void:
      break;
   case ast_TypeRefKind_User:
      if (ast_TypeRef_hasPrefix(r)) return r->refs[1].loc;
      else return r->refs[0].loc;
   case ast_TypeRefKind_Function:
      break;
   }
   return r->loc;
}

static bool ast_TypeRef_isPointer(const ast_TypeRef* r)
{
   return r->flags.num_ptrs != 0;
}

static uint32_t ast_TypeRef_getNumPointers(const ast_TypeRef* r)
{
   return r->flags.num_ptrs;
}

static const ast_Ref* ast_TypeRef_getUser(const ast_TypeRef* r)
{
   if (ast_TypeRef_isUser(r)) return &r->refs[0];
   return NULL;
}

static const ast_Ref* ast_TypeRef_getStructMemberType(const ast_TypeRef* r)
{
   return &r->refs[0];
}

static const ast_Decl* ast_TypeRef_getUserDecl(const ast_TypeRef* r)
{
   if (ast_TypeRef_isUser(r)) return r->refs[0].decl;
   return NULL;
}

static const ast_Ref* ast_TypeRef_getPrefix(const ast_TypeRef* r)
{
   if (r->flags.has_prefix) return &r->refs[1];
   return NULL;
}

static void ast_TypeRef_setPrefix(ast_TypeRef* r, ast_Decl* d)
{
   r->refs[1].decl = d;
}

static void ast_TypeRef_setUser(ast_TypeRef* r, ast_Decl* d)
{
   r->refs[0].decl = d;
}

static bool ast_TypeRef_isArray(const ast_TypeRef* r)
{
   return r->flags.num_arrays != 0;
}

static uint32_t ast_TypeRef_getNumArrays(const ast_TypeRef* r)
{
   return r->flags.num_arrays;
}

static ast_Expr* ast_TypeRef_getArray(const ast_TypeRef* r, uint32_t idx)
{
   const uint32_t numrefs = ast_TypeRef_isUser(r) + r->flags.has_prefix;
   const uint8_t* ptr = (uint8_t*)r->refs + numrefs * 16;
   ast_Expr** arrays = (ast_Expr**)ptr;
   return arrays[idx];
}

static ast_Expr** ast_TypeRef_getArray2(ast_TypeRef* r, uint32_t idx)
{
   const uint32_t numrefs = ast_TypeRef_isUser(r) + r->flags.has_prefix;
   const uint8_t* ptr = (uint8_t*)r->refs + numrefs * 16;
   ast_Expr** arrays = (ast_Expr**)ptr;
   return &arrays[idx];
}

static void ast_TypeRef_printLiteral(const ast_TypeRef* r, string_buffer_Buf* out, bool print_prefix)
{
   if (ast_TypeRef_isConst(r)) string_buffer_Buf_add(out, "const ");
   if (ast_TypeRef_isVolatile(r)) string_buffer_Buf_add(out, "volatile ");
   switch ((ast_TypeRefKind)r->flags.kind) {
   case ast_TypeRefKind_Builtin:
      string_buffer_Buf_add(out, ast_builtinType_names[ast_TypeRef_getBuiltinKind(r)]);
      break;
   case ast_TypeRefKind_Void:
      string_buffer_Buf_add(out, "void");
      break;
   case ast_TypeRefKind_User: {
      ast_Decl* d = r->refs[0].decl;
      ;//assert(d);
      if (print_prefix) {
         string_buffer_Buf_add(out, ast_Decl_getFullName(d));
      } else {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
      break;
   }
   case ast_TypeRefKind_Function:
      string_buffer_Buf_add(out, "FN TODO");
      break;
   }
   for (uint32_t i = 0; i < r->flags.num_ptrs; i++) string_buffer_Buf_add1(out, '*');
   if (r->flags.incr_array) string_buffer_Buf_add(out, "[+]");
   for (uint32_t i = 0; i < r->flags.num_arrays; i++) {
      string_buffer_Buf_add1(out, '[');
      const ast_Expr* a = ast_TypeRef_getArray(r, i);
      if (a) ast_Expr_printLiteral(a, out);
      string_buffer_Buf_add1(out, ']');
   }
}

static void ast_TypeRef_print(const ast_TypeRef* r, string_buffer_Buf* out, bool filled)
{
   string_buffer_Buf_color(out, ast_col_Error);
   if (ast_TypeRef_isConst(r)) string_buffer_Buf_add(out, "const ");
   if (ast_TypeRef_isVolatile(r)) string_buffer_Buf_add(out, "volatile ");
   switch ((ast_TypeRefKind)r->flags.kind) {
   case ast_TypeRefKind_Builtin:
      string_buffer_Buf_add(out, ast_builtinType_names[ast_TypeRef_getBuiltinKind(r)]);
      break;
   case ast_TypeRefKind_Void:
      string_buffer_Buf_add(out, "void");
      break;
   case ast_TypeRefKind_User:
      if (r->flags.has_prefix) {
         string_buffer_Buf_add(out, ast_idx2name(r->refs[1].name_idx));
         string_buffer_Buf_add1(out, '.');
      }
      string_buffer_Buf_add(out, ast_idx2name(r->refs[0].name_idx));
      break;
   case ast_TypeRefKind_Function: {
      string_buffer_Buf_add(out, "fn ");
      ;//assert(r->refs[0].decl);
      const ast_FunctionDecl* fd = (ast_FunctionDecl*)r->refs[0].decl;
      ast_FunctionDecl_printType(fd, out);
      break;
   }
   }
   for (uint32_t i = 0; i < r->flags.num_ptrs; i++) string_buffer_Buf_add1(out, '*');
   if (r->flags.incr_array) {
      string_buffer_Buf_add(out, "[+]");
   }
   if (filled) {
      for (uint32_t i = 0; i < r->flags.num_arrays; i++) {
         string_buffer_Buf_add1(out, '[');
         const ast_Expr* a = ast_TypeRef_getArray(r, i);
         if (a) ast_Expr_printLiteral(a, out);
         string_buffer_Buf_add1(out, ']');
      }
   }
}

static void ast_TypeRef_dump(const ast_TypeRef* r)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   ast_TypeRef_print(r, out, true);
   ast_flushDumpBuf(out);
}

static void ast_TypeRef_dump_full(const ast_TypeRef* r)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   string_buffer_Buf_add(out, "TypeRef:\n");
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_add(out, "flags:");
   if (r->flags.is_const) string_buffer_Buf_add(out, " const");
   string_buffer_Buf_print(out, " ptrs=%u", r->flags.num_ptrs);
   string_buffer_Buf_print(out, " kind=%s", ast_TypeRefKind_str((ast_TypeRefKind)r->flags.kind));
   string_buffer_Buf_print(out, " has_prefix=%u", r->flags.has_prefix);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_print(out, "dest %u\n", r->dest);
   uint32_t num_refs = 0;
   if (ast_TypeRef_isUser(r)) num_refs++;
   if (r->flags.has_prefix) num_refs++;
   for (uint32_t i = 0; i < num_refs; i++) {
      string_buffer_Buf_indent(out, 1);
      const ast_Ref* ref = &r->refs[i];
      string_buffer_Buf_print(out, "ref[%u] loc %u  name_idx %u  decl %p\n", i, ref->loc, ref->name_idx, ref->decl);
   }
   ast_flushDumpBuf(out);
}

static const char* ast_TypeRef_diagName(const ast_TypeRef* r)
{
   static char result[128];
   string_buffer_Buf buf; string_buffer_Buf_init(&buf, result, 128, false, false, 0);
   ast_TypeRef_print(r, &buf, true);
   return string_buffer_Buf_str(&buf);
}

static ast_VoidType* ast_VoidType_create(ast_context_Context* c)
{
   ast_VoidType* b = ast_context_Context_alloc(c, 16);
   ast_Type_init(&b->base, ast_TypeKind_Void);
   ast_Type_setCanonicalType(&b->base, ast_QualType_create(&b->base));
   return b;
}

static void ast_VoidType_print(const ast_VoidType* b, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "void");
}

static void ast_VoidType_fullPrint(const ast_VoidType* t, string_buffer_Buf* out, uint32_t indent)
{
   string_buffer_Buf_indent(out, indent);
   string_buffer_Buf_print(out, "VoidType [%p] void\n", t);
}

static void ast_ArrayValueList_init(ast_ArrayValueList* l, uint32_t initial_size)
{
   l->count = 0;
   l->capacity = initial_size;
   l->values = NULL;
   if (initial_size) {
      l->values = malloc(l->capacity * 8);
   }
}

static void ast_ArrayValueList_free(ast_ArrayValueList* l)
{
   if (l->values) free(l->values);
}

static void ast_ArrayValueList_add(ast_ArrayValueList* l, ast_ArrayValue* v)
{
   if (l->count >= l->capacity) {
      l->capacity += 4;
      void* values2 = malloc(l->capacity * 8);
      void* old = l->values;
      if (old) {
         memcpy(values2, old, l->count * 8);
         free(old);
      }
      l->values = values2;
   }
   l->values[l->count] = v;
   l->count++;
}

static uint32_t ast_ArrayValueList_getCount(const ast_ArrayValueList* l)
{
   return l->count;
}

static ast_ArrayValue** ast_ArrayValueList_get(ast_ArrayValueList* l)
{
   return l->values;
}

static ast_AST* ast_AST_create(string_pool_Pool* auxPool, uint32_t name, ast_Module* mod, bool is_interface, bool is_generated)
{
   ast_AST* a = calloc(1, 208);
   a->mod = mod;
   a->auxPool = auxPool;
   a->name = name;
   a->idx = ast_addAST(a);
   a->is_interface = is_interface;
   a->is_generated = is_generated;
   ast_ImportDeclList_init(&a->imports);
   ast_DeclList_init(&a->types);
   ast_DeclList_init(&a->variables);
   ast_FunctionDeclList_init(&a->functions);
   ast_StaticAssertList_init(&a->static_asserts, 0);
   ast_ArrayValueList_init(&a->array_values, 0);
   return a;
}

static void ast_AST_free(ast_AST* a)
{
   ast_ImportDeclList_free(&a->imports);
   ast_DeclList_free(&a->types);
   ast_DeclList_free(&a->variables);
   ast_FunctionDeclList_free(&a->functions);
   ast_StaticAssertList_free(&a->static_asserts);
   ast_ArrayValueList_free(&a->array_values);
   if (a->attrs) attr_table_Table_free(a->attrs);
   free(a);
}

static const char* ast_AST_getFilename(const ast_AST* a)
{
   return string_pool_Pool_idx2str(a->auxPool, a->name);
}

static uint32_t ast_AST_getIdx(const ast_AST* a)
{
   return a->idx;
}

static const char* ast_AST_getName(const ast_AST* a)
{
   return ast_Module_getName(a->mod);
}

static uint32_t ast_AST_getNameIdx(const ast_AST* a)
{
   return ast_Module_getNameIdx(a->mod);
}

static src_loc_SrcLoc ast_AST_getLoc(const ast_AST* a)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   ast_Decl* d = (ast_Decl*)imports[0];
   return ast_Decl_getLoc(d);
}

static void ast_AST_setPtr(ast_AST* a, void* ptr)
{
   a->ptr = ptr;
}

static void* ast_AST_getPtr(const ast_AST* a)
{
   return a->ptr;
}

static ast_Module* ast_AST_getMod(const ast_AST* a)
{
   return a->mod;
}

static void ast_AST_addImport(ast_AST* a, ast_ImportDecl* d)
{
   ast_ImportDeclList_add(&a->imports, d);
}

static ast_ImportDecl* ast_AST_findImport(const ast_AST* a, uint32_t name)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 1; i < ast_ImportDeclList_size(&a->imports); i++) {
      ast_ImportDecl* d = imports[i];
      if (ast_Decl_getNameIdx(ast_ImportDecl_asDecl(d)) == name) return d;
   }
   return NULL;
}

static bool ast_AST_isGenerated(const ast_AST* a)
{
   return a->is_generated;
}

static bool ast_AST_isInterface(const ast_AST* a)
{
   return a->is_interface;
}

static void ast_AST_addFunc(ast_AST* a, ast_FunctionDecl* d)
{
   ast_FunctionDeclList_add(&a->functions, d);
}

static void ast_AST_addTypeDecl(ast_AST* a, ast_Decl* d)
{
   ast_DeclList_add(&a->types, d);
}

static void ast_AST_addVarDecl(ast_AST* a, ast_Decl* d)
{
   ast_DeclList_add(&a->variables, d);
}

static void ast_AST_addStaticAssert(ast_AST* a, ast_StaticAssert* s)
{
   ast_StaticAssertList_add(&a->static_asserts, s);
}

static void ast_AST_addArrayValue(ast_AST* a, ast_ArrayValue* v)
{
   ast_ArrayValueList_add(&a->array_values, v);
}

static void ast_AST_visitImports(const ast_AST* a, ast_ImportVisitor visitor, void* arg)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 1; i < ast_ImportDeclList_size(&a->imports); i++) {
      visitor(arg, imports[i]);
   }
}

static const ast_ImportDeclList* ast_AST_getImports(const ast_AST* a)
{
   return &a->imports;
}

static void ast_AST_visitArrayValues(ast_AST* a, ast_ArrayValueVisitor visitor, void* arg)
{
   ast_ArrayValue** values = ast_ArrayValueList_get(&a->array_values);
   for (uint32_t i = 0; i < ast_ArrayValueList_getCount(&a->array_values); i++) {
      visitor(arg, values[i]);
   }
}

static void ast_AST_visitTypeFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg)
{
   ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; i < ast_FunctionDeclList_size(&a->functions); i++) {
      ast_FunctionDecl* d = functions[i];
      if (ast_FunctionDecl_hasPrefix(d)) visitor(arg, d);
   }
}

static void ast_AST_visitFunctions(const ast_AST* a, ast_FunctionVisitor visitor, void* arg)
{
   ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; i < ast_FunctionDeclList_size(&a->functions); i++) {
      ast_FunctionDecl* d = functions[i];
      visitor(arg, d);
   }
}

static void ast_AST_visitTypeDecls(const ast_AST* a, ast_TypeDeclVisitor visitor, void* arg)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->types); i++) {
      visitor(arg, types[i]);
   }
}

static void ast_AST_visitVarDecls(const ast_AST* a, ast_VarDeclVisitor visitor, void* arg)
{
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->variables); i++) {
      visitor(arg, (ast_VarDecl*)variables[i]);
   }
}

static void ast_AST_visitStaticAsserts(ast_AST* a, ast_StaticAssertVisitor visitor, void* arg)
{
   ast_StaticAssert** asserts = ast_StaticAssertList_get(&a->static_asserts);
   for (uint32_t i = 0; i < ast_StaticAssertList_getCount(&a->static_asserts); i++) {
      visitor(arg, asserts[i]);
   }
}

static void ast_AST_visitDecls(const ast_AST* a, ast_DeclVisitor visitor, void* arg)
{
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 0; i < ast_ImportDeclList_size(&a->imports); i++) {
      visitor(arg, (ast_Decl*)imports[i]);
   }
   ast_AST_visitDeclsWithoutImports(a, visitor, arg);
}

static void ast_AST_visitDeclsWithoutImports(const ast_AST* a, ast_DeclVisitor visitor, void* arg)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->types); i++) {
      visitor(arg, types[i]);
   }
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->variables); i++) {
      visitor(arg, variables[i]);
   }
   ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; i < ast_FunctionDeclList_size(&a->functions); i++) {
      ast_FunctionDecl* d = functions[i];
      visitor(arg, (ast_Decl*)d);
   }
}

static ast_Decl* ast_AST_findType(const ast_AST* a, uint32_t name_idx)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->types); i++) {
      ast_Decl* d = types[i];
      if (ast_Decl_getNameIdx(d) == name_idx) return d;
   }
   return NULL;
}

static void ast_AST_storeAttr(ast_AST* a, ast_Decl* d, const attr_Attr* at)
{
   if (!a->attrs) a->attrs = attr_table_create();
   attr_table_Table_add(a->attrs, d, at);
}

static const attr_Attr* ast_AST_getAttr(const ast_AST* a, const ast_Decl* d, attr_AttrKind kind)
{
   if (a->attrs) return attr_table_Table_find(a->attrs, d, kind);
   return NULL;
}

static void ast_AST_print(const ast_AST* a, string_buffer_Buf* out, bool show_funcs)
{
   string_buffer_Buf_color(out, ast_col_Normal);
   string_buffer_Buf_print(out, "---- AST %s ----\n", ast_AST_getFilename(a));
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(&a->imports);
   for (uint32_t i = 1; i < ast_ImportDeclList_size(&a->imports); i++) {
      ast_ImportDecl_print(imports[i], out, 0);
   }
   if (ast_ImportDeclList_size(&a->imports) > 1) string_buffer_Buf_newline(out);
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->types); i++) {
      ast_Decl_print(types[i], out, 0);
      string_buffer_Buf_newline(out);
   }
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->variables); i++) {
      ast_Decl_print(variables[i], out, 0);
      string_buffer_Buf_newline(out);
   }
   if (show_funcs) {
      ast_FunctionDecl** functions = ast_FunctionDeclList_getDecls(&a->functions);
      for (uint32_t i = 0; i < ast_FunctionDeclList_size(&a->functions); i++) {
         ast_FunctionDecl_print(functions[i], out, 0);
         string_buffer_Buf_newline(out);
      }
   }
   for (uint32_t i = 0; i < ast_StaticAssertList_getCount(&a->static_asserts); i++) {
      ast_StaticAssert_print(ast_StaticAssertList_getAt(&a->static_asserts, i), out, 0);
      string_buffer_Buf_newline(out);
   }
}

static void ast_AST_setExported(ast_AST* a)
{
   ast_Decl** types = ast_DeclList_getDecls(&a->types);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->types); i++) {
      ast_Decl_setExportedIfPublic(types[i]);
   }
   ast_Decl** variables = ast_DeclList_getDecls(&a->variables);
   for (uint32_t i = 0; i < ast_DeclList_size(&a->variables); i++) {
      ast_Decl_setExportedIfPublic(variables[i]);
   }
   ast_Decl** functions = (ast_Decl**)ast_FunctionDeclList_getDecls(&a->functions);
   for (uint32_t i = 0; i < ast_FunctionDeclList_size(&a->functions); i++) {
      ast_Decl_setExportedIfPublic(functions[i]);
   }
}

static void ast_DeclList_init(ast_DeclList* l)
{
   l->count = 0;
   l->capacity = 4;
   l->decls = l->stash;
}

static void ast_DeclList_free(ast_DeclList* l)
{
   if (l->capacity > 4) free(l->decls);
   l->count = 0;
   l->capacity = 0;
}

static void ast_DeclList_add(ast_DeclList* l, ast_Decl* d)
{
   if (l->count >= l->capacity) {
      if (l->capacity == 0) {
         l->capacity = 4;
         l->decls = l->stash;
      } else {
         uint32_t capacity2 = l->capacity + l->capacity / 2 + 2;
         void* decls2 = malloc(capacity2 * 8);
         memcpy(decls2, l->decls, l->count * 8);
         if (l->capacity > 4) free(l->decls);
         l->capacity = capacity2;
         l->decls = decls2;
      }
   }
   l->decls[l->count] = d;
   l->count++;
}

static void ast_DeclList_clear(ast_DeclList* l)
{
   l->count = 0;
}

static uint32_t ast_DeclList_size(const ast_DeclList* l)
{
   return l->count;
}

static ast_Decl* ast_DeclList_get(const ast_DeclList* l, uint32_t idx)
{
   return l->decls[idx];
}

static ast_Decl** ast_DeclList_getDecls(const ast_DeclList* l)
{
   return l->decls;
}

static void ast_ExprList_init(ast_ExprList* l)
{
   l->count = 0;
   l->capacity = 4;
   l->exprs = l->stash;
}

static void ast_ExprList_free(ast_ExprList* l)
{
   if (l->capacity > 4) free(l->exprs);
   l->count = 0;
   l->capacity = 0;
}

static void ast_ExprList_add(ast_ExprList* l, ast_Expr* d)
{
   if (l->count >= l->capacity) {
      if (l->capacity == 0) {
         l->capacity = 4;
         l->exprs = l->stash;
      } else {
         uint32_t capacity2 = l->capacity + l->capacity / 2 + 2;
         void* exprs2 = malloc(capacity2 * 8);
         memcpy(exprs2, l->exprs, l->count * 8);
         if (l->capacity > 4) free(l->exprs);
         l->capacity = capacity2;
         l->exprs = exprs2;
      }
   }
   l->exprs[l->count] = d;
   l->count++;
}

static uint32_t ast_ExprList_size(const ast_ExprList* l)
{
   return l->count;
}

static ast_Expr** ast_ExprList_getExprs(const ast_ExprList* l)
{
   return l->exprs;
}

static void ast_FunctionDeclList_init(ast_FunctionDeclList* l)
{
   memset(l, 0, 16);
}

static void ast_FunctionDeclList_free(ast_FunctionDeclList* l)
{
   if (l->decls) free(l->decls);
}

static void ast_FunctionDeclList_clear(ast_FunctionDeclList* l)
{
   l->count = 0;
}

static void ast_FunctionDeclList_add(ast_FunctionDeclList* l, ast_FunctionDecl* d)
{
   if (l->count >= l->capacity) {
      l->capacity = (l->capacity == 0) ? 4 : l->capacity * 2;
      void* decls2 = malloc(l->capacity * 8);
      void* old = l->decls;
      if (old) {
         memcpy(decls2, old, l->count * 8);
         free(old);
      }
      l->decls = decls2;
   }
   l->decls[l->count] = d;
   l->count++;
}

static uint32_t ast_FunctionDeclList_size(const ast_FunctionDeclList* l)
{
   return l->count;
}

static ast_FunctionDecl** ast_FunctionDeclList_getDecls(const ast_FunctionDeclList* l)
{
   return l->decls;
}

static ast_FunctionDecl* ast_FunctionDeclList_find(const ast_FunctionDeclList* l, uint32_t name_idx)
{
   for (uint32_t i = 0; i < l->count; i++) {
      ast_FunctionDecl* fd = l->decls[i];
      if (ast_Decl_getNameIdx(ast_FunctionDecl_asDecl(fd)) == name_idx) return fd;
   }
   return NULL;
}

static void ast_ImportDeclList_init(ast_ImportDeclList* l)
{
   memset(l, 0, 16);
}

static void ast_ImportDeclList_free(ast_ImportDeclList* l)
{
   if (l->decls) free(l->decls);
}

static void ast_ImportDeclList_add(ast_ImportDeclList* l, ast_ImportDecl* d)
{
   if (l->count >= l->capacity) {
      l->capacity += 4;
      void* decls2 = malloc(l->capacity * 8);
      void* old = l->decls;
      if (old) {
         memcpy(decls2, old, l->count * 8);
         free(old);
      }
      l->decls = decls2;
   }
   l->decls[l->count] = d;
   l->count++;
}

static uint32_t ast_ImportDeclList_size(const ast_ImportDeclList* l)
{
   return l->count;
}

static ast_ImportDecl** ast_ImportDeclList_getDecls(const ast_ImportDeclList* l)
{
   return l->decls;
}

static ast_ImportDecl* ast_ImportDeclList_find(const ast_ImportDeclList* l, uint32_t name_idx)
{
   for (uint32_t i = 0; i < l->count; i++) {
      ast_ImportDecl* d = l->decls[i];
      if (ast_ImportDecl_getImportNameIdx(d) == name_idx) return d;
   }
   return NULL;
}

static ast_ImportDecl* ast_ImportDeclList_findAny(const ast_ImportDeclList* l, uint32_t name_idx)
{
   for (uint32_t i = 0; i < l->count; i++) {
      ast_ImportDecl* d = l->decls[i];
      if (ast_Decl_getNameIdx(ast_ImportDecl_asDecl(d)) == name_idx) return d;
   }
   return NULL;
}

static void ast_TemplateFunction_init(ast_TemplateFunction* f, const ast_FunctionDecl* fd)
{
   f->fd = fd;
   f->count = 0;
   f->capacity = 0;
   f->instances = NULL;
   ast_TemplateFunction_resize(f, 2);
}

static void ast_TemplateFunction_resize(ast_TemplateFunction* f, uint16_t capacity)
{
   f->capacity = capacity;
   ast_TemplateInstance* inst2 = malloc(capacity * 16);
   if (f->count) {
      memcpy(inst2, f->instances, f->count * 16);
      free(f->instances);
   }
   f->instances = inst2;
}

static uint16_t ast_TemplateFunction_add(ast_TemplateFunction* f, ast_QualType qt, ast_FunctionDecl* instance)
{
   if (f->count == f->capacity) ast_TemplateFunction_resize(f, f->capacity * 2);
   uint16_t idx = f->count;
   ast_TemplateInstance* ti = &f->instances[idx];
   f->count++;
   ti->qt = qt;
   ti->instance = instance;
   return idx;
}

static ast_FunctionDecl* ast_TemplateFunction_find(const ast_TemplateFunction* f, ast_QualType qt)
{
   for (uint32_t i = 0; i < f->count; i++) {
      const ast_TemplateInstance* ti = &f->instances[i];
      if (ti->qt.ptr == qt.ptr) return ti->instance;
   }
   return NULL;
}

static ast_FunctionDecl* ast_TemplateFunction_get(const ast_TemplateFunction* f, uint32_t idx)
{
   return f->instances[idx].instance;
}

static void ast_InstanceTable_init(ast_InstanceTable* t)
{
   t->count = 0;
   t->capacity = 0;
   t->funcs = NULL;
}

static void ast_InstanceTable_free(ast_InstanceTable* t)
{
   for (uint32_t i = 0; i < t->count; i++) {
      free(t->funcs[i].instances);
   }
   free(t->funcs);
}

static void ast_InstanceTable_resize(ast_InstanceTable* t, uint32_t capacity)
{
   t->capacity = capacity;
   ast_TemplateFunction* funcs2 = malloc(capacity * 24);
   if (t->count) {
      memcpy(funcs2, t->funcs, t->count * 24);
      free(t->funcs);
   }
   t->funcs = funcs2;
}

static ast_TemplateFunction* ast_InstanceTable_findFunc(const ast_InstanceTable* t, const ast_FunctionDecl* fd)
{
   for (uint32_t i = 0; i < t->count; i++) {
      ast_TemplateFunction* fi = &t->funcs[i];
      if (fi->fd == fd) return fi;
   }
   return NULL;
}

static ast_FunctionDecl* ast_InstanceTable_find(const ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt)
{
   const ast_TemplateFunction* fi = ast_InstanceTable_findFunc(t, fd);
   if (fi) return ast_TemplateFunction_find(fi, qt);
   return NULL;
}

static ast_FunctionDecl* ast_InstanceTable_get(const ast_InstanceTable* t, const ast_FunctionDecl* fd, uint32_t idx)
{
   const ast_TemplateFunction* fi = ast_InstanceTable_findFunc(t, fd);
   ;//assert(fi);
   return ast_TemplateFunction_get(fi, idx);
}

static uint16_t ast_InstanceTable_add(ast_InstanceTable* t, const ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance)
{
   ast_TemplateFunction* fi = ast_InstanceTable_findFunc(t, fd);
   if (!fi) {
      if (t->count == t->capacity) {
         if (t->capacity == 0) t->capacity = 2;
         ast_InstanceTable_resize(t, t->capacity * 2);
      }
      fi = &t->funcs[t->count];
      t->count++;
      ast_TemplateFunction_init(fi, fd);
   }
   return ast_TemplateFunction_add(fi, qt, instance);
}

static void ast_Instantiator_on_opaque(ast_Instantiator* inst, src_loc_SrcLoc loc, ast_Decl* decl)
{
   inst->on_error(inst->arg, loc, decl);
}

static ast_Module* ast_Module_create(ast_context_Context* c, uint32_t name_idx, bool is_external)
{
   ast_Module* m = calloc(1, 80);
   m->mt = ast_ModuleType_create(c, m);
   m->name_idx = name_idx;
   m->is_external = is_external;
   m->is_foreign = is_external;
   m->is_loaded = false;
   ast_Module_resizeFiles(m, 1);
   ast_SymbolTable_init(&m->symbols, 16);
   ast_InstanceTable_init(&m->instances);
   return m;
}

static void ast_Module_free(ast_Module* m)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_free(m->files[i]);
   }
   free(m->files);
   ast_SymbolTable_free(&m->symbols);
   ast_InstanceTable_free(&m->instances);
   free(m);
}

static void ast_Module_setUsed(ast_Module* m)
{
   m->is_used = true;
}

static bool ast_Module_isUsed(const ast_Module* m)
{
   return m->is_used;
}

static bool ast_Module_isExternal(const ast_Module* m)
{
   return m->is_external;
}

static void ast_Module_setForeign(ast_Module* m, bool is_foreign)
{
   m->is_foreign = is_foreign;
}

static bool ast_Module_isForeign(const ast_Module* m)
{
   return m->is_foreign;
}

static void ast_Module_setLoaded(ast_Module* m)
{
   m->is_loaded = true;
}

static bool ast_Module_isLoaded(const ast_Module* m)
{
   return m->is_loaded;
}

static void ast_Module_setExported(ast_Module* m)
{
   m->is_exported = true;
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_setExported(m->files[i]);
   }
}

static bool ast_Module_isExported(const ast_Module* m)
{
   return m->is_exported;
}

static void ast_Module_setPrivate(ast_Module* m, bool is_private)
{
   m->is_private = is_private;
}

static bool ast_Module_isPrivate(const ast_Module* m)
{
   return m->is_private;
}

static const ast_SymbolTable* ast_Module_getSymbols(const ast_Module* m)
{
   return &m->symbols;
}

static ast_ModuleType* ast_Module_getType(const ast_Module* m)
{
   return m->mt;
}

static const char* ast_Module_getFirstFilename(const ast_Module* m)
{
   if (m->num_files) return ast_AST_getFilename(m->files[0]);
   return NULL;
}

static void ast_Module_visitASTs(const ast_Module* m, ast_ASTVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      visitor(arg, m->files[i]);
   }
}

static void ast_Module_visitImports(const ast_Module* m, ast_ImportVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitImports(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitArrayValues(const ast_Module* m, ast_ArrayValueVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitArrayValues(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitTypeFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitTypeFunctions(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitFunctions(const ast_Module* m, ast_FunctionVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitFunctions(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitTypeDecls(const ast_Module* m, ast_TypeDeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitTypeDecls(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitVarDecls(const ast_Module* m, ast_VarDeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitVarDecls(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitStaticAsserts(const ast_Module* m, ast_StaticAssertVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitStaticAsserts(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitDecls(const ast_Module* m, ast_DeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitDecls(m->files[i], visitor, arg);
   }
}

static void ast_Module_visitDeclsWithoutImports(const ast_Module* m, ast_DeclVisitor visitor, void* arg)
{
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_visitDeclsWithoutImports(m->files[i], visitor, arg);
   }
}

static ast_Decl* ast_Module_findType(const ast_Module* m, uint32_t name_idx)
{
   ast_Decl* result = NULL;
   for (uint32_t i = 0; i < m->num_files; i++) {
      result = ast_AST_findType(m->files[i], name_idx);
      if (result) break;
   }
   return result;
}

static const char* ast_Module_getName(const ast_Module* m)
{
   return ast_idx2name(m->name_idx);
}

static uint32_t ast_Module_getNameIdx(const ast_Module* m)
{
   return m->name_idx;
}

static void ast_Module_resizeFiles(ast_Module* m, uint32_t cap)
{
   m->max_files = cap;
   void* buf = malloc(m->max_files * 8);
   if (m->files) {
      void* old = m->files;
      memcpy(buf, old, m->num_files * 8);
      free(old);
   }
   m->files = buf;
}

static ast_AST* ast_Module_add(ast_Module* m, string_pool_Pool* auxPool, uint32_t filename, bool is_interface, bool is_generated)
{
   ast_AST* a = ast_AST_create(auxPool, filename, m, is_interface, is_generated);
   if (m->num_files == m->max_files) ast_Module_resizeFiles(m, m->max_files * 2);
   m->files[m->num_files] = a;
   m->num_files++;
   return a;
}

static void ast_Module_addSymbol(ast_Module* m, uint32_t name_idx, ast_Decl* d)
{
   ast_SymbolTable_add(&m->symbols, name_idx, d);
}

static ast_Decl* ast_Module_findSymbol(const ast_Module* m, uint32_t name_idx)
{
   return ast_SymbolTable_find(&m->symbols, name_idx);
}

static ast_Decl* ast_Module_findPublicSymbol(const ast_Module* m, uint32_t name_idx)
{
   return ast_SymbolTable_findPublic(&m->symbols, name_idx);
}

static ast_Decl* ast_Module_findPrivateSymbol(const ast_Module* m, uint32_t name_idx)
{
   return ast_SymbolTable_findPrivate(&m->symbols, name_idx);
}

static ast_FunctionDecl* ast_Module_findInstance(const ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt)
{
   return ast_InstanceTable_find(&m->instances, fd, qt);
}

static uint16_t ast_Module_addInstance(ast_Module* m, ast_FunctionDecl* fd, ast_QualType qt, ast_FunctionDecl* instance)
{
   return ast_InstanceTable_add(&m->instances, fd, qt, instance);
}

static ast_FunctionDecl* ast_Module_getInstance(const ast_Module* m, ast_FunctionDecl* fd, uint32_t idx)
{
   return ast_InstanceTable_get(&m->instances, fd, idx);
}

static void ast_Module_print(const ast_Module* m, string_buffer_Buf* out, bool show_funcs)
{
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_print(out, "------ module %s (used %u, exported %u, private %u) ------\n", ast_idx2name(m->name_idx), m->is_used, m->is_exported, m->is_private);
   for (uint32_t i = 0; i < m->num_files; i++) {
      ast_AST_print(m->files[i], out, show_funcs);
   }
}

static void ast_PointerPool_init(ast_PointerPool* p, ast_context_Context* c)
{
   p->count = 1;
   p->capacity = 0;
   p->slots = NULL;
   p->context = c;
   ast_PointerPool_resize(p, 64);
}

static void ast_PointerPool_clear(ast_PointerPool* p)
{
   free(p->slots);
   p->count = 1;
   p->capacity = 0;
   p->slots = NULL;
}

static void ast_PointerPool_resize(ast_PointerPool* p, uint32_t cap)
{
   p->capacity = cap;
   ast_PointerPoolSlot* slots2 = malloc(p->capacity * 32);
   if (p->count > 1) {
      memcpy(slots2, p->slots, p->count * 32);
      free(p->slots);
   }
   p->slots = slots2;
}

static ast_Type* ast_PointerPool_getPointer(ast_PointerPool* p, ast_QualType qt)
{
   ast_Type* t = ast_QualType_getTypeOrNil(qt);
   ;//assert(t);
   const uint32_t ptr_pool_idx = t->ptr_pool_idx;
   ast_PointerPoolSlot* slot = &p->slots[ptr_pool_idx];
   if (ptr_pool_idx == 0) {
      uint32_t slot_idx = p->count;
      if (slot_idx == p->capacity) ast_PointerPool_resize(p, p->capacity * 2);
      slot = &p->slots[slot_idx];
      memset(slot, 0, 32);
      t->ptr_pool_idx = slot_idx;
      p->count++;
   }
   uint32_t quals = ast_QualType_getQuals(qt);
   ast_Type* ptr = slot->ptrs[quals];
   if (ptr) return ptr;
   ptr = (ast_Type*)ast_PointerType_create(p->context, qt);
   slot->ptrs[quals] = ptr;
   return ptr;
}

static void ast_StaticAssertList_init(ast_StaticAssertList* l, uint32_t initial_size)
{
   l->count = 0;
   l->capacity = initial_size;
   l->asserts = NULL;
   if (initial_size) {
      l->asserts = malloc(l->capacity * 8);
   }
}

static void ast_StaticAssertList_free(ast_StaticAssertList* l)
{
   if (l->asserts) free(l->asserts);
}

static void ast_StaticAssertList_add(ast_StaticAssertList* l, ast_StaticAssert* v)
{
   if (l->count >= l->capacity) {
      l->capacity += 4;
      void* asserts2 = malloc(l->capacity * 8);
      void* old = l->asserts;
      if (old) {
         memcpy(asserts2, old, l->count * 8);
         free(old);
      }
      l->asserts = asserts2;
   }
   l->asserts[l->count] = v;
   l->count++;
}

static uint32_t ast_StaticAssertList_getCount(const ast_StaticAssertList* l)
{
   return l->count;
}

static ast_StaticAssert* ast_StaticAssertList_getAt(const ast_StaticAssertList* l, uint32_t idx)
{
   return l->asserts[idx];
}

static ast_StaticAssert** ast_StaticAssertList_get(ast_StaticAssertList* l)
{
   return l->asserts;
}

static void ast_StringTypePool_init(ast_StringTypePool* p, ast_context_Context* c)
{
   p->count = 0;
   p->capacity = 0;
   p->slots = NULL;
   p->context = c;
   ast_StringTypePool_resize(p, 8);
}

static void ast_StringTypePool_clear(ast_StringTypePool* p)
{
   free(p->slots);
   p->count = 0;
   p->capacity = 0;
   p->slots = NULL;
}

static void ast_StringTypePool_resize(ast_StringTypePool* p, uint32_t cap)
{
   p->capacity = cap;
   ast_StringTypeSlot* slots2 = malloc(p->capacity * 16);
   if (p->count) {
      memcpy(slots2, p->slots, p->count * 16);
      free(p->slots);
   }
   p->slots = slots2;
}

static ast_QualType ast_StringTypePool_get(ast_StringTypePool* p, uint32_t len)
{
   for (uint32_t i = 0; i < p->count; i++) {
      ast_StringTypeSlot* s = &p->slots[i];
      if (s->len == len) {
         ast_QualType qt = ast_QualType_create(s->type_);
         ast_QualType_setConst(&qt);
         return qt;
      }
   }
   if (p->count == p->capacity) ast_StringTypePool_resize(p, p->capacity * 2);
   ast_Type* t = (ast_Type*)ast_ArrayType_create(p->context, ast_getBuiltinQT(ast_BuiltinKind_Char), true, len, false, ast_QualType_Invalid);
   uint32_t idx = p->count;
   p->slots[idx].len = len;
   p->slots[idx].type_ = t;
   p->count++;
   ast_QualType qt = ast_QualType_create(t);
   ast_Type_setCanonicalType(t, qt);
   ast_QualType_setConst(&qt);
   return qt;
}

static void ast_SymbolTable_init(ast_SymbolTable* t, uint32_t initial)
{
   t->num_public = 0;
   t->num_private = 0;
   t->capacity = 0;
   ast_SymbolTable_resize(t, initial);
}

static void ast_SymbolTable_free(ast_SymbolTable* t)
{
   free(t->decls);
   free(t->symbols);
}

static uint32_t ast_SymbolTable_size(const ast_SymbolTable* t)
{
   return t->num_public + t->num_private;
}

static ast_Decl** ast_SymbolTable_getDecls(const ast_SymbolTable* t)
{
   return t->decls;
}

static void ast_SymbolTable_resize(ast_SymbolTable* t, uint32_t capacity)
{
   uint32_t* symbols = malloc(capacity * 4);
   ast_Decl** decls = malloc(capacity * 8);
   t->capacity = capacity;
   uint32_t count = t->num_public + t->num_private;
   if (count) {
      memcpy(symbols, t->symbols, count * 4);
      memcpy(decls, t->decls, count * 8);
      free(t->decls);
      free(t->symbols);
   }
   t->symbols = symbols;
   t->decls = decls;
}

static void ast_SymbolTable_add(ast_SymbolTable* t, uint32_t name_idx, ast_Decl* d)
{
   uint32_t count = t->num_public + t->num_private;
   if (count == t->capacity) ast_SymbolTable_resize(t, t->capacity * 2);
   if (ast_Decl_isPublic(d)) {
      if (t->num_private != 0) {
         t->symbols[count] = t->symbols[t->num_public];
         t->decls[count] = t->decls[t->num_public];
      }
      t->symbols[t->num_public] = name_idx;
      t->decls[t->num_public] = d;
      t->num_public++;
   } else {
      t->symbols[count] = name_idx;
      t->decls[count] = d;
      t->num_private++;
   }
}

static ast_Decl* ast_SymbolTable_find(const ast_SymbolTable* t, uint32_t name_idx)
{
   uint32_t count = t->num_public + t->num_private;
   for (uint32_t i = 0; i < count; i++) {
      if (t->symbols[i] == name_idx) return t->decls[i];
   }
   return NULL;
}

static ast_Decl* ast_SymbolTable_findPublic(const ast_SymbolTable* t, uint32_t name_idx)
{
   for (uint32_t i = 0; i < t->num_public; i++) {
      if (t->symbols[i] == name_idx) return t->decls[i];
   }
   return NULL;
}

static ast_Decl* ast_SymbolTable_findPrivate(const ast_SymbolTable* t, uint32_t name_idx)
{
   uint32_t count = t->num_public + t->num_private;
   for (uint32_t i = t->num_public; i < count; i++) {
      if (t->symbols[i] == name_idx) return t->decls[i];
   }
   return NULL;
}

static void ast_SymbolTable_print(const ast_SymbolTable* t, string_buffer_Buf* out)
{
   uint32_t count = t->num_public + t->num_private;
   for (uint32_t i = 0; i < count; i++) {
      const ast_Decl* d = t->decls[i];
      string_buffer_Buf_color(out, ast_Decl_isUsed(d) ? color_Normal : color_Grey);
      const char* name = ast_idx2name(t->symbols[i]);
      string_buffer_Buf_print(out, "    %s", name);
      if (ast_Decl_isFunction(d)) string_buffer_Buf_add(out, "()");
      if (ast_Decl_isPublic(d)) {
         string_buffer_Buf_color(out, color_Yellow);
         string_buffer_Buf_add(out, " public");
      }
      string_buffer_Buf_newline(out);
      if (ast_Decl_isStructType(d)) {
         ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
         const ast_FunctionDecl** fds = ast_StructTypeDecl_getStructFunctions(std);
         for (uint32_t j = 0; j < ast_StructTypeDecl_getNumStructFunctions(std); j++) {
            ast_Decl* fd = (ast_Decl*)fds[j];
            string_buffer_Buf_color(out, ast_Decl_isUsed(fd) ? color_Normal : color_Grey);
            string_buffer_Buf_indent(out, 6);
            string_buffer_Buf_print(out, "%s.%s()", name, ast_Decl_getName(fd));
            if (ast_Decl_isPublic(fd)) {
               string_buffer_Buf_color(out, color_Yellow);
               string_buffer_Buf_add(out, " public");
            }
            string_buffer_Buf_newline(out);
         }
      }
   }
}

static void ast_SymbolTable_dump(const ast_SymbolTable* t)
{
   string_buffer_Buf* out = ast_getDumpBuf();
   uint32_t count = t->num_public + t->num_private;
   string_buffer_Buf_add(out, "Symbols:\n");
   for (uint32_t i = 0; i < count; i++) {
      uint32_t name_idx = t->symbols[i];
      const char* name = ast_idx2name(name_idx);
      string_buffer_Buf_print(out, "  [%2u]  %6u  %s\n", i, name_idx, name);
   }
   ast_flushDumpBuf(out);
}

static ast_Globals* ast_getGlobals(void)
{
   return ast_globals;
}

static void ast_setGlobals(ast_Globals* g)
{
   ast_globals = g;
}

static void ast_initialize(ast_context_Context* c, string_pool_Pool* astPool, uint32_t wordsize, bool use_color)
{
   ast_globals = malloc(344);
   ast_PointerPool_init(&ast_globals->pointers, c);
   ast_StringTypePool_init(&ast_globals->string_types, c);
   ast_globals->wordsize = wordsize;
   ast_globals->use_color = use_color;
   ast_globals->names_pool = astPool;
   ast_globals->ast_count = 1;
   ast_globals->ast_capacity = 0;
   ast_globals->ast_list = NULL;
   ast_globals->dump_buf = string_buffer_create(4096, use_color, 2);
   for (ast_BuiltinKind kind = ast_BuiltinKind_Char; kind <= ast_BuiltinKind_Bool; kind++) {
      ast_QualType_set(&ast_globals->builtins[kind], (ast_Type*)ast_BuiltinType_create(c, kind));
   }
   ast_QualType_set(&ast_globals->void_type, (ast_Type*)ast_VoidType_create(c));
   ast_Type* void_ptr = ast_getPointerType(ast_globals->void_type);
   ast_QualType_set(&ast_globals->void_ptr_type, void_ptr);
   ast_Type_setCanonicalType(void_ptr, ast_globals->void_ptr_type);
   memcpy(ast_globals->builtinType_sizes, ast_BuiltinType_default_sizes, 56);
   ast_globals->builtinType_sizes[ast_BuiltinKind_ISize] = wordsize;
   ast_globals->builtinType_sizes[ast_BuiltinKind_USize] = wordsize;
   memcpy(ast_globals->builtinType_width, ast_BuiltinType_default_widths, 56);
   ast_globals->builtinType_width[ast_BuiltinKind_ISize] = wordsize * 8;
   ast_globals->builtinType_width[ast_BuiltinKind_USize] = wordsize * 8;
   for (ast_BuiltinKind kind = ast_BuiltinKind_Char; kind <= ast_BuiltinKind_Bool; kind++) {
      ast_globals->builtinType_baseTypes[kind] = kind;
   }
   if (wordsize == 4) {
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_ISize] = ast_BuiltinKind_Int32;
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_USize] = ast_BuiltinKind_UInt32;
   } else {
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_ISize] = ast_BuiltinKind_Int64;
      ast_globals->builtinType_baseTypes[ast_BuiltinKind_USize] = ast_BuiltinKind_UInt64;
   }
}

static void ast_deinit(bool print_stats)
{
   ast_globals->names_pool = NULL;
   ast_globals->ast_count = 0;
   ast_globals->ast_capacity = 0;
   free(ast_globals->ast_list);
   ast_globals->ast_list = NULL;
   ast_PointerPool_clear(&ast_globals->pointers);
   ast_StringTypePool_clear(&ast_globals->string_types);
   string_buffer_Buf_free(ast_globals->dump_buf);
   free(ast_globals);
   ast_globals = NULL;
}

static uint32_t ast_getWordSize(void)
{
   return ast_globals->wordsize;
}

static bool ast_useColor(void)
{
   return ast_globals->use_color;
}

static ast_QualType ast_getStringType(uint32_t len)
{
   return ast_StringTypePool_get(&ast_globals->string_types, len);
}

static const char* ast_idx2name(uint32_t idx)
{
   if (idx) return string_pool_Pool_idx2str(ast_globals->names_pool, idx);
   return NULL;
}

static ast_QualType ast_getVoidPtr(void)
{
   return ast_globals->void_ptr_type;
}

static ast_Type* ast_getPointerType(ast_QualType inner)
{
   return ast_PointerPool_getPointer(&ast_globals->pointers, inner);
}

static ast_QualType ast_getVoidQT(void)
{
   return ast_globals->void_type;
}

static ast_QualType ast_getBuiltinQT(ast_BuiltinKind kind)
{
   return ast_globals->builtins[kind];
}

static uint32_t ast_addAST(ast_AST* ast_)
{
   if (ast_globals->ast_count >= ast_globals->ast_capacity) {
      if (ast_globals->ast_capacity == 0) ast_globals->ast_capacity = 16;
      else ast_globals->ast_capacity *= 2;
      void* buf = malloc(ast_globals->ast_capacity * 8);
      if (ast_globals->ast_list) {
         void* old = ast_globals->ast_list;
         memcpy(buf, old, ast_globals->ast_count * 8);
         free(old);
      }
      ast_globals->ast_list = buf;
   }
   uint32_t idx = ast_globals->ast_count;
   ast_globals->ast_list[idx] = ast_;
   ast_globals->ast_count++;
   return idx;
}

static ast_AST* ast_idx2ast(uint32_t idx)
{
   if (idx == 0) return NULL;
   return ast_globals->ast_list[idx];
}

static string_buffer_Buf* ast_getDumpBuf(void)
{
   return ast_globals->dump_buf;
}

static void ast_flushDumpBuf(string_buffer_Buf* out)
{
   string_buffer_Buf_color(out, ast_col_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_clear(out);
}

static void ast_setTypePublicUsed(ast_QualType qt)
{
   const ast_Type* t = ast_QualType_getType(qt);
   ast_Decl* d = NULL;
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin:
   case ast_TypeKind_Void:
      return;
   case ast_TypeKind_Pointer: {
      ast_PointerType* pt = (ast_PointerType*)t;
      ast_setTypePublicUsed(pt->inner);
      return;
   }
   case ast_TypeKind_Array: {
      ast_ArrayType* at = (ast_ArrayType*)t;
      ast_setTypePublicUsed(at->elem);
      return;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = (ast_StructType*)t;
      d = (ast_Decl*)st->decl;
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = (ast_EnumType*)t;
      d = (ast_Decl*)et->decl;
      break;
   }
   case ast_TypeKind_Function:
      return;
   case ast_TypeKind_Alias: {
      ast_AliasType* at = (ast_AliasType*)t;
      d = (ast_Decl*)at->decl;
      break;
   }
   case ast_TypeKind_Module:
      return;
   }
   if (d) ast_Decl_setUsedPublic(d);
}

static ast_BuiltinKind ast_getNativeKind(void)
{
   return ast_globals->wordsize == 8 ? ast_BuiltinKind_UInt64 : ast_BuiltinKind_UInt32;
}

static ast_Value ast_Evaluator_get_value(ast_Evaluator* eval, const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral: {
      const ast_IntegerLiteral* i = (ast_IntegerLiteral*)e;
      return ast_IntegerLiteral_getValue(i);
   }
   case ast_ExprKind_FloatLiteral: {
      const ast_FloatLiteral* f = (ast_FloatLiteral*)e;
      return ast_FloatLiteral_getValue(f);
   }
   case ast_ExprKind_BooleanLiteral: {
      const ast_BooleanLiteral* b = (ast_BooleanLiteral*)e;
      return ast_BooleanLiteral_getValue(b);
   }
   case ast_ExprKind_CharLiteral: {
      const ast_CharLiteral* c = (ast_CharLiteral*)e;
      return ast_CharLiteral_getValue(c);
   }
   case ast_ExprKind_StringLiteral:
      ;//assert(0);
      break;
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      const ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      return ast_Evaluator_get_decl_value(eval, ast_IdentifierExpr_getDecl(i));
   }
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call: {
      const ast_CallExpr* c = (ast_CallExpr*)e;
      return ast_Evaluator_eval_call(eval, c);
   }
   case ast_ExprKind_InitList:
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return ast_Evaluator_get_binaryop_value(eval, (ast_BinaryOperator*)e);
   case ast_ExprKind_UnaryOperator:
      return ast_Evaluator_get_unaryop_value(eval, (ast_UnaryOperator*)e);
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = (ast_ConditionalOperator*)e;
      ast_Value v = ast_Evaluator_get_value(eval, ast_ConditionalOperator_getCond(c));
      if (ast_Value_isError(&v)) return v;
      return ast_Evaluator_get_value(eval, !ast_Value_isZero(&v) ? ast_ConditionalOperator_getLHS(c) : ast_ConditionalOperator_getRHS(c));
   }
   case ast_ExprKind_Builtin: {
      const ast_BuiltinExpr* bi = (ast_BuiltinExpr*)e;
      return ast_BuiltinExpr_getValue(bi);
   }
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = (ast_ArraySubscriptExpr*)e;
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      if (!ast_Expr_isBitOffset(index)) break;
      ast_Value result = ast_Evaluator_get_value(eval, ast_ArraySubscriptExpr_getBase(a));
      ;//assert(ast_Value_isDecimal(&result) && !ast_Value_isNegative(&result));
      ast_BitOffsetExpr* bo = (ast_BitOffsetExpr*)index;
      ast_Value high = ast_Evaluator_get_value(eval, ast_BitOffsetExpr_getLHS(bo));
      ast_Value low = ast_Evaluator_get_value(eval, ast_BitOffsetExpr_getRHS(bo));
      ast_Value width = ast_Value_minus(&high, &low);
      ast_Value_incr(&width);
      result = ast_Value_right_shift(&result, &low);
      ast_Value_mask(&result, ast_Value_as_u32(&width));
      return result;
   }
   case ast_ExprKind_Member: {
      const ast_MemberExpr* m = (ast_MemberExpr*)e;
      return ast_Evaluator_get_decl_value(eval, ast_MemberExpr_getFullDecl(m));
   }
   case ast_ExprKind_Paren: {
      const ast_ParenExpr* p = (ast_ParenExpr*)e;
      return ast_Evaluator_get_value(eval, ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      ;//assert(0);
      break;
   case ast_ExprKind_ExplicitCast: {
      const ast_ExplicitCastExpr* i = (ast_ExplicitCastExpr*)e;
      ast_Value result = ast_Evaluator_get_value(eval, ast_ExplicitCastExpr_getInner(i));
      return ast_Value_castAs(&result, ast_Expr_getType(e));
   }
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* i = (ast_ImplicitCastExpr*)e;
      return ast_Evaluator_get_value(eval, ast_ImplicitCastExpr_getInner(i));
   }
   case ast_ExprKind_Range:
      ;//assert(0);
      break;
   case ast_ExprKind_NamedArgument: {
      const ast_NamedArgument* n = (ast_NamedArgument*)e;
      return ast_Evaluator_get_value(eval, ast_NamedArgument_getInner(n));
   }
   case ast_ExprKind_Alternate: {
      const ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      return ast_Evaluator_get_value(eval, ast_AlternateExpr_getOriginal(n));
   }
   }
   return ast_Value_error("expression is not constant");
}

static ast_Value ast_Evaluator_get_binaryop_value(ast_Evaluator* eval, const ast_BinaryOperator* e)
{
   ast_Value left = ast_Evaluator_get_value(eval, ast_BinaryOperator_getLHS(e));
   if (ast_Value_isError(&left)) return left;
   ast_BinaryOpcode op = ast_BinaryOperator_getOpcode(e);
   ast_Value right;
   if (!(op >= ast_BinaryOpcode_LAnd && op <= ast_BinaryOpcode_LOr)) right = ast_Evaluator_get_value(eval, ast_BinaryOperator_getRHS(e));
   switch (op) {
   case ast_BinaryOpcode_Multiply:
      return ast_Value_multiply(&left, &right);
   case ast_BinaryOpcode_Divide:
      return ast_Value_divide(&left, &right);
   case ast_BinaryOpcode_Remainder:
      return ast_Value_remainder(&left, &right);
   case ast_BinaryOpcode_Add:
      return ast_Value_add(&left, &right);
   case ast_BinaryOpcode_Subtract:
      return ast_Value_minus(&left, &right);
   case ast_BinaryOpcode_ShiftLeft:
      return ast_Value_left_shift(&left, &right);
   case ast_BinaryOpcode_ShiftRight:
      return ast_Value_right_shift(&left, &right);
   case ast_BinaryOpcode_LessThan:
      return ast_Value_createBool(ast_Value_is_less(&left, &right));
   case ast_BinaryOpcode_GreaterThan:
      return ast_Value_createBool(ast_Value_is_greater(&left, &right));
   case ast_BinaryOpcode_LessEqual:
      return ast_Value_createBool(ast_Value_is_less_equal(&left, &right));
   case ast_BinaryOpcode_GreaterEqual:
      return ast_Value_createBool(ast_Value_is_greater_equal(&left, &right));
   case ast_BinaryOpcode_Equal:
      return ast_Value_createBool(ast_Value_is_equal(&left, &right));
   case ast_BinaryOpcode_NotEqual:
      return ast_Value_createBool(!ast_Value_is_equal(&left, &right));
   case ast_BinaryOpcode_And:
      return ast_Value_and(&left, &right);
   case ast_BinaryOpcode_Xor:
      return ast_Value_xor(&left, &right);
   case ast_BinaryOpcode_Or:
      return ast_Value_or(&left, &right);
   case ast_BinaryOpcode_LAnd:
      if (ast_Value_isZero(&left)) return ast_Value_createBool(0);
      right = ast_Evaluator_get_value(eval, ast_BinaryOperator_getRHS(e));
      return ast_Value_toBool(&right);
   case ast_BinaryOpcode_LOr:
      if (!ast_Value_isZero(&left)) return ast_Value_createBool(1);
      right = ast_Evaluator_get_value(eval, ast_BinaryOperator_getRHS(e));
      return ast_Value_toBool(&right);
   case ast_BinaryOpcode_Assign:
   case ast_BinaryOpcode_MulAssign:
   case ast_BinaryOpcode_DivAssign:
   case ast_BinaryOpcode_RemAssign:
   case ast_BinaryOpcode_AddAssign:
   case ast_BinaryOpcode_SubAssign:
   case ast_BinaryOpcode_ShlAssign:
   case ast_BinaryOpcode_ShrAssign:
   case ast_BinaryOpcode_AndAssign:
   case ast_BinaryOpcode_XorAssign:
   case ast_BinaryOpcode_OrAssign:
      ;//assert(0);
      break;
   }
   return ast_Value_error("unsupported operator");
}

static ast_Value ast_Evaluator_get_unaryop_value(ast_Evaluator* eval, const ast_UnaryOperator* e)
{
   const ast_Expr* inner = ast_UnaryOperator_getInner(e);
   ast_Value res2 = ast_Evaluator_get_value(eval, inner);
   switch (ast_UnaryOperator_getOpcode(e)) {
   case ast_UnaryOpcode_PostInc:
   case ast_UnaryOpcode_PostDec:
   case ast_UnaryOpcode_PreInc:
   case ast_UnaryOpcode_PreDec:
      break;
   case ast_UnaryOpcode_AddrOf:
   case ast_UnaryOpcode_Deref:
      break;
   case ast_UnaryOpcode_Plus:
      return res2;
   case ast_UnaryOpcode_Minus:
      return ast_Value_negate(&res2);
   case ast_UnaryOpcode_Not:
      return ast_Value_bitnot(&res2);
   case ast_UnaryOpcode_LNot:
      return ast_Value_lnot(&res2);
   }
   return ast_Value_error("unsupported operator");
}

static ast_Value ast_Evaluator_get_decl_value(ast_Evaluator* eval, const ast_Decl* d)
{
   ;//assert(d);
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_EnumConstant: {
      const ast_EnumConstantDecl* ecd = (ast_EnumConstantDecl*)d;
      return ast_EnumConstantDecl_getValue(ecd);
   }
   case ast_DeclKind_Variable: {
      const ast_VarDecl* vd = (ast_VarDecl*)d;
      switch (ast_VarDecl_getKind(vd)) {
      case ast_VarDeclKind_GlobalVar:
      case ast_VarDeclKind_LocalVar: {
         const ast_Expr* initval = ast_VarDecl_getInit(vd);
         if (!initval) break;
         return ast_Evaluator_get_value(eval, initval);
      }
      case ast_VarDeclKind_FunctionParam: {
         uint32_t off = ast_VarDecl_getOffset(vd);
         ;//assert(off < eval->num_args);
         return eval->args[off];
      }
      case ast_VarDeclKind_StructMember:
         break;
      }
      return ast_Value_error("variable cannot be evaluated");
   }
   default:
      ;//assert(0);
      break;
   }
   return ast_Value_error("not a constant value");
}

static ast_Value ast_Evaluator_eval_call(ast_Evaluator* caller, const ast_CallExpr* c)
{
   if (caller->depth > ast_Max_depth) {
      return ast_Value_error("recursion too deep");
   }
   if (caller->complexity > ast_Max_complexity) {
      return ast_Value_error("expression too complex");
   }
   uint32_t num_args = ast_CallExpr_getNumArgs(c);
   ast_Expr** args = ast_CallExpr_getArgs(((ast_CallExpr*)c));
   ast_FunctionDecl* fd = ast_expr2function(ast_CallExpr_getFunc(c));
   ast_Evaluator eval;
   if (num_args > 16) {
      return ast_Value_error("too many arguments in pure function evaluation");
   }
   eval.prev = caller;
   eval.fd = fd;
   eval.num_args = num_args;
   eval.depth = caller->depth + 1;
   eval.complexity = caller->complexity + 1;
   for (uint32_t i = 0; i < num_args; i++) {
      ast_Value v = ast_Evaluator_get_value(caller, args[i]);
      if (ast_Value_isError(&v)) return v;
      eval.args[i] = v;
   }
   ast_CompoundStmt* body = ast_FunctionDecl_getBody(fd);
   if (body) {
      ast_Cont cont = ast_CompoundStmt_eval(body, &eval);
      caller->complexity = eval.complexity;
      switch (cont) {
      case ast_Cont_Normal:
         return ast_Value_error("pure function did not return anything");
      case ast_Cont_Continue:
      case ast_Cont_Break:
      case ast_Cont_Goto:
         break;
      case ast_Cont_Abort:
         if (!ast_Value_isError(&eval.result)) break;
         fallthrough;
      case ast_Cont_Return:
      case ast_Cont_Error:
         return eval.result;
      }
   } else {
      ast_Fun fun = { .address = ast_FunctionDecl_getAddress(fd) };
      if (!fun.address) {
         const char* cname = ast_FunctionDecl_getCName(fd);
         if (!cname) return ast_Value_error("no function name");
         fun.address = dlsym(dlfcn_RTLD_DEFAULT, cname);
         if (fun.address) {
            ast_FunctionDecl_setAddress(fd, fun.address);
         } else {
            return ast_Value_error("function not found");
         }
      }
      if (fun.address) {
         ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
         if (num_args == 1) {
            ast_Decl* d = (ast_Decl*)params[0];
            ast_QualType qt1 = ast_Decl_getType(d);
            ast_QualType rt = ast_FunctionDecl_getRType(fd);
            qt1 = ast_QualType_getCanonicalType(qt1);
            rt = ast_QualType_getCanonicalType(rt);
            if (ast_QualType_isInteger(rt) && ast_QualType_isInteger(qt1)) {
               return ast_Value_createSigned(fun.funII(ast_Value_as_i32(&eval.args[0])));
            }
            if (ast_QualType_isFloat(rt) && ast_QualType_isFloat(qt1)) {
               return ast_Value_createFloat(fun.funDD(ast_Value_toFloat(&eval.args[0])));
            }
            fprintf(stderr, "function prototype not supported: %s\n", ast_FunctionDecl_getCName(fd));
            ast_QualType_dump_full(qt1);
            ast_QualType_dump_full(rt);
            return ast_Value_error("function prototype not supported");
         }
      }
   }
   return ast_Value_error("pure function evaluation error");
}

static ast_FunctionDecl* ast_expr2function(ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      return (ast_FunctionDecl*)ast_IdentifierExpr_getDecl(i);
   }
   case ast_ExprKind_Member: {
      ast_MemberExpr* m = (ast_MemberExpr*)e;
      return (ast_FunctionDecl*)ast_MemberExpr_getFullDecl(m);
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)e;
      return ast_expr2function(ast_ImplicitCastExpr_getInner(ic));
   }
   default:
      ;//assert(0);
      break;
   }
   return NULL;
}

static ast_Value ast_evalExpr(const ast_Expr* e)
{
   ast_Evaluator top = { };
   return ast_Evaluator_get_value(&top, e);
}

static ast_Cont ast_Evaluator_error(ast_Evaluator* sf, const char* msg)
{
   sf->result = ast_Value_error(msg);
   return ast_Cont_Abort;
}

static ast_Cont ast_Stmt_eval(ast_Stmt* s, ast_Evaluator* sf)
{
   sf->complexity++;
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      return ast_ReturnStmt_eval(((ast_ReturnStmt*)s), sf);
   case ast_StmtKind_Expr:
      return ast_Expr_eval(((ast_Expr*)s), sf);
   case ast_StmtKind_If:
      return ast_IfStmt_eval(((ast_IfStmt*)s), sf);
   case ast_StmtKind_While:
      return ast_WhileStmt_eval(((ast_WhileStmt*)s), sf);
   case ast_StmtKind_For:
      return ast_ForStmt_eval(((ast_ForStmt*)s), sf);
   case ast_StmtKind_Switch:
      return ast_SwitchStmt_eval(((ast_SwitchStmt*)s), sf);
   case ast_StmtKind_Break:
      return ast_BreakStmt_eval(((ast_BreakStmt*)s), sf);
   case ast_StmtKind_Continue:
      return ast_ContinueStmt_eval(((ast_ContinueStmt*)s), sf);
   case ast_StmtKind_Fallthrough:
      return ast_FallthroughStmt_eval(((ast_FallthroughStmt*)s), sf);
   case ast_StmtKind_Label:
      return ast_LabelStmt_eval(((ast_LabelStmt*)s), sf);
   case ast_StmtKind_Goto:
      return ast_GotoStmt_eval(((ast_GotoStmt*)s), sf);
   case ast_StmtKind_Compound:
      return ast_CompoundStmt_eval(((ast_CompoundStmt*)s), sf);
   case ast_StmtKind_Decl:
      return ast_DeclStmt_eval(((ast_DeclStmt*)s), sf);
   case ast_StmtKind_Asm:
      return ast_AsmStmt_eval(((ast_AsmStmt*)s), sf);
   case ast_StmtKind_Assert:
      return ast_AssertStmt_eval(((ast_AssertStmt*)s), sf);
   }
   return ast_Cont_Abort;
}

static ast_Cont ast_ReturnStmt_eval(ast_ReturnStmt* r, ast_Evaluator* sf)
{
   ast_Expr* e = ast_ReturnStmt_getValue(r);
   if (e) {
      sf->result = ast_Evaluator_get_value(sf, e);
      if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
      return ast_Cont_Return;
   } else {
      ast_Evaluator_error(sf, "void return");
      return ast_Cont_Return;
   }
}

static ast_Cont ast_Expr_eval(ast_Expr* e, ast_Evaluator* sf)
{
   sf->result = ast_Evaluator_get_value(sf, e);
   if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
   else return ast_Cont_Normal;
}

static ast_Cont ast_IfStmt_eval(ast_IfStmt* s, ast_Evaluator* sf)
{
   ast_Stmt* cond = ast_IfStmt_getCond(s);
   ast_Expr* e = NULL;
   if (ast_Stmt_isExpr(cond)) {
      e = (ast_Expr*)cond;
   } else if (ast_Stmt_isDecl(cond)) {
      e = ast_VarDecl_getInit(ast_DeclStmt_getDecl(((ast_DeclStmt*)cond), 0));
   }
   if (!e) return ast_Cont_Abort;
   sf->result = ast_Evaluator_get_value(sf, e);
   if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
   if (!ast_Value_isZero(&sf->result)) {
      return ast_Stmt_eval(ast_IfStmt_getThen(s), sf);
   } else {
      ast_Stmt* s1 = ast_IfStmt_getElse(s);
      if (s1) return ast_Stmt_eval(s1, sf);
      return ast_Cont_Normal;
   }
}

static ast_Cont ast_WhileStmt_eval(ast_WhileStmt* s, ast_Evaluator* sf)
{
   for (;;) {
      ast_Stmt* cond = ast_WhileStmt_getCond(s);
      ast_Expr* e = NULL;
      if (ast_Stmt_isExpr(cond)) {
         e = (ast_Expr*)cond;
      } else if (ast_Stmt_isDecl(cond)) {
         e = ast_VarDecl_getInit(ast_DeclStmt_getDecl(((ast_DeclStmt*)cond), 0));
      }
      if (!e) return ast_Cont_Abort;
      sf->result = ast_Evaluator_get_value(sf, e);
      if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
      if (ast_Value_isZero(&sf->result)) return ast_Cont_Normal;
      ast_Cont cont = ast_Stmt_eval(ast_WhileStmt_getBody(s), sf);
      switch (cont) {
      case ast_Cont_Normal:
      case ast_Cont_Continue:
         break;
      case ast_Cont_Break:
         return ast_Cont_Normal;
      case ast_Cont_Return:
      case ast_Cont_Goto:
      case ast_Cont_Abort:
      case ast_Cont_Error:
         return cont;
      }
   }
}

static ast_Cont ast_ForStmt_eval(ast_ForStmt* s, ast_Evaluator* sf)
{
   ast_Stmt* s1 = ast_ForStmt_getInit(s);
   ast_Expr* e;
   ast_Cont cont;
   if (s1) {
      cont = ast_Stmt_eval(s1, sf);
      if (cont != ast_Cont_Normal) return cont;
   }
   for (;;) {
      e = ast_ForStmt_getCond(s);
      if (e) {
         sf->result = ast_Evaluator_get_value(sf, e);
         if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
         if (ast_Value_isZero(&sf->result)) return ast_Cont_Normal;
      }
      cont = ast_Stmt_eval(ast_ForStmt_getBody(s), sf);
      switch (cont) {
      case ast_Cont_Normal:
      case ast_Cont_Continue:
         break;
      case ast_Cont_Break:
         return ast_Cont_Normal;
      case ast_Cont_Return:
      case ast_Cont_Goto:
      case ast_Cont_Abort:
      case ast_Cont_Error:
         return cont;
      }
      e = ast_ForStmt_getCont(s);
      if (e) {
         sf->result = ast_Evaluator_get_value(sf, e);
         if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
      }
   }
}

static ast_Cont ast_SwitchStmt_eval(ast_SwitchStmt* s, ast_Evaluator* sf)
{
   return ast_Evaluator_error(sf, "switch not supported");
}

static ast_Cont ast_BreakStmt_eval(ast_BreakStmt* s, ast_Evaluator* sf)
{
   return ast_Cont_Break;
}

static ast_Cont ast_ContinueStmt_eval(ast_ContinueStmt* s, ast_Evaluator* sf)
{
   return ast_Cont_Continue;
}

static ast_Cont ast_FallthroughStmt_eval(ast_FallthroughStmt* s, ast_Evaluator* sf)
{
   return ast_Cont_Normal;
}

static ast_Cont ast_LabelStmt_eval(ast_LabelStmt* s, ast_Evaluator* sf)
{
   ast_Stmt* s1 = ast_LabelStmt_getStmt(s);
   return s1 ? ast_Stmt_eval(s1, sf) : ast_Cont_Normal;
}

static ast_Cont ast_GotoStmt_eval(ast_GotoStmt* s, ast_Evaluator* sf)
{
   return ast_Evaluator_error(sf, "goto not supported");
}

static ast_Cont ast_CompoundStmt_eval(ast_CompoundStmt* body, ast_Evaluator* sf)
{
   uint32_t count = ast_CompoundStmt_getCount(body);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(body);
   for (uint32_t i = 0; i < count; i++) {
      ast_Cont cont = ast_Stmt_eval(stmts[i], sf);
      if (cont != ast_Cont_Normal) return cont;
   }
   return ast_Cont_Normal;
}

static ast_Cont ast_DeclStmt_eval(ast_DeclStmt* s, ast_Evaluator* sf)
{
   return ast_Evaluator_error(sf, "declarations not supported");
}

static ast_Cont ast_AsmStmt_eval(ast_AsmStmt* s, ast_Evaluator* sf)
{
   return ast_Evaluator_error(sf, "asm not supported");
}

static ast_Cont ast_AssertStmt_eval(ast_AssertStmt* s, ast_Evaluator* sf)
{
   ast_Expr* e = ast_AssertStmt_getInner(s);
   sf->result = ast_Evaluator_get_value(sf, e);
   if (ast_Value_isError(&sf->result)) return ast_Cont_Error;
   if (ast_Value_isZero(&sf->result)) {
      return ast_Evaluator_error(sf, "assertion failed");
   }
   return ast_Cont_Normal;
}


// --- module build_target ---
typedef struct build_target_Plugin_ build_target_Plugin;
typedef struct build_target_PluginList_ build_target_PluginList;
typedef struct build_target_Target_ build_target_Target;
typedef struct build_target_Lib_ build_target_Lib;
typedef struct build_target_List_ build_target_List;

typedef uint8_t build_target_BackEndKind;
enum build_target_BackEndKind {
   build_target_BackEndKind_None,
   build_target_BackEndKind_C,
   build_target_BackEndKind_IR,
};

typedef uint8_t build_target_Kind;
enum build_target_Kind {
   build_target_Kind_Image,
   build_target_Kind_Executable,
   build_target_Kind_StaticLibrary,
   build_target_Kind_DynamicLibrary,
   build_target_Kind_SourceLibrary,
};

struct build_target_Plugin_ {
   uint32_t name;
   uint32_t options;
   src_loc_SrcLoc loc;
};

struct build_target_PluginList_ {
   build_target_Plugin* plugins;
   uint32_t count;
   uint32_t capacity;
};

struct build_target_List_ {
   build_target_Lib* libs;
   uint32_t count;
   uint32_t capacity;
};

struct build_target_Target_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   warning_flags_Flags warnings;
   build_target_Kind kind;
   bool disable_asserts;
   bool no_libc;
   build_target_BackEndKind backend;
   bool backend_no_build;
   bool backend_fast;
   bool optional;
   string_list_List features;
   build_target_List libs;
   string_list_List exports;
   build_target_PluginList plugins;
   file_list_FileList files;
   file_list_FileList asm_files;
};

typedef void (*build_target_Visitor)(void* arg, uint32_t name, build_target_Kind kind);

static bool build_target_has_dynamic(build_target_Kind k);
static void build_target_PluginList_init(build_target_PluginList* l);
static void build_target_PluginList_free(build_target_PluginList* l);
static uint32_t build_target_PluginList_size(const build_target_PluginList* l);
static const build_target_Plugin* build_target_PluginList_get(const build_target_PluginList* l, uint32_t idx);
static void build_target_PluginList_add(build_target_PluginList* l, uint32_t name, uint32_t options, src_loc_SrcLoc loc);
static build_target_Target* build_target_create(uint32_t name_idx, src_loc_SrcLoc loc, build_target_Kind kind, string_pool_Pool* pool);
static void build_target_Target_free(build_target_Target* t);
static uint32_t build_target_Target_getNameIdx(const build_target_Target* t);
static void build_target_Target_setNameIdx(build_target_Target* t, uint32_t name_idx);
static uint32_t build_target_Target_numFiles(const build_target_Target* t);
static uint32_t build_target_Target_numAsmFiles(const build_target_Target* t);
static const string_list_List* build_target_Target_getFeatures(const build_target_Target* t);
static void build_target_Target_addFeature(build_target_Target* t, uint32_t feature);
static void build_target_Target_addPlugin(build_target_Target* t, uint32_t name, uint32_t options, src_loc_SrcLoc loc);
static const build_target_PluginList* build_target_Target_getPlugins(const build_target_Target* t);
static void build_target_Target_disableAsserts(build_target_Target* t);
static bool build_target_Target_hasAsserts(const build_target_Target* t);
static void build_target_Target_visitLibs(const build_target_Target* t, build_target_Visitor visitor, void* arg);
static bool build_target_Target_hasLib(const build_target_Target* t, uint32_t lib);
static void build_target_Target_addLib(build_target_Target* t, uint32_t lib, build_target_Kind kind);
static void build_target_Target_disableWarnings(build_target_Target* t);
static void build_target_Target_enableWarnings(build_target_Target* t);
static const warning_flags_Flags* build_target_Target_getWarnings(const build_target_Target* t);
static warning_flags_Flags* build_target_Target_getWarnings2(build_target_Target* t);
static void build_target_Target_addExport(build_target_Target* t, uint32_t export);
static const string_list_List* build_target_Target_getExports(const build_target_Target* t);
static build_target_Kind build_target_Target_getKind(const build_target_Target* t);
static bool build_target_Target_needsMain(const build_target_Target* t);
static bool build_target_Target_addFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc);
static const file_list_File* build_target_Target_getFile(const build_target_Target* t, uint32_t idx);
static bool build_target_Target_addAsmFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc);
static const file_list_File* build_target_Target_getAsmFile(const build_target_Target* t, uint32_t idx);
static void build_target_Target_setNoLibC(build_target_Target* t);
static bool build_target_Target_getNoLibC(const build_target_Target* t);
static build_target_BackEndKind build_target_Target_getBackEnd(const build_target_Target* t);
static bool build_target_Target_hasBackEnd(const build_target_Target* t);
static void build_target_Target_setBackEnd(build_target_Target* t, build_target_BackEndKind kind);
static void build_target_Target_setNoBuild(build_target_Target* t);
static bool build_target_Target_getNoBuild(const build_target_Target* t);
static void build_target_Target_setFastBuild(build_target_Target* t);
static bool build_target_Target_getFastBuild(const build_target_Target* t);
static void build_target_Target_setOptional(build_target_Target* t);
static bool build_target_Target_getOptional(const build_target_Target* t);
struct build_target_Lib_ {
   uint32_t name;
   build_target_Kind kind;
};

static void build_target_List_init(build_target_List* l);
static void build_target_List_free(build_target_List* l);
static void build_target_List_visit(const build_target_List* l, build_target_Visitor visitor, void* arg);
static void build_target_List_add(build_target_List* l, uint32_t name, build_target_Kind kind);
static bool build_target_List_contains(const build_target_List* l, uint32_t name);
static void build_target_List_resize(build_target_List* l, uint32_t cap);

static bool build_target_has_dynamic(build_target_Kind k)
{
   switch (k) {
   case build_target_Kind_Image:
      return false;
   case build_target_Kind_Executable:
      return true;
   case build_target_Kind_StaticLibrary:
      return false;
   case build_target_Kind_DynamicLibrary:
      return true;
   case build_target_Kind_SourceLibrary:
      return false;
   }
   return false;
}

static void build_target_PluginList_init(build_target_PluginList* l)
{
   memset(l, 0, 16);
}

static void build_target_PluginList_free(build_target_PluginList* l)
{
   free(l->plugins);
}

static uint32_t build_target_PluginList_size(const build_target_PluginList* l)
{
   return l->count;
}

static const build_target_Plugin* build_target_PluginList_get(const build_target_PluginList* l, uint32_t idx)
{
   return &l->plugins[idx];
}

static void build_target_PluginList_add(build_target_PluginList* l, uint32_t name, uint32_t options, src_loc_SrcLoc loc)
{
   if (l->count == l->capacity) {
      l->capacity = l->capacity ? l->capacity * 2 : 4;
      build_target_Plugin* plugins2 = malloc(l->capacity * 12);
      if (l->count) {
         memcpy(plugins2, l->plugins, l->count * 12);
         free(l->plugins);
      }
      l->plugins = plugins2;
   }
   build_target_Plugin* p = &l->plugins[l->count];
   p->name = name;
   p->options = options;
   p->loc = loc;
   l->count++;
}

static build_target_Target* build_target_create(uint32_t name_idx, src_loc_SrcLoc loc, build_target_Kind kind, string_pool_Pool* pool)
{
   build_target_Target* t = calloc(1, 144);
   t->name_idx = name_idx;
   t->loc = loc;
   t->warnings.no_unreachable_code = true;
   t->kind = kind;
   string_list_List_init(&t->features, pool);
   build_target_List_init(&t->libs);
   string_list_List_init(&t->exports, pool);
   file_list_FileList_init(&t->files, 8);
   file_list_FileList_init(&t->asm_files, 0);
   return t;
}

static void build_target_Target_free(build_target_Target* t)
{
   string_list_List_free(&t->exports);
   build_target_PluginList_free(&t->plugins);
   build_target_List_free(&t->libs);
   string_list_List_free(&t->features);
   file_list_FileList_free(&t->asm_files);
   file_list_FileList_free(&t->files);
   free(t);
}

static uint32_t build_target_Target_getNameIdx(const build_target_Target* t)
{
   return t->name_idx;
}

static void build_target_Target_setNameIdx(build_target_Target* t, uint32_t name_idx)
{
   t->name_idx = name_idx;
}

static uint32_t build_target_Target_numFiles(const build_target_Target* t)
{
   return file_list_FileList_getCount(&t->files);
}

static uint32_t build_target_Target_numAsmFiles(const build_target_Target* t)
{
   return file_list_FileList_getCount(&t->asm_files);
}

static const string_list_List* build_target_Target_getFeatures(const build_target_Target* t)
{
   return &t->features;
}

static void build_target_Target_addFeature(build_target_Target* t, uint32_t feature)
{
   string_list_List_add(&t->features, feature);
}

static void build_target_Target_addPlugin(build_target_Target* t, uint32_t name, uint32_t options, src_loc_SrcLoc loc)
{
   build_target_PluginList_add(&t->plugins, name, options, loc);
}

static const build_target_PluginList* build_target_Target_getPlugins(const build_target_Target* t)
{
   return &t->plugins;
}

static void build_target_Target_disableAsserts(build_target_Target* t)
{
   t->disable_asserts = true;
}

static bool build_target_Target_hasAsserts(const build_target_Target* t)
{
   return !t->disable_asserts;
}

static void build_target_Target_visitLibs(const build_target_Target* t, build_target_Visitor visitor, void* arg)
{
   build_target_List_visit(&t->libs, visitor, arg);
}

static bool build_target_Target_hasLib(const build_target_Target* t, uint32_t lib)
{
   return build_target_List_contains(&t->libs, lib);
}

static void build_target_Target_addLib(build_target_Target* t, uint32_t lib, build_target_Kind kind)
{
   build_target_List_add(&t->libs, lib, kind);
}

static void build_target_Target_disableWarnings(build_target_Target* t)
{
   t->warnings.no_unused = true;
   t->warnings.no_unused_variable = true;
   t->warnings.no_unused_function = true;
   t->warnings.no_unused_parameter = true;
   t->warnings.no_unused_type = true;
   t->warnings.no_unused_module = true;
   t->warnings.no_unused_import = true;
   t->warnings.no_unused_public = true;
   t->warnings.no_unused_label = true;
   t->warnings.no_unused_enum_constant = true;
   t->warnings.no_unreachable_code = true;
   t->warnings.no_unknown_attribute = true;
   t->warnings.no_deprecated = true;
}

static void build_target_Target_enableWarnings(build_target_Target* t)
{
   t->warnings.no_unused = false;
   t->warnings.no_unused_variable = false;
   t->warnings.no_unused_function = false;
   t->warnings.no_unused_parameter = false;
   t->warnings.no_unused_type = false;
   t->warnings.no_unused_module = false;
   t->warnings.no_unused_import = false;
   t->warnings.no_unused_public = false;
   t->warnings.no_unused_label = false;
   t->warnings.no_unused_enum_constant = false;
   t->warnings.no_unreachable_code = false;
   t->warnings.no_unknown_attribute = false;
   t->warnings.no_deprecated = false;
}

static const warning_flags_Flags* build_target_Target_getWarnings(const build_target_Target* t)
{
   return &t->warnings;
}

static warning_flags_Flags* build_target_Target_getWarnings2(build_target_Target* t)
{
   return &t->warnings;
}

static void build_target_Target_addExport(build_target_Target* t, uint32_t export)
{
   string_list_List_add(&t->exports, export);
}

static const string_list_List* build_target_Target_getExports(const build_target_Target* t)
{
   return &t->exports;
}

static build_target_Kind build_target_Target_getKind(const build_target_Target* t)
{
   return t->kind;
}

static bool build_target_Target_needsMain(const build_target_Target* t)
{
   switch (t->kind) {
   case build_target_Kind_Image:
   case build_target_Kind_Executable:
      return true;
   case build_target_Kind_StaticLibrary:
   case build_target_Kind_DynamicLibrary:
   case build_target_Kind_SourceLibrary:
      break;
   }
   return false;
}

static bool build_target_Target_addFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc)
{
   return file_list_FileList_add(&t->files, filename, loc);
}

static const file_list_File* build_target_Target_getFile(const build_target_Target* t, uint32_t idx)
{
   return file_list_FileList_get(&t->files, idx);
}

static bool build_target_Target_addAsmFile(build_target_Target* t, uint32_t filename, src_loc_SrcLoc loc)
{
   return file_list_FileList_add(&t->asm_files, filename, loc);
}

static const file_list_File* build_target_Target_getAsmFile(const build_target_Target* t, uint32_t idx)
{
   return file_list_FileList_get(&t->asm_files, idx);
}

static void build_target_Target_setNoLibC(build_target_Target* t)
{
   t->no_libc = true;
}

static bool build_target_Target_getNoLibC(const build_target_Target* t)
{
   return t->no_libc;
}

static build_target_BackEndKind build_target_Target_getBackEnd(const build_target_Target* t)
{
   return t->backend;
}

static bool build_target_Target_hasBackEnd(const build_target_Target* t)
{
   return t->backend != build_target_BackEndKind_None;
}

static void build_target_Target_setBackEnd(build_target_Target* t, build_target_BackEndKind kind)
{
   t->backend = kind;
}

static void build_target_Target_setNoBuild(build_target_Target* t)
{
   t->backend_no_build = true;
}

static bool build_target_Target_getNoBuild(const build_target_Target* t)
{
   return t->backend_no_build;
}

static void build_target_Target_setFastBuild(build_target_Target* t)
{
   t->backend_fast = true;
}

static bool build_target_Target_getFastBuild(const build_target_Target* t)
{
   return t->backend_fast;
}

static void build_target_Target_setOptional(build_target_Target* t)
{
   t->optional = true;
}

static bool build_target_Target_getOptional(const build_target_Target* t)
{
   return t->optional;
}

static void build_target_List_init(build_target_List* l)
{
   memset(l, 0, 16);
   build_target_List_resize(l, 2);
}

static void build_target_List_free(build_target_List* l)
{
   free(l->libs);
}

static void build_target_List_visit(const build_target_List* l, build_target_Visitor visitor, void* arg)
{
   for (uint32_t i = 0; i < l->count; i++) {
      const build_target_Lib* lib = &l->libs[i];
      visitor(arg, lib->name, lib->kind);
   }
}

static void build_target_List_add(build_target_List* l, uint32_t name, build_target_Kind kind)
{
   if (l->count == l->capacity) build_target_List_resize(l, l->capacity * 2);
   l->libs[l->count].name = name;
   l->libs[l->count].kind = kind;
   l->count++;
}

static bool build_target_List_contains(const build_target_List* l, uint32_t name)
{
   for (uint32_t i = 0; i < l->count; i++) {
      if (l->libs[i].name == name) return true;
   }
   return false;
}

static void build_target_List_resize(build_target_List* l, uint32_t cap)
{
   l->capacity = cap;
   build_target_Lib* libs2 = malloc(l->capacity * 8);
   if (l->libs) {
      memcpy(libs2, l->libs, l->count * 8);
      free(l->libs);
   }
   l->libs = libs2;
}


// --- module diagnostics ---
typedef struct diagnostics_Diags_ diagnostics_Diags;

struct diagnostics_Diags_ {
   source_mgr_SourceMgr* sm;
   string_buffer_Buf* out;
   uint32_t num_errors;
   uint32_t num_warnings;
   bool promote_warnings;
   const utils_PathInfo* path_info;
};

typedef uint8_t diagnostics_Category;
enum diagnostics_Category {
   diagnostics_Category_Note,
   diagnostics_Category_Warning,
   diagnostics_Category_Error,
};

static const char* diagnostics_category_names[3] = { "note", "warning", "error" };
static color_Color diagnostics_category_colors[3] = { color_Color_Grey, color_Color_Bmagenta, color_Color_Bred };
static diagnostics_Diags* diagnostics_create(source_mgr_SourceMgr* sm, bool use_color, const utils_PathInfo* path_info);
static void diagnostics_Diags_free(diagnostics_Diags* diags);
static void diagnostics_Diags_clear(diagnostics_Diags* diags);
static void diagnostics_Diags_setWarningAsError(diagnostics_Diags* diags, bool are_errors);
__attribute__((__format__(printf, 3, 4)))
static void diagnostics_Diags_error(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...);
static void diagnostics_Diags_error2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args);
__attribute__((__format__(printf, 3, 4)))
static void diagnostics_Diags_note(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...);
static void diagnostics_Diags_note2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args);
__attribute__((__format__(printf, 3, 4)))
static void diagnostics_Diags_warn(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...);
static void diagnostics_Diags_warn2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args);
__attribute__((__format__(printf, 4, 5)))
static void diagnostics_Diags_errorRange(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...);
static void diagnostics_Diags_errorRange2(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, va_list args);
static void diagnostics_Diags_internal(diagnostics_Diags* diags, diagnostics_Category category, src_loc_SrcLoc sloc, src_loc_SrcRange range, const char* format, va_list args);
static bool diagnostics_Diags_isOk(const diagnostics_Diags* diags);
static bool diagnostics_Diags_hasErrors(const diagnostics_Diags* diags);
static uint32_t diagnostics_Diags_getNumErrors(const diagnostics_Diags* diags);
static void diagnostics_Diags_printStatus(const diagnostics_Diags* diags);

static diagnostics_Diags* diagnostics_create(source_mgr_SourceMgr* sm, bool use_color, const utils_PathInfo* path_info)
{
   diagnostics_Diags* diags = calloc(1, 40);
   diags->sm = sm;
   diags->out = string_buffer_create(512, use_color, 1);
   diags->path_info = path_info;
   return diags;
}

static void diagnostics_Diags_free(diagnostics_Diags* diags)
{
   string_buffer_Buf_free(diags->out);
   free(diags);
}

static void diagnostics_Diags_clear(diagnostics_Diags* diags)
{
   diags->num_errors = 0;
   diags->num_warnings = 0;
}

static void diagnostics_Diags_setWarningAsError(diagnostics_Diags* diags, bool are_errors)
{
   diags->promote_warnings = are_errors;
}

__attribute__((__format__(printf, 3, 4)))
static void diagnostics_Diags_error(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_error2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args)
{
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
}

__attribute__((__format__(printf, 3, 4)))
static void diagnostics_Diags_note(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Note, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_note2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args)
{
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Diags_internal(diags, diagnostics_Category_Note, loc, range, format, args);
}

__attribute__((__format__(printf, 3, 4)))
static void diagnostics_Diags_warn(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Category category = diagnostics_Category_Warning;
   if (diags->promote_warnings) category = diagnostics_Category_Error;
   diagnostics_Diags_internal(diags, category, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_warn2(diagnostics_Diags* diags, src_loc_SrcLoc loc, const char* format, va_list args)
{
   src_loc_SrcRange range = { 0, 0 };
   diagnostics_Category category = diagnostics_Category_Warning;
   if (diags->promote_warnings) category = diagnostics_Category_Error;
   diagnostics_Diags_internal(diags, category, loc, range, format, args);
}

__attribute__((__format__(printf, 4, 5)))
static void diagnostics_Diags_errorRange(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
   va_end(args);
}

static void diagnostics_Diags_errorRange2(diagnostics_Diags* diags, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, va_list args)
{
   diagnostics_Diags_internal(diags, diagnostics_Category_Error, loc, range, format, args);
}

static void diagnostics_Diags_internal(diagnostics_Diags* diags, diagnostics_Category category, src_loc_SrcLoc sloc, src_loc_SrcRange range, const char* format, va_list args)
{
   if (category == diagnostics_Category_Error) {
      diags->num_errors++;
   } else {
      diags->num_warnings++;
   }
   string_buffer_Buf* out = diags->out;
   string_buffer_Buf_clear(out);
   source_mgr_Location loc = source_mgr_SourceMgr_locate(diags->sm, sloc);
   if (sloc && !loc.line_start) {
      string_buffer_Buf_print(out, "<invalid location %u>: ", sloc);
      sloc = 0;
   }
   if (sloc) {
      if (utils_PathInfo_hasSubdir(diags->path_info) && loc.filename[0] != '/') {
         string_buffer_Buf_add(out, diags->path_info->root2orig);
      }
      string_buffer_Buf_print(out, "%s:%u:%u: ", loc.filename, loc.line, loc.column);
   }
   string_buffer_Buf_color(out, diagnostics_category_colors[category]);
   string_buffer_Buf_add(out, diagnostics_category_names[category]);
   string_buffer_Buf_add(out, ": ");
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_vprintf(out, format, args);
   string_buffer_Buf_newline(out);
   if (sloc) {
      const char* text = loc.line_start;
      uint32_t loc_col = loc.column;
      uint32_t range_start_col = loc_col;
      uint32_t range_end_col = loc_col + 1;
      uint32_t end_col = loc_col + 1;
      if (range.start && range.end) {
         source_mgr_Location startLoc = source_mgr_SourceMgr_locate(diags->sm, range.start);
         source_mgr_Location endLoc = source_mgr_SourceMgr_locate(diags->sm, range.end);
         if (loc.line == startLoc.line && loc.line == endLoc.line && startLoc.column < endLoc.column) {
            range_start_col = startLoc.column;
            range_end_col = endLoc.column;
            if (end_col < range_end_col) end_col = range_end_col;
         }
      }
      uint32_t skip = 0;
      if (loc_col > 128) {
         skip = loc_col - 64;
         skip += utf8_sync(&text[skip]);
         if (range_start_col > skip) range_start_col -= skip;
         else range_start_col = 1;
         if (range_end_col > skip) range_end_col -= skip;
         else range_end_col = 1;
         loc_col -= skip;
         end_col -= skip;
         text += skip;
      }
      uint32_t len = 0;
      while (len < 128 && text[len] && text[len] != '\n' && text[len] != '\r') {
         len++;
      }
      len += utf8_sync(&text[len]);
      if (end_col > len + 2) end_col = len + 2;
      if (skip) string_buffer_Buf_add(out, "...");
      string_buffer_Buf_add2(out, text, len);
      string_buffer_Buf_newline(out);
      if (skip) string_buffer_Buf_add(out, "   ");
      for (uint32_t col = 1; col < end_col; col++) {
         char c = ' ';
         if (text[col - 1] == '\t') c = '\t';
         if (col == range_start_col) string_buffer_Buf_color(out, color_Bgreen);
         if (col >= range_start_col && col < range_end_col) c = '~';
         if (col == loc_col) c = '^';
         string_buffer_Buf_add1(out, c);
      }
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_newline(out);
   }
   fputs(string_buffer_Buf_data(out), stderr);
}

static bool diagnostics_Diags_isOk(const diagnostics_Diags* diags)
{
   return diags->num_errors == 0;
}

static bool diagnostics_Diags_hasErrors(const diagnostics_Diags* diags)
{
   return diags->num_errors != 0;
}

static uint32_t diagnostics_Diags_getNumErrors(const diagnostics_Diags* diags)
{
   return diags->num_errors;
}

static void diagnostics_Diags_printStatus(const diagnostics_Diags* diags)
{
   string_buffer_Buf* out = diags->out;
   string_buffer_Buf_clear(out);
   if (diags->num_warnings) {
      string_buffer_Buf_print(out, "%u warning%s", diags->num_warnings, diags->num_warnings > 1 ? "s" : "");
   }
   if (diags->num_errors) {
      if (diags->num_warnings) string_buffer_Buf_add(out, " and ");
      string_buffer_Buf_print(out, "%u error%s", diags->num_errors, diags->num_errors > 1 ? "s" : "");
   }
   if (string_buffer_Buf_size(out)) {
      string_buffer_Buf_add(out, " generated.\n");
      fputs(string_buffer_Buf_data(out), stderr);
   }
}


// --- module module_list ---
typedef struct module_list_List_ module_list_List;

typedef void (*module_list_Visitor)(void* arg, ast_Module* m);

struct module_list_List_ {
   ast_Module** mods;
   uint32_t num_mods;
   uint32_t max_mods;
   bool owns_modules;
};

static void module_list_List_init(module_list_List* l, bool owns_modules, uint32_t capacity);
static void module_list_List_free(module_list_List* l);
static void module_list_List_visit(const module_list_List* l, module_list_Visitor visitor, void* arg);
static ast_Module* module_list_List_find(const module_list_List* l, uint32_t module_name);
static void module_list_List_add(module_list_List* list, ast_Module* m);
static void module_list_List_addList(module_list_List* list, module_list_List* other, bool checkPrivate);
static void module_list_List_clear(module_list_List* l);
static uint32_t module_list_List_length(const module_list_List* l);
static ast_Module** module_list_List_get(const module_list_List* l);
static const ast_Module** module_list_List_getConst(const module_list_List* l);
static ast_Module* module_list_List_at(const module_list_List* l, uint32_t idx);
static bool module_list_List_contains(const module_list_List* l, const ast_Module* mod);
static bool module_list_List_containsName(const module_list_List* l, uint32_t name_idx);
static void module_list_List_resize(module_list_List* l, uint32_t cap);

static void module_list_List_init(module_list_List* l, bool owns_modules, uint32_t capacity)
{
   memset(l, 0, 24);
   l->owns_modules = owns_modules;
   module_list_List_resize(l, capacity);
}

static void module_list_List_free(module_list_List* l)
{
   if (l->owns_modules) {
      for (uint32_t i = 0; i < l->num_mods; i++) {
         ast_Module_free(l->mods[i]);
      }
   }
   free(l->mods);
}

static void module_list_List_visit(const module_list_List* l, module_list_Visitor visitor, void* arg)
{
   for (uint32_t i = 0; i < l->num_mods; i++) {
      visitor(arg, l->mods[i]);
   }
}

static ast_Module* module_list_List_find(const module_list_List* l, uint32_t module_name)
{
   for (uint32_t i = 0; i < l->num_mods; i++) {
      if (ast_Module_getNameIdx(l->mods[i]) == module_name) return l->mods[i];
   }
   return NULL;
}

static void module_list_List_add(module_list_List* list, ast_Module* m)
{
   if (list->num_mods == list->max_mods) module_list_List_resize(list, list->max_mods * 2);
   list->mods[list->num_mods] = m;
   list->num_mods++;
}

static void module_list_List_addList(module_list_List* list, module_list_List* other, bool checkPrivate)
{
   uint32_t total = list->num_mods + other->num_mods;
   if (total > list->max_mods) module_list_List_resize(list, total);
   if (checkPrivate) {
      for (uint32_t i = 0; i < other->num_mods; i++) {
         if (ast_Module_isPrivate(other->mods[i])) continue;
         list->mods[list->num_mods++] = other->mods[i];
      }
   } else {
      memcpy(&list->mods[list->num_mods], other->mods, other->num_mods * 8);
      list->num_mods = total;
   }
}

static void module_list_List_clear(module_list_List* l)
{
   ;//assert(!l->owns_modules);
   l->num_mods = 0;
}

static uint32_t module_list_List_length(const module_list_List* l)
{
   return l->num_mods;
}

static ast_Module** module_list_List_get(const module_list_List* l)
{
   return l->mods;
}

static const ast_Module** module_list_List_getConst(const module_list_List* l)
{
   return (const ast_Module**)l->mods;
}

static ast_Module* module_list_List_at(const module_list_List* l, uint32_t idx)
{
   return l->mods[idx];
}

static bool module_list_List_contains(const module_list_List* l, const ast_Module* mod)
{
   for (uint32_t i = 0; i < l->num_mods; i++) {
      if (l->mods[i] == mod) return true;
   }
   return false;
}

static bool module_list_List_containsName(const module_list_List* l, uint32_t name_idx)
{
   for (uint32_t i = 0; i < l->num_mods; i++) {
      if (ast_Module_getNameIdx(l->mods[i]) == name_idx) return true;
   }
   return false;
}

static void module_list_List_resize(module_list_List* l, uint32_t cap)
{
   l->max_mods = cap;
   void* buf = malloc(l->max_mods * 8);
   if (l->mods) {
      void* old = l->mods;
      memcpy(buf, old, l->num_mods * 8);
      free(old);
   }
   l->mods = buf;
}


// --- module c_prec ---

typedef uint8_t c_prec_C_Prec;
enum c_prec_C_Prec {
   c_prec_C_Prec_Unknown,
   c_prec_C_Prec_Comma,
   c_prec_C_Prec_Assignment,
   c_prec_C_Prec_Conditional,
   c_prec_C_Prec_LogicalOr,
   c_prec_C_Prec_LogicalAnd,
   c_prec_C_Prec_Or,
   c_prec_C_Prec_Xor,
   c_prec_C_Prec_And,
   c_prec_C_Prec_Equality,
   c_prec_C_Prec_Relative,
   c_prec_C_Prec_Shift,
   c_prec_C_Prec_Additive,
   c_prec_C_Prec_Multiplicative,
   c_prec_C_Prec_Prefix,
   c_prec_C_Prec_Postfix,
};

static const c_prec_C_Prec c_prec_C_Prec_table[29] = {
   [ast_BinaryOpcode_Multiply] = c_prec_C_Prec_Multiplicative,
   [ast_BinaryOpcode_Divide] = c_prec_C_Prec_Multiplicative,
   [ast_BinaryOpcode_Remainder] = c_prec_C_Prec_Multiplicative,
   [ast_BinaryOpcode_Add] = c_prec_C_Prec_Additive,
   [ast_BinaryOpcode_Subtract] = c_prec_C_Prec_Additive,
   [ast_BinaryOpcode_ShiftLeft] = c_prec_C_Prec_Shift,
   [ast_BinaryOpcode_ShiftRight] = c_prec_C_Prec_Shift,
   [ast_BinaryOpcode_LessThan] = c_prec_C_Prec_Relative,
   [ast_BinaryOpcode_GreaterThan] = c_prec_C_Prec_Relative,
   [ast_BinaryOpcode_LessEqual] = c_prec_C_Prec_Relative,
   [ast_BinaryOpcode_GreaterEqual] = c_prec_C_Prec_Relative,
   [ast_BinaryOpcode_Equal] = c_prec_C_Prec_Equality,
   [ast_BinaryOpcode_NotEqual] = c_prec_C_Prec_Equality,
   [ast_BinaryOpcode_And] = c_prec_C_Prec_And,
   [ast_BinaryOpcode_Xor] = c_prec_C_Prec_Xor,
   [ast_BinaryOpcode_Or] = c_prec_C_Prec_Or,
   [ast_BinaryOpcode_LAnd] = c_prec_C_Prec_LogicalAnd,
   [ast_BinaryOpcode_LOr] = c_prec_C_Prec_LogicalOr,
   [ast_BinaryOpcode_Assign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_MulAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_DivAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_RemAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_AddAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_SubAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_ShlAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_ShrAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_AndAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_XorAssign] = c_prec_C_Prec_Assignment,
   [ast_BinaryOpcode_OrAssign] = c_prec_C_Prec_Assignment
};


// --- module c2_prec ---

typedef uint8_t c2_prec_Prec;
enum c2_prec_Prec {
   c2_prec_Prec_Unknown,
   c2_prec_Prec_Comma,
   c2_prec_Prec_Assignment,
   c2_prec_Prec_Conditional,
   c2_prec_Prec_LogicalAndOr,
   c2_prec_Prec_Relational,
   c2_prec_Prec_Additive,
   c2_prec_Prec_Bitwise,
   c2_prec_Prec_Shift,
   c2_prec_Prec_Multiplicative,
};

static const c2_prec_Prec c2_prec_Prec_table[29] = {
   [ast_BinaryOpcode_Multiply] = c2_prec_Prec_Multiplicative,
   [ast_BinaryOpcode_Divide] = c2_prec_Prec_Multiplicative,
   [ast_BinaryOpcode_Remainder] = c2_prec_Prec_Multiplicative,
   [ast_BinaryOpcode_Add] = c2_prec_Prec_Additive,
   [ast_BinaryOpcode_Subtract] = c2_prec_Prec_Additive,
   [ast_BinaryOpcode_ShiftLeft] = c2_prec_Prec_Shift,
   [ast_BinaryOpcode_ShiftRight] = c2_prec_Prec_Shift,
   [ast_BinaryOpcode_LessThan] = c2_prec_Prec_Relational,
   [ast_BinaryOpcode_GreaterThan] = c2_prec_Prec_Relational,
   [ast_BinaryOpcode_LessEqual] = c2_prec_Prec_Relational,
   [ast_BinaryOpcode_GreaterEqual] = c2_prec_Prec_Relational,
   [ast_BinaryOpcode_Equal] = c2_prec_Prec_Relational,
   [ast_BinaryOpcode_NotEqual] = c2_prec_Prec_Relational,
   [ast_BinaryOpcode_And] = c2_prec_Prec_Bitwise,
   [ast_BinaryOpcode_Xor] = c2_prec_Prec_Bitwise,
   [ast_BinaryOpcode_Or] = c2_prec_Prec_Bitwise,
   [ast_BinaryOpcode_LAnd] = c2_prec_Prec_LogicalAndOr,
   [ast_BinaryOpcode_LOr] = c2_prec_Prec_LogicalAndOr,
   [ast_BinaryOpcode_Assign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_MulAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_DivAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_RemAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_AddAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_SubAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_ShlAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_ShrAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_AndAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_XorAssign] = c2_prec_Prec_Assignment,
   [ast_BinaryOpcode_OrAssign] = c2_prec_Prec_Assignment
};


// --- module case_list ---
typedef struct case_list_List_ case_list_List;

#define case_list_StackSize 4
struct case_list_List_ {
   uint32_t count;
   uint32_t capacity;
   ast_SwitchCase* stack[4];
   ast_SwitchCase** heap;
};

static void case_list_List_init(case_list_List* l);
static void case_list_List_add(case_list_List* l, ast_SwitchCase* s);
static void case_list_List_free(case_list_List* l);
static uint32_t case_list_List_size(const case_list_List* l);
static ast_SwitchCase** case_list_List_getData(case_list_List* l);

static void case_list_List_init(case_list_List* l)
{
   memset(l, 0, 48);
   l->heap = l->stack;
   l->capacity = 4;
}

static void case_list_List_add(case_list_List* l, ast_SwitchCase* s)
{
   if (l->count == l->capacity) {
      l->capacity *= 2;
      ast_SwitchCase** heap2 = malloc(l->capacity * 8);
      memcpy(heap2, l->heap, l->count * 8);
      if (l->heap != l->stack) free(l->heap);
      l->heap = heap2;
   }
   l->heap[l->count] = s;
   l->count++;
}

static void case_list_List_free(case_list_List* l)
{
   if (l->heap != l->stack) free(l->heap);
}

static uint32_t case_list_List_size(const case_list_List* l)
{
   return l->count;
}

static ast_SwitchCase** case_list_List_getData(case_list_List* l)
{
   return l->heap;
}


// --- module expr_list ---
typedef struct expr_list_List_ expr_list_List;

#define expr_list_StackSize 4
struct expr_list_List_ {
   uint32_t count;
   uint32_t capacity;
   ast_Expr* stack[4];
   ast_Expr** data;
};

static void expr_list_List_init(expr_list_List* l);
static void expr_list_List_add(expr_list_List* l, ast_Expr* e);
static void expr_list_List_free(expr_list_List* l);
static uint32_t expr_list_List_size(const expr_list_List* l);
static ast_Expr** expr_list_List_getData(expr_list_List* l);

static void expr_list_List_init(expr_list_List* l)
{
   memset(l, 0, 48);
   l->data = l->stack;
   l->capacity = 4;
}

static void expr_list_List_add(expr_list_List* l, ast_Expr* e)
{
   if (l->count == l->capacity) {
      l->capacity *= 2;
      ast_Expr** data2 = malloc(l->capacity * 8);
      memcpy(data2, l->data, l->count * 8);
      if (l->data != l->stack) free(l->data);
      l->data = data2;
   }
   l->data[l->count] = e;
   l->count++;
}

static void expr_list_List_free(expr_list_List* l)
{
   if (l->data != l->stack) free(l->data);
}

static uint32_t expr_list_List_size(const expr_list_List* l)
{
   return l->count;
}

static ast_Expr** expr_list_List_getData(expr_list_List* l)
{
   return l->data;
}


// --- module keywords ---
typedef struct keywords_Info_ keywords_Info;

struct keywords_Info_ {
   token_Kind indexes[656];
   uint32_t max_index;
};

static const char keywords_C_keywords[182] = "alignas alignof auto constexpr do double extern float inline int long nullptr register restrict short signed static thread_local typedef typeof typeof_unqual unsigned size_t ssize_t";
static void keywords_Info_init(keywords_Info* info, string_pool_Pool* pool);

static void keywords_Info_init(keywords_Info* info, string_pool_Pool* pool)
{
   uint32_t idx = 0;
   memset(info, 0, 660);
   const char* p = keywords_C_keywords;
   while (*p) {
      uint32_t len;
      for (len = 0; p[len] && p[len] != ' '; len++) continue;

      idx = string_pool_Pool_add(pool, p, len, true);
      ;//assert(idx < 656);
      info->indexes[idx] = token_Kind_Error;
      p += len;
      while (*p == ' ') p++;
   }
   for (token_Kind k = token_Kind_KW_bool; k <= token_Kind_KW_while; k++) {
      const char* s = token_Kind_str(k);
      idx = string_pool_Pool_add(pool, s, strlen(s), true);
      ;//assert(idx < 656);
      info->indexes[idx] = k;
   }
   info->max_index = idx;
}


// --- module stmt_list ---
typedef struct stmt_list_List_ stmt_list_List;

#define stmt_list_StackSize 4
struct stmt_list_List_ {
   uint32_t count;
   uint32_t capacity;
   ast_Stmt* stack[4];
   ast_Stmt** data;
};

static void stmt_list_List_init(stmt_list_List* l);
static void stmt_list_List_clear(stmt_list_List* l);
static void stmt_list_List_add(stmt_list_List* l, ast_Stmt* s);
static void stmt_list_List_free(stmt_list_List* l);
static uint32_t stmt_list_List_size(const stmt_list_List* l);
static ast_Stmt** stmt_list_List_getData(stmt_list_List* l);

static void stmt_list_List_init(stmt_list_List* l)
{
   memset(l, 0, 48);
   l->data = l->stack;
   l->capacity = 4;
}

static void stmt_list_List_clear(stmt_list_List* l)
{
   l->count = 0;
}

static void stmt_list_List_add(stmt_list_List* l, ast_Stmt* s)
{
   if (l->count == l->capacity) {
      l->capacity *= 2;
      ast_Stmt** data2 = malloc(l->capacity * 8);
      memcpy(data2, l->data, l->count * 8);
      if (l->data != l->stack) free(l->data);
      l->data = data2;
   }
   l->data[l->count] = s;
   l->count++;
}

static void stmt_list_List_free(stmt_list_List* l)
{
   if (l->data != l->stack) free(l->data);
}

static uint32_t stmt_list_List_size(const stmt_list_List* l)
{
   return l->count;
}

static ast_Stmt** stmt_list_List_getData(stmt_list_List* l)
{
   return l->data;
}


// --- module ctv_analyser ---
typedef struct ctv_analyser_Limit_ ctv_analyser_Limit;

struct ctv_analyser_Limit_ {
   int64_t min_val;
   uint64_t max_val;
};

static void ctv_analyser_Limit_init(ctv_analyser_Limit* l, uint32_t width, bool is_signed);
static bool ctv_analyser_checkRange(diagnostics_Diags* diags, ast_QualType qt, const ast_Expr* e);
static bool ctv_analyser_checkBitfield(diagnostics_Diags* diags, uint8_t bitfield_width, bool bitfield_signed, const ast_Expr* e);
static bool ctv_analyser_checkTypeRange(diagnostics_Diags* diags, ast_QualType qt, ast_Value* value, src_loc_SrcLoc loc, const ast_Expr* e);

static void ctv_analyser_Limit_init(ctv_analyser_Limit* l, uint32_t width, bool is_signed)
{
   if (is_signed) {
      int64_t max_val = (int64_t)0x7fffffffffffffffL >> (64 - width);
      l->min_val = -max_val - 1;
      l->max_val = (uint64_t)max_val;
   } else {
      l->min_val = 0;
      l->max_val = (uint64_t)~(uint64_t)0 >> (64 - width);
   }
}

static bool ctv_analyser_checkRange(diagnostics_Diags* diags, ast_QualType qt, const ast_Expr* e)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   if (!ast_QualType_isBuiltin(canon)) return true;
   ;//assert(ast_Expr_isCtv(e));
   ast_Value value = ast_evalExpr((e));
   if (value.kind == ast_ValueKind_Error) {
      diagnostics_Diags_errorRange(diags, ast_Expr_getLoc(e), ast_Expr_getRange(e), "%s", value.error_msg);
      return false;
   }
   return ctv_analyser_checkTypeRange(diags, qt, &value, 0, e);
}

static bool ctv_analyser_checkBitfield(diagnostics_Diags* diags, uint8_t bitfield_width, bool bitfield_signed, const ast_Expr* e)
{
   ast_Value value = ast_evalExpr((e));
   if (value.kind == ast_ValueKind_Error) {
      diagnostics_Diags_errorRange(diags, ast_Expr_getLoc(e), ast_Expr_getRange(e), "%s", value.error_msg);
      return false;
   }
   ctv_analyser_Limit limit; ctv_analyser_Limit_init(&limit, bitfield_width, bitfield_signed);
   if (!ast_Value_checkRange(&value, limit.min_val, limit.max_val)) {
      diagnostics_Diags_errorRange(diags, ast_Expr_getLoc(e), ast_Expr_getRange(e), "constant value %s out-of-bounds for bitfield, range [%ld, %lu]", ast_Value_str(&value), limit.min_val, limit.max_val);
      return false;
   }
   return true;
}

static bool ctv_analyser_checkTypeRange(diagnostics_Diags* diags, ast_QualType qt, ast_Value* value, src_loc_SrcLoc loc, const ast_Expr* e)
{
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   if (!ast_QualType_isBuiltin(canon)) return true;
   if (e && ast_Expr_isTilde(e)) return true;
   ast_BuiltinType* bi = ast_QualType_getBuiltin(canon);
   if (ast_BuiltinType_isFloatingPoint(bi)) return true;
   ctv_analyser_Limit limit; ctv_analyser_Limit_init(&limit, ast_BuiltinType_getWidth(bi), ast_BuiltinType_isSigned(bi));
   if (!ast_Value_checkRange(value, limit.min_val, limit.max_val)) {
      src_loc_SrcRange range = { 0, 0 };
      if (e) {
         loc = ast_Expr_getLoc(e);
         range = ast_Expr_getRange(e);
      }
      diagnostics_Diags_errorRange(diags, loc, range, "constant value %s out-of-bounds for type '%s', range [%ld, %lu]", ast_Value_str(value), ast_QualType_diagNameBare(qt), limit.min_val, limit.max_val);
      return false;
   }
   return true;
}


// --- module incr_array_list ---
typedef struct incr_array_list_Info_ incr_array_list_Info;
typedef struct incr_array_list_List_ incr_array_list_List;

struct incr_array_list_Info_ {
   uint32_t name;
   src_loc_SrcLoc loc;
   ast_ExprList values;
};

struct incr_array_list_List_ {
   incr_array_list_Info* entries;
   uint32_t count;
   uint32_t capacity;
};

static void incr_array_list_List_free(incr_array_list_List* v);
static void incr_array_list_List_resize(incr_array_list_List* v);
static ast_ExprList* incr_array_list_List_find(incr_array_list_List* v, uint32_t name);
static void incr_array_list_List_add(incr_array_list_List* v, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value);

static void incr_array_list_List_free(incr_array_list_List* v)
{
   for (uint32_t i = 0; i < v->count; i++) {
      ast_ExprList_free(&v->entries[i].values);
   }
   free(v->entries);
   v->count = 0;
   v->capacity = 0;
   v->entries = NULL;
}

static void incr_array_list_List_resize(incr_array_list_List* v)
{
   v->capacity = v->capacity == 0 ? 4 : v->capacity * 2;
   incr_array_list_Info* entries2 = malloc(v->capacity * 56);
   if (v->entries) {
      memcpy(entries2, v->entries, v->count * 56);
      free(v->entries);
   }
   v->entries = entries2;
}

static ast_ExprList* incr_array_list_List_find(incr_array_list_List* v, uint32_t name)
{
   for (uint32_t i = 0; i < v->count; i++) {
      incr_array_list_Info* info = &v->entries[i];
      if (info->name == name) return &info->values;
   }
   return NULL;
}

static void incr_array_list_List_add(incr_array_list_List* v, uint32_t name, src_loc_SrcLoc loc, ast_Expr* value)
{
   ast_ExprList* values = incr_array_list_List_find(v, name);
   if (!values) {
      if (v->count == v->capacity) incr_array_list_List_resize(v);
      incr_array_list_Info* info = &v->entries[v->count];
      info->name = name;
      info->loc = loc;
      ast_ExprList_init(&info->values);
      v->count++;
      values = &info->values;
   }
   ast_ExprList_add(values, value);
}


// --- module label_vector ---
typedef struct label_vector_Label_ label_vector_Label;
typedef struct label_vector_LabelVector_ label_vector_LabelVector;

struct label_vector_Label_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   bool used;
   bool is_label;
   ast_LabelStmt* stmt;
};

struct label_vector_LabelVector_ {
   label_vector_Label* data;
   uint32_t count;
   uint32_t capacity;
};

static void label_vector_LabelVector_init(label_vector_LabelVector* v, uint32_t capacity);
static void label_vector_LabelVector_free(label_vector_LabelVector* v);
static void label_vector_LabelVector_reset(label_vector_LabelVector* v);
static void label_vector_LabelVector_resize(label_vector_LabelVector* v);
static uint32_t label_vector_LabelVector_add(label_vector_LabelVector* v, label_vector_Label label);
static uint32_t label_vector_LabelVector_getCount(const label_vector_LabelVector* v);
static const label_vector_Label* label_vector_LabelVector_getLabels(const label_vector_LabelVector* v);
static label_vector_Label* label_vector_LabelVector_find(label_vector_LabelVector* v, uint32_t name_idx);

static void label_vector_LabelVector_init(label_vector_LabelVector* v, uint32_t capacity)
{
   v->data = NULL;
   v->count = 0;
   v->capacity = capacity;
   if (capacity) v->data = malloc(capacity * 24);
}

static void label_vector_LabelVector_free(label_vector_LabelVector* v)
{
   if (v->data) free(v->data);
   v->count = 0;
   v->capacity = 0;
   v->data = NULL;
}

static void label_vector_LabelVector_reset(label_vector_LabelVector* v)
{
   v->count = 0;
}

static void label_vector_LabelVector_resize(label_vector_LabelVector* v)
{
   v->capacity = v->capacity == 0 ? 4 : v->capacity * 2;
   void* data2 = malloc(v->capacity * 24);
   if (v->data) {
      memcpy(data2, v->data, v->count * 24);
      free(v->data);
   }
   v->data = data2;
}

static uint32_t label_vector_LabelVector_add(label_vector_LabelVector* v, label_vector_Label label)
{
   if (v->count == v->capacity) label_vector_LabelVector_resize(v);
   uint32_t index = v->count;
   v->data[index] = label;
   v->count++;
   return index;
}

static uint32_t label_vector_LabelVector_getCount(const label_vector_LabelVector* v)
{
   return v->count;
}

static const label_vector_Label* label_vector_LabelVector_getLabels(const label_vector_LabelVector* v)
{
   return v->data;
}

static label_vector_Label* label_vector_LabelVector_find(label_vector_LabelVector* v, uint32_t name_idx)
{
   for (uint32_t i = 0; i < v->count; i++) {
      if (v->data[i].name_idx == name_idx) return &v->data[i];
   }
   return NULL;
}


// --- module scope ---
typedef struct scope_Level_ scope_Level;
typedef struct scope_Scope_ scope_Scope;

struct scope_Level_ {
   uint32_t flags;
   uint32_t first_index;
};

struct scope_Scope_ {
   const module_list_List* allmodules;
   diagnostics_Diags* diags;
   const ast_ImportDeclList* imports;
   const ast_Module* mod;
   const ast_SymbolTable* symbols;
   bool warn_on_unused;
   uint32_t stack_count;
   uint32_t stack_capacity;
   uint32_t* stack_symbols;
   ast_Decl** stack_decls;
   uint32_t cache_count;
   uint32_t cache_capacity;
   uint32_t* cache_symbols;
   ast_Decl** cache_decls;
   ast_ImportDecl** cache_imports;
   scope_Level levels[32];
   uint32_t lvl;
};

#define scope_Function 0x1
#define scope_Break 0x2
#define scope_Continue 0x4
#define scope_Decl 0x8
#define scope_Control 0x10
#define scope_Unreachable 0x80
static scope_Scope* scope_create(module_list_List* allmodules, diagnostics_Diags* diags, const ast_ImportDeclList* imports, ast_Module* mod, const ast_SymbolTable* symbols, bool warn_on_unused);
static void scope_Scope_free(scope_Scope* s);
static void scope_Scope_reset(scope_Scope* s);
static void scope_Scope_addImports(scope_Scope* s);
static void scope_Scope_enter(scope_Scope* s, uint32_t flags);
static void scope_Scope_exit(scope_Scope* s, bool has_error);
static ast_Decl* scope_Scope_stack_find(const scope_Scope* s, uint32_t name_idx);
static void scope_Scope_stack_add(scope_Scope* s, uint32_t name_idx, ast_Decl* d);
static void scope_Scope_stack_resize(scope_Scope* s, uint32_t capacity);
static void scope_Scope_cache_resize(scope_Scope* s, uint32_t capacity);
static void scope_Scope_setUnreachable(scope_Scope* s);
static void scope_Scope_setReachable(scope_Scope* s);
static bool scope_Scope_isUnreachable(const scope_Scope* s);
static bool scope_Scope_allowBreak(const scope_Scope* s);
static bool scope_Scope_allowContinue(const scope_Scope* s);
static bool scope_Scope_inFunction(const scope_Scope* s);
static bool scope_Scope_add(scope_Scope* s, ast_Decl* d);
static ast_Decl* scope_Scope_find(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, bool usedPublic);
static bool scope_Scope_checkGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_ImportDecl* scope_Scope_findModule(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_Decl* scope_Scope_findSymbolInModule(scope_Scope* s, ast_Module* mod, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_Decl* scope_Scope_findType(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, bool usedPublic);
static ast_Decl* scope_Scope_findGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, bool* other_error, bool usedPublic, bool search_privates);
static void scope_Scope_dump(const scope_Scope* s);
static bool scope_Scope_checkAccess(scope_Scope* s, ast_Decl* d, src_loc_SrcLoc loc);

static scope_Scope* scope_create(module_list_List* allmodules, diagnostics_Diags* diags, const ast_ImportDeclList* imports, ast_Module* mod, const ast_SymbolTable* symbols, bool warn_on_unused)
{
   scope_Scope* s = calloc(1, 368);
   s->allmodules = allmodules;
   s->diags = diags;
   s->imports = imports;
   s->mod = mod;
   s->symbols = symbols;
   s->warn_on_unused = warn_on_unused;
   scope_Scope_stack_resize(s, 64);
   scope_Scope_cache_resize(s, 32);
   scope_Scope_addImports(s);
   return s;
}

static void scope_Scope_free(scope_Scope* s)
{
   free(s->cache_imports);
   free(s->cache_decls);
   free(s->stack_symbols);
   free(s->cache_symbols);
   free(s->stack_decls);
   free(s);
}

static void scope_Scope_reset(scope_Scope* s)
{
   s->lvl = 0;
   uint32_t first_index = ast_ImportDeclList_size(s->imports);
   s->stack_count = first_index;
}

static void scope_Scope_addImports(scope_Scope* s)
{
   uint32_t num_imports = ast_ImportDeclList_size(s->imports);
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(s->imports);
   for (uint32_t i = 0; i < num_imports; i++) {
      ast_ImportDecl* id = imports[i];
      ast_Decl* d = (ast_Decl*)id;
      uint32_t name_idx = ast_ImportDecl_getImportNameIdx(id);
      ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
      if (decl) {
         diagnostics_Diags_error(s->diags, ast_ImportDecl_getLoc(id), "duplicate import name '%s'", ast_idx2name(name_idx));
         ;//assert(ast_Decl_isImport(decl));
         ast_ImportDecl* other = (ast_ImportDecl*)decl;
         diagnostics_Diags_note(s->diags, ast_ImportDecl_getLoc(other), "previous definition is here");
         continue;
      }
      decl = ast_SymbolTable_find(s->symbols, name_idx);
      if (decl) {
         diagnostics_Diags_error(s->diags, ast_ImportDecl_getLoc(id), "import redefinition of '%s'", ast_idx2name(name_idx));
         diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
         continue;
      }
      scope_Scope_stack_add(s, name_idx, d);
   }
}

static void scope_Scope_enter(scope_Scope* s, uint32_t flags)
{
   if (s->lvl == constants_MaxScopes) {
      diagnostics_Diags_error(s->diags, 0, "max scope depth reached");
      ;//assert(0);
      return;
   }
   scope_Level* top = &s->levels[s->lvl];
   if (s->lvl) {
      const scope_Level* parent = &s->levels[s->lvl - 1];
      flags |= (parent->flags & (scope_Break | scope_Continue));
   }
   top->flags = flags;
   top->first_index = s->stack_count;
   s->lvl++;
}

static void scope_Scope_exit(scope_Scope* s, bool has_error)
{
   ;//assert(s->lvl != 0);
   s->lvl--;
   uint32_t first = s->levels[s->lvl].first_index;
   if (s->warn_on_unused && !has_error) {
      uint32_t last = s->stack_count;
      for (uint32_t i = first; i < last; i++) {
         ast_Decl* d = s->stack_decls[i];
         if (!ast_Decl_isUsed(d)) {
            ast_VarDecl* vd = (ast_VarDecl*)d;
            if (ast_VarDecl_isLocal(vd)) diagnostics_Diags_warn(s->diags, ast_Decl_getLoc(d), "unused variable '%s'", ast_Decl_getName(d));
         }
      }
   }
   s->stack_count = first;
}

static ast_Decl* scope_Scope_stack_find(const scope_Scope* s, uint32_t name_idx)
{
   for (uint32_t i = 0; i < s->stack_count; i++) {
      if (s->stack_symbols[i] == name_idx) return s->stack_decls[i];
   }
   return NULL;
}

static void scope_Scope_stack_add(scope_Scope* s, uint32_t name_idx, ast_Decl* d)
{
   if (s->stack_count == s->stack_capacity) scope_Scope_stack_resize(s, s->stack_capacity * 2);
   s->stack_symbols[s->stack_count] = name_idx;
   s->stack_decls[s->stack_count] = d;
   s->stack_count++;
}

static void scope_Scope_stack_resize(scope_Scope* s, uint32_t capacity)
{
   uint32_t* symbols = malloc(capacity * 4);
   ast_Decl** decls = malloc(capacity * 8);
   s->stack_capacity = capacity;
   if (s->stack_count) {
      memcpy(symbols, s->stack_symbols, s->stack_count * 4);
      memcpy(decls, s->stack_decls, s->stack_count * 8);
      free(s->stack_decls);
      free(s->stack_symbols);
   }
   s->stack_symbols = symbols;
   s->stack_decls = decls;
}

static void scope_Scope_cache_resize(scope_Scope* s, uint32_t capacity)
{
   uint32_t* symbols = malloc(capacity * 4);
   ast_Decl** decls = malloc(capacity * 8);
   ast_ImportDecl** imports = malloc(capacity * 8);
   s->cache_capacity = capacity;
   if (s->cache_count) {
      memcpy(symbols, s->cache_symbols, s->cache_count * 4);
      memcpy(decls, s->cache_decls, s->cache_count * 8);
      memcpy(imports, s->cache_imports, s->cache_count * 8);
      free(s->cache_imports);
      free(s->cache_decls);
      free(s->cache_symbols);
   }
   s->cache_symbols = symbols;
   s->cache_decls = decls;
   s->cache_imports = imports;
}

static void scope_Scope_setUnreachable(scope_Scope* s)
{
   ;//assert(s->lvl);
   scope_Level* top = &s->levels[s->lvl - 1];
   top->flags |= scope_Unreachable;
}

static void scope_Scope_setReachable(scope_Scope* s)
{
   ;//assert(s->lvl);
   scope_Level* top = &s->levels[s->lvl - 1];
   top->flags &= ~scope_Unreachable;
}

static bool scope_Scope_isUnreachable(const scope_Scope* s)
{
   ;//assert(s->lvl);
   const scope_Level* top = &s->levels[s->lvl - 1];
   return (top->flags & scope_Unreachable);
}

static bool scope_Scope_allowBreak(const scope_Scope* s)
{
   ;//assert(s->lvl);
   const scope_Level* top = &s->levels[s->lvl - 1];
   return (top->flags & scope_Break);
}

static bool scope_Scope_allowContinue(const scope_Scope* s)
{
   ;//assert(s->lvl);
   const scope_Level* top = &s->levels[s->lvl - 1];
   return (top->flags & scope_Continue);
}

static bool scope_Scope_inFunction(const scope_Scope* s)
{
   const scope_Level* top = &s->levels[0];
   return (top->flags & scope_Function);
}

static bool scope_Scope_add(scope_Scope* s, ast_Decl* d)
{
   ;//assert(s->lvl);
   const uint32_t name_idx = ast_Decl_getNameIdx(d);
   ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
   if (decl) {
      diagnostics_Diags_error(s->diags, ast_Decl_getLoc(d), "redefinition of '%s'", ast_Decl_getName(decl));
      diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
      return true;
   }
   bool other_error = false;
   decl = scope_Scope_findGlobalSymbol(s, name_idx, ast_Decl_getLoc(d), &other_error, false, false);
   if (decl) {
      diagnostics_Diags_error(s->diags, ast_Decl_getLoc(d), "redefinition of '%s'", ast_Decl_getName(decl));
      diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
      return true;
   }
   scope_Scope_stack_add(s, name_idx, d);
   return false;
}

static ast_Decl* scope_Scope_find(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, bool usedPublic)
{
   ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
   if (decl) {
      if (ast_Decl_isImport(decl)) {
         ast_Decl_setUsed(decl);
         if (usedPublic) ast_Decl_setUsedPublic(decl);
      }
      return decl;
   }
   bool other_error = false;
   decl = scope_Scope_findGlobalSymbol(s, name_idx, loc, &other_error, usedPublic, true);
   if (!decl && !other_error) {
      const char* name = ast_idx2name(name_idx);
      ast_ImportDecl* id = ast_ImportDeclList_findAny(s->imports, name_idx);
      if (id) {
         diagnostics_Diags_error(s->diags, loc, "module '%s' is imported with alias '%s'", ast_Decl_getName(ast_ImportDecl_asDecl(id)), ast_ImportDecl_getAliasName(id));
      } else {
         diagnostics_Diags_error(s->diags, loc, "use of undeclared identifier '%s'", name);
      }
      return NULL;
   }
   return decl;
}

static bool scope_Scope_checkGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc)
{
   uint32_t num_imports = ast_ImportDeclList_size(s->imports);
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(s->imports);
   ast_Decl* decl = NULL;
   for (uint32_t i = 0; i < num_imports; i++) {
      ast_ImportDecl* id = imports[i];
      if (name_idx == ast_ImportDecl_getImportNameIdx(id)) {
         decl = (ast_Decl*)id;
         break;
      }
      if (ast_ImportDecl_isLocal(id)) {
         ast_Module* dest = ast_ImportDecl_getDest(id);
         decl = ast_Module_findSymbol(dest, name_idx);
         if (decl) break;
      }
   }
   if (decl) {
      diagnostics_Diags_error(s->diags, loc, "redefinition of '%s'", ast_idx2name(name_idx));
      diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "previous definition is here");
      return false;
   }
   return true;
}

static ast_ImportDecl* scope_Scope_findModule(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc)
{
   ;//assert(s);
   ast_ImportDecl* d = ast_ImportDeclList_find(s->imports, name_idx);
   if (d) {
      ast_Decl_setUsed(ast_ImportDecl_asDecl(d));
      return d;
   }
   d = ast_ImportDeclList_findAny(s->imports, name_idx);
   if (d) {
      diagnostics_Diags_error(s->diags, loc, "module '%s' is imported with alias '%s'", ast_Decl_getName(ast_ImportDecl_asDecl(d)), ast_ImportDecl_getAliasName(d));
      return NULL;
   }
   ast_Module* mod = module_list_List_find(s->allmodules, name_idx);
   if (mod) {
      diagnostics_Diags_error(s->diags, loc, "module %s not imported", ast_idx2name(name_idx));
   } else {
      diagnostics_Diags_error(s->diags, loc, "unknown module: '%s'", ast_idx2name(name_idx));
   }
   return NULL;
}

static ast_Decl* scope_Scope_findSymbolInModule(scope_Scope* s, ast_Module* mod, uint32_t name_idx, src_loc_SrcLoc loc)
{
   ;//assert(s);
   ast_Decl* d = ast_Module_findSymbol(mod, name_idx);
   if (!d) {
      diagnostics_Diags_error(s->diags, loc, "module '%s' has no symbol '%s'", ast_Module_getName(mod), ast_idx2name(name_idx));
      return NULL;
   }
   if (mod != s->mod) {
      if (!ast_Decl_isPublic(d)) {
         diagnostics_Diags_error(s->diags, loc, "symbol '%s' is not public", ast_Decl_getFullName(d));
         diagnostics_Diags_note(s->diags, ast_Decl_getLoc(d), "symbol definition is here");
         return NULL;
      }
      ast_Decl_setUsedPublic(d);
   }
   return d;
}

static ast_Decl* scope_Scope_findType(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, bool usedPublic)
{
   ;//assert(s);
   ast_Decl* decl = scope_Scope_stack_find(s, name_idx);
   if (decl) return decl;
   bool other_error = false;
   decl = scope_Scope_findGlobalSymbol(s, name_idx, loc, &other_error, usedPublic, true);
   if (!decl && !other_error) {
      diagnostics_Diags_error(s->diags, loc, "unknown type '%s'", ast_idx2name(name_idx));
   }
   return decl;
}

static ast_Decl* scope_Scope_findGlobalSymbol(scope_Scope* s, uint32_t name_idx, src_loc_SrcLoc loc, bool* other_error, bool usedPublic, bool search_privates)
{
   for (uint32_t i = 0; i < s->cache_count; i++) {
      if (s->cache_symbols[i] == name_idx) {
         ast_Decl* decl = s->cache_decls[i];
         ast_ImportDecl* used_import = s->cache_imports[i];
         bool external = (ast_ImportDecl_getDest(used_import) != s->mod) && ((ast_Decl*)used_import) != decl;
         if (external || usedPublic) {
            ast_Decl_setUsedPublic(decl);
            if (usedPublic) {
               ast_Decl_setUsedPublic(ast_ImportDecl_asDecl(used_import));
            }
         }
         return decl;
      }
   }
   ast_Decl* decl = NULL;
   ast_ImportDecl* used_import = NULL;
   bool ambiguous = false;
   uint32_t num_imports = ast_ImportDeclList_size(s->imports);
   ast_ImportDecl** imports = ast_ImportDeclList_getDecls(s->imports);
   for (uint32_t i = 0; i < num_imports; i++) {
      ast_ImportDecl* id = imports[i];
      if (!ast_ImportDecl_isLocal(id)) continue;
      ast_Module* dest = ast_ImportDecl_getDest(id);
      ast_Decl* d;
      if (s->mod == dest) {
         d = ast_Module_findSymbol(dest, name_idx);
      } else {
         d = ast_Module_findPublicSymbol(dest, name_idx);
      }
      if (!d) continue;
      if (decl) {
         const char* name = ast_idx2name(name_idx);
         if (!ambiguous) {
            diagnostics_Diags_error(s->diags, loc, "symbol '%s' is ambiguous", name);
            diagnostics_Diags_note(s->diags, ast_Decl_getLoc(decl), "did you mean '%s'?", ast_Decl_getFullName(decl));
            diagnostics_Diags_note(s->diags, ast_Decl_getLoc(d), "did you mean '%s'?", ast_Decl_getFullName(d));
            ambiguous = true;
            *other_error = true;
         } else {
            diagnostics_Diags_note(s->diags, ast_Decl_getLoc(d), "did you mean '%s'?", ast_Decl_getFullName(d));
         }
         continue;
      } else {
         decl = d;
         used_import = id;
      }
   }
   if (ambiguous) return NULL;
   if (decl) {
      bool external = (ast_ImportDecl_getDest(used_import) != s->mod) && ((ast_Decl*)used_import) != decl;
      ast_Decl_setUsed(ast_ImportDecl_asDecl(used_import));
      if (external || usedPublic) {
         ast_Decl_setUsedPublic(decl);
         if (usedPublic) {
            ast_Decl_setUsedPublic(ast_ImportDecl_asDecl(used_import));
         }
      }
      if (s->cache_count == s->cache_capacity) {
         scope_Scope_cache_resize(s, s->cache_capacity * 2);
      }
      s->cache_symbols[s->cache_count] = name_idx;
      s->cache_decls[s->cache_count] = decl;
      s->cache_imports[s->cache_count] = used_import;
      s->cache_count++;
   } else {
      if (search_privates) {
         for (uint32_t i = 0; i < num_imports; i++) {
            ast_ImportDecl* id = imports[i];
            if (!ast_ImportDecl_isLocal(id)) continue;
            ast_Module* dest = ast_ImportDecl_getDest(id);
            ast_Decl* d = ast_Module_findPrivateSymbol(dest, name_idx);
            if (d) {
               diagnostics_Diags_error(s->diags, loc, "symbol '%s' is not public", ast_Decl_getFullName(d));
               *other_error = true;
               return NULL;
            }
         }
      }
   }
   return decl;
}

static void scope_Scope_dump(const scope_Scope* s)
{
   printf("Scope (lvl %u) %u\n", s->lvl, s->stack_count);
   for (uint32_t i = 0; i < s->lvl; i++) {
      const scope_Level* l = &s->levels[i];
      printf("  [%u]  start %2u  flags 0x%02x\n", i, l->first_index, l->flags);
   }
}

static bool scope_Scope_checkAccess(scope_Scope* s, ast_Decl* d, src_loc_SrcLoc loc)
{
   bool external = (s->mod != ast_Decl_getModule(d));
   if (external) {
      if (ast_Decl_isPublic(d)) {
         ast_Decl_setUsedPublic(d);
      } else {
         diagnostics_Diags_error(s->diags, loc, "symbol '%s' is not public", ast_Decl_getFullName(d));
         return false;
      }
   }
   return true;
}


// --- module size_analyser ---
typedef struct size_analyser_TypeSize_ size_analyser_TypeSize;

struct size_analyser_TypeSize_ {
   uint32_t size;
   uint32_t align : 31;
   uint32_t is_signed : 1;
};

static void size_analyser_sizeOfUnion(ast_StructTypeDecl* s);
static void size_analyser_sizeOfStruct(ast_StructTypeDecl* s);
static size_analyser_TypeSize size_analyser_sizeOfType(ast_QualType qt);

static void size_analyser_sizeOfUnion(ast_StructTypeDecl* s)
{
   bool packed = ast_StructTypeDecl_isPacked(s);
   uint32_t max_size = 0;
   uint32_t max_align = ast_StructTypeDecl_getAttrAlignment(s);
   if (!max_align) max_align = 1;
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
   ast_Decl** members = ast_StructTypeDecl_getMembers(s);
   for (uint32_t i = 0; i < num_members; i++) {
      ast_Decl* d = members[i];
      size_analyser_TypeSize member = size_analyser_sizeOfType(ast_Decl_getType(d));
      uint32_t size = member.size;
      uint32_t align = member.align;
      if (packed) align = 1;
      if (ast_Decl_isVariable(d)) {
         ast_VarDecl* vd = (ast_VarDecl*)d;
         ast_BitFieldLayout* bit_layout = ast_VarDecl_getBitfieldLayout(vd);
         if (bit_layout) {
            uint32_t bit_size = bit_layout->bit_width;
            if (packed) size = (bit_size + 7) / 8;
            if (!ast_Decl_getNameIdx(d)) align = 1;
         }
      }
      if (max_align < align) max_align = align;
      if (max_size < size) max_size = size;
   }
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(s);
   layout->size = max_size;
   layout->alignment = max_align;
}

static void size_analyser_sizeOfStruct(ast_StructTypeDecl* s)
{
   if (ast_StructTypeDecl_isUnion(s)) {
      size_analyser_sizeOfUnion(s);
      return;
   }
   bool packed = ast_StructTypeDecl_isPacked(s);
   uint32_t max_align = ast_StructTypeDecl_getAttrAlignment(s);
   if (!max_align) max_align = 1;
   uint32_t pos = 0;
   uint32_t bit_pos = 0;
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
   ast_Decl** members = ast_StructTypeDecl_getMembers(s);
   ast_StructLayout* layout = ast_StructTypeDecl_getLayout(s);
   for (uint32_t i = 0; i < num_members; i++) {
      ast_Decl* d = members[i];
      size_analyser_TypeSize member = size_analyser_sizeOfType(ast_Decl_getType(d));
      ast_StructMemberLayout* ml = &layout->members[i];
      uint32_t size = member.size;
      uint32_t align = member.align;
      if (packed) align = 1;
      ml->size = size;
      ast_BitFieldLayout* bit_layout = NULL;
      if (ast_Decl_isVariable(d)) {
         ast_VarDecl* vd = (ast_VarDecl*)d;
         bit_layout = ast_VarDecl_getBitfieldLayout(vd);
      }
      if (bit_layout) {
         ml->is_bitfield = true;
         ml->bitfield_width = bit_layout->bit_width;
         ml->bitfield_signed = (uint8_t)member.is_signed;
         uint32_t bit_size = bit_layout->bit_width;
         if (!ast_Decl_getNameIdx(d)) align = 1;
         if (max_align < align) max_align = align;
         if (bit_size == 0) {
            pos += (bit_pos + 7) / 8;
            pos = (pos + member.align - 1) & -member.align;
            bit_pos = 0;
         } else {
            uint32_t a8 = align * 8;
            uint32_t ofs = ((pos * 8 + bit_pos) % a8 + bit_size + a8 - 1) / a8;
            if (ofs > size / align && !packed) {
               pos += (bit_pos + 7) / 8;
               pos = (pos + align - 1) & -align;
               bit_pos = bit_size;
            } else {
               while (bit_pos >= a8) {
                  pos += align;
                  bit_pos -= a8;
               }
               bit_layout->bit_offset = (uint8_t)bit_pos;
               ml->bitfield_offset = (uint8_t)bit_pos;
               bit_pos += bit_size;
            }
            if (size == 8 && bit_size <= 32) size = 4;
         }
         ml->offset = pos;
      } else {
         if (max_align < align) max_align = align;
         pos += (bit_pos + 7) / 8;
         bit_pos = 0;
         pos = (pos + align - 1) & -align;
         ml->offset = pos;
         pos += size;
      }
   }
   pos += (bit_pos + 7) / 8;
   pos = (pos + max_align - 1) & -max_align;
   layout->size = pos;
   layout->alignment = max_align;
}

static size_analyser_TypeSize size_analyser_sizeOfType(ast_QualType qt)
{
   size_analyser_TypeSize result = { 0, 1, 0 };
   if (ast_QualType_isInvalid(qt)) return result;
   uint32_t pointerSize = ast_getWordSize();
   qt = ast_QualType_getCanonicalType(qt);
   ast_Type* t = ast_QualType_getType(qt);
   switch (ast_Type_getKind(t)) {
   case ast_TypeKind_Builtin: {
      const ast_BuiltinType* bi = (ast_BuiltinType*)t;
      result.size = ast_BuiltinType_getAlignment(bi);
      result.align = result.size;
      result.is_signed = ast_BuiltinType_isSigned(bi);
      break;
   }
   case ast_TypeKind_Pointer:
      result.size = pointerSize;
      result.align = result.size;
      break;
   case ast_TypeKind_Array: {
      ast_ArrayType* arrayType = (ast_ArrayType*)t;
      result = size_analyser_sizeOfType(ast_ArrayType_getElemType(arrayType));
      result.size *= ast_ArrayType_getSize(arrayType);
      break;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = (ast_StructType*)t;
      ast_StructTypeDecl* d = ast_StructType_getDecl(st);
      ;//assert(ast_Decl_isChecked(ast_StructTypeDecl_asDecl(d)));
      result.size = ast_StructTypeDecl_getSize(d);
      result.align = ast_StructTypeDecl_getAlignment(d);
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = (ast_EnumType*)t;
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      return size_analyser_sizeOfType(ast_EnumTypeDecl_getImplType(etd));
   }
   case ast_TypeKind_Function:
      result.size = pointerSize;
      result.align = pointerSize;
      break;
   case ast_TypeKind_Void:
      result.size = 0;
      result.align = 0;
      result.is_signed = false;
      break;
   case ast_TypeKind_Alias:
      ;//assert(0);
      break;
   case ast_TypeKind_Module:
      ;//assert(0);
      break;
   }
   return result;
}


// --- module struct_func_list ---
typedef struct struct_func_list_Info_ struct_func_list_Info;
typedef struct struct_func_list_List_ struct_func_list_List;

struct struct_func_list_Info_ {
   ast_Decl* decl;
   ast_FunctionDeclList functions;
};

struct struct_func_list_List_ {
   struct_func_list_Info* data;
   uint32_t count;
   uint32_t capacity;
};

static void struct_func_list_List_free(struct_func_list_List* v);
static void struct_func_list_List_resize(struct_func_list_List* v);
static void struct_func_list_List_addDecl(struct_func_list_List* v, ast_Decl* decl);
static ast_Decl* struct_func_list_List_getDecl(const struct_func_list_List* v, uint32_t index);
static void struct_func_list_List_addFunc(struct_func_list_List* v, uint32_t index, ast_FunctionDecl* fd);
static ast_FunctionDecl* struct_func_list_List_findFunc(struct_func_list_List* v, uint32_t index, uint32_t name_idx);

static void struct_func_list_List_free(struct_func_list_List* v)
{
   for (uint32_t i = 0; i < v->count; i++) {
      ast_FunctionDeclList_free(&v->data[i].functions);
   }
   free(v->data);
   v->count = 0;
   v->capacity = 0;
   v->data = NULL;
}

static void struct_func_list_List_resize(struct_func_list_List* v)
{
   v->capacity = v->capacity == 0 ? 4 : v->capacity * 2;
   struct_func_list_Info* data2 = malloc(v->capacity * 24);
   if (v->data) {
      memcpy(data2, v->data, v->count * 24);
      free(v->data);
   }
   v->data = data2;
}

static void struct_func_list_List_addDecl(struct_func_list_List* v, ast_Decl* decl)
{
   if (v->count == v->capacity) struct_func_list_List_resize(v);
   struct_func_list_Info* info = &v->data[v->count];
   info->decl = decl;
   ast_FunctionDeclList_init(&info->functions);
   v->count++;
}

static ast_Decl* struct_func_list_List_getDecl(const struct_func_list_List* v, uint32_t index)
{
   return v->data[index].decl;
}

static void struct_func_list_List_addFunc(struct_func_list_List* v, uint32_t index, ast_FunctionDecl* fd)
{
   ;//assert(index < v->count);
   struct_func_list_Info* info = &v->data[index];
   ast_FunctionDeclList_add(&info->functions, fd);
}

static ast_FunctionDecl* struct_func_list_List_findFunc(struct_func_list_List* v, uint32_t index, uint32_t name_idx)
{
   ;//assert(index < v->count);
   struct_func_list_Info* info = &v->data[index];
   return ast_FunctionDeclList_find(&info->functions, name_idx);
}


// --- module unused_checker ---
typedef struct unused_checker_Checker_ unused_checker_Checker;

struct unused_checker_Checker_ {
   diagnostics_Diags* diags;
   const warning_flags_Flags* warnings;
};

static void unused_checker_check(diagnostics_Diags* diags, const warning_flags_Flags* warnings, ast_Module* mod);
static void unused_checker_Checker_unused_module(void* arg, ast_AST* a);
static void unused_checker_Checker_check(void* arg, ast_Decl* d);
static void unused_checker_Checker_checkEnum(unused_checker_Checker* c, ast_EnumTypeDecl* d);
static void unused_checker_Checker_checkStructMembers(unused_checker_Checker* c, ast_Decl* d);

static void unused_checker_check(diagnostics_Diags* diags, const warning_flags_Flags* warnings, ast_Module* mod)
{
   unused_checker_Checker c = { .diags = diags, .warnings = warnings };
   if (ast_Module_isUsed(mod)) {
      ast_Module_visitDecls(mod, unused_checker_Checker_check, &c);
   } else {
      ast_Module_visitASTs(mod, unused_checker_Checker_unused_module, &c);
   }
}

static void unused_checker_Checker_unused_module(void* arg, ast_AST* a)
{
   unused_checker_Checker* c = arg;
   if (!c->warnings->no_unused_public) {
      diagnostics_Diags_warn(c->diags, ast_AST_getLoc(a), "unused module '%s'", ast_AST_getName(a));
   }
}

static void unused_checker_Checker_check(void* arg, ast_Decl* d)
{
   unused_checker_Checker* c = arg;
   bool used = ast_Decl_isUsed(d);
   if (used && ast_Decl_isPublic(d) && !ast_Decl_isUsedPublic(d) && !c->warnings->no_unused_public && !ast_Decl_hasAttrUnused(d)) {
      diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(d), "%s '%s' is not used public", ast_Decl_getKindName(d), ast_Decl_getFullName(d));
   }
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      if (c->warnings->no_unused_function) return;
      if (ast_Decl_hasAttrUnused(d)) return;
      break;
   case ast_DeclKind_Import:
      if (c->warnings->no_unused_import) return;
      break;
   case ast_DeclKind_StructType:
      if (used) {
         unused_checker_Checker_checkStructMembers(c, d);
      }
      if (c->warnings->no_unused_type) return;
      break;
   case ast_DeclKind_EnumType:
      if (used && !c->warnings->no_unused_enum_constant) {
         unused_checker_Checker_checkEnum(c, (ast_EnumTypeDecl*)d);
      }
      break;
   case ast_DeclKind_EnumConstant:
      break;
   case ast_DeclKind_FunctionType:
      if (c->warnings->no_unused_type) return;
      break;
   case ast_DeclKind_AliasType:
      if (c->warnings->no_unused_type) return;
      break;
   case ast_DeclKind_Variable:
      if (c->warnings->no_unused_variable) return;
      break;
   }
   if (!used && !ast_Decl_hasAttrUnused(d) && !ast_Decl_isExported(d)) {
      diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(d), "unused %s '%s'", ast_Decl_getKindName(d), ast_Decl_getFullName(d));
      return;
   }
}

static void unused_checker_Checker_checkEnum(unused_checker_Checker* c, ast_EnumTypeDecl* d)
{
   uint32_t num_consts = ast_EnumTypeDecl_getNumConstants(d);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(d);
   for (uint32_t i = 0; i < num_consts; i++) {
      ast_EnumConstantDecl* ecd = constants[i];
      ast_Decl* dd = (ast_Decl*)ecd;
      if (!ast_Decl_isUsed(dd)) {
         diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(dd), "unused %s '%s'", ast_Decl_getKindName(dd), ast_Decl_getName(dd));
      }
   }
}

static void unused_checker_Checker_checkStructMembers(unused_checker_Checker* c, ast_Decl* d)
{
   ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   for (uint32_t i = 0; i < num_members; i++) {
      ast_Decl* member = members[i];
      if (ast_Decl_isStructType(member)) {
         unused_checker_Checker_checkStructMembers(c, member);
      } else {
         if (!ast_Decl_isUsed(member) && !c->warnings->no_unused_variable) {
            diagnostics_Diags_warn(c->diags, ast_Decl_getLoc(member), "unused %s member '%s'", ast_StructTypeDecl_isStruct(std) ? "struct" : "union", ast_Decl_getName(member));
         }
      }
   }
}


// --- module c2recipe ---
typedef struct c2recipe_Recipe_ c2recipe_Recipe;
typedef struct c2recipe_Token_ c2recipe_Token;
typedef struct c2recipe_Set_ c2recipe_Set;
typedef struct c2recipe_Parser_ c2recipe_Parser;

struct c2recipe_Recipe_ {
   string_pool_Pool* pool;
   source_mgr_SourceMgr* sm;
   build_target_Target** targets;
   uint32_t num_targets;
   uint32_t max_targets;
   build_target_PluginList plugins;
};

static c2recipe_Recipe* c2recipe_create(source_mgr_SourceMgr* sm, string_pool_Pool* pool);
static void c2recipe_Recipe_free(c2recipe_Recipe* r);
static void c2recipe_Recipe_addPlugin(c2recipe_Recipe* r, uint32_t name, uint32_t options, src_loc_SrcLoc loc);
static build_target_Target* c2recipe_Recipe_addTarget(c2recipe_Recipe* r, uint32_t name, src_loc_SrcLoc loc, build_target_Kind kind);
static bool c2recipe_Recipe_parse(c2recipe_Recipe* r, int32_t file_id);
static uint32_t c2recipe_Recipe_numTargets(const c2recipe_Recipe* r);
static build_target_Target* c2recipe_Recipe_getTarget(const c2recipe_Recipe* r, uint32_t idx);
static const build_target_PluginList* c2recipe_Recipe_getPlugins(const c2recipe_Recipe* r);
typedef uint8_t c2recipe_Kind;
enum c2recipe_Kind {
   c2recipe_Kind_Plugin,
   c2recipe_Kind_PluginOptions,
   c2recipe_Kind_Text,
   c2recipe_Kind_Executable,
   c2recipe_Kind_Lib,
   c2recipe_Kind_Image,
   c2recipe_Kind_File,
   c2recipe_Kind_End,
   c2recipe_Kind_Warnings,
   c2recipe_Kind_Backend,
   c2recipe_Kind_DisableAsserts,
   c2recipe_Kind_NoLibc,
   c2recipe_Kind_Config,
   c2recipe_Kind_Export,
   c2recipe_Kind_Use,
   c2recipe_Kind_AsmFile,
   c2recipe_Kind_Optional,
   c2recipe_Kind_Set,
   c2recipe_Kind_SetUse,
   c2recipe_Kind_Eof,
};

struct c2recipe_Token_ {
   src_loc_SrcLoc loc;
   c2recipe_Kind kind;
   uint32_t value;
};

struct c2recipe_Set_ {
   uint32_t name_idx;
   src_loc_SrcLoc loc;
   file_list_FileList files;
   c2recipe_Set* next;
};

struct c2recipe_Parser_ {
   c2recipe_Recipe* recipe;
   string_pool_Pool* pool;
   source_mgr_SourceMgr* sm;
   string_list_List global_configs;
   const char* input_start;
   const char* cur;
   src_loc_SrcLoc loc_start;
   __jmp_buf_tag jmpbuf;
   c2recipe_Token token;
   bool new_line;
   bool targets_started;
   build_target_Target* target;
   c2recipe_Set* sets;
};

static const char* c2recipe_kind_names[20] = {
   "plugin",
   "[plugin_options]",
   "text",
   "executable",
   "lib",
   "image",
   "file",
   "end",
   "$warnings",
   "$backend",
   "$disable-asserts",
   "$nolibc",
   "$config",
   "$export",
   "$use",
   "$asm",
   "$optional",
   "set",
   "(set)",
   "eof"
};
static void c2recipe_Token_init(c2recipe_Token* t);
static c2recipe_Set* c2recipe_Set_create(uint32_t name, src_loc_SrcLoc loc, c2recipe_Set* next);
static void c2recipe_Set_free(c2recipe_Set* s);
static bool c2recipe_Set_addFile(c2recipe_Set* s, uint32_t filename, src_loc_SrcLoc loc);
static void c2recipe_Parser_free(c2recipe_Parser* p);
static bool c2recipe_Parser_parse(c2recipe_Recipe* recipe, string_pool_Pool* pool, source_mgr_SourceMgr* sm, int32_t file_id);
static bool c2recipe_Parser_addGlobalFeature(c2recipe_Parser* p, uint32_t feature);
__attribute__((noreturn)) __attribute__((__format__(printf, 2, 3)))
static void c2recipe_Parser_error(c2recipe_Parser* p, const char* format, ...);
__attribute__((__format__(printf, 2, 3)))
static void c2recipe_Parser_warning(c2recipe_Parser* p, const char* format, ...);
static void c2recipe_Parser_consumeToken(c2recipe_Parser* p);
static void c2recipe_Parser_expect(c2recipe_Parser* p, c2recipe_Kind kind, const char* msg);
static bool c2recipe_Parser_is(const c2recipe_Parser* p, c2recipe_Kind kind);
static void c2recipe_Parser_lex(c2recipe_Parser* p, c2recipe_Token* result);
static void c2recipe_Parser_lex_plugin_options(c2recipe_Parser* p, c2recipe_Token* result);
static bool c2recipe_is_name(char c);
static void c2recipe_Parser_lex_set_use(c2recipe_Parser* p, c2recipe_Token* result);
static void c2recipe_Parser_lex_option(c2recipe_Parser* p, c2recipe_Token* result);
static void c2recipe_Parser_skip_comments(c2recipe_Parser* p);
static void c2recipe_Parser_parseTop(c2recipe_Parser* p);
static void c2recipe_Parser_parsePlugin(c2recipe_Parser* p, bool is_global);
static void c2recipe_Parser_parseWarnings(c2recipe_Parser* p);
static void c2recipe_Parser_parseExecutable(c2recipe_Parser* p);
static void c2recipe_Parser_parseImage(c2recipe_Parser* p);
static void c2recipe_Parser_parseSet(c2recipe_Parser* p);
static c2recipe_Set* c2recipe_Parser_findSet(c2recipe_Parser* p, uint32_t name_idx);
static void c2recipe_Parser_parseLibrary(c2recipe_Parser* p);
static void c2recipe_Parser_parseTarget(c2recipe_Parser* p);
static void c2recipe_Parser_parseBackend(c2recipe_Parser* p);
static void c2recipe_Parser_parseBackEndOptions(c2recipe_Parser* p);
static bool c2recipe_equals(const char* str, const char* expect, uint32_t len);

static c2recipe_Recipe* c2recipe_create(source_mgr_SourceMgr* sm, string_pool_Pool* pool)
{
   c2recipe_Recipe* r = calloc(1, 48);
   r->sm = sm;
   r->pool = pool;
   r->max_targets = 4;
   r->targets = calloc(r->max_targets, 8);
   build_target_PluginList_init(&r->plugins);
   return r;
}

static void c2recipe_Recipe_free(c2recipe_Recipe* r)
{
   for (uint32_t i = 0; i < r->num_targets; i++) {
      build_target_Target_free(r->targets[i]);
   }
   free(r->targets);
   build_target_PluginList_free(&r->plugins);
   free(r);
}

static void c2recipe_Recipe_addPlugin(c2recipe_Recipe* r, uint32_t name, uint32_t options, src_loc_SrcLoc loc)
{
   build_target_PluginList_add(&r->plugins, name, options, loc);
}

static build_target_Target* c2recipe_Recipe_addTarget(c2recipe_Recipe* r, uint32_t name, src_loc_SrcLoc loc, build_target_Kind kind)
{
   if (r->num_targets == r->max_targets) {
      r->max_targets *= 2;
      build_target_Target** targets2 = malloc(r->max_targets * 8);
      memcpy(targets2, r->targets, r->num_targets * 8);
      free(r->targets);
      r->targets = targets2;
   }
   build_target_Target* t = build_target_create(name, loc, kind, r->pool);
   r->targets[r->num_targets] = t;
   r->num_targets++;
   return t;
}

static bool c2recipe_Recipe_parse(c2recipe_Recipe* r, int32_t file_id)
{
   return c2recipe_Parser_parse(r, r->pool, r->sm, file_id);
}

static uint32_t c2recipe_Recipe_numTargets(const c2recipe_Recipe* r)
{
   return r->num_targets;
}

static build_target_Target* c2recipe_Recipe_getTarget(const c2recipe_Recipe* r, uint32_t idx)
{
   return r->targets[idx];
}

static const build_target_PluginList* c2recipe_Recipe_getPlugins(const c2recipe_Recipe* r)
{
   return &r->plugins;
}

static void c2recipe_Token_init(c2recipe_Token* t)
{
   memset(t, 0, 12);
}

static c2recipe_Set* c2recipe_Set_create(uint32_t name, src_loc_SrcLoc loc, c2recipe_Set* next)
{
   c2recipe_Set* s = calloc(1, 32);
   s->name_idx = name;
   s->loc = loc;
   s->next = next;
   file_list_FileList_init(&s->files, 8);
   return s;
}

static void c2recipe_Set_free(c2recipe_Set* s)
{
   file_list_FileList_free(&s->files);
   free(s);
}

static bool c2recipe_Set_addFile(c2recipe_Set* s, uint32_t filename, src_loc_SrcLoc loc)
{
   return file_list_FileList_add(&s->files, filename, loc);
}

static void c2recipe_Parser_free(c2recipe_Parser* p)
{
   string_list_List_free(&p->global_configs);
   c2recipe_Set* s = p->sets;
   while (s) {
      c2recipe_Set* next = s->next;
      c2recipe_Set_free(s);
      s = next;
   }
}

static bool c2recipe_Parser_parse(c2recipe_Recipe* recipe, string_pool_Pool* pool, source_mgr_SourceMgr* sm, int32_t file_id)
{
   const char* data = source_mgr_SourceMgr_get_content(sm, file_id);
   c2recipe_Parser p = { };
   p.recipe = recipe;
   p.pool = pool;
   p.sm = sm;
   string_list_List_init(&p.global_configs, pool);
   p.input_start = data;
   p.cur = data;
   p.loc_start = source_mgr_SourceMgr_get_offset(sm, file_id);
   p.new_line = true;
   c2recipe_Token_init(&p.token);
   int32_t res = setjmp(&p.jmpbuf);
   if (res == 0) {
      c2recipe_Parser_consumeToken(&p);
      c2recipe_Parser_parseTop(&p);
   }
   c2recipe_Parser_free(&p);
   return res == 0;
}

static bool c2recipe_Parser_addGlobalFeature(c2recipe_Parser* p, uint32_t feature)
{
   if (string_list_List_contains_idx(&p->global_configs, feature)) return false;
   string_list_List_add(&p->global_configs, feature);
   return true;
}

__attribute__((noreturn)) __attribute__((__format__(printf, 2, 3)))
static void c2recipe_Parser_error(c2recipe_Parser* p, const char* format, ...)
{
   char msg[128];
   va_list args;
   va_start(args, format);
   vsnprintf(msg, 128, format, args);
   va_end(args);
   char locstr[256];
   source_mgr_SourceMgr_loc2str(p->sm, p->token.loc, locstr, 256);
   if (color_useColor()) {
      fprintf(stderr, "%s: %serror:%s %s\n", locstr, color_Color_str(color_Red), color_Color_str(color_Normal), msg);
   } else {
      fprintf(stderr, "%s: error: %s\n", locstr, msg);
   }
   longjmp(&p->jmpbuf, 1);
}

__attribute__((__format__(printf, 2, 3)))
static void c2recipe_Parser_warning(c2recipe_Parser* p, const char* format, ...)
{
   char msg[128];
   va_list args;
   va_start(args, format);
   vsnprintf(msg, 128, format, args);
   va_end(args);
   char locstr[256];
   source_mgr_SourceMgr_loc2str(p->sm, p->token.loc, locstr, 256);
   if (color_useColor()) {
      fprintf(stderr, "%s: %swarning:%s %s\n", locstr, color_Color_str(color_Red), color_Color_str(color_Normal), msg);
   } else {
      fprintf(stderr, "%s: warning: %s\n", locstr, msg);
   }
}

static void c2recipe_Parser_consumeToken(c2recipe_Parser* p)
{
   c2recipe_Parser_lex(p, &p->token);
}

static void c2recipe_Parser_expect(c2recipe_Parser* p, c2recipe_Kind kind, const char* msg)
{
   if (p->token.kind != kind) c2recipe_Parser_error(p, "%s", msg);
}

static bool c2recipe_Parser_is(const c2recipe_Parser* p, c2recipe_Kind kind)
{
   return p->token.kind == kind;
}

static void c2recipe_Parser_lex(c2recipe_Parser* p, c2recipe_Token* result)
{
   while (1) {
      switch (*p->cur) {
      case 0:
         p->cur--;
         result->loc = p->loc_start + (src_loc_SrcLoc)(p->cur - p->input_start);
         result->kind = c2recipe_Kind_Eof;
         return;
      case ' ':
      case '\t':
      case '\r':
         p->cur++;
         break;
      case '\n':
         p->cur++;
         p->new_line = true;
         break;
      case '#':
         c2recipe_Parser_skip_comments(p);
         break;
      case '[':
         c2recipe_Parser_lex_plugin_options(p, result);
         p->new_line = false;
         return;
      case '$':
         c2recipe_Parser_lex_option(p, result);
         p->new_line = false;
         return;
      case '(':
         c2recipe_Parser_lex_set_use(p, result);
         p->new_line = false;
         return;
      case '/': {
         const char* start = p->cur;
         while (*p->cur && !isspace(*p->cur)) p->cur++;
         result->kind = p->new_line ? c2recipe_Kind_File : c2recipe_Kind_Text;
         if (*p->cur == 0) result->kind = c2recipe_Kind_Eof;
         p->new_line = false;
         uint32_t len = (uint32_t)(p->cur - start);
         result->value = string_pool_Pool_add(p->pool, start, len, true);
         return;
      }
      default:
         if (isalnum(*p->cur)) {
            result->loc = p->loc_start + (src_loc_SrcLoc)(p->cur - p->input_start);
            if (c2recipe_equals(p->cur, "plugin ", 7)) {
               result->kind = c2recipe_Kind_Plugin;
               p->cur += 7;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "executable ", 11)) {
               result->kind = c2recipe_Kind_Executable;
               p->cur += 11;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "lib ", 4)) {
               result->kind = c2recipe_Kind_Lib;
               p->cur += 4;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "end", 3)) {
               result->kind = c2recipe_Kind_End;
               p->cur += 3;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "image ", 6)) {
               result->kind = c2recipe_Kind_Image;
               p->cur += 6;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "config ", 7)) {
               result->kind = c2recipe_Kind_Config;
               p->cur += 7;
               p->new_line = false;
               return;
            }
            if (c2recipe_equals(p->cur, "set ", 4)) {
               result->kind = c2recipe_Kind_Set;
               p->cur += 4;
               p->new_line = false;
               return;
            }
            const char* start = p->cur;
            while (*p->cur && !isspace(*p->cur)) p->cur++;
            result->kind = p->new_line ? c2recipe_Kind_File : c2recipe_Kind_Text;
            p->new_line = false;
            uint32_t len = (uint32_t)(p->cur - start);
            result->value = string_pool_Pool_add(p->pool, start, len, true);
            return;
         }
         result->loc = p->loc_start + (src_loc_SrcLoc)(p->cur - p->input_start);
         c2recipe_Parser_error(p, "unexpected input '%c'", *p->cur);
         return;
      }
   }
}

static void c2recipe_Parser_lex_plugin_options(c2recipe_Parser* p, c2recipe_Token* result)
{
   p->cur++;
   const char* start = p->cur;
   while (1) {
      if (*p->cur == 0) {
         return;
      }
      if (*p->cur == ']') {
         uint32_t len = (uint32_t)(p->cur - start);
         result->loc = p->loc_start + (src_loc_SrcLoc)(start - p->input_start);
         result->kind = c2recipe_Kind_PluginOptions;
         result->value = string_pool_Pool_add(p->pool, start, len, true);
         p->cur++;
         return;
      }
      p->cur++;
   }
}

static bool c2recipe_is_name(char c)
{
   if (c >= 'a' && c <= 'z') return true;
   if (c >= 'A' && c <= 'Z') return true;
   if (c >= '0' && c <= '9') return true;
   if (c == '_') return true;
   return false;
}

static void c2recipe_Parser_lex_set_use(c2recipe_Parser* p, c2recipe_Token* result)
{
   p->cur++;
   result->loc = p->loc_start + (src_loc_SrcLoc)(p->cur - p->input_start);
   const char* start = p->cur;
   while (c2recipe_is_name(*p->cur)) p->cur++;
   result->kind = c2recipe_Kind_SetUse;
   uint32_t len = (uint32_t)(p->cur - start);
   if (len == 0) c2recipe_Parser_error(p, "expected set name");
   result->value = string_pool_Pool_add(p->pool, start, len, true);
   if (*p->cur != ')') {
      result->loc = p->loc_start + (src_loc_SrcLoc)(p->cur - p->input_start);
      c2recipe_Parser_error(p, "expected ')'");
   }
   p->cur++;
}

static void c2recipe_Parser_lex_option(c2recipe_Parser* p, c2recipe_Token* result)
{
   p->cur++;
   result->loc = p->loc_start + (src_loc_SrcLoc)(p->cur - p->input_start);
   const char* end = p->cur;
   while (*end && !isspace(*end)) end++;
   char option[24];
   uint32_t len = (uint32_t)(end - p->cur);
   if (len >= 24) c2recipe_Parser_error(p, "unknown option");
   memcpy(option, p->cur, len);
   option[len] = 0;
   switch (c2_strswitch(option, "\010warnings" "\007backend" "\017disable-asserts" "\006nolibc" "\006config" "\006export" "\006plugin" "\003use" "\003asm" "\010optional")) {
   case 2: // "warnings"
      result->kind = c2recipe_Kind_Warnings;
      break;
   case 3: // "backend"
      result->kind = c2recipe_Kind_Backend;
      break;
   case 4: // "disable-asserts"
      result->kind = c2recipe_Kind_DisableAsserts;
      break;
   case 5: // "nolibc"
      result->kind = c2recipe_Kind_NoLibc;
      break;
   case 6: // "config"
      result->kind = c2recipe_Kind_Config;
      break;
   case 7: // "export"
      result->kind = c2recipe_Kind_Export;
      break;
   case 8: // "plugin"
      result->kind = c2recipe_Kind_Plugin;
      break;
   case 9: // "use"
      result->kind = c2recipe_Kind_Use;
      break;
   case 10: // "asm"
      result->kind = c2recipe_Kind_AsmFile;
      break;
   case 11: // "optional"
      result->kind = c2recipe_Kind_Optional;
      break;
   default:
      c2recipe_Parser_warning(p, "unknown option '%s'", option);
      break;
   }
   p->cur += strlen(option);
}

static void c2recipe_Parser_skip_comments(c2recipe_Parser* p)
{
   while (*p->cur) {
      if (*p->cur == '\n') return;
      p->cur++;
   }
}

static void c2recipe_Parser_parseTop(c2recipe_Parser* p)
{
   while (1) {
      switch (p->token.kind) {
      case c2recipe_Kind_Plugin:
         c2recipe_Parser_parsePlugin(p, true);
         break;
      case c2recipe_Kind_PluginOptions:
         break;
      case c2recipe_Kind_Text:
         break;
      case c2recipe_Kind_Executable:
         c2recipe_Parser_parseExecutable(p);
         break;
      case c2recipe_Kind_Lib:
         c2recipe_Parser_parseLibrary(p);
         break;
      case c2recipe_Kind_Image:
         c2recipe_Parser_parseImage(p);
         break;
      case c2recipe_Kind_File:
         c2recipe_Parser_error(p, "syntax error");
         break;
      case c2recipe_Kind_End:
         break;
      case c2recipe_Kind_Warnings:
      case c2recipe_Kind_Backend:
      case c2recipe_Kind_DisableAsserts:
      case c2recipe_Kind_NoLibc:
         c2recipe_Parser_error(p, "must be inside target");
         break;
      case c2recipe_Kind_Config:
         if (p->targets_started) c2recipe_Parser_error(p, "global configs must come before targets");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect config");
         if (!c2recipe_Parser_addGlobalFeature(p, p->token.value)) {
            c2recipe_Parser_error(p, "duplicate config '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_Export:
      case c2recipe_Kind_Use:
      case c2recipe_Kind_AsmFile:
      case c2recipe_Kind_Optional:
         c2recipe_Parser_error(p, "must be inside target");
         break;
      case c2recipe_Kind_Set:
         c2recipe_Parser_parseSet(p);
         break;
      case c2recipe_Kind_SetUse:
         c2recipe_Parser_error(p, "syntax error");
         break;
      case c2recipe_Kind_Eof:
         return;
      }
   }
}

static void c2recipe_Parser_parsePlugin(c2recipe_Parser* p, bool is_global)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect plugin name");
   uint32_t name = p->token.value;
   src_loc_SrcLoc loc = p->token.loc;
   c2recipe_Parser_consumeToken(p);
   uint32_t options = 0;
   if (p->token.kind == c2recipe_Kind_PluginOptions) {
      options = p->token.value;
      c2recipe_Parser_consumeToken(p);
   }
   if (is_global) {
      c2recipe_Recipe_addPlugin(p->recipe, name, options, loc);
   } else {
      build_target_Target_addPlugin(p->target, name, options, loc);
   }
}

static void c2recipe_Parser_parseWarnings(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect options");
   warning_flags_Flags* warnings = build_target_Target_getWarnings2(p->target);
   while (c2recipe_Parser_is(p, c2recipe_Kind_Text)) {
      const char* option = string_pool_Pool_idx2str(p->pool, p->token.value);
      bool disable = false;
      if (!strncmp(option, "no-", 3)) {
         disable = true;
         option += 3;
      }
      switch (c2_strswitch(option, "\006unused" "\017unused-variable" "\017unused-function" "\020unused-parameter" "\013unused-type" "\015unused-module" "\015unused-import" "\015unused-public" "\014unused-label" "\024unused-enum-constant" "\020unreachable-code" "\021unknown-attribute" "\012deprecated" "\020promote-to-error")) {
      case 2: // "unused"
         warnings->no_unused = disable;
         warnings->no_unused_variable = disable;
         warnings->no_unused_function = disable;
         warnings->no_unused_parameter = disable;
         warnings->no_unused_type = disable;
         warnings->no_unused_module = disable;
         warnings->no_unused_import = disable;
         warnings->no_unused_public = disable;
         warnings->no_unused_label = disable;
         warnings->no_unused_enum_constant = disable;
         break;
      case 3: // "unused-variable"
         warnings->no_unused_variable = disable;
         break;
      case 4: // "unused-function"
         warnings->no_unused_function = disable;
         break;
      case 5: // "unused-parameter"
         warnings->no_unused_parameter = disable;
         break;
      case 6: // "unused-type"
         warnings->no_unused_type = disable;
         break;
      case 7: // "unused-module"
         warnings->no_unused_module = disable;
         break;
      case 8: // "unused-import"
         warnings->no_unused_import = disable;
         break;
      case 9: // "unused-public"
         warnings->no_unused_public = disable;
         break;
      case 10: // "unused-label"
         warnings->no_unused_label = disable;
         break;
      case 11: // "unused-enum-constant"
         warnings->no_unused_enum_constant = disable;
         break;
      case 12: // "unreachable-code"
         warnings->no_unreachable_code = disable;
         break;
      case 13: // "unknown-attribute"
         warnings->no_unknown_attribute = disable;
         break;
      case 14: // "deprecated"
         warnings->no_deprecated = disable;
         break;
      case 15: // "promote-to-error"
         warnings->are_errors = !disable;
         break;
      default:
         c2recipe_Parser_warning(p, "unknown warning '%s'", option);
         break;
      }
      c2recipe_Parser_consumeToken(p);
   }
}

static void c2recipe_Parser_parseExecutable(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect target name");
   p->target = c2recipe_Recipe_addTarget(p->recipe, p->token.value, p->token.loc, build_target_Kind_Executable);
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_parseTarget(p);
}

static void c2recipe_Parser_parseImage(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect image name");
   p->target = c2recipe_Recipe_addTarget(p->recipe, p->token.value, p->token.loc, build_target_Kind_Image);
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_parseTarget(p);
}

static void c2recipe_Parser_parseSet(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect set name");
   c2recipe_Set* old = c2recipe_Parser_findSet(p, p->token.value);
   if (old) {
      c2recipe_Parser_error(p, "duplicate set '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
   }
   p->sets = c2recipe_Set_create(p->token.value, p->token.loc, p->sets);
   c2recipe_Parser_consumeToken(p);
   while (1) {
      switch (p->token.kind) {
      case c2recipe_Kind_File:
         if (!c2recipe_Set_addFile(p->sets, p->token.value, p->token.loc)) {
            c2recipe_Parser_error(p, "duplicate file '%s' in set '%s'", string_pool_Pool_idx2str(p->pool, p->token.value), string_pool_Pool_idx2str(p->pool, p->sets->name_idx));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_End:
         c2recipe_Parser_consumeToken(p);
         return;
      default:
         c2recipe_Parser_error(p, "syntax error");
         break;
      }
   }
}

static c2recipe_Set* c2recipe_Parser_findSet(c2recipe_Parser* p, uint32_t name_idx)
{
   c2recipe_Set* s = p->sets;
   while (s) {
      if (s->name_idx == name_idx) return s;
      s = s->next;
   }
   return NULL;
}

static void c2recipe_Parser_parseLibrary(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect target name");
   uint32_t name = p->token.value;
   src_loc_SrcLoc loc = p->token.loc;
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect lib type");
   uint32_t kind_name = p->token.value;
   build_target_Kind kind = build_target_Kind_StaticLibrary;
   switch (c2_strswitch(string_pool_Pool_idx2str(p->pool, kind_name), "\006static" "\007dynamic" "\006source")) {
   case 2: // "static"
      kind = build_target_Kind_StaticLibrary;
      break;
   case 3: // "dynamic"
      kind = build_target_Kind_DynamicLibrary;
      break;
   case 4: // "source"
      kind = build_target_Kind_SourceLibrary;
      break;
   default:
      c2recipe_Parser_error(p, "invalid library kind (allowed: dynamic|static|source)");
      break;
   }
   c2recipe_Parser_consumeToken(p);
   p->target = c2recipe_Recipe_addTarget(p->recipe, name, loc, kind);
   c2recipe_Parser_parseTarget(p);
}

static void c2recipe_Parser_parseTarget(c2recipe_Parser* p)
{
   p->targets_started = true;
   bool files_started = false;
   for (uint32_t i = 0; i < string_list_List_length(&p->global_configs); i++) {
      build_target_Target_addFeature(p->target, string_list_List_get_idx(&p->global_configs, i));
   }
   while (1) {
      switch (p->token.kind) {
      case c2recipe_Kind_Plugin:
         c2recipe_Parser_parsePlugin(p, false);
         break;
      case c2recipe_Kind_PluginOptions:
      case c2recipe_Kind_Text:
      case c2recipe_Kind_Executable:
      case c2recipe_Kind_Lib:
      case c2recipe_Kind_Image:
         c2recipe_Parser_error(p, "syntax error");
         break;
      case c2recipe_Kind_File:
         files_started = true;
         if (!build_target_Target_addFile(p->target, p->token.value, p->token.loc)) {
            c2recipe_Parser_error(p, "duplicate file '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_End:
         c2recipe_Parser_consumeToken(p);
         p->target = NULL;
         return;
      case c2recipe_Kind_Warnings:
         if (files_started) c2recipe_Parser_error(p, "$warnings must come before files");
         c2recipe_Parser_parseWarnings(p);
         break;
      case c2recipe_Kind_Backend:
         if (files_started) c2recipe_Parser_error(p, "$backend must come before files");
         c2recipe_Parser_parseBackend(p);
         break;
      case c2recipe_Kind_DisableAsserts:
         if (files_started) c2recipe_Parser_error(p, "$disable-asserts must come before files");
         c2recipe_Parser_consumeToken(p);
         build_target_Target_disableAsserts(p->target);
         break;
      case c2recipe_Kind_NoLibc:
         if (files_started) c2recipe_Parser_error(p, "$nolibc must come before files");
         c2recipe_Parser_consumeToken(p);
         build_target_Target_setNoLibC(p->target);
         break;
      case c2recipe_Kind_Config:
         if (files_started) c2recipe_Parser_error(p, "$config must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect config");
         build_target_Target_addFeature(p->target, p->token.value);
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_Export:
         if (files_started) c2recipe_Parser_error(p, "$export must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect export");
         while (p->token.kind == c2recipe_Kind_Text) {
            build_target_Target_addExport(p->target, p->token.value);
            c2recipe_Parser_consumeToken(p);
         }
         break;
      case c2recipe_Kind_Use: {
         if (files_started) c2recipe_Parser_error(p, "$use must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect library name");
         uint32_t libname = p->token.value;
         if (build_target_Target_hasLib(p->target, libname)) {
            c2recipe_Parser_error(p, "duplicate use of %s", string_pool_Pool_idx2str(p->pool, libname));
         }
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect library type");
         const char* libtype = string_pool_Pool_idx2str(p->pool, p->token.value);
         build_target_Kind kind = build_target_Kind_StaticLibrary;
         switch (c2_strswitch(libtype, "\006static" "\007dynamic" "\006source")) {
         case 2: // "static"
            kind = build_target_Kind_StaticLibrary;
            break;
         case 3: // "dynamic"
            kind = build_target_Kind_DynamicLibrary;
            break;
         case 4: // "source"
            kind = build_target_Kind_SourceLibrary;
            break;
         default:
            c2recipe_Parser_error(p, "unknown library kind '%s'", libtype);
            break;
         }
         build_target_Target_addLib(p->target, libname, kind);
         c2recipe_Parser_consumeToken(p);
         while (p->token.kind == c2recipe_Kind_Text) c2recipe_Parser_consumeToken(p);
         break;
      }
      case c2recipe_Kind_AsmFile:
         if (files_started) c2recipe_Parser_error(p, "$asm must come before files");
         c2recipe_Parser_consumeToken(p);
         c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect filename");
         if (!build_target_Target_addAsmFile(p->target, p->token.value, p->token.loc)) {
            c2recipe_Parser_error(p, "duplicate asm file '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         }
         c2recipe_Parser_consumeToken(p);
         break;
      case c2recipe_Kind_Optional:
         if (files_started) c2recipe_Parser_error(p, "$optional must come before files");
         c2recipe_Parser_consumeToken(p);
         build_target_Target_setOptional(p->target);
         break;
      case c2recipe_Kind_Set:
         c2recipe_Parser_error(p, "cannot define a set here");
         break;
      case c2recipe_Kind_SetUse: {
         c2recipe_Set* s = c2recipe_Parser_findSet(p, p->token.value);
         if (!s) c2recipe_Parser_error(p, "unknown set '%s'", string_pool_Pool_idx2str(p->pool, p->token.value));
         c2recipe_Parser_consumeToken(p);
         files_started = true;
         for (uint32_t i = 0; i < file_list_FileList_getCount(&s->files); i++) {
            const file_list_File* f = file_list_FileList_get(&s->files, i);
            if (!build_target_Target_addFile(p->target, f->name, f->loc)) {
               c2recipe_Parser_error(p, "duplicate file '%s' from set '%s'", string_pool_Pool_idx2str(p->pool, f->name), string_pool_Pool_idx2str(p->pool, s->name_idx));
            }
         }
         break;
      }
      case c2recipe_Kind_Eof:
         c2recipe_Parser_error(p, "un-terminated target");
         return;
      }
   }
}

static void c2recipe_Parser_parseBackend(c2recipe_Parser* p)
{
   c2recipe_Parser_consumeToken(p);
   c2recipe_Parser_expect(p, c2recipe_Kind_Text, "expect backend type");
   const char* backend_kind = string_pool_Pool_idx2str(p->pool, p->token.value);
   c2recipe_Parser_consumeToken(p);
   if (build_target_Target_hasBackEnd(p->target)) c2recipe_Parser_error(p, "duplicate backend");
   switch (c2_strswitch(backend_kind, "\001c" "\002ir")) {
   case 2: // "c"
      build_target_Target_setBackEnd(p->target, build_target_BackEndKind_C);
      break;
   case 3: // "ir"
      build_target_Target_setBackEnd(p->target, build_target_BackEndKind_IR);
      break;
   default:
      c2recipe_Parser_error(p, "unknown backend type (supported: c,ir)");
      break;
   }
   c2recipe_Parser_parseBackEndOptions(p);
}

static void c2recipe_Parser_parseBackEndOptions(c2recipe_Parser* p)
{
   while (p->token.kind == c2recipe_Kind_Text) {
      const char* option = string_pool_Pool_idx2str(p->pool, p->token.value);
      switch (c2_strswitch(option, "\010no-build" "\004fast")) {
      case 2: // "no-build"
         build_target_Target_setNoBuild(p->target);
         break;
      case 3: // "fast"
         build_target_Target_setFastBuild(p->target);
         break;
      default:
         c2recipe_Parser_error(p, "invalid backend option '%s'", option);
         break;
      }
      c2recipe_Parser_consumeToken(p);
   }
}

static bool c2recipe_equals(const char* str, const char* expect, uint32_t len)
{
   for (uint32_t i = 0; i < len; i++) {
      if (str[i] != expect[i]) return false;
   }
   return true;
}


// --- module ast_visitor ---
typedef struct ast_visitor_Visitor_ ast_visitor_Visitor;

typedef void (*ast_visitor_OnRef)(void* arg, const ast_Ref* ref);

struct ast_visitor_Visitor_ {
   void* arg;
   ast_visitor_OnRef on_ref;
};

static ast_visitor_Visitor* ast_visitor_create(void* arg, ast_visitor_OnRef on_ref);
static void ast_visitor_Visitor_free(ast_visitor_Visitor* v);
static void ast_visitor_Visitor_handleAssert(ast_visitor_Visitor* v, ast_StaticAssert* a);
static void ast_visitor_Visitor_handle(ast_visitor_Visitor* v, ast_Decl* d);
static void ast_visitor_Visitor_handleFunction(ast_visitor_Visitor* v, ast_FunctionDecl* d);
static void ast_visitor_Visitor_handleVarDecl(ast_visitor_Visitor* v, ast_VarDecl* d);
static void ast_visitor_Visitor_handleTypeRef(ast_visitor_Visitor* v, const ast_TypeRef* r);
static void ast_visitor_Visitor_handleStmt(ast_visitor_Visitor* v, ast_Stmt* s);
static void ast_visitor_Visitor_handleCompoundStmt(ast_visitor_Visitor* v, ast_CompoundStmt* s);
static void ast_visitor_Visitor_handleExpr(ast_visitor_Visitor* v, ast_Expr* e);
static void ast_visitor_Visitor_handleCallExpr(ast_visitor_Visitor* v, ast_CallExpr* c);
static void ast_visitor_Visitor_handleMemberExpr(ast_visitor_Visitor* v, ast_MemberExpr* m);
static void ast_visitor_Visitor_handleBuiltinExpr(ast_visitor_Visitor* v, ast_BuiltinExpr* b);

static ast_visitor_Visitor* ast_visitor_create(void* arg, ast_visitor_OnRef on_ref)
{
   ast_visitor_Visitor* v = calloc(1, 16);
   v->arg = arg;
   v->on_ref = on_ref;
   return v;
}

static void ast_visitor_Visitor_free(ast_visitor_Visitor* v)
{
   free(v);
}

static void ast_visitor_Visitor_handleAssert(ast_visitor_Visitor* v, ast_StaticAssert* a)
{
   ast_visitor_Visitor_handleExpr(v, ast_StaticAssert_getLhs(a));
   ast_visitor_Visitor_handleExpr(v, ast_StaticAssert_getRhs(a));
}

static void ast_visitor_Visitor_handle(ast_visitor_Visitor* v, ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      ast_visitor_Visitor_handleFunction(v, (ast_FunctionDecl*)d);
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType: {
      ast_StructTypeDecl* s = (ast_StructTypeDecl*)d;
      uint32_t num_members = ast_StructTypeDecl_getNumMembers(s);
      ast_Decl** members = ast_StructTypeDecl_getMembers(s);
      for (uint32_t i = 0; i < num_members; i++) {
         ast_visitor_Visitor_handle(v, members[i]);
      }
      break;
   }
   case ast_DeclKind_EnumType:
      break;
   case ast_DeclKind_EnumConstant: {
      const ast_EnumConstantDecl* ecd = (ast_EnumConstantDecl*)d;
      ast_Expr* init_expr = ast_EnumConstantDecl_getInit(ecd);
      if (init_expr) ast_visitor_Visitor_handleExpr(v, init_expr);
      break;
   }
   case ast_DeclKind_FunctionType: {
      ast_FunctionTypeDecl* ftd = (ast_FunctionTypeDecl*)d;
      ast_visitor_Visitor_handleFunction(v, ast_FunctionTypeDecl_getDecl(ftd));
      break;
   }
   case ast_DeclKind_AliasType: {
      ast_AliasTypeDecl* atd = (ast_AliasTypeDecl*)d;
      ast_visitor_Visitor_handleTypeRef(v, ast_AliasTypeDecl_getTypeRef(atd));
      break;
   }
   case ast_DeclKind_Variable:
      ast_visitor_Visitor_handleVarDecl(v, (ast_VarDecl*)d);
      break;
   }
}

static void ast_visitor_Visitor_handleFunction(ast_visitor_Visitor* v, ast_FunctionDecl* d)
{
   if (ast_FunctionDecl_isTemplate(d)) return;
   ast_visitor_Visitor_handleTypeRef(v, ast_FunctionDecl_getReturnTypeRef(d));
   ast_Ref* prefix = ast_FunctionDecl_getPrefix(d);
   if (prefix) v->on_ref(v->arg, prefix);
   uint32_t num_params = ast_FunctionDecl_getNumParams(d);
   ast_VarDecl** args = ast_FunctionDecl_getParams(d);
   for (uint32_t i = 0; i < num_params; i++) ast_visitor_Visitor_handleVarDecl(v, args[i]);
   ast_CompoundStmt* body = ast_FunctionDecl_getBody(d);
   if (body) {
      ast_visitor_Visitor_handleCompoundStmt(v, body);
   }
}

static void ast_visitor_Visitor_handleVarDecl(ast_visitor_Visitor* v, ast_VarDecl* d)
{
   ast_visitor_Visitor_handleTypeRef(v, ast_VarDecl_getTypeRef(d));
   ast_Expr* init_expr = ast_VarDecl_getInit(d);
   if (init_expr) ast_visitor_Visitor_handleExpr(v, init_expr);
   ast_Expr* bitfield = ast_VarDecl_getBitfield(d);
   if (bitfield) ast_visitor_Visitor_handleExpr(v, bitfield);
}

static void ast_visitor_Visitor_handleTypeRef(ast_visitor_Visitor* v, const ast_TypeRef* r)
{
   if (ast_TypeRef_isUser(r)) {
      const ast_Ref* prefix = ast_TypeRef_getPrefix(r);
      if (prefix) v->on_ref(v->arg, prefix);
      const ast_Ref* user = ast_TypeRef_getUser(r);
      v->on_ref(v->arg, user);
   } else if (ast_TypeRef_isFunction(r)) {
      const ast_Ref* member = ast_TypeRef_getStructMemberType(r);
      ast_visitor_Visitor_handleFunction(v, (ast_FunctionDecl*)member->decl);
   }
   uint32_t num_arrays = ast_TypeRef_getNumArrays(r);
   for (uint32_t i = 0; i < num_arrays; i++) {
      ast_Expr* e = ast_TypeRef_getArray(r, i);
      if (e) ast_visitor_Visitor_handleExpr(v, e);
   }
}

static void ast_visitor_Visitor_handleStmt(ast_visitor_Visitor* v, ast_Stmt* s)
{
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      ast_ReturnStmt* r = (ast_ReturnStmt*)s;
      ast_Expr* e = ast_ReturnStmt_getValue(r);
      if (e) ast_visitor_Visitor_handleExpr(v, e);
      break;
   }
   case ast_StmtKind_Expr:
      ast_visitor_Visitor_handleExpr(v, (ast_Expr*)s);
      break;
   case ast_StmtKind_If: {
      ast_IfStmt* i = (ast_IfStmt*)s;
      ast_visitor_Visitor_handleStmt(v, ast_IfStmt_getCond(i));
      ast_visitor_Visitor_handleStmt(v, ast_IfStmt_getThen(i));
      ast_Stmt* e = ast_IfStmt_getElse(i);
      if (e) ast_visitor_Visitor_handleStmt(v, e);
      break;
   }
   case ast_StmtKind_While: {
      ast_WhileStmt* w = (ast_WhileStmt*)s;
      ast_visitor_Visitor_handleStmt(v, ast_WhileStmt_getCond(w));
      ast_visitor_Visitor_handleStmt(v, ast_WhileStmt_getBody(w));
      break;
   }
   case ast_StmtKind_For: {
      ast_ForStmt* f = (ast_ForStmt*)s;
      ast_Stmt* in = ast_ForStmt_getInit(f);
      if (in) ast_visitor_Visitor_handleStmt(v, in);
      ast_Expr* cond = ast_ForStmt_getCond(f);
      if (cond) ast_visitor_Visitor_handleExpr(v, cond);
      ast_Expr* cont = ast_ForStmt_getCont(f);
      if (cont) ast_visitor_Visitor_handleExpr(v, cont);
      ast_Stmt* body = ast_ForStmt_getBody(f);
      if (body) ast_visitor_Visitor_handleStmt(v, body);
      break;
   }
   case ast_StmtKind_Switch: {
      ast_SwitchStmt* sw = (ast_SwitchStmt*)s;
      ast_visitor_Visitor_handleStmt(v, ast_SwitchStmt_getCond(sw));
      const uint32_t numcases = ast_SwitchStmt_getNumCases(sw);
      ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
      for (uint32_t i = 0; i < numcases; i++) {
         ast_SwitchCase* c = cases[i];
         uint32_t numconds = ast_SwitchCase_getNumConds(c);
         for (uint32_t j = 0; j < numconds; j++) ast_visitor_Visitor_handleExpr(v, ast_SwitchCase_getCond(c, j));
         uint32_t numstmts = ast_SwitchCase_getNumStmts(c);
         for (uint32_t j = 0; j < numstmts; j++) ast_visitor_Visitor_handleStmt(v, ast_SwitchCase_getStmt(c, j));
      }
      break;
   }
   case ast_StmtKind_Break:
      break;
   case ast_StmtKind_Continue:
      break;
   case ast_StmtKind_Fallthrough:
      break;
   case ast_StmtKind_Label: {
      ast_LabelStmt* ls = (ast_LabelStmt*)s;
      ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      if (stmt) ast_visitor_Visitor_handleStmt(v, stmt);
      break;
   }
   case ast_StmtKind_Goto:
      break;
   case ast_StmtKind_Compound:
      ast_visitor_Visitor_handleCompoundStmt(v, (ast_CompoundStmt*)s);
      break;
   case ast_StmtKind_Decl: {
      ast_DeclStmt* d = (ast_DeclStmt*)s;
      uint32_t count = ast_DeclStmt_getDeclCount(d);
      for (uint32_t i = 0; i < count; i++) {
         ast_visitor_Visitor_handleVarDecl(v, ast_DeclStmt_getDecl(d, i));
      }
      break;
   }
   case ast_StmtKind_Asm: {
      ast_AsmStmt* a = (ast_AsmStmt*)s;
      uint32_t num_exprs = ast_AsmStmt_getNumExprs(a);
      ast_Expr** exprs = ast_AsmStmt_getExprs(a);
      for (uint32_t i = 0; i < num_exprs; i++) {
         ast_visitor_Visitor_handleExpr(v, exprs[i]);
      }
      break;
   }
   case ast_StmtKind_Assert: {
      ast_AssertStmt* a = (ast_AssertStmt*)s;
      ast_visitor_Visitor_handleExpr(v, ast_AssertStmt_getInner(a));
      break;
   }
   }
}

static void ast_visitor_Visitor_handleCompoundStmt(ast_visitor_Visitor* v, ast_CompoundStmt* s)
{
   uint32_t count = ast_CompoundStmt_getCount(s);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(s);
   for (uint32_t i = 0; i < count; i++) ast_visitor_Visitor_handleStmt(v, stmts[i]);
}

static void ast_visitor_Visitor_handleExpr(ast_visitor_Visitor* v, ast_Expr* e)
{
   ;//assert(e);
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
      return;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      ast_Ref ref = ast_IdentifierExpr_getRef(i);
      v->on_ref(v->arg, &ref);
      break;
   }
   case ast_ExprKind_Type: {
      ast_TypeExpr* t = (ast_TypeExpr*)e;
      ast_visitor_Visitor_handleTypeRef(v, ast_TypeExpr_getTypeRef(t));
      break;
   }
   case ast_ExprKind_Call:
      ast_visitor_Visitor_handleCallExpr(v, (ast_CallExpr*)e);
      break;
   case ast_ExprKind_InitList: {
      ast_InitListExpr* ili = (ast_InitListExpr*)e;
      uint32_t count = ast_InitListExpr_getNumValues(ili);
      ast_Expr** exprs = ast_InitListExpr_getValues(ili);
      for (uint32_t i = 0; i < count; i++) ast_visitor_Visitor_handleExpr(v, exprs[i]);
      break;
   }
   case ast_ExprKind_FieldDesignatedInit: {
      ast_FieldDesignatedInitExpr* f = (ast_FieldDesignatedInitExpr*)e;
      ast_Ref ref = { .loc = ast_Expr_getLoc(e), .name_idx = ast_FieldDesignatedInitExpr_getField(f), .decl = ast_FieldDesignatedInitExpr_getDecl(f) };
      v->on_ref(v->arg, &ref);
      ast_visitor_Visitor_handleExpr(v, ast_FieldDesignatedInitExpr_getInit(f));
      break;
   }
   case ast_ExprKind_ArrayDesignatedInit: {
      ast_ArrayDesignatedInitExpr* a = (ast_ArrayDesignatedInitExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_ArrayDesignatedInitExpr_getDesignator(a));
      ast_visitor_Visitor_handleExpr(v, ast_ArrayDesignatedInitExpr_getInit(a));
      break;
   }
   case ast_ExprKind_BinaryOperator: {
      ast_BinaryOperator* b = (ast_BinaryOperator*)e;
      ast_visitor_Visitor_handleExpr(v, ast_BinaryOperator_getLHS(b));
      ast_visitor_Visitor_handleExpr(v, ast_BinaryOperator_getRHS(b));
      break;
   }
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* u = (ast_UnaryOperator*)e;
      ast_visitor_Visitor_handleExpr(v, ast_UnaryOperator_getInner(u));
      break;
   }
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = (ast_ConditionalOperator*)e;
      ast_visitor_Visitor_handleExpr(v, ast_ConditionalOperator_getCond(c));
      ast_visitor_Visitor_handleExpr(v, ast_ConditionalOperator_getLHS(c));
      ast_visitor_Visitor_handleExpr(v, ast_ConditionalOperator_getRHS(c));
      break;
   }
   case ast_ExprKind_Builtin:
      ast_visitor_Visitor_handleBuiltinExpr(v, (ast_BuiltinExpr*)e);
      break;
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = (ast_ArraySubscriptExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_ArraySubscriptExpr_getBase(a));
      ast_visitor_Visitor_handleExpr(v, ast_ArraySubscriptExpr_getIndex(a));
      break;
   }
   case ast_ExprKind_Member:
      ast_visitor_Visitor_handleMemberExpr(v, (ast_MemberExpr*)e);
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = (ast_ParenExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_ParenExpr_getInner(p));
      break;
   }
   case ast_ExprKind_BitOffset: {
      ast_BitOffsetExpr* bi = (ast_BitOffsetExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_BitOffsetExpr_getLHS(bi));
      ast_visitor_Visitor_handleExpr(v, ast_BitOffsetExpr_getRHS(bi));
      break;
   }
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* ec = (ast_ExplicitCastExpr*)e;
      ast_visitor_Visitor_handleTypeRef(v, ast_ExplicitCastExpr_getTypeRef(ec));
      ast_visitor_Visitor_handleExpr(v, ast_ExplicitCastExpr_getInner(ec));
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_ImplicitCastExpr_getInner(ic));
      break;
   }
   case ast_ExprKind_Range: {
      ast_RangeExpr* b = (ast_RangeExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_RangeExpr_getLHS(b));
      ast_visitor_Visitor_handleExpr(v, ast_RangeExpr_getRHS(b));
      break;
   }
   case ast_ExprKind_NamedArgument: {
      ast_NamedArgument* n = (ast_NamedArgument*)e;
      ast_visitor_Visitor_handleExpr(v, ast_NamedArgument_getInner(n));
      break;
   }
   case ast_ExprKind_Alternate: {
      ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      ast_visitor_Visitor_handleExpr(v, ast_AlternateExpr_getOriginal(n));
      break;
   }
   }
}

static void ast_visitor_Visitor_handleCallExpr(ast_visitor_Visitor* v, ast_CallExpr* c)
{
   ast_visitor_Visitor_handleExpr(v, ast_CallExpr_getFunc(c));
   uint32_t num_args = ast_CallExpr_getNumArgs(c);
   ast_Expr** args = ast_CallExpr_getArgs(c);
   for (uint32_t i = 0; i < num_args; i++) ast_visitor_Visitor_handleExpr(v, args[i]);
}

static void ast_visitor_Visitor_handleMemberExpr(ast_visitor_Visitor* v, ast_MemberExpr* m)
{
   ast_Ref ref;
   if (ast_MemberExpr_hasExpr(m)) {
      ast_visitor_Visitor_handleExpr(v, ast_MemberExpr_getBaseExpr(m));
   } else {
      ref = ast_MemberExpr_getBaseRef(m);
      v->on_ref(v->arg, &ref);
   }
   ref = ast_MemberExpr_getRef(m);
   v->on_ref(v->arg, &ref);
}

static void ast_visitor_Visitor_handleBuiltinExpr(ast_visitor_Visitor* v, ast_BuiltinExpr* b)
{
   ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getInner(b));
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof:
      break;
   case ast_BuiltinExprKind_Elemsof:
      break;
   case ast_BuiltinExprKind_EnumMin:
      break;
   case ast_BuiltinExprKind_EnumMax:
      break;
   case ast_BuiltinExprKind_OffsetOf:
      ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getOffsetOfMember(b));
      break;
   case ast_BuiltinExprKind_ToContainer:
      ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getToContainerMember(b));
      ast_visitor_Visitor_handleExpr(v, ast_BuiltinExpr_getToContainerPointer(b));
      break;
   }
}


// --- module dep_finder ---
typedef struct dep_finder_Finder_ dep_finder_Finder;

typedef void (*dep_finder_OnDecl)(void* arg, ast_Decl* d);

struct dep_finder_Finder_ {
   ast_Module* mod;
   void* arg;
   dep_finder_OnDecl on_decl;
   ast_Decl* current;
};

static void dep_finder_Finder_init(dep_finder_Finder* f, ast_Module* mod, void* arg, dep_finder_OnDecl on_decl);
static void dep_finder_Finder_check(dep_finder_Finder* s, ast_Decl* d);
static void dep_finder_Finder_handleFunction(dep_finder_Finder* s, ast_FunctionDecl* d);
static void dep_finder_Finder_handleStruct(dep_finder_Finder* s, ast_StructTypeDecl* d);
static void dep_finder_Finder_handleEnumType(dep_finder_Finder* s, ast_EnumTypeDecl* etd);
static void dep_finder_Finder_handleTypeRef(dep_finder_Finder* f, ast_TypeRef* r);
static void dep_finder_Finder_handleVarDecl(dep_finder_Finder* s, ast_VarDecl* d);
static void dep_finder_Finder_handleExpr(dep_finder_Finder* s, ast_Expr* e);
static void dep_finder_Finder_handleInitList(dep_finder_Finder* s, ast_InitListExpr* ile);
static void dep_finder_Finder_handleMemberExpr(dep_finder_Finder* s, ast_MemberExpr* m);
static void dep_finder_Finder_onDep(dep_finder_Finder* s, const ast_Decl* d, bool full);

static void dep_finder_Finder_init(dep_finder_Finder* f, ast_Module* mod, void* arg, dep_finder_OnDecl on_decl)
{
   f->mod = mod;
   f->arg = arg;
   f->on_decl = on_decl;
   f->current = NULL;
}

static void dep_finder_Finder_check(dep_finder_Finder* s, ast_Decl* d)
{
   s->current = d;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      dep_finder_Finder_handleFunction(s, (ast_FunctionDecl*)d);
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      dep_finder_Finder_handleStruct(s, (ast_StructTypeDecl*)d);
      break;
   case ast_DeclKind_EnumType:
      dep_finder_Finder_handleEnumType(s, (ast_EnumTypeDecl*)d);
      break;
   case ast_DeclKind_EnumConstant:
      ast_Decl_dump(d);
      ;//assert(0);
      break;
   case ast_DeclKind_FunctionType: {
      ast_FunctionTypeDecl* ftd = (ast_FunctionTypeDecl*)d;
      dep_finder_Finder_handleFunction(s, ast_FunctionTypeDecl_getDecl(ftd));
      break;
   }
   case ast_DeclKind_AliasType: {
      ast_AliasTypeDecl* at = (ast_AliasTypeDecl*)d;
      dep_finder_Finder_handleTypeRef(s, ast_AliasTypeDecl_getTypeRef(at));
      break;
   }
   case ast_DeclKind_Variable:
      dep_finder_Finder_handleVarDecl(s, (ast_VarDecl*)d);
      break;
   }
}

static void dep_finder_Finder_handleFunction(dep_finder_Finder* s, ast_FunctionDecl* d)
{
   if (ast_FunctionDecl_isTemplate(d)) return;
   dep_finder_Finder_handleTypeRef(s, ast_FunctionDecl_getReturnTypeRef(d));
   uint32_t num_params = ast_FunctionDecl_getNumParams(d);
   ast_VarDecl** args = ast_FunctionDecl_getParams(d);
   for (uint32_t i = 0; i < num_params; i++) dep_finder_Finder_handleVarDecl(s, args[i]);
}

static void dep_finder_Finder_handleStruct(dep_finder_Finder* s, ast_StructTypeDecl* d)
{
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(d);
   ast_Decl** members = ast_StructTypeDecl_getMembers(d);
   for (uint32_t i = 0; i < num_members; i++) {
      ast_Decl* m = members[i];
      if (ast_Decl_isStructType(m)) {
         dep_finder_Finder_handleStruct(s, (ast_StructTypeDecl*)m);
      } else {
         ;//assert(ast_Decl_isVariable(m));
         dep_finder_Finder_handleVarDecl(s, (ast_VarDecl*)m);
      }
   }
}

static void dep_finder_Finder_handleEnumType(dep_finder_Finder* s, ast_EnumTypeDecl* etd)
{
   uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(etd);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
   for (uint32_t i = 0; i < num_constants; i++) {
      ast_EnumConstantDecl* c = constants[i];
      ast_Expr* initExpr = ast_EnumConstantDecl_getInit(c);
      if (initExpr) dep_finder_Finder_handleExpr(s, initExpr);
   }
}

static void dep_finder_Finder_handleTypeRef(dep_finder_Finder* f, ast_TypeRef* r)
{
   const ast_Decl* refDecl = ast_TypeRef_getUserDecl(r);
   if (refDecl) {
      if (ast_TypeRef_isPointer(r) && ast_Decl_isStructType(refDecl)) {
      } else {
         dep_finder_Finder_onDep(f, refDecl, !ast_TypeRef_isPointer(r));
      }
   }
   uint32_t num_arrays = ast_TypeRef_getNumArrays(r);
   for (uint32_t i = 0; i < num_arrays; i++) {
      ast_Expr* e = ast_TypeRef_getArray(r, i);
      if (e) dep_finder_Finder_handleExpr(f, e);
   }
}

static void dep_finder_Finder_handleVarDecl(dep_finder_Finder* s, ast_VarDecl* d)
{
   dep_finder_Finder_handleTypeRef(s, ast_VarDecl_getTypeRef(d));
   ast_Expr* init_expr = ast_VarDecl_getInit(d);
   if (init_expr) dep_finder_Finder_handleExpr(s, init_expr);
}

static void dep_finder_Finder_handleExpr(dep_finder_Finder* s, ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      ast_Decl* d = ast_IdentifierExpr_getDecl(i);
      dep_finder_Finder_onDep(s, d, true);
      break;
   }
   case ast_ExprKind_Type: {
      ast_TypeExpr* t = (ast_TypeExpr*)e;
      dep_finder_Finder_handleTypeRef(s, ast_TypeExpr_getTypeRef(t));
      break;
   }
   case ast_ExprKind_Call:
      break;
   case ast_ExprKind_InitList:
      dep_finder_Finder_handleInitList(s, (ast_InitListExpr*)e);
      break;
   case ast_ExprKind_FieldDesignatedInit: {
      ast_FieldDesignatedInitExpr* i = (ast_FieldDesignatedInitExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_FieldDesignatedInitExpr_getInit(i));
      break;
   }
   case ast_ExprKind_ArrayDesignatedInit: {
      ast_ArrayDesignatedInitExpr* a = (ast_ArrayDesignatedInitExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_ArrayDesignatedInitExpr_getDesignator(a));
      dep_finder_Finder_handleExpr(s, ast_ArrayDesignatedInitExpr_getInit(a));
      break;
   }
   case ast_ExprKind_BinaryOperator: {
      ast_BinaryOperator* b = (ast_BinaryOperator*)e;
      dep_finder_Finder_handleExpr(s, ast_BinaryOperator_getLHS(b));
      dep_finder_Finder_handleExpr(s, ast_BinaryOperator_getRHS(b));
      break;
   }
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* u = (ast_UnaryOperator*)e;
      dep_finder_Finder_handleExpr(s, ast_UnaryOperator_getInner(u));
      break;
   }
   case ast_ExprKind_ConditionalOperator: {
      ast_ConditionalOperator* c = (ast_ConditionalOperator*)e;
      dep_finder_Finder_handleExpr(s, ast_ConditionalOperator_getCond(c));
      dep_finder_Finder_handleExpr(s, ast_ConditionalOperator_getLHS(c));
      dep_finder_Finder_handleExpr(s, ast_ConditionalOperator_getRHS(c));
      break;
   }
   case ast_ExprKind_Builtin: {
      ast_BuiltinExpr* b = (ast_BuiltinExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_BuiltinExpr_getInner(b));
      break;
   }
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = (ast_ArraySubscriptExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_ArraySubscriptExpr_getBase(a));
      dep_finder_Finder_handleExpr(s, ast_ArraySubscriptExpr_getIndex(a));
      break;
   }
   case ast_ExprKind_Member:
      dep_finder_Finder_handleMemberExpr(s, (ast_MemberExpr*)e);
      break;
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = (ast_ParenExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_ParenExpr_getInner(p));
      break;
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* c = (ast_ExplicitCastExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_ExplicitCastExpr_getInner(c));
      dep_finder_Finder_handleTypeRef(s, ast_ExplicitCastExpr_getTypeRef(c));
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* c = (ast_ImplicitCastExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_ImplicitCastExpr_getInner(c));
      break;
   }
   case ast_ExprKind_Range: {
      ast_RangeExpr* b = (ast_RangeExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_RangeExpr_getLHS(b));
      dep_finder_Finder_handleExpr(s, ast_RangeExpr_getRHS(b));
      break;
   }
   case ast_ExprKind_NamedArgument: {
      ast_NamedArgument* n = (ast_NamedArgument*)e;
      dep_finder_Finder_handleExpr(s, ast_NamedArgument_getInner(n));
      break;
   }
   case ast_ExprKind_Alternate: {
      ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      dep_finder_Finder_handleExpr(s, ast_AlternateExpr_getOriginal(n));
      break;
   }
   }
}

static void dep_finder_Finder_handleInitList(dep_finder_Finder* s, ast_InitListExpr* ile)
{
   uint32_t count = ast_InitListExpr_getNumValues(ile);
   ast_Expr** exprs = ast_InitListExpr_getValues(ile);
   for (uint32_t i = 0; i < count; i++) {
      dep_finder_Finder_handleExpr(s, exprs[i]);
   }
}

static void dep_finder_Finder_handleMemberExpr(dep_finder_Finder* s, ast_MemberExpr* m)
{
   ast_Decl* d = ast_MemberExpr_getFullDecl(m);
   if (ast_Decl_isEnumConstant(d)) {
      d = ast_MemberExpr_getBaseDecl(m);
      ;//assert(ast_Decl_isEnum(d));
   }
   dep_finder_Finder_onDep(s, d, true);
}

static void dep_finder_Finder_onDep(dep_finder_Finder* s, const ast_Decl* d, bool full)
{
   if (ast_Decl_getModule(d) != s->mod) return;
   if (ast_Decl_isGenerated(d)) return;
   if (d == s->current) return;
   s->on_decl(s->arg, (ast_Decl*)d);
}


// --- module attr_handler ---
typedef struct attr_handler_Entry_ attr_handler_Entry;
typedef struct attr_handler_Handler_ attr_handler_Handler;

struct attr_handler_Entry_ {
   uint32_t name;
   ast_AttrHandlerFn func;
   void* arg;
};

struct attr_handler_Handler_ {
   diagnostics_Diags* diags;
   const warning_flags_Flags* warnings;
   attr_handler_Entry* entries;
   uint32_t count;
   uint32_t capacity;
};

static attr_handler_Handler* attr_handler_create(diagnostics_Diags* diags, const warning_flags_Flags* warnings);
static void attr_handler_Handler_free(attr_handler_Handler* h);
static bool attr_handler_Handler_register(attr_handler_Handler* h, uint32_t name, ast_AttrHandlerFn func, void* arg);
static bool attr_handler_Handler_handle(attr_handler_Handler* h, ast_Decl* d, const attr_Attr* a);

static attr_handler_Handler* attr_handler_create(diagnostics_Diags* diags, const warning_flags_Flags* warnings)
{
   attr_handler_Handler* h = calloc(1, 32);
   h->diags = diags;
   h->warnings = warnings;
   return h;
}

static void attr_handler_Handler_free(attr_handler_Handler* h)
{
   if (h->entries) free(h->entries);
   free(h);
}

static bool attr_handler_Handler_register(attr_handler_Handler* h, uint32_t name, ast_AttrHandlerFn func, void* arg)
{
   if (h->count == h->capacity) {
      h->capacity += 2;
      attr_handler_Entry* entries2 = malloc(h->capacity * 24);
      if (h->count) {
         memcpy(entries2, h->entries, h->count * 24);
         free(h->entries);
      }
      h->entries = entries2;
   }
   attr_handler_Entry* e = &h->entries[h->count];
   e->name = name;
   e->func = func;
   e->arg = arg;
   h->count++;
   return true;
}

static bool attr_handler_Handler_handle(attr_handler_Handler* h, ast_Decl* d, const attr_Attr* a)
{
   for (uint32_t i = 0; i < h->count; i++) {
      attr_handler_Entry* e = &h->entries[i];
      if (e->name == a->name) return e->func(e->arg, d, a);
   }
   if (!h->warnings->no_unknown_attribute) {
      diagnostics_Diags_warn(h->diags, a->loc, "unknown attribute '%s'", ast_idx2name(a->name));
   }
   return false;
}


// --- module component ---
typedef struct component_Component_ component_Component;
typedef struct component_List_ component_List;

typedef uint8_t component_Kind;
enum component_Kind {
   component_Kind_Internal,
   component_Kind_Image,
   component_Kind_Executable,
   component_Kind_StaticLibrary,
   component_Kind_DynamicLibrary,
   component_Kind_SourceLibrary,
   component_Kind_ExternalStaticLib,
   component_Kind_ExternalDynamicLib,
   component_Kind_ExternalSourceLib,
};

struct component_Component_ {
   uint32_t name_idx;
   uint32_t dirname_idx;
   uint32_t linkname;
   component_Kind kind;
   bool is_foreign;
   bool available_static;
   bool available_dynamic;
   bool available_source;
   ast_context_Context* context;
   string_pool_Pool* auxPool;
   module_list_List mods;
   string_list_List deps;
   file_list_FileList files;
};

typedef void (*component_FileVisitor)(void* arg, const char* filename, uint32_t src_loc);

struct component_List_ {
   component_Component** components;
   uint32_t count;
   uint32_t capacity;
};

static const char* component_kind_names[9] = {
   "internal",
   "image",
   "executable",
   "static library",
   "dynamic library",
   "source library",
   "external static library",
   "external dynamic library",
   "external source library"
};
static component_Component* component_create(ast_context_Context* context, string_pool_Pool* auxPool, uint32_t name_idx, component_Kind kind);
static void component_Component_free(component_Component* c);
static const char* component_Component_getName(const component_Component* c);
static uint32_t component_Component_getNameIdx(const component_Component* c);
static void component_Component_setPath(component_Component* c, uint32_t dirname);
static const char* component_Component_getPath(const component_Component* c);
static void component_Component_setForeign(component_Component* c, bool is_foreign);
static bool component_Component_isForeign(const component_Component* c);
static void component_Component_setLinkName(component_Component* c, const char* name);
static const char* component_Component_getLinkName(const component_Component* c);
static bool component_Component_isExternal(const component_Component* c);
static bool component_Component_isInternal(const component_Component* c);
static bool component_Component_isSourceLib(const component_Component* c);
static bool component_Component_isExternalSourceLib(const component_Component* c);
static bool component_Component_hasSources(const component_Component* c);
static void component_Component_setKind(component_Component* c, bool is_static, bool is_dynamic, bool is_source);
static bool component_Component_isAvailableStatic(const component_Component* c);
static bool component_Component_isAvailableDynamic(const component_Component* c);
static bool component_Component_isAvailableSource(const component_Component* c);
static void component_Component_addFile(component_Component* c, uint32_t filename, src_loc_SrcLoc loc);
static void component_Component_visitFiles(const component_Component* c, void* arg, component_FileVisitor visitor);
static void component_Component_visitModules(const component_Component* c, module_list_Visitor visitor, void* arg);
static module_list_List* component_Component_getModules(component_Component* c);
static ast_Module* component_Component_getOrAddModule(component_Component* c, uint32_t name_idx, bool is_private);
static bool component_Component_hasModule(const component_Component* c, const ast_Module* mod);
static void component_Component_print(const component_Component* c, bool show_funcs);
static void component_Component_printModules(const component_Component* c);
static void component_Component_printSymbols(const component_Component* c, bool print_external);
static void component_Component_addDep(component_Component* c, uint32_t dep_idx);
static string_list_List* component_Component_getDeps(component_Component* c);
static bool component_Component_hasDep(const component_Component* c, uint32_t name_idx);
static void component_List_init(component_List* l);
static void component_List_free(component_List* l);
static void component_List_resize(component_List* l, uint32_t capacity);
static void component_List_add(component_List* l, component_Component* c);
static uint32_t component_List_size(const component_List* l);
static component_Component* component_List_get(const component_List* l, uint32_t idx);
static component_Component** component_List_get_all(component_List* l);
static component_Component* component_List_getLast(const component_List* l);
static bool component_Component_isLibrary(const component_Component* c);
static bool component_Component_isExternalLibrary(const component_Component* c);
static component_Kind component_Component_getKind(const component_Component* c);
static const char* component_Component_getKindName(const component_Component* c);
static component_Component* component_List_find(const component_List* l, uint32_t name_idx);

static component_Component* component_create(ast_context_Context* context, string_pool_Pool* auxPool, uint32_t name_idx, component_Kind kind)
{
   component_Component* c = calloc(1, 104);
   c->name_idx = name_idx;
   c->kind = kind;
   c->context = context;
   c->auxPool = auxPool;
   module_list_List_init(&c->mods, true, 4);
   string_list_List_init(&c->deps, auxPool);
   file_list_FileList_init(&c->files, 0);
   return c;
}

static void component_Component_free(component_Component* c)
{
   file_list_FileList_free(&c->files);
   module_list_List_free(&c->mods);
   string_list_List_free(&c->deps);
   free(c);
}

static const char* component_Component_getName(const component_Component* c)
{
   return string_pool_Pool_idx2str(c->auxPool, c->name_idx);
}

static uint32_t component_Component_getNameIdx(const component_Component* c)
{
   return c->name_idx;
}

static void component_Component_setPath(component_Component* c, uint32_t dirname)
{
   c->dirname_idx = dirname;
}

static const char* component_Component_getPath(const component_Component* c)
{
   return string_pool_Pool_idx2str(c->auxPool, c->dirname_idx);
}

static void component_Component_setForeign(component_Component* c, bool is_foreign)
{
   c->is_foreign = is_foreign;
}

static bool component_Component_isForeign(const component_Component* c)
{
   return c->is_foreign;
}

static void component_Component_setLinkName(component_Component* c, const char* name)
{
   c->linkname = string_pool_Pool_addStr(c->auxPool, name, false);
}

static const char* component_Component_getLinkName(const component_Component* c)
{
   if (c->linkname) return string_pool_Pool_idx2str(c->auxPool, c->linkname);
   return NULL;
}

static bool component_Component_isExternal(const component_Component* c)
{
   return c->kind >= component_Kind_ExternalStaticLib;
}

static bool component_Component_isInternal(const component_Component* c)
{
   return c->kind == component_Kind_Internal;
}

static bool component_Component_isSourceLib(const component_Component* c)
{
   return c->kind == component_Kind_SourceLibrary;
}

static bool component_Component_isExternalSourceLib(const component_Component* c)
{
   return c->kind == component_Kind_ExternalSourceLib;
}

static bool component_Component_hasSources(const component_Component* c)
{
   return c->kind != component_Kind_ExternalStaticLib && c->kind != component_Kind_ExternalDynamicLib;
}

static void component_Component_setKind(component_Component* c, bool is_static, bool is_dynamic, bool is_source)
{
   c->available_static = is_static;
   c->available_dynamic = is_dynamic;
   c->available_source = is_source;
}

static bool component_Component_isAvailableStatic(const component_Component* c)
{
   return c->available_static;
}

static bool component_Component_isAvailableDynamic(const component_Component* c)
{
   return c->available_dynamic;
}

static bool component_Component_isAvailableSource(const component_Component* c)
{
   return c->available_source;
}

static void component_Component_addFile(component_Component* c, uint32_t filename, src_loc_SrcLoc loc)
{
   file_list_FileList_add(&c->files, filename, loc);
}

static void component_Component_visitFiles(const component_Component* c, void* arg, component_FileVisitor visitor)
{
   uint32_t num_files = file_list_FileList_getCount(&c->files);
   for (uint32_t i = 0; i < num_files; i++) {
      const file_list_File* f = file_list_FileList_get(&c->files, i);
      visitor(arg, string_pool_Pool_idx2str(c->auxPool, f->name), f->loc);
   }
}

static void component_Component_visitModules(const component_Component* c, module_list_Visitor visitor, void* arg)
{
   module_list_List_visit(&c->mods, visitor, arg);
}

static module_list_List* component_Component_getModules(component_Component* c)
{
   return &c->mods;
}

static ast_Module* component_Component_getOrAddModule(component_Component* c, uint32_t name_idx, bool is_private)
{
   ast_Module* m = module_list_List_find(&c->mods, name_idx);
   if (!m) {
      m = ast_Module_create(c->context, name_idx, component_Component_isExternal(c));
      ast_Module_setPrivate(m, is_private);
      module_list_List_add(&c->mods, m);
   }
   return m;
}

static bool component_Component_hasModule(const component_Component* c, const ast_Module* mod)
{
   return module_list_List_contains(&c->mods, mod);
}

static void component_Component_print(const component_Component* c, bool show_funcs)
{
   string_buffer_Buf* out = string_buffer_create(128 * 1024, color_useColor(), 1);
   const ast_Module** mods = module_list_List_getConst(&c->mods);
   for (uint32_t i = 0; i < module_list_List_length(&c->mods); i++) {
      ast_Module_print(mods[i], out, show_funcs);
   }
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void component_Component_printModules(const component_Component* c)
{
   string_buffer_Buf* out = string_buffer_create(4096, color_useColor(), 1);
   string_buffer_Buf_print(out, "--- %s [%s]", component_Component_getName(c), component_kind_names[c->kind]);
   string_buffer_Buf_add(out, " ---\n");
   const ast_Module** mods = module_list_List_getConst(&c->mods);
   for (uint32_t i = 0; i < module_list_List_length(&c->mods); i++) {
      const ast_Module* m = mods[i];
      string_buffer_Buf_color(out, ast_Module_isUsed(m) ? color_Normal : color_Grey);
      string_buffer_Buf_print(out, "   %s", ast_Module_getName(m));
      if (ast_Module_isPrivate(m)) string_buffer_Buf_add(out, "  (private)");
      string_buffer_Buf_newline(out);
   }
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void component_Component_printSymbols(const component_Component* c, bool print_external)
{
   if (component_Component_isExternal(c) != print_external) return;
   string_buffer_Buf* out = string_buffer_create(4096, color_useColor(), 1);
   string_buffer_Buf_print(out, "--- %s [%s] ---\n", component_Component_getName(c), component_kind_names[c->kind]);
   const ast_Module** mods = module_list_List_getConst(&c->mods);
   for (uint32_t i = 0; i < module_list_List_length(&c->mods); i++) {
      string_buffer_Buf_color(out, color_Cyan);
      string_buffer_Buf_print(out, "  %s\n", ast_Module_getName(mods[i]));
      const ast_SymbolTable* table = ast_Module_getSymbols(mods[i]);
      ast_SymbolTable_print(table, out);
   }
   string_buffer_Buf_color(out, color_Normal);
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void component_Component_addDep(component_Component* c, uint32_t dep_idx)
{
   string_list_List_add(&c->deps, dep_idx);
}

static string_list_List* component_Component_getDeps(component_Component* c)
{
   return &c->deps;
}

static bool component_Component_hasDep(const component_Component* c, uint32_t name_idx)
{
   return string_list_List_contains_idx(&c->deps, name_idx);
}

static void component_List_init(component_List* l)
{
   l->components = NULL;
   l->count = 0;
   component_List_resize(l, 4);
}

static void component_List_free(component_List* l)
{
   for (uint32_t i = 0; i < l->count; i++) {
      component_Component_free(l->components[i]);
   }
   free(l->components);
}

static void component_List_resize(component_List* l, uint32_t capacity)
{
   l->capacity = capacity;
   component_Component** comps2 = malloc(l->capacity * 8);
   if (l->count) {
      memcpy(comps2, l->components, l->count * 8);
      free(l->components);
   }
   l->components = comps2;
}

static void component_List_add(component_List* l, component_Component* c)
{
   if (l->count == l->capacity) component_List_resize(l, l->capacity * 2);
   l->components[l->count] = c;
   l->count++;
}

static uint32_t component_List_size(const component_List* l)
{
   return l->count;
}

static component_Component* component_List_get(const component_List* l, uint32_t idx)
{
   return l->components[idx];
}

static component_Component** component_List_get_all(component_List* l)
{
   return l->components;
}

static component_Component* component_List_getLast(const component_List* l)
{
   if (l->count == 0) return NULL;
   return l->components[l->count - 1];
}

static bool component_Component_isLibrary(const component_Component* c)
{
   return c->kind == component_Kind_StaticLibrary || c->kind == component_Kind_DynamicLibrary;
}

static bool component_Component_isExternalLibrary(const component_Component* c)
{
   return c->kind == component_Kind_ExternalStaticLib || c->kind == component_Kind_ExternalDynamicLib;
}

static component_Kind component_Component_getKind(const component_Component* c)
{
   return c->kind;
}

static const char* component_Component_getKindName(const component_Component* c)
{
   return component_kind_names[c->kind];
}

static component_Component* component_List_find(const component_List* l, uint32_t name_idx)
{
   for (uint32_t i = 0; i < l->count; i++) {
      if (l->components[i]->name_idx == name_idx) return l->components[i];
   }
   return NULL;
}


// --- module ast_builder ---
typedef struct ast_builder_Builder_ ast_builder_Builder;

struct ast_builder_Builder_ {
   ast_context_Context* context;
   diagnostics_Diags* diags;
   string_pool_Pool* auxPool;
   component_Component* comp;
   ast_Module* mod;
   ast_AST* ast;
   uint32_t ast_idx;
   uint32_t c2_name;
   uint32_t main_name;
   bool is_interface;
   bool is_private;
   attr_Attr attrs[8];
   uint32_t num_attrs;
   attr_handler_Handler* attr_handler;
};

static ast_builder_Builder* ast_builder_create(ast_context_Context* context, diagnostics_Diags* diags, string_pool_Pool* auxPool, uint32_t c2_name, uint32_t main_name, attr_handler_Handler* attr_handler_);
static void ast_builder_Builder_free(ast_builder_Builder* b);
static void ast_builder_Builder_setComponent(ast_builder_Builder* b, component_Component* comp);
static void ast_builder_Builder_actOnModule(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t filename, bool is_interface, bool is_generated);
static void ast_builder_Builder_actOnImport(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, bool islocal);
static ast_Decl* ast_builder_Builder_actOnAliasType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref);
static ast_Decl* ast_builder_Builder_actOnFunctionTypeDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* rtype, ast_VarDecl** params, uint32_t num_params, bool is_variadic);
static ast_Decl* ast_builder_Builder_actOnFunctionType(ast_builder_Builder* b, const ast_TypeRefHolder* rtype, ast_VarDecl** params, uint32_t num_params, bool is_variadic, ast_DefKind def_kind);
static ast_StructTypeDecl* ast_builder_Builder_actOnStructType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, bool is_struct, bool is_global, ast_Decl** members, uint32_t num_members);
static ast_VarDecl* ast_builder_Builder_actOnStructMember(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, ast_Expr* bitfield);
static ast_FieldInitInfo* ast_builder_Builder_actOnFieldInitInfo(ast_builder_Builder* b, ast_StructTypeDecl* std);
static ast_Decl* ast_builder_Builder_actOnGlobalVarDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, bool has_embed, ast_Expr* initValue);
static ast_VarDecl* ast_builder_Builder_actOnFunctionParam(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue);
static ast_Stmt* ast_builder_Builder_actOnDeclStmt(ast_builder_Builder* b, ast_VarDecl** decl, uint32_t count);
static ast_VarDecl* ast_builder_Builder_actOnVarDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, const ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue, bool has_local, bool has_init_call);
static void ast_builder_Builder_storeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnArrayValue(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Expr* initValue);
static void ast_builder_Builder_actOnFunctionAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnStructAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static bool ast_builder_Builder_actOnTypeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_actOnVarAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static bool ast_builder_Builder_hasOpaqueAttr(ast_builder_Builder* b);
static bool ast_builder_Builder_hasEmbedAttr(ast_builder_Builder* b);
static bool ast_builder_Builder_actOnParamAttr(ast_builder_Builder* b, ast_VarDecl* d, const attr_Attr* a);
static bool ast_builder_Builder_actOnAttr(ast_builder_Builder* b, const attr_Attr* a);
static void ast_builder_Builder_clearAttributes(ast_builder_Builder* b);
static void ast_builder_Builder_applyAttribute(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a);
static void ast_builder_Builder_applyAttributes(ast_builder_Builder* b, ast_Decl* d, uint32_t count);
static ast_QualType ast_builder_Builder_actOnBuiltinType(ast_builder_Builder* _arg0, ast_BuiltinKind kind);
static ast_QualType ast_builder_Builder_actOnVoidType(ast_builder_Builder* _arg0);
static ast_QualType ast_builder_Builder_actOnPointerType(ast_builder_Builder* _arg0, ast_QualType inner);
static ast_QualType ast_builder_Builder_actOnArrayType(ast_builder_Builder* b, ast_QualType elem, bool has_size, uint32_t size, bool is_enum_index, ast_QualType index_type);
static ast_QualType ast_builder_Builder_actOnIncrementalArrayType(ast_builder_Builder* b, ast_QualType elem);
static ast_FunctionDecl* ast_builder_Builder_actOnFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, bool is_variadic);
static ast_FunctionDecl* ast_builder_Builder_actOnTemplateFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, bool is_variadic);
static void ast_builder_Builder_actOnFunctionBody(ast_builder_Builder* _arg0, ast_FunctionDecl* f, ast_CompoundStmt* body);
static ast_EnumConstantDecl* ast_builder_Builder_actOnEnumConstant(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, ast_Expr* init_expr);
static ast_Decl* ast_builder_Builder_actOnEnumType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, bool is_incr, ast_QualType implType, ast_EnumConstantDecl** constants, uint32_t num_constants);
static ast_Stmt* ast_builder_Builder_actOnAsmStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, bool is_basic, bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* asm_string);
static ast_CompoundStmt* ast_builder_Builder_actOnCompoundStmt(ast_builder_Builder* b, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count);
static ast_Stmt* ast_builder_Builder_actOnReturnStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* ret);
static ast_Stmt* ast_builder_Builder_actOnIfStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt);
static ast_Stmt* ast_builder_Builder_actOnWhileStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then);
static ast_Stmt* ast_builder_Builder_actOnForStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* incr, ast_Stmt* body);
static ast_Stmt* ast_builder_Builder_actOnSwitchStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_SwitchCase** cases, uint32_t num_cases, bool has_default);
static ast_SwitchCase* ast_builder_Builder_actOnCase(ast_builder_Builder* b, src_loc_SrcLoc loc, bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts);
static ast_Stmt* ast_builder_Builder_actOnAssertStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* inner);
static ast_Stmt* ast_builder_Builder_actOnBreakStmt(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Stmt* ast_builder_Builder_actOnContinueStmt(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Stmt* ast_builder_Builder_actOnFallthroughStmt(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Stmt* ast_builder_Builder_actOnLabelStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt);
static ast_Stmt* ast_builder_Builder_actOnGotoStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc);
static ast_Expr* ast_builder_Builder_actOnIdentifier(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t name, uint32_t name_len);
static ast_Expr* ast_builder_Builder_actOnIntegerLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint64_t value, number_radix_Radix radix, ast_BuiltinKind kind);
static ast_Expr* ast_builder_Builder_actOnFloatLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, double value, number_radix_Radix radix, ast_BuiltinKind kind);
static ast_Expr* ast_builder_Builder_actOnCharLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint8_t value, number_radix_Radix radix);
static ast_Expr* ast_builder_Builder_actOnStringLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len);
static ast_Expr* ast_builder_Builder_actOnNilExpr(ast_builder_Builder* b, src_loc_SrcLoc loc);
static ast_Expr* ast_builder_Builder_actOnParenExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner);
static ast_Expr* ast_builder_Builder_actOnUnaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_UnaryOpcode opcode, ast_Expr* inner);
static ast_Expr* ast_builder_Builder_actOnBinaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_BinaryOpcode opcode, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnConditionalOperator(ast_builder_Builder* b, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnBooleanConstant(ast_builder_Builder* b, src_loc_SrcLoc loc, bool value);
static ast_Expr* ast_builder_Builder_actOnBuiltinExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind);
static ast_Expr* ast_builder_Builder_actOnOffsetOfExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member);
static ast_Expr* ast_builder_Builder_actOnToContainerExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member, ast_Expr* pointer);
static ast_Expr* ast_builder_Builder_actOnTypeExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref);
static ast_Expr* ast_builder_Builder_actOnBitOffsetExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnArraySubscriptExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* base, ast_Expr* idx);
static ast_Expr* ast_builder_Builder_actOnCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args);
static ast_Expr* ast_builder_Builder_actOnTemplateCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, const ast_TypeRefHolder* ref);
static ast_Expr* ast_builder_Builder_actOnExplicitCast(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, bool c_style);
static ast_Expr* ast_builder_Builder_actOnMemberExpr(ast_builder_Builder* b, ast_Expr* base, uint32_t base_name_idx, uint32_t base_len, src_loc_SrcLoc loc, uint32_t member_name_idx);
static ast_Expr* ast_builder_Builder_actOnRange(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static ast_Expr* ast_builder_Builder_actOnInitList(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values);
static ast_Expr* ast_builder_Builder_actOnFieldDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue);
static ast_Expr* ast_builder_Builder_actOnArrayDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue);
static void ast_builder_Builder_actOnStaticAssert(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs);
static void ast_builder_Builder_insertImplicitCast(ast_builder_Builder* b, ast_ImplicitCastKind kind, ast_Expr** e_ptr, ast_QualType qt);
static void ast_builder_Builder_addSymbol(ast_builder_Builder* b, uint32_t name_idx, ast_Decl* d);
static ast_Expr* ast_builder_Builder_actOnNamedArgument(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t name, ast_Expr* inner);
static ast_Expr* ast_builder_Builder_actOnAlternate(ast_builder_Builder* b, ast_Expr* original, ast_Expr* generated);

static ast_builder_Builder* ast_builder_create(ast_context_Context* context, diagnostics_Diags* diags, string_pool_Pool* auxPool, uint32_t c2_name, uint32_t main_name, attr_handler_Handler* attr_handler_)
{
   ast_builder_Builder* b = calloc(1, 336);
   b->context = context;
   b->diags = diags;
   b->auxPool = auxPool;
   b->c2_name = c2_name;
   b->main_name = main_name;
   b->attr_handler = attr_handler_;
   return b;
}

static void ast_builder_Builder_free(ast_builder_Builder* b)
{
   free(b);
}

static void ast_builder_Builder_setComponent(ast_builder_Builder* b, component_Component* comp)
{
   b->comp = comp;
   b->mod = NULL;
   b->is_interface = !component_Component_hasSources(comp);
   b->is_private = component_Component_isExternalSourceLib(comp);
}

static void ast_builder_Builder_actOnModule(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t filename, bool is_interface, bool is_generated)
{
   ;//assert(b->comp);
   if (mod_name == b->c2_name && !is_interface) {
      diagnostics_Diags_error(b->diags, mod_loc, "module name 'c2' is reserved");
      exit(-1);
   }
   if (mod_name == b->main_name) {
      diagnostics_Diags_error(b->diags, mod_loc, "module name 'main' is reserved");
      exit(-1);
   }
   b->mod = component_Component_getOrAddModule(b->comp, mod_name, b->is_private);
   b->ast = ast_Module_add(b->mod, b->auxPool, filename, is_interface, is_generated);
   b->ast_idx = ast_AST_getIdx(b->ast);
   ast_ImportDecl* i = ast_ImportDecl_create(b->context, mod_name, mod_loc, 0, 0, b->ast_idx, true);
   ast_Decl* d = (ast_Decl*)i;
   ast_Decl_setUsed(d);
   ast_Decl_setChecked(d);
   ast_ImportDecl_setDest(i, b->mod);
   ast_Decl_setType(d, ast_QualType_create((ast_Type*)ast_Module_getType(b->mod)));
   ast_AST_addImport(b->ast, i);
}

static void ast_builder_Builder_actOnImport(ast_builder_Builder* b, uint32_t mod_name, src_loc_SrcLoc mod_loc, uint32_t alias_name, src_loc_SrcLoc alias_loc, bool islocal)
{
   if (ast_AST_getNameIdx(b->ast) == mod_name) {
      if (mod_loc) {
         diagnostics_Diags_error(b->diags, mod_loc, "cannot import own module '%s'", ast_idx2name(mod_name));
      }
      return;
   }
   ast_ImportDecl* old = ast_AST_findImport(b->ast, mod_name);
   if (old) {
      if (mod_loc) {
         diagnostics_Diags_error(b->diags, mod_loc, "duplicate import of module '%s'", ast_idx2name(mod_name));
         diagnostics_Diags_note(b->diags, ast_Decl_getLoc(ast_ImportDecl_asDecl(old)), "previous import is here");
      }
      return;
   }
   if (alias_name) {
      if (alias_name == mod_name) {
         diagnostics_Diags_error(b->diags, alias_loc, "alias name is same as module name");
         return;
      }
   }
   ast_ImportDecl* d = ast_ImportDecl_create(b->context, mod_name, mod_loc, alias_name, alias_loc, b->ast_idx, islocal);
   ast_AST_addImport(b->ast, d);
}

static ast_Decl* ast_builder_Builder_actOnAliasType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref)
{
   is_public |= b->is_interface;
   ast_AliasTypeDecl* d = ast_AliasTypeDecl_create(b->context, name, loc, is_public, b->ast_idx, ref);
   ast_AST_addTypeDecl(b->ast, ast_AliasTypeDecl_asDecl(d));
   ast_Decl* dd = (ast_Decl*)d;
   if (b->is_interface) ast_Decl_setExternal(dd);
   ast_builder_Builder_addSymbol(b, name, dd);
   return dd;
}

static ast_Decl* ast_builder_Builder_actOnFunctionTypeDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* rtype, ast_VarDecl** params, uint32_t num_params, bool is_variadic)
{
   is_public |= b->is_interface;
   ast_FunctionDecl* fd = ast_FunctionDecl_create(b->context, name, loc, is_public, b->ast_idx, rtype, NULL, params, num_params, is_variadic, ast_DefKind_Type);
   ast_FunctionTypeDecl* d = ast_FunctionTypeDecl_create(b->context, fd);
   ast_AST_addTypeDecl(b->ast, ast_FunctionTypeDecl_asDecl(d));
   ast_Decl* dd = (ast_Decl*)d;
   if (b->is_interface) {
      ast_Decl_setExternal(dd);
      ast_Decl_setExternal(ast_FunctionDecl_asDecl(fd));
   }
   ast_builder_Builder_addSymbol(b, name, dd);
   return dd;
}

static ast_Decl* ast_builder_Builder_actOnFunctionType(ast_builder_Builder* b, const ast_TypeRefHolder* rtype, ast_VarDecl** params, uint32_t num_params, bool is_variadic, ast_DefKind def_kind)
{
   ast_FunctionDecl* fd = ast_FunctionDecl_create(b->context, 0, 0, false, b->ast_idx, rtype, NULL, params, num_params, is_variadic, def_kind);
   return (ast_Decl*)fd;
}

static ast_StructTypeDecl* ast_builder_Builder_actOnStructType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, bool is_struct, bool is_global, ast_Decl** members, uint32_t num_members)
{
   is_public |= b->is_interface;
   ast_StructTypeDecl* d = ast_StructTypeDecl_create(b->context, name, loc, is_public, b->ast_idx, is_struct, is_global, members, num_members);
   if (is_global) {
      ast_AST_addTypeDecl(b->ast, ast_StructTypeDecl_asDecl(d));
      ast_builder_Builder_addSymbol(b, name, ast_StructTypeDecl_asDecl(d));
   }
   if (b->is_interface) ast_Decl_setExternal(ast_StructTypeDecl_asDecl(d));
   return d;
}

static ast_VarDecl* ast_builder_Builder_actOnStructMember(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, ast_Expr* bitfield)
{
   is_public |= b->is_interface;
   return ast_VarDecl_createStructMember(b->context, name, loc, is_public, ref, b->ast_idx, bitfield);
}

static ast_FieldInitInfo* ast_builder_Builder_actOnFieldInitInfo(ast_builder_Builder* b, ast_StructTypeDecl* std)
{
   return ast_StructTypeDecl_createFieldInfo(std, b->context);
}

static ast_Decl* ast_builder_Builder_actOnGlobalVarDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, bool has_embed, ast_Expr* initValue)
{
   is_public |= b->is_interface;
   ast_VarDecl* vd = ast_VarDecl_create(b->context, ast_VarDeclKind_GlobalVar, name, loc, is_public, ref, b->ast_idx, assignLoc, has_embed, initValue);
   ast_Decl* d = ast_VarDecl_asDecl(vd);
   ast_AST_addVarDecl(b->ast, d);
   ast_builder_Builder_addSymbol(b, name, d);
   if (b->is_interface) ast_Decl_setExternal(d);
   return d;
}

static ast_VarDecl* ast_builder_Builder_actOnFunctionParam(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue)
{
   is_public |= b->is_interface;
   return ast_VarDecl_create(b->context, ast_VarDeclKind_FunctionParam, name, loc, is_public, ref, b->ast_idx, assignLoc, false, initValue);
}

static ast_Stmt* ast_builder_Builder_actOnDeclStmt(ast_builder_Builder* b, ast_VarDecl** decl, uint32_t count)
{
   return (ast_Stmt*)ast_DeclStmt_create(b->context, decl, count);
}

static ast_VarDecl* ast_builder_Builder_actOnVarDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, const ast_TypeRefHolder* ref, src_loc_SrcLoc assignLoc, ast_Expr* initValue, bool has_local, bool has_init_call)
{
   ast_VarDecl* d = ast_VarDecl_create(b->context, ast_VarDeclKind_LocalVar, name, loc, false, ref, b->ast_idx, assignLoc, false, initValue);
   ast_VarDecl_setLocal(d, has_local);
   ast_VarDecl_setInitCall(d, has_init_call);
   return d;
}

static void ast_builder_Builder_storeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_Decl_setHasAttr(d);
   ast_AST_storeAttr(b->ast, d, a);
}

static void ast_builder_Builder_actOnArrayValue(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Expr* initValue)
{
   ast_ArrayValue* avd = ast_ArrayValue_create(b->context, name, loc, initValue);
   ast_AST_addArrayValue(b->ast, avd);
}

static void ast_builder_Builder_actOnFunctionAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Unused:
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_UnusedParams:
      ast_FunctionDecl_setAttrUnusedParams(fd);
      break;
   case attr_AttrKind_Section:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_NoReturn:
      ast_FunctionDecl_setAttrNoReturn(fd);
      break;
   case attr_AttrKind_Inline:
      ast_FunctionDecl_setAttrInline(fd);
      break;
   case attr_AttrKind_Weak:
      if (!ast_Decl_isPublic(d)) diagnostics_Diags_error(b->diags, a->loc, "weak declarations must be public");
      ast_FunctionDecl_setAttrWeak(fd);
      break;
   case attr_AttrKind_CName:
   case attr_AttrKind_CDef:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Constructor:
      ast_FunctionDecl_setAttrConstructor(fd);
      break;
   case attr_AttrKind_Destructor:
      ast_FunctionDecl_setAttrDestructor(fd);
      break;
   case attr_AttrKind_Pure:
      ast_FunctionDecl_setAttrPure(fd);
      break;
   case attr_AttrKind_Deprecated:
      ast_FunctionDecl_setAttrDeprecated(fd);
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to functions", attr_Attr_kind2name(a));
      break;
   }
}

static void ast_builder_Builder_actOnStructAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Packed:
      ast_StructTypeDecl_setPacked(std);
      break;
   case attr_AttrKind_Unused:
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_Section:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' cannot be applied to type declarations", attr_Attr_kind2name(a));
      break;
   case attr_AttrKind_Aligned:
      ast_StructTypeDecl_setAttrAlignment(std, a->value.number);
      break;
   case attr_AttrKind_Opaque:
      if (!ast_Decl_isPublic(d)) {
         diagnostics_Diags_error(b->diags, a->loc, "opaque declaration must be public");
      }
      ast_StructTypeDecl_setOpaque(std);
      break;
   case attr_AttrKind_CName:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_NoTypeDef:
      if (b->is_interface) {
         ast_StructTypeDecl_setAttrNoTypeDef(std);
      } else {
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be used in interfaces", attr_Attr_kind2name(a));
      }
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to structs", attr_Attr_kind2name(a));
      break;
   }
}

static bool ast_builder_Builder_actOnTypeAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Packed:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be applied to struct/union types", attr_Attr_kind2name(a));
      return false;
   case attr_AttrKind_Unused:
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_Opaque:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be applied to struct/union types", attr_Attr_kind2name(a));
      return false;
   case attr_AttrKind_CName:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to Enum/Alias types", attr_Attr_kind2name(a));
      return false;
   }
   return true;
}

static void ast_builder_Builder_actOnVarAttr(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_VarDecl* vd = (ast_VarDecl*)d;
   if (ast_VarDecl_getKind(vd) == ast_VarDeclKind_FunctionParam) {
      ast_builder_Builder_actOnParamAttr(b, vd, a);
      return;
   }
   switch (a->kind) {
   case attr_AttrKind_Export:
      ast_Decl_setAttrExport(d);
      break;
   case attr_AttrKind_Unused:
      ast_Decl_setAttrUnused(d);
      break;
   case attr_AttrKind_Section:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Aligned:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Weak:
      if (!ast_Decl_isPublic(d)) diagnostics_Diags_error(b->diags, a->loc, "weak declarations must be public");
      ast_VarDecl_setAttrWeak(vd);
      break;
   case attr_AttrKind_CName:
   case attr_AttrKind_CDef:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   case attr_AttrKind_Embed:
      ast_builder_Builder_storeAttr(b, d, a);
      break;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' is not applicable to variables", attr_Attr_kind2name(a));
      break;
   }
}

static bool ast_builder_Builder_hasOpaqueAttr(ast_builder_Builder* b)
{
   for (uint32_t i = 0; i < b->num_attrs; i++) {
      const attr_Attr* a = &b->attrs[i];
      if (b->attrs[i].kind == attr_AttrKind_Opaque) return true;
   }
   return false;
}

static bool ast_builder_Builder_hasEmbedAttr(ast_builder_Builder* b)
{
   for (uint32_t i = 0; i < b->num_attrs; i++) {
      const attr_Attr* a = &b->attrs[i];
      if (b->attrs[i].kind == attr_AttrKind_Embed) return true;
   }
   return false;
}

static bool ast_builder_Builder_actOnParamAttr(ast_builder_Builder* b, ast_VarDecl* d, const attr_Attr* a)
{
   switch (a->kind) {
   case attr_AttrKind_PrintfFormat:
      ast_VarDecl_setFormatAttr(d, ast_FormatAttr_Printf);
      return true;
   case attr_AttrKind_ScanfFormat:
      ast_VarDecl_setFormatAttr(d, ast_FormatAttr_Scanf);
      return true;
   case attr_AttrKind_AutoFile:
      if (ast_VarDecl_hasAutoAttr(d)) break;
      ast_VarDecl_setAttrAutoFile(d);
      return true;
   case attr_AttrKind_AutoLine:
      if (ast_VarDecl_hasAutoAttr(d)) break;
      ast_VarDecl_setAttrAutoLine(d);
      return true;
   case attr_AttrKind_AutoFunc:
      if (ast_VarDecl_hasAutoAttr(d)) break;
      ast_VarDecl_setAttrAutoFunc(d);
      return true;
   default:
      diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' cannot be applied to function parameters", ast_idx2name(a->name));
      return false;
   }
   diagnostics_Diags_error(b->diags, a->loc, "invalid combination of attributes");
   return false;
}

static bool ast_builder_Builder_actOnAttr(ast_builder_Builder* b, const attr_Attr* a)
{
   switch (a->kind) {
   case attr_AttrKind_CName:
   case attr_AttrKind_CDef:
      if (!b->is_interface) {
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' can only be used in interface files", attr_Attr_kind2name(a));
         return false;
      }
      break;
   default:
      break;
   }
   if (a->kind != attr_AttrKind_Unknown) {
      switch (attr_Attr_checkArgument(a)) {
      case attr_AttrReq_NoArg:
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' has no argument", attr_Attr_kind2name(a));
         return false;
      case attr_AttrReq_Arg:
         diagnostics_Diags_error(b->diags, a->loc, "attribute '%s' needs an argument", attr_Attr_kind2name(a));
         return false;
      case attr_AttrReq_Number:
         diagnostics_Diags_error(b->diags, a->value.loc, "attribute '%s' needs a number argument", attr_Attr_kind2name(a));
         return false;
      case attr_AttrReq_String:
         diagnostics_Diags_error(b->diags, a->value.loc, "attribute '%s' needs a string argument", attr_Attr_kind2name(a));
         return false;
      case attr_AttrReq_Power2:
         diagnostics_Diags_error(b->diags, a->value.loc, "requested alignment is not a power of 2");
         return false;
      case attr_AttrReq_Ok:
         break;
      }
   }
   if (b->num_attrs == 8) {
      diagnostics_Diags_error(b->diags, a->loc, "too many attributes");
      return false;
   }
   b->attrs[b->num_attrs] = *a;
   b->num_attrs++;
   return true;
}

static void ast_builder_Builder_clearAttributes(ast_builder_Builder* b)
{
   b->num_attrs = 0;
}

static void ast_builder_Builder_applyAttribute(ast_builder_Builder* b, ast_Decl* d, const attr_Attr* a)
{
   ast_DeclKind dk = ast_Decl_getKind(d);
   switch (dk) {
   case ast_DeclKind_Function:
      ast_builder_Builder_actOnFunctionAttr(b, d, a);
      break;
   case ast_DeclKind_StructType:
      ast_builder_Builder_actOnStructAttr(b, d, a);
      break;
   case ast_DeclKind_EnumType:
      ast_builder_Builder_actOnTypeAttr(b, d, a);
      break;
   case ast_DeclKind_FunctionType: {
      if (!ast_builder_Builder_actOnTypeAttr(b, d, a)) return;
      ast_FunctionTypeDecl* ftd = (ast_FunctionTypeDecl*)d;
      ast_builder_Builder_applyAttribute(b, (ast_Decl*)ast_FunctionTypeDecl_getDecl(ftd), a);
      break;
   }
   case ast_DeclKind_AliasType:
      ast_builder_Builder_actOnTypeAttr(b, d, a);
      break;
   case ast_DeclKind_Variable:
      ast_builder_Builder_actOnVarAttr(b, d, a);
      break;
   default:
      ;//assert(0);
      return;
   }
}

static void ast_builder_Builder_applyAttributes(ast_builder_Builder* b, ast_Decl* d, uint32_t count)
{
   ;//assert(d);
   ;//assert(count <= b->num_attrs);
   for (uint32_t i = 0; i < count; i++) {
      const attr_Attr* a = &b->attrs[b->num_attrs - count + i];
      if (a->kind == attr_AttrKind_Unknown) {
         if (!attr_handler_Handler_handle(b->attr_handler, d, a)) ast_builder_Builder_storeAttr(b, d, a);
      } else {
         ast_builder_Builder_applyAttribute(b, d, a);
      }
   }
   b->num_attrs -= count;
}

static ast_QualType ast_builder_Builder_actOnBuiltinType(ast_builder_Builder* _arg0, ast_BuiltinKind kind)
{
   return ast_getBuiltinQT(kind);
}

static ast_QualType ast_builder_Builder_actOnVoidType(ast_builder_Builder* _arg0)
{
   return ast_getVoidQT();
}

static ast_QualType ast_builder_Builder_actOnPointerType(ast_builder_Builder* _arg0, ast_QualType inner)
{
   ast_QualType ptr = ast_QualType_create(ast_getPointerType(inner));
   ast_QualType canon = ast_QualType_getCanonicalType(inner);
   if (ast_QualType_getTypeOrNil(inner) == ast_QualType_getTypeOrNil(canon)) {
      canon = ptr;
   } else {
      canon = ast_QualType_create(ast_getPointerType(canon));
      ast_QualType_setCanonicalType(&canon, canon);
   }
   ast_QualType_setCanonicalType(&ptr, canon);
   return ptr;
}

static ast_QualType ast_builder_Builder_actOnArrayType(ast_builder_Builder* b, ast_QualType elem, bool has_size, uint32_t size, bool is_enum_index, ast_QualType index_type)
{
   ast_ArrayType* t = ast_ArrayType_create(b->context, elem, has_size, size, is_enum_index, index_type);
   ast_QualType a = ast_QualType_create((ast_Type*)t);
   ast_QualType canon = ast_QualType_getCanonicalType(elem);
   if (ast_QualType_getTypeOrNil(elem) == ast_QualType_getTypeOrNil(canon)) {
      canon = a;
   } else {
      ast_ArrayType* t2 = ast_ArrayType_create(b->context, canon, has_size, size, is_enum_index, index_type);
      canon = ast_QualType_create((ast_Type*)t2);
   }
   ast_QualType_setCanonicalType(&a, canon);
   return a;
}

static ast_QualType ast_builder_Builder_actOnIncrementalArrayType(ast_builder_Builder* b, ast_QualType elem)
{
   ast_ArrayType* t = ast_ArrayType_createIncremental(b->context, elem);
   ast_QualType a = ast_QualType_create((ast_Type*)t);
   ast_QualType canon = ast_QualType_getCanonicalType(elem);
   if (ast_QualType_getTypeOrNil(elem) == ast_QualType_getTypeOrNil(canon)) {
      canon = a;
   } else {
      ast_ArrayType* t2 = ast_ArrayType_createIncremental(b->context, canon);
      canon = ast_QualType_create((ast_Type*)t2);
   }
   ast_QualType_setCanonicalType(&a, canon);
   return a;
}

static ast_FunctionDecl* ast_builder_Builder_actOnFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* rtype, const ast_Ref* prefix, ast_VarDecl** params, uint32_t num_params, bool is_variadic)
{
   is_public |= b->is_interface;
   ast_FunctionDecl* f = ast_FunctionDecl_create(b->context, name, loc, is_public, b->ast_idx, rtype, prefix, params, num_params, is_variadic, ast_DefKind_Global);
   ast_AST_addFunc(b->ast, f);
   if (!prefix) ast_builder_Builder_addSymbol(b, name, ast_FunctionDecl_asDecl(f));
   if (b->is_interface) ast_Decl_setExternal(ast_FunctionDecl_asDecl(f));
   return f;
}

static ast_FunctionDecl* ast_builder_Builder_actOnTemplateFunctionDecl(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, const ast_TypeRefHolder* rtype, uint32_t template_name, src_loc_SrcLoc template_loc, ast_VarDecl** params, uint32_t num_params, bool is_variadic)
{
   if (b->is_interface) diagnostics_Diags_error(b->diags, loc, "template functions are not allow in interfaces");
   is_public |= b->is_interface;
   ast_FunctionDecl* f = ast_FunctionDecl_createTemplate(b->context, name, loc, is_public, b->ast_idx, rtype, template_name, template_loc, params, num_params, is_variadic);
   ast_AST_addFunc(b->ast, f);
   ast_builder_Builder_addSymbol(b, name, ast_FunctionDecl_asDecl(f));
   if (b->is_interface) ast_Decl_setExternal(ast_FunctionDecl_asDecl(f));
   return f;
}

static void ast_builder_Builder_actOnFunctionBody(ast_builder_Builder* _arg0, ast_FunctionDecl* f, ast_CompoundStmt* body)
{
   ast_FunctionDecl_setBody(f, body);
}

static ast_EnumConstantDecl* ast_builder_Builder_actOnEnumConstant(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, ast_Expr* init_expr)
{
   return ast_EnumConstantDecl_create(b->context, name, loc, is_public, b->ast_idx, init_expr);
}

static ast_Decl* ast_builder_Builder_actOnEnumType(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, bool is_public, bool is_incr, ast_QualType implType, ast_EnumConstantDecl** constants, uint32_t num_constants)
{
   is_public |= b->is_interface;
   ast_EnumTypeDecl* d = ast_EnumTypeDecl_create(b->context, name, loc, is_public, b->ast_idx, implType, is_incr, constants, num_constants);
   ast_AST_addTypeDecl(b->ast, ast_EnumTypeDecl_asDecl(d));
   ast_builder_Builder_addSymbol(b, name, ast_EnumTypeDecl_asDecl(d));
   return (ast_Decl*)d;
}

static ast_Stmt* ast_builder_Builder_actOnAsmStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, bool is_basic, bool is_volatile, uint32_t num_outputs, uint32_t num_inputs, const uint32_t* names, ast_ExprList* constraints, ast_ExprList* exprs, ast_ExprList* clobbers, ast_Expr* asm_string)
{
   return (ast_Stmt*)ast_AsmStmt_create(b->context, loc, is_basic, is_volatile, num_outputs, num_inputs, names, constraints, exprs, clobbers, asm_string);
}

static ast_CompoundStmt* ast_builder_Builder_actOnCompoundStmt(ast_builder_Builder* b, src_loc_SrcLoc endLoc, ast_Stmt** stmts, uint32_t count)
{
   return ast_CompoundStmt_create(b->context, endLoc, stmts, count);
}

static ast_Stmt* ast_builder_Builder_actOnReturnStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* ret)
{
   return (ast_Stmt*)ast_ReturnStmt_create(b->context, loc, ret);
}

static ast_Stmt* ast_builder_Builder_actOnIfStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then, ast_Stmt* else_stmt)
{
   return (ast_Stmt*)ast_IfStmt_create(b->context, loc, cond, then, else_stmt);
}

static ast_Stmt* ast_builder_Builder_actOnWhileStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_Stmt* then)
{
   return (ast_Stmt*)ast_WhileStmt_create(b->context, loc, cond, then);
}

static ast_Stmt* ast_builder_Builder_actOnForStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* init, ast_Expr* cond, ast_Expr* incr, ast_Stmt* body)
{
   return (ast_Stmt*)ast_ForStmt_create(b->context, loc, init, cond, incr, body);
}

static ast_Stmt* ast_builder_Builder_actOnSwitchStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Stmt* cond, ast_SwitchCase** cases, uint32_t num_cases, bool has_default)
{
   return (ast_Stmt*)ast_SwitchStmt_create(b->context, loc, cond, cases, num_cases, has_default);
}

static ast_SwitchCase* ast_builder_Builder_actOnCase(ast_builder_Builder* b, src_loc_SrcLoc loc, bool is_default, ast_Expr** conds, uint32_t num_conds, ast_Stmt** stmts, uint32_t num_stmts)
{
   return ast_SwitchCase_create(b->context, loc, is_default, conds, num_conds, stmts, num_stmts);
}

static ast_Stmt* ast_builder_Builder_actOnAssertStmt(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* inner)
{
   return (ast_Stmt*)ast_AssertStmt_create(b->context, loc, inner);
}

static ast_Stmt* ast_builder_Builder_actOnBreakStmt(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return (ast_Stmt*)ast_BreakStmt_create(b->context, loc);
}

static ast_Stmt* ast_builder_Builder_actOnContinueStmt(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return (ast_Stmt*)ast_ContinueStmt_create(b->context, loc);
}

static ast_Stmt* ast_builder_Builder_actOnFallthroughStmt(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return (ast_Stmt*)ast_FallthroughStmt_create(b->context, loc);
}

static ast_Stmt* ast_builder_Builder_actOnLabelStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc, ast_Stmt* stmt)
{
   return (ast_Stmt*)ast_LabelStmt_create(b->context, name, loc, stmt);
}

static ast_Stmt* ast_builder_Builder_actOnGotoStmt(ast_builder_Builder* b, uint32_t name, src_loc_SrcLoc loc)
{
   return (ast_Stmt*)ast_GotoStmt_create(b->context, name, loc);
}

static ast_Expr* ast_builder_Builder_actOnIdentifier(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t name, uint32_t name_len)
{
   return (ast_Expr*)ast_IdentifierExpr_create(b->context, loc, name, name_len);
}

static ast_Expr* ast_builder_Builder_actOnIntegerLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint64_t value, number_radix_Radix radix, ast_BuiltinKind kind)
{
   return (ast_Expr*)ast_IntegerLiteral_create(b->context, loc, src_len, value, radix, kind);
}

static ast_Expr* ast_builder_Builder_actOnFloatLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, double value, number_radix_Radix radix, ast_BuiltinKind kind)
{
   return (ast_Expr*)ast_FloatLiteral_create(b->context, loc, src_len, value, radix, kind);
}

static ast_Expr* ast_builder_Builder_actOnCharLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint8_t value, number_radix_Radix radix)
{
   return (ast_Expr*)ast_CharLiteral_create(b->context, loc, src_len, value, radix);
}

static ast_Expr* ast_builder_Builder_actOnStringLiteral(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, uint32_t value, uint32_t len)
{
   return (ast_Expr*)ast_StringLiteral_create(b->context, loc, src_len, value, len);
}

static ast_Expr* ast_builder_Builder_actOnNilExpr(ast_builder_Builder* b, src_loc_SrcLoc loc)
{
   return (ast_Expr*)ast_NilExpr_create(b->context, loc);
}

static ast_Expr* ast_builder_Builder_actOnParenExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner)
{
   return (ast_Expr*)ast_ParenExpr_create(b->context, loc, src_len, inner);
}

static ast_Expr* ast_builder_Builder_actOnUnaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_UnaryOpcode opcode, ast_Expr* inner)
{
   return (ast_Expr*)ast_UnaryOperator_create(b->context, loc, opcode, inner);
}

static ast_Expr* ast_builder_Builder_actOnBinaryOperator(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_BinaryOpcode opcode, ast_Expr* lhs, ast_Expr* rhs)
{
   return (ast_Expr*)ast_BinaryOperator_create(b->context, loc, opcode, lhs, rhs);
}

static ast_Expr* ast_builder_Builder_actOnConditionalOperator(ast_builder_Builder* b, src_loc_SrcLoc questionLoc, src_loc_SrcLoc colonLoc, ast_Expr* cond, ast_Expr* lhs, ast_Expr* rhs)
{
   return (ast_Expr*)ast_ConditionalOperator_create(b->context, questionLoc, colonLoc, cond, lhs, rhs);
}

static ast_Expr* ast_builder_Builder_actOnBooleanConstant(ast_builder_Builder* b, src_loc_SrcLoc loc, bool value)
{
   return (ast_Expr*)ast_BooleanLiteral_create(b->context, loc, value);
}

static ast_Expr* ast_builder_Builder_actOnBuiltinExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* inner, ast_BuiltinExprKind kind)
{
   return (ast_Expr*)ast_BuiltinExpr_create(b->context, loc, src_len, inner, kind);
}

static ast_Expr* ast_builder_Builder_actOnOffsetOfExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member)
{
   return (ast_Expr*)ast_BuiltinExpr_createOffsetOf(b->context, loc, src_len, structExpr, member);
}

static ast_Expr* ast_builder_Builder_actOnToContainerExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* structExpr, ast_Expr* member, ast_Expr* pointer)
{
   return (ast_Expr*)ast_BuiltinExpr_createToContainer(b->context, loc, src_len, structExpr, member, pointer);
}

static ast_Expr* ast_builder_Builder_actOnTypeExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref)
{
   return (ast_Expr*)ast_TypeExpr_create(b->context, loc, src_len, ref);
}

static ast_Expr* ast_builder_Builder_actOnBitOffsetExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   return (ast_Expr*)ast_BitOffsetExpr_create(b->context, loc, lhs, rhs);
}

static ast_Expr* ast_builder_Builder_actOnArraySubscriptExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, ast_Expr* base, ast_Expr* idx)
{
   return (ast_Expr*)ast_ArraySubscriptExpr_create(b->context, loc, src_len, base, idx);
}

static ast_Expr* ast_builder_Builder_actOnCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args)
{
   return (ast_Expr*)ast_CallExpr_create(b->context, loc, endLoc, func, args, num_args);
}

static ast_Expr* ast_builder_Builder_actOnTemplateCallExpr(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr* func, ast_Expr** args, uint32_t num_args, const ast_TypeRefHolder* ref)
{
   return (ast_Expr*)ast_CallExpr_createTemplate(b->context, loc, endLoc, func, args, num_args, b->ast_idx, ref);
}

static ast_Expr* ast_builder_Builder_actOnExplicitCast(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t src_len, const ast_TypeRefHolder* ref, ast_Expr* inner, bool c_style)
{
   return (ast_Expr*)ast_ExplicitCastExpr_create(b->context, loc, src_len, ref, inner, c_style);
}

static ast_Expr* ast_builder_Builder_actOnMemberExpr(ast_builder_Builder* b, ast_Expr* base, uint32_t base_name_idx, uint32_t base_len, src_loc_SrcLoc loc, uint32_t member_name_idx)
{
   return (ast_Expr*)ast_MemberExpr_create(b->context, base, base_name_idx, base_len, loc, member_name_idx);
}

static ast_Expr* ast_builder_Builder_actOnRange(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   return (ast_Expr*)ast_RangeExpr_create(b->context, loc, lhs, rhs);
}

static ast_Expr* ast_builder_Builder_actOnInitList(ast_builder_Builder* b, src_loc_SrcLoc loc, src_loc_SrcLoc endLoc, ast_Expr** values, uint32_t num_values)
{
   return (ast_Expr*)ast_InitListExpr_create(b->context, loc, endLoc, values, num_values);
}

static ast_Expr* ast_builder_Builder_actOnFieldDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t field, ast_Expr* initValue)
{
   return (ast_Expr*)ast_FieldDesignatedInitExpr_create(b->context, loc, field, initValue);
}

static ast_Expr* ast_builder_Builder_actOnArrayDesignatedInit(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* designator, ast_Expr* initValue)
{
   return (ast_Expr*)ast_ArrayDesignatedInitExpr_create(b->context, loc, designator, initValue);
}

static void ast_builder_Builder_actOnStaticAssert(ast_builder_Builder* b, src_loc_SrcLoc loc, ast_Expr* lhs, ast_Expr* rhs)
{
   ast_StaticAssert* d = ast_StaticAssert_create(b->context, b->ast_idx, loc, lhs, rhs);
   ast_AST_addStaticAssert(b->ast, d);
}

static void ast_builder_Builder_insertImplicitCast(ast_builder_Builder* b, ast_ImplicitCastKind kind, ast_Expr** e_ptr, ast_QualType qt)
{
   ast_Expr* inner = *e_ptr;
   ast_Expr* ic = (ast_Expr*)ast_ImplicitCastExpr_create(b->context, ast_Expr_getLoc(inner), kind, inner);
   ast_Expr_setType(ic, qt);
   *e_ptr = ic;
}

static void ast_builder_Builder_addSymbol(ast_builder_Builder* b, uint32_t name_idx, ast_Decl* d)
{
   ast_Decl* old = ast_Module_findSymbol(b->mod, name_idx);
   if (old) {
      diagnostics_Diags_error(b->diags, ast_Decl_getLoc(d), "redefinition of '%s'", ast_idx2name(name_idx));
      diagnostics_Diags_note(b->diags, ast_Decl_getLoc(old), "previous definition is here");
   } else {
      ast_Module_addSymbol(b->mod, name_idx, d);
   }
}

static ast_Expr* ast_builder_Builder_actOnNamedArgument(ast_builder_Builder* b, src_loc_SrcLoc loc, uint32_t name, ast_Expr* inner)
{
   return (ast_Expr*)ast_NamedArgument_create(b->context, loc, name, inner);
}

static ast_Expr* ast_builder_Builder_actOnAlternate(ast_builder_Builder* b, ast_Expr* original, ast_Expr* generated)
{
   return (ast_Expr*)ast_AlternateExpr_create(b->context, original, generated);
}


// --- module component_sorter ---

static uint32_t component_sorter_find_idx(component_Component** comps, uint32_t count, uint32_t name);
static void component_sorter_sort(component_Component** orig, uint32_t count, diagnostics_Diags* diags);

static uint32_t component_sorter_find_idx(component_Component** comps, uint32_t count, uint32_t name)
{
   for (uint32_t i = 0; i < count; i++) {
      if (component_Component_getNameIdx(comps[i]) == name) return i;
   }
   ;//assert(0);
   return 0;
}

static void component_sorter_sort(component_Component** orig, uint32_t count, diagnostics_Diags* diags)
{
   if (count <= 1) return;
   dsm_sorter_Sorter dsm; dsm_sorter_Sorter_init(&dsm, count);
   for (uint32_t i = 0; i < count; i++) {
      component_Component* c = orig[i];
      const string_list_List* deps = component_Component_getDeps(c);
      for (uint32_t j = 0; j < string_list_List_length(deps); j++) {
         uint32_t dest_name = string_list_List_get_idx(deps, j);
         uint32_t dest_idx = component_sorter_find_idx(orig, count, dest_name);
         dsm_sorter_Sorter_add_dep(&dsm, i, dest_idx);
      }
   }
   const uint8_t* sorted = dsm_sorter_Sorter_sort(&dsm);
   if (!sorted) {
      diagnostics_Diags_error(diags, 0, "circular dependency between libraries");
      exit(-1);
   }
   component_Component** copy = malloc(count * 8);
   memcpy(copy, orig, count * 8);
   for (uint32_t i = 0; i < count; i++) orig[i] = copy[sorted[i]];
   free(copy);
   dsm_sorter_Sorter_free(&dsm);
}


// --- module manifest_writer ---

static const char* manifest_writer_getKindStr(const component_Component* c);
static void manifest_writer_on_module(void* arg, ast_Module* m);
static void manifest_writer_on_file(void* arg, const char* filename, uint32_t src_loc);
static void manifest_writer_write(const char* dir, component_Component* c, const char* filename);

static const char* manifest_writer_getKindStr(const component_Component* c)
{
   switch (component_Component_getKind(c)) {
   case component_Kind_Internal:
   case component_Kind_Image:
      ;//assert(0);
      break;
   case component_Kind_Executable:
      ;//assert(0);
      break;
   case component_Kind_StaticLibrary:
      return "static";
   case component_Kind_DynamicLibrary:
      return "dynamic";
   case component_Kind_SourceLibrary:
      return "source";
   case component_Kind_ExternalStaticLib:
   case component_Kind_ExternalDynamicLib:
   case component_Kind_ExternalSourceLib:
      ;//assert(0);
      break;
   }
   return "";
}

static void manifest_writer_on_module(void* arg, ast_Module* m)
{
   if (!ast_Module_isExported(m)) return;
   string_buffer_Buf* out = arg;
   string_buffer_Buf_print(out, "    - %s\n", ast_Module_getName(m));
}

static void manifest_writer_on_file(void* arg, const char* filename, uint32_t src_loc)
{
   string_buffer_Buf* out = arg;
   string_buffer_Buf_print(out, "   - %s\n", filename);
}

static void manifest_writer_write(const char* dir, component_Component* c, const char* filename)
{
   string_buffer_Buf* out = string_buffer_create(4096, false, 2);
   string_buffer_Buf_print(out, "# Generated by C2C\n\ninfo:\n    language: C2\n    type: library\n    linkname: %s\n    kinds:\n        - %s\n\n", component_Component_getName(c), manifest_writer_getKindStr(c));
   const string_list_List* deps = component_Component_getDeps(c);
   if (string_list_List_length(deps)) {
      string_buffer_Buf_print(out, "dependencies:\n");
      for (uint32_t i = 0; i < string_list_List_length(deps); i++) {
         const char* depname = string_list_List_get(deps, i);
         if (strcmp(depname, "c2") == 0) continue;
         string_buffer_Buf_print(out, "    %s: dynamic\n", string_list_List_get(deps, i));
      }
      string_buffer_Buf_newline(out);
   }
   string_buffer_Buf_add(out, "modules:\n");
   component_Component_visitModules(c, manifest_writer_on_module, out);
   string_buffer_Buf_newline(out);
   if (component_Component_isSourceLib(c)) {
      string_buffer_Buf_add(out, "files:\n");
      component_Component_visitFiles(c, out, manifest_writer_on_file);
      string_buffer_Buf_newline(out);
   }
   file_utils_File file; file_utils_File_init(&file, dir, filename);
   if (!file_utils_File_write(&file, string_buffer_Buf_data(out), string_buffer_Buf_size(out))) {
      console_error("cannot write to %s: %s", file.path, file_utils_File_getError(&file));
      exit(stdlib_EXIT_FAILURE);
   }
   string_buffer_Buf_free(out);
}


// --- module c2_tokenizer ---
typedef struct c2_tokenizer_Feature_ c2_tokenizer_Feature;
typedef struct c2_tokenizer_Tokenizer_ c2_tokenizer_Tokenizer;
typedef struct c2_tokenizer_Operand_ c2_tokenizer_Operand;

typedef uint8_t c2_tokenizer_Action;
enum c2_tokenizer_Action {
   c2_tokenizer_Action_INVALID = 0,
   c2_tokenizer_Action_TABSPACE,
   c2_tokenizer_Action_IDENT,
   c2_tokenizer_Action_DIGIT,
   c2_tokenizer_Action_LPAREN,
   c2_tokenizer_Action_RPAREN,
   c2_tokenizer_Action_LSQUARE,
   c2_tokenizer_Action_RSQUARE,
   c2_tokenizer_Action_NEWLINE,
   c2_tokenizer_Action_EXCLAIM,
   c2_tokenizer_Action_BQUOTE,
   c2_tokenizer_Action_DQUOTE,
   c2_tokenizer_Action_SQUOTE,
   c2_tokenizer_Action_POUND,
   c2_tokenizer_Action_STAR,
   c2_tokenizer_Action_PLUS,
   c2_tokenizer_Action_MINUS,
   c2_tokenizer_Action_COMMA,
   c2_tokenizer_Action_DOT,
   c2_tokenizer_Action_PERCENT,
   c2_tokenizer_Action_SLASH,
   c2_tokenizer_Action_COLON,
   c2_tokenizer_Action_SEMI_COLON,
   c2_tokenizer_Action_LESS,
   c2_tokenizer_Action_EQUAL,
   c2_tokenizer_Action_GREATER,
   c2_tokenizer_Action_QUESTION,
   c2_tokenizer_Action_AT,
   c2_tokenizer_Action_AMP,
   c2_tokenizer_Action_CARET,
   c2_tokenizer_Action_LBRACE,
   c2_tokenizer_Action_RBRACE,
   c2_tokenizer_Action_PIPE,
   c2_tokenizer_Action_TILDE,
   c2_tokenizer_Action_CR,
   c2_tokenizer_Action_EOF,
};

struct c2_tokenizer_Feature_ {
   src_loc_SrcLoc loc;
   token_Kind kind;
   uint8_t skipping;
   bool is_else;
};

typedef uint8_t c2_tokenizer_ErrorLevel;
enum c2_tokenizer_ErrorLevel {
   c2_tokenizer_ErrorLevel_Note,
   c2_tokenizer_ErrorLevel_Warning,
   c2_tokenizer_ErrorLevel_Error,
   c2_tokenizer_ErrorLevel_FatalError,
};

typedef void (*c2_tokenizer_ErrorFn)(void* arg, c2_tokenizer_ErrorLevel level, src_loc_SrcLoc loc, const char* msg);

struct c2_tokenizer_Tokenizer_ {
   const char* cur;
   src_loc_SrcLoc loc_start;
   const char* input_start;
   const keywords_Info* kwinfo;
   const char* line_start;
   string_pool_Pool* pool;
   string_buffer_Buf* buf;
   c2_tokenizer_ErrorFn on_error;
   void* on_error_arg;
   c2_tokenizer_Feature feature_stack[7];
   uint32_t feature_count;
   const string_list_List* features;
   bool raw_mode;
   bool stop_at_eol;
   char error_msg[256];
};

struct c2_tokenizer_Operand_ {
   int64_t val;
   token_Kind op;
   uint8_t prec;
};

static const c2_tokenizer_Action c2_tokenizer_Char_lookup[256] = {
   [0] = c2_tokenizer_Action_EOF,
   ['\t'] = c2_tokenizer_Action_TABSPACE,
   ['\n'] = c2_tokenizer_Action_NEWLINE,
   ['\r'] = c2_tokenizer_Action_CR,
   [' '] = c2_tokenizer_Action_TABSPACE,
   ['!'] = c2_tokenizer_Action_EXCLAIM,
   ['"'] = c2_tokenizer_Action_DQUOTE,
   ['#'] = c2_tokenizer_Action_POUND,
   ['%'] = c2_tokenizer_Action_PERCENT,
   ['&'] = c2_tokenizer_Action_AMP,
   ['\''] = c2_tokenizer_Action_SQUOTE,
   ['('] = c2_tokenizer_Action_LPAREN,
   [')'] = c2_tokenizer_Action_RPAREN,
   ['*'] = c2_tokenizer_Action_STAR,
   ['+'] = c2_tokenizer_Action_PLUS,
   [','] = c2_tokenizer_Action_COMMA,
   ['-'] = c2_tokenizer_Action_MINUS,
   ['.'] = c2_tokenizer_Action_DOT,
   ['/'] = c2_tokenizer_Action_SLASH,
   ['0'] = c2_tokenizer_Action_DIGIT,
   ['1'] = c2_tokenizer_Action_DIGIT,
   ['2'] = c2_tokenizer_Action_DIGIT,
   ['3'] = c2_tokenizer_Action_DIGIT,
   ['4'] = c2_tokenizer_Action_DIGIT,
   ['5'] = c2_tokenizer_Action_DIGIT,
   ['6'] = c2_tokenizer_Action_DIGIT,
   ['7'] = c2_tokenizer_Action_DIGIT,
   ['8'] = c2_tokenizer_Action_DIGIT,
   ['9'] = c2_tokenizer_Action_DIGIT,
   [':'] = c2_tokenizer_Action_COLON,
   [';'] = c2_tokenizer_Action_SEMI_COLON,
   ['<'] = c2_tokenizer_Action_LESS,
   ['='] = c2_tokenizer_Action_EQUAL,
   ['>'] = c2_tokenizer_Action_GREATER,
   ['?'] = c2_tokenizer_Action_QUESTION,
   ['@'] = c2_tokenizer_Action_AT,
   ['A'] = c2_tokenizer_Action_IDENT,
   ['B'] = c2_tokenizer_Action_IDENT,
   ['C'] = c2_tokenizer_Action_IDENT,
   ['D'] = c2_tokenizer_Action_IDENT,
   ['E'] = c2_tokenizer_Action_IDENT,
   ['F'] = c2_tokenizer_Action_IDENT,
   ['G'] = c2_tokenizer_Action_IDENT,
   ['H'] = c2_tokenizer_Action_IDENT,
   ['I'] = c2_tokenizer_Action_IDENT,
   ['J'] = c2_tokenizer_Action_IDENT,
   ['K'] = c2_tokenizer_Action_IDENT,
   ['L'] = c2_tokenizer_Action_IDENT,
   ['M'] = c2_tokenizer_Action_IDENT,
   ['N'] = c2_tokenizer_Action_IDENT,
   ['O'] = c2_tokenizer_Action_IDENT,
   ['P'] = c2_tokenizer_Action_IDENT,
   ['Q'] = c2_tokenizer_Action_IDENT,
   ['R'] = c2_tokenizer_Action_IDENT,
   ['S'] = c2_tokenizer_Action_IDENT,
   ['T'] = c2_tokenizer_Action_IDENT,
   ['U'] = c2_tokenizer_Action_IDENT,
   ['V'] = c2_tokenizer_Action_IDENT,
   ['W'] = c2_tokenizer_Action_IDENT,
   ['X'] = c2_tokenizer_Action_IDENT,
   ['Y'] = c2_tokenizer_Action_IDENT,
   ['Z'] = c2_tokenizer_Action_IDENT,
   ['['] = c2_tokenizer_Action_LSQUARE,
   ['\\'] = c2_tokenizer_Action_INVALID,
   [']'] = c2_tokenizer_Action_RSQUARE,
   ['^'] = c2_tokenizer_Action_CARET,
   ['_'] = c2_tokenizer_Action_IDENT,
   ['`'] = c2_tokenizer_Action_BQUOTE,
   ['a'] = c2_tokenizer_Action_IDENT,
   ['b'] = c2_tokenizer_Action_IDENT,
   ['c'] = c2_tokenizer_Action_IDENT,
   ['d'] = c2_tokenizer_Action_IDENT,
   ['e'] = c2_tokenizer_Action_IDENT,
   ['f'] = c2_tokenizer_Action_IDENT,
   ['g'] = c2_tokenizer_Action_IDENT,
   ['h'] = c2_tokenizer_Action_IDENT,
   ['i'] = c2_tokenizer_Action_IDENT,
   ['j'] = c2_tokenizer_Action_IDENT,
   ['k'] = c2_tokenizer_Action_IDENT,
   ['l'] = c2_tokenizer_Action_IDENT,
   ['m'] = c2_tokenizer_Action_IDENT,
   ['n'] = c2_tokenizer_Action_IDENT,
   ['o'] = c2_tokenizer_Action_IDENT,
   ['p'] = c2_tokenizer_Action_IDENT,
   ['q'] = c2_tokenizer_Action_IDENT,
   ['r'] = c2_tokenizer_Action_IDENT,
   ['s'] = c2_tokenizer_Action_IDENT,
   ['t'] = c2_tokenizer_Action_IDENT,
   ['u'] = c2_tokenizer_Action_IDENT,
   ['v'] = c2_tokenizer_Action_IDENT,
   ['w'] = c2_tokenizer_Action_IDENT,
   ['x'] = c2_tokenizer_Action_IDENT,
   ['y'] = c2_tokenizer_Action_IDENT,
   ['z'] = c2_tokenizer_Action_IDENT,
   ['{'] = c2_tokenizer_Action_LBRACE,
   ['|'] = c2_tokenizer_Action_PIPE,
   ['}'] = c2_tokenizer_Action_RBRACE,
   ['~'] = c2_tokenizer_Action_TILDE
};
static const uint8_t c2_tokenizer_Identifier_char[256] = {
   ['0'] = 1,
   ['1'] = 1,
   ['2'] = 1,
   ['3'] = 1,
   ['4'] = 1,
   ['5'] = 1,
   ['6'] = 1,
   ['7'] = 1,
   ['8'] = 1,
   ['9'] = 1,
   ['A'] = 1,
   ['B'] = 1,
   ['C'] = 1,
   ['D'] = 1,
   ['E'] = 1,
   ['F'] = 1,
   ['G'] = 1,
   ['H'] = 1,
   ['I'] = 1,
   ['J'] = 1,
   ['K'] = 1,
   ['L'] = 1,
   ['M'] = 1,
   ['N'] = 1,
   ['O'] = 1,
   ['P'] = 1,
   ['Q'] = 1,
   ['R'] = 1,
   ['S'] = 1,
   ['T'] = 1,
   ['U'] = 1,
   ['V'] = 1,
   ['W'] = 1,
   ['X'] = 1,
   ['Y'] = 1,
   ['Z'] = 1,
   ['_'] = 1,
   ['a'] = 1,
   ['b'] = 1,
   ['c'] = 1,
   ['d'] = 1,
   ['e'] = 1,
   ['f'] = 1,
   ['g'] = 1,
   ['h'] = 1,
   ['i'] = 1,
   ['j'] = 1,
   ['k'] = 1,
   ['l'] = 1,
   ['m'] = 1,
   ['n'] = 1,
   ['o'] = 1,
   ['p'] = 1,
   ['q'] = 1,
   ['r'] = 1,
   ['s'] = 1,
   ['t'] = 1,
   ['u'] = 1,
   ['v'] = 1,
   ['w'] = 1,
   ['x'] = 1,
   ['y'] = 1,
   ['z'] = 1
};
#define c2_tokenizer_MAX_LEVEL 16
static void c2_tokenizer_Tokenizer_init(c2_tokenizer_Tokenizer* t, string_pool_Pool* pool, string_buffer_Buf* buf, const char* input, src_loc_SrcLoc loc_start, const keywords_Info* kwinfo, const string_list_List* features, c2_tokenizer_ErrorFn on_error, void* on_error_arg, bool raw_mode);
static void c2_tokenizer_Tokenizer_lex(c2_tokenizer_Tokenizer* t, token_Token* result);
__attribute__((__format__(printf, 3, 4)))
static void c2_tokenizer_Tokenizer_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* format, ...);
__attribute__((__format__(printf, 4, 5)))
static void c2_tokenizer_Tokenizer_num_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* format, ...);
static void c2_tokenizer_Tokenizer_lex_identifier(c2_tokenizer_Tokenizer* t, token_Token* result);
static uint8_t c2_tokenizer_hex2val(char c);
static bool c2_tokenizer_is_octal(char c);
static bool c2_tokenizer_is_binary(char c);
static void c2_tokenizer_Tokenizer_lex_number_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* qual);
static void c2_tokenizer_Tokenizer_lex_number(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_floating_point(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start);
static void c2_tokenizer_Tokenizer_lex_floating_point_hex(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start);
static uint32_t c2_tokenizer_Tokenizer_lex_escaped_char(c2_tokenizer_Tokenizer* t, token_Token* result, const char* stype);
static void c2_tokenizer_Tokenizer_lex_char_literal(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_raw_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result);
static void c2_tokenizer_Tokenizer_lex_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_Tokenizer_lex_line_comment(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_Tokenizer_lex_block_comment(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_compare_word(const char* cur, const char* expect);
static bool c2_tokenizer_Tokenizer_lex_feature_cmd(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_Tokenizer_at_bol(c2_tokenizer_Tokenizer* t);
static bool c2_tokenizer_Tokenizer_parse_error_warn(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind);
static bool c2_tokenizer_Tokenizer_is_enabled(const c2_tokenizer_Tokenizer* t);
static token_Kind c2_tokenizer_Tokenizer_lex_preproc(c2_tokenizer_Tokenizer* t, token_Token* result);
static int64_t c2_tokenizer_Tokenizer_parse_ppexpr(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_Tokenizer_handle_if(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind);
static bool c2_tokenizer_Tokenizer_handle_else(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_Tokenizer_handle_endif(c2_tokenizer_Tokenizer* t, token_Token* result);
static bool c2_tokenizer_Tokenizer_skip_feature(c2_tokenizer_Tokenizer* t, token_Token* result);
static const char* c2_tokenizer_skip_blanks(const char* p);
static const char* c2_tokenizer_skip_string_literal(const char* p);
static const char* c2_tokenizer_skip_raw_string_literal(const char* p);
static const char* c2_tokenizer_skip_line_comment(const char* p);
static const char* c2_tokenizer_skip_block_comment(const char* p);
static uint32_t c2_tokenizer_hexconv(const char* p, uint32_t maxn, uint32_t* pc);
static uint32_t c2_tokenizer_octconv(const char* p, uint32_t maxn, uint32_t* pc);

static void c2_tokenizer_Tokenizer_init(c2_tokenizer_Tokenizer* t, string_pool_Pool* pool, string_buffer_Buf* buf, const char* input, src_loc_SrcLoc loc_start, const keywords_Info* kwinfo, const string_list_List* features, c2_tokenizer_ErrorFn on_error, void* on_error_arg, bool raw_mode)
{
   memset(t, 0, 408);
   t->cur = input;
   t->loc_start = loc_start;
   t->input_start = input;
   t->kwinfo = kwinfo;
   t->line_start = input;
   t->pool = pool;
   t->buf = buf;
   t->on_error = on_error;
   t->on_error_arg = on_error_arg;
   t->features = features;
   t->raw_mode = raw_mode;
}

static void c2_tokenizer_Tokenizer_lex(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   while (1) {
      token_Token_init(result);
      result->loc = t->loc_start + (src_loc_SrcLoc)(t->cur - t->input_start);
      result->len = 1;
      c2_tokenizer_Action act = c2_tokenizer_Char_lookup[(uint8_t)(*t->cur)];
      switch (act) {
      case c2_tokenizer_Action_INVALID: {
         uint32_t len;
         uint32_t cc;
         if ((*t->cur & 0x80) && (len = utf8_decode(t->cur, 4, &cc)) > 0) {
            if (cc == 0xfeff && t->cur == t->input_start) {
               t->cur += len;
               continue;
            }
            if (t->raw_mode) {
               result->kind = token_Kind_Invalid;
               result->len = (uint16_t)len;
               memcpy(result->invalid, t->cur, len);
               t->cur += len;
               return;
            }
            c2_tokenizer_Tokenizer_error(t, result, "Unicode (UTF-8) is only allowed inside string literals or comments");
            return;
         }
         goto invalid_char;
      }
      case c2_tokenizer_Action_TABSPACE:
         t->cur++;
         while (*t->cur == ' ') t->cur++;
         continue;
      case c2_tokenizer_Action_IDENT:
         c2_tokenizer_Tokenizer_lex_identifier(t, result);
         if (result->name_idx <= t->kwinfo->max_index) {
            token_Kind k = t->kwinfo->indexes[result->name_idx];
            ;//assert(k != token_Kind_None);
            if (k == token_Kind_Error) {
               result->reserved = true;
               return;
            }
            result->kind = k;
         }
         return;
      case c2_tokenizer_Action_DIGIT:
         c2_tokenizer_Tokenizer_lex_number(t, result);
         return;
      case c2_tokenizer_Action_LPAREN:
         result->kind = token_Kind_LParen;
         t->cur++;
         return;
      case c2_tokenizer_Action_RPAREN:
         result->kind = token_Kind_RParen;
         t->cur++;
         return;
      case c2_tokenizer_Action_LSQUARE:
         result->kind = token_Kind_LSquare;
         t->cur++;
         return;
      case c2_tokenizer_Action_RSQUARE:
         result->kind = token_Kind_RSquare;
         t->cur++;
         return;
      case c2_tokenizer_Action_NEWLINE:
         if (t->stop_at_eol) {
            result->kind = token_Kind_Eof;
            result->len = 0;
            return;
         }
         t->cur++;
         t->line_start = t->cur;
         continue;
      case c2_tokenizer_Action_EXCLAIM:
         t->cur++;
         if (*t->cur == '=') {
            result->kind = token_Kind_ExclaimEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Exclaim;
         }
         return;
      case c2_tokenizer_Action_BQUOTE:
         c2_tokenizer_Tokenizer_lex_raw_string_literal(t, result);
         return;
      case c2_tokenizer_Action_DQUOTE:
         c2_tokenizer_Tokenizer_lex_string_literal(t, result);
         return;
      case c2_tokenizer_Action_SQUOTE:
         c2_tokenizer_Tokenizer_lex_char_literal(t, result);
         return;
      case c2_tokenizer_Action_POUND:
         if (!c2_tokenizer_Tokenizer_at_bol(t)) goto invalid_char;
         if (c2_tokenizer_Tokenizer_lex_feature_cmd(t, result)) return;
         if (!c2_tokenizer_Tokenizer_is_enabled(t)) {
            if (c2_tokenizer_Tokenizer_skip_feature(t, result)) return;
         }
         continue;
      case c2_tokenizer_Action_STAR:
         t->cur++;
         if (*t->cur == '=') {
            result->kind = token_Kind_StarEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Star;
         }
         return;
      case c2_tokenizer_Action_PLUS:
         t->cur++;
         if (*t->cur == '+') {
            t->cur++;
            result->kind = token_Kind_PlusPlus;
            result->len = 2;
            return;
         }
         if (*t->cur == '=') {
            t->cur++;
            result->kind = token_Kind_PlusEqual;
            result->len = 2;
            return;
         }
         result->kind = token_Kind_Plus;
         return;
      case c2_tokenizer_Action_MINUS:
         t->cur++;
         if (*t->cur == '-') {
            t->cur++;
            result->kind = token_Kind_MinusMinus;
            result->len = 2;
            return;
         }
         if (*t->cur == '=') {
            t->cur++;
            result->kind = token_Kind_MinusEqual;
            result->len = 2;
            return;
         }
         if (*t->cur == '>' && !t->raw_mode) {
            t->cur--;
            c2_tokenizer_Tokenizer_error(t, result, "use the dot operators instead of '->'");
            return;
         }
         result->kind = token_Kind_Minus;
         return;
      case c2_tokenizer_Action_COMMA:
         result->kind = token_Kind_Comma;
         t->cur++;
         return;
      case c2_tokenizer_Action_DOT:
         t->cur++;
         if (t->cur[0] == '.') {
            if (t->cur[1] == '.') {
               t->cur += 2;
               result->kind = token_Kind_Ellipsis;
               result->len = 3;
            } else {
               result->kind = token_Kind_Dot;
            }
         } else if (isdigit(t->cur[0])) {
            t->cur--;
            c2_tokenizer_Tokenizer_lex_number(t, result);
         } else {
            result->kind = token_Kind_Dot;
         }
         return;
      case c2_tokenizer_Action_PERCENT:
         t->cur++;
         if (*t->cur == '=') {
            result->kind = token_Kind_PercentEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Percent;
         }
         return;
      case c2_tokenizer_Action_SLASH:
         t->cur++;
         if (*t->cur == '=') {
            result->kind = token_Kind_SlashEqual;
            result->len = 2;
            t->cur++;
            return;
         }
         if (*t->cur == '/') {
            if (c2_tokenizer_Tokenizer_lex_line_comment(t, result)) return;
            continue;
         }
         if (*t->cur == '*') {
            if (c2_tokenizer_Tokenizer_lex_block_comment(t, result)) return;
            continue;
         }
         result->kind = token_Kind_Slash;
         return;
      case c2_tokenizer_Action_COLON:
         result->kind = token_Kind_Colon;
         t->cur++;
         return;
      case c2_tokenizer_Action_SEMI_COLON:
         result->kind = token_Kind_Semicolon;
         t->cur++;
         return;
      case c2_tokenizer_Action_LESS:
         t->cur++;
         if (*t->cur == '=') {
            t->cur++;
            result->kind = token_Kind_LessEqual;
            result->len = 2;
            return;
         }
         if (*t->cur == '<') {
            t->cur++;
            if (*t->cur == '=') {
               t->cur++;
               result->kind = token_Kind_LessLessEqual;
               result->len = 3;
            } else {
               result->kind = token_Kind_LessLess;
               result->len = 2;
            }
            return;
         }
         result->kind = token_Kind_Less;
         return;
      case c2_tokenizer_Action_EQUAL:
         t->cur++;
         if (*t->cur == '=') {
            result->kind = token_Kind_EqualEqual;
            result->len = 2;
            t->cur++;
         } else {
            result->kind = token_Kind_Equal;
         }
         return;
      case c2_tokenizer_Action_GREATER:
         t->cur++;
         if (*t->cur == '=') {
            t->cur++;
            result->kind = token_Kind_GreaterEqual;
            result->len = 2;
            return;
         }
         if (*t->cur == '>') {
            t->cur++;
            if (*t->cur == '=') {
               t->cur++;
               result->kind = token_Kind_GreaterGreaterEqual;
               result->len = 3;
            } else {
               result->kind = token_Kind_GreaterGreater;
               result->len = 2;
            }
            return;
         }
         result->kind = token_Kind_Greater;
         return;
      case c2_tokenizer_Action_QUESTION:
         result->kind = token_Kind_Question;
         t->cur++;
         return;
      case c2_tokenizer_Action_AT:
         result->kind = token_Kind_At;
         t->cur++;
         return;
      case c2_tokenizer_Action_AMP:
         t->cur++;
         if (*t->cur == '&') {
            result->kind = token_Kind_AmpAmp;
            result->len = 2;
            t->cur++;
            return;
         }
         if (*t->cur == '=') {
            result->kind = token_Kind_AmpEqual;
            result->len = 2;
            t->cur++;
            return;
         }
         result->kind = token_Kind_Amp;
         return;
      case c2_tokenizer_Action_CARET:
         t->cur++;
         if (*t->cur == '=') {
            t->cur++;
            result->kind = token_Kind_CaretEqual;
            result->len = 2;
            return;
         }
         result->kind = token_Kind_Caret;
         return;
      case c2_tokenizer_Action_LBRACE:
         result->kind = token_Kind_LBrace;
         t->cur++;
         return;
      case c2_tokenizer_Action_RBRACE:
         result->kind = token_Kind_RBrace;
         t->cur++;
         return;
      case c2_tokenizer_Action_PIPE:
         t->cur++;
         if (*t->cur == '|') {
            result->kind = token_Kind_PipePipe;
            result->len = 2;
            t->cur++;
            return;
         }
         if (*t->cur == '=') {
            result->kind = token_Kind_PipeEqual;
            result->len = 2;
            t->cur++;
            return;
         }
         result->kind = token_Kind_Pipe;
         return;
      case c2_tokenizer_Action_TILDE:
         result->kind = token_Kind_Tilde;
         t->cur++;
         return;
      case c2_tokenizer_Action_CR:
         t->cur++;
         if (*t->cur != '\n') {
            if (t->raw_mode) continue;
            c2_tokenizer_Tokenizer_error(t, result, "unexpected character 0x%02X after CR", *t->cur & 0xff);
            return;
         }
         if (t->stop_at_eol) {
            result->kind = token_Kind_Eof;
            result->len = 0;
            return;
         }
         t->cur++;
         t->line_start = t->cur;
         continue;
      case c2_tokenizer_Action_EOF:
         if (t->feature_count) {
            c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
            t->cur = t->input_start + (top->loc - t->loc_start);
            c2_tokenizer_Tokenizer_error(t, result, "un-terminated %s", token_Kind_str(top->kind));
            return;
         }
         result->kind = token_Kind_Eof;
         result->len = 0;
         result->done = true;
         return;
      }
   invalid_char:
      if (t->raw_mode) {
         result->kind = token_Kind_Invalid;
         result->invalid[0] = *t->cur;
         t->cur += 1;
         return;
      }
      if (*t->cur >= ' ' && *t->cur < 0x7f) c2_tokenizer_Tokenizer_error(t, result, "invalid char '%c'", *t->cur);
      else c2_tokenizer_Tokenizer_error(t, result, "invalid char 0x%02X", *t->cur & 0xff);
      return;
   }
}

__attribute__((__format__(printf, 3, 4)))
static void c2_tokenizer_Tokenizer_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   vsnprintf(t->error_msg, 256, format, args);
   va_end(args);
   result->loc = t->loc_start + (src_loc_SrcLoc)(t->cur - t->input_start);
   result->kind = token_Kind_Error;
   result->error_msg = t->error_msg;
   result->done = true;
   if (t->on_error) t->on_error(t->on_error_arg, c2_tokenizer_ErrorLevel_FatalError, result->loc, t->error_msg);
}

__attribute__((__format__(printf, 4, 5)))
static void c2_tokenizer_Tokenizer_num_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   vsnprintf(t->error_msg, 256, format, args);
   va_end(args);
   src_loc_SrcLoc err_loc = t->loc_start + (src_loc_SrcLoc)(p - t->input_start);
   for (;;) {
      if ((*p == 'e' || *p == 'E' || *p == 'p' || *p == 'P') && (p[1] == '+' || p[1] == '-')) {
         p += 2;
      } else if (*p == '\'' && isalnum(p[1])) {
         p += 2;
      } else if (isalnum(*p) || *p == '_' || (*p == '.' && p[1] != '.')) {
         p++;
      } else {
         break;
      }
   }
   t->cur = p;
   result->len = (uint16_t)((p - t->input_start) - (result->loc - t->loc_start));
   if (t->on_error) t->on_error(t->on_error_arg, c2_tokenizer_ErrorLevel_Error, err_loc, t->error_msg);
}

static void c2_tokenizer_Tokenizer_lex_identifier(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_Identifier;
   const char* start = t->cur;
   const char* end = t->cur + 1;
   while (c2_tokenizer_Identifier_char[(uint8_t)(*end)]) end++;
   size_t len = (size_t)(end - start);
   if (len > constants_MaxIdentifierLen && !t->raw_mode) {
      c2_tokenizer_Tokenizer_error(t, result, "identifier too long (max %u chars)", constants_MaxIdentifierLen);
      return;
   }
   t->cur += len;
   result->name_idx = string_pool_Pool_add(t->pool, start, len, true);
   result->len = (uint16_t)len;
}

static uint8_t c2_tokenizer_hex2val(char c)
{
   if (c >= '0' && c <= '9') return (uint8_t)(c - '0');
   if (c >= 'a' && c <= 'f') return (uint8_t)(c - 'a' + 10);
   return (uint8_t)(c - 'A' + 10);
}

static bool c2_tokenizer_is_octal(char c)
{
   return (c >= '0' && c <= '7');
}

static bool c2_tokenizer_is_binary(char c)
{
   return (c >= '0' && c <= '1');
}

static void c2_tokenizer_Tokenizer_lex_number_error(c2_tokenizer_Tokenizer* t, token_Token* result, const char* p, const char* qual)
{
   if (isdigit(*p)) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid digit '%c' in %s constant", *p, qual);
      return;
   }
   if (*p == '_') {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "digit separator '%c' not surrounded by digits", *p);
      return;
   }
   if (isalpha(*p)) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid character '%c' in %s constant", *p, qual);
      return;
   }
   c2_tokenizer_Tokenizer_num_error(t, result, p, "missing digits in %s constant", qual);
}

static void c2_tokenizer_Tokenizer_lex_number(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_IntegerLiteral;
   const char* start = t->cur;
   const char* p = start;
   uint64_t value = 0;
   bool overflow = false;
   if (p[0] == '0') {
      if (p[1] == 'x' || p[1] == 'X') {
         result->radix = number_radix_Radix_Hex;
         p += 2;
         if (isxdigit(*p)) {
            while (isxdigit(*p)) {
               if (value > c2_max_u64 >> 4) {
                  value = c2_max_u64;
                  overflow = true;
               } else {
                  value = (value << 4) + c2_tokenizer_hex2val(*p);
               }
               p++;
               if (*p == '_' && isxdigit(p[1])) p++;
            }
            if (*p == 'p' || *p == 'P' || (*p == '.' && p[1] != '.')) {
               c2_tokenizer_Tokenizer_lex_floating_point_hex(t, result, start);
               return;
            }
         } else {
            if (*p == '.' && p[1] != '.' && isxdigit(p[1])) {
               c2_tokenizer_Tokenizer_lex_floating_point_hex(t, result, start);
               return;
            }
         }
         if (*p == '_' || isalpha(*p) || p == start + 2) {
            c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "hexadecimal");
            return;
         }
         goto check_overflow;
      }
      if (p[1] == 'b' || p[1] == 'B') {
         result->radix = number_radix_Radix_Binary;
         p += 2;
         while (c2_tokenizer_is_binary(*p)) {
            if (value > c2_max_u64 >> 1) {
               value = c2_max_u64;
               overflow = true;
            } else {
               value = (value << 1) + (*p - '0');
            }
            p++;
            if (*p == '_' && c2_tokenizer_is_binary(p[1])) p++;
         }
         if (*p == '_' || isalnum(*p) || p == start + 2) {
            c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "binary");
            return;
         }
         goto check_overflow;
      }
      while (c2_tokenizer_is_octal(*p)) {
         if (value > c2_max_u64 >> 3) {
            value = c2_max_u64;
            overflow = true;
         } else {
            value = (value << 3) + (*p - '0');
         }
         p++;
         if (*p == '_' && isdigit(p[1])) p++;
      }
      const char* p0 = p;
      if (isdigit(*p)) {
         while (isdigit(*p) || (*p == '_' && isdigit(p[1]))) p++;
      }
      if (*p == 'e' || *p == 'E' || (*p == '.' && p[1] != '.')) {
         c2_tokenizer_Tokenizer_lex_floating_point(t, result, start);
         return;
      }
      p = p0;
      if (*p == '_' || isalnum(*p)) {
         c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "octal");
         return;
      }
      t->cur = p;
      if (p == start + 1) {
         return;
      }
      result->radix = number_radix_Radix_Octal;
      goto check_overflow;
   }
   while (isdigit(*p)) {
      uint32_t digit = (uint32_t)(*p++ - '0');
      if (value >= c2_max_u64 / 10 && (value > c2_max_u64 / 10 || digit > c2_max_u64 % 10)) {
         value = c2_max_u64;
         overflow = true;
      } else {
         value = value * 10 + digit;
      }
      if (*p == '_' && isdigit(p[1])) p++;
   }
   if (*p == 'e' || *p == 'E' || (*p == '.' && p[1] != '.')) {
      c2_tokenizer_Tokenizer_lex_floating_point(t, result, start);
      return;
   }
   if (*p == '_' || isalpha(*p)) {
      c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "decimal");
      return;
   }
check_overflow:
   t->cur = p;
   result->int_value = value;
   result->len = (uint16_t)(p - start);
   if (overflow) {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "integer literal is too large to be represented in any integer type");
      return;
   }
}

static void c2_tokenizer_Tokenizer_lex_floating_point(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start)
{
   char buf[4096];
   const char* p = start;
   size_t pos = 0;
   uint8_t seen_dot = 0;
   result->kind = token_Kind_FloatLiteral;
   result->float_value = 0;
   for (;;) {
      if (!isdigit(*p)) {
         if (*p == '_' && isdigit(p[1])) p++;
         else if (*p != '.' || seen_dot++) break;
      }
      buf[pos++] = *p++;
      if (pos == 4096) goto too_large;
   }
   if (*p == 'e' || *p == 'E') {
      if (pos >= 4096 - 2) goto too_large;
      buf[pos++] = *p++;
      if (*p == '+' || *p == '-') buf[pos++] = *p++;
      if (!isdigit(*p)) {
         c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid exponent in floating point constant");
         return;
      }
      while (isdigit(*p)) {
         buf[pos++] = *p++;
         if (pos == 4096) goto too_large;
         if (*p == '_' && isdigit(p[1])) p++;
      }
   }
   if (*p == 'f' || *p == 'F') {
      result->suffix_F = true;
      p++;
   }
   if (*p == '_' || isalpha(*p)) {
      c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "floating point");
      return;
   }
   t->cur = p;
   buf[pos] = '\0';
   result->len = (uint16_t)(p - start);
   result->float_value = strtod(buf, NULL);
   return;
too_large:
   c2_tokenizer_Tokenizer_num_error(t, result, p, "floating point constant too large");
   return;
}

static void c2_tokenizer_Tokenizer_lex_floating_point_hex(c2_tokenizer_Tokenizer* t, token_Token* result, const char* start)
{
   char buf[4096];
   const char* p = start;
   size_t pos = 0;
   uint8_t seen_dot = 0;
   result->kind = token_Kind_FloatLiteral;
   result->float_value = 0;
   if (*p == '0' && (p[1] == 'x' || p[1] == 'X')) {
      buf[pos++] = *p++;
      buf[pos++] = *p++;
   }
   for (;;) {
      if (!isxdigit(*p)) {
         if (*p == '_' && isxdigit(p[1])) p++;
         else if (*p != '.' || seen_dot++) break;
      }
      buf[pos++] = *p++;
      if (pos == 4096) goto too_large;
   }
   if (*p == 'p' || *p == 'P') {
      if (pos >= 4096 - 2) goto too_large;
      buf[pos++] = *p++;
      if (*p == '+' || *p == '-') buf[pos++] = *p++;
      if (!isdigit(*p)) {
         c2_tokenizer_Tokenizer_num_error(t, result, p, "invalid exponent in floating point constant");
         return;
      }
      while (isdigit(*p)) {
         buf[pos++] = *p++;
         if (pos == 4096) goto too_large;
         if (*p == '_' && isdigit(p[1])) p++;
      }
   } else {
      c2_tokenizer_Tokenizer_num_error(t, result, p, "hexadecimal floating constant requires an exponent");
      return;
   }
   if (*p == 'f' || *p == 'F') {
      result->suffix_F = true;
      p++;
   }
   if (*p == '_' || isalpha(*p)) {
      c2_tokenizer_Tokenizer_lex_number_error(t, result, p, "floating point");
      return;
   }
   t->cur = p;
   buf[pos] = '\0';
   result->len = (uint16_t)(p - start);
   result->float_value = strtod(buf, NULL);
   return;
too_large:
   c2_tokenizer_Tokenizer_num_error(t, result, p, "floating point constant too large");
}

static uint32_t c2_tokenizer_Tokenizer_lex_escaped_char(c2_tokenizer_Tokenizer* t, token_Token* result, const char* stype)
{
   const char* p = t->cur;
   uint32_t nc = 1;
   uint32_t cc;
   char c;
   switch (c = *p) {
   case 0:
   case '\r':
   case '\n':
      c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", stype);
      return 0;
   case '0':
   case '1':
   case '2':
   case '3':
   case '4':
   case '5':
   case '6':
   case '7':
      result->radix = number_radix_Radix_Octal;
      nc = c2_tokenizer_octconv(p, 3, &cc);
      if (cc > 255) {
         c2_tokenizer_Tokenizer_error(t, result, "octal escape sequence out of range");
         return 0;
      }
      c = cc & 0xff;
      goto add_char;
   case 'x':
      result->radix = number_radix_Radix_Hex;
      nc = c2_tokenizer_hexconv(p + 1, c2_max_i32, &cc);
      if (nc == 0) {
         c2_tokenizer_Tokenizer_error(t, result, "expect hexadecimal number after '\\x'");
         return 0;
      } else if (nc < 2) {
         c2_tokenizer_Tokenizer_error(t, result, "expect 2 hexadecimal digits after '\\x'");
         return 0;
      } else if (nc > 2) {
         c2_tokenizer_Tokenizer_error(t, result, "too many digits in hexadecimal escape sequence '\\x'");
         return 0;
      }
      nc++;
      c = cc & 0xff;
      goto add_char;
   case 'a':
      c = '\a';
      goto add_char;
   case 'b':
      c = '\b';
      goto add_char;
   case 'f':
      c = '\f';
      goto add_char;
   case 'n':
      c = '\n';
      goto add_char;
   case 'r':
      c = '\r';
      goto add_char;
   case 't':
      c = '\t';
      goto add_char;
   case 'v':
      c = '\v';
      goto add_char;
   case '"':
   case '\'':
   case '?':
   case '\\':
   add_char:
      string_buffer_Buf_add1(t->buf, c);
      break;
   case 'u':
      result->radix = number_radix_Radix_Hex;
      nc = c2_tokenizer_hexconv(p + 1, 4, &cc);
      if (nc != 4) {
         c2_tokenizer_Tokenizer_error(t, result, "expect 4 hexadecimal digits after '\\u'");
         return 0;
      }
      nc++;
      goto add_utf8;
   case 'U':
      result->radix = number_radix_Radix_Hex;
      nc = c2_tokenizer_hexconv(p + 1, 8, &cc);
      if (nc != 8) {
         c2_tokenizer_Tokenizer_error(t, result, "expect 8 hexadecimal digits after '\\U'");
         return 0;
      }
      nc++;
      if (cc > 0x10ffff) {
         c2_tokenizer_Tokenizer_error(t, result, "code point value out of range: %08x", cc);
         return 0;
      }
   add_utf8:
      {
         char tab[4];
         uint32_t clen = utf8_encode(tab, 4, cc);
         string_buffer_Buf_add2(t->buf, tab, clen);
      }
      break;
   default:
      if (c < ' ' || c == 0x7f) {
         c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", c, stype);
      } else if (c < 0x80) {
         c2_tokenizer_Tokenizer_error(t, result, "unknown escape sequence '\\%c'", c);
      } else {
         c2_tokenizer_Tokenizer_error(t, result, "invalid UTF-8 escape sequence");
      }
      nc = 0;
      break;
   }
   return nc;
}

static void c2_tokenizer_Tokenizer_lex_char_literal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_CharLiteral;
   const char* start = t->cur;
   t->cur++;
   switch (*t->cur) {
   case 0:
   case '\r':
   case '\n':
      c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", "character constant");
      return;
   case '\'':
      c2_tokenizer_Tokenizer_error(t, result, "empty character constant");
      return;
   case '\\': {
      t->cur++;
      string_buffer_Buf_clear(t->buf);
      uint32_t esc_len = c2_tokenizer_Tokenizer_lex_escaped_char(t, result, "character constant");
      if (esc_len == 0) {
         return;
      }
      t->cur += esc_len;
      if (string_buffer_Buf_size(t->buf) != 1) {
         c2_tokenizer_Tokenizer_error(t, result, "multi-character character constant");
         return;
      }
      result->char_value = string_buffer_Buf_at(t->buf, 0);
      break;
   }
   default: {
      uint8_t c = *t->cur;
      uint32_t cc;
      if ((c & 0x80) && utf8_decode(t->cur, 4, &cc) > 0) {
         c2_tokenizer_Tokenizer_error(t, result, "multi-character character constant");
         return;
      } else if (c < ' ' || c == 0x7f) {
         c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", c, "character constant");
         return;
      } else {
         result->char_value = c;
         t->cur += 1;
      }
      break;
   }
   }
   if (*t->cur != '\'') {
      if (*t->cur != '\0' && t->cur[1] == '\'') {
         c2_tokenizer_Tokenizer_error(t, result, "multi-character character constant");
      } else {
         c2_tokenizer_Tokenizer_error(t, result, "missing terminating ' character (GOT %c)", *t->cur);
      }
      return;
   }
   t->cur += 1;
   result->len = (uint16_t)(t->cur - start);
}

static void c2_tokenizer_Tokenizer_lex_raw_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_StringLiteral;
   result->raw = 1;
   const char* start = t->cur;
   string_buffer_Buf_clear(t->buf);
   uint32_t count = 1;
   while (*++t->cur == '`') count++;
   const char* p = t->cur;
   const char* bol = p;
   uint32_t indent = 0;
   bool at_bol = false;
   if (count >= 3) {
      for (; *p && *p != '\n'; p++) {
         if (*p == '`' && !memcmp(p, start, count)) break;
      }
      if (*p == '\n') {
         p++;
         t->cur = p;
         at_bol = true;
         for (;; p++) {
            for (bol = p; *p == ' ' || *p == '\t'; p++) continue;

            indent = (uint32_t)(p - bol);
            if (*p == '\r') p++;
            if (*p != '\n') break;
         }
         for (p = start;;) {
            if (p == t->input_start || p[-1] == '\n') {
               bol = p;
               indent = (uint32_t)(start - bol);
               break;
            }
            p--;
            if (*p != ' ' && *p != '\t') break;
         }
      }
   }
   for (p = t->cur;;) {
      if (at_bol) {
         at_bol = false;
         uint32_t i;
         for (i = 0; i < indent && p[i] == bol[i]; i++) continue;

         p += i;
         t->cur = p;
         if (i < indent) {
            if (*p == '\n' || *p == '\r' || !*p || !strncmp(p, start, count)) continue;
            c2_tokenizer_Tokenizer_error(t, result, "raw string indentation error: expected %u %s%.*s", indent, *bol == '\t' ? "tab" : "space", indent > 1 ? 1 : 0, "s");
            return;
         }
      }
      while (*p && *p >= ' ' && *p < 0x7f && *p != '`') p++;
      string_buffer_Buf_add2(t->buf, t->cur, (uint32_t)(p - t->cur));
      t->cur = p;
      switch (*p) {
      case '\0':
         t->cur = start;
         c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", "raw string");
         return;
      case '\t':
         p++;
         continue;
      case '\r':
         if (p[1] != '\n') goto invalid;
         p++;
         fallthrough;
      case '\n':
         string_buffer_Buf_add1(t->buf, '\n');
         p++;
         t->cur = p;
         at_bol = true;
         continue;
      case '`': {
         uint32_t i;
         for (i = 1; *++p == '`'; i++) continue;

         if (i < count) continue;
         if (i > count) string_buffer_Buf_add2(t->buf, t->cur, i - count);
         t->cur += i;
         uint32_t len = string_buffer_Buf_size(t->buf);
         result->text_len = len;
         result->text_idx = string_pool_Pool_add(t->pool, string_buffer_Buf_data(t->buf), len, true);
         result->len = (uint16_t)(t->cur - start);
         return;
      }
      default:
         if (*p >= 0x80) {
            uint32_t cc;
            uint32_t nc = utf8_decode(p, 4, &cc);
            if (nc > 0) {
               p += nc;
               continue;
            } else {
               c2_tokenizer_Tokenizer_error(t, result, "invalid UTF-8 sequence");
               return;
            }
         }
      invalid:
         c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", *p, "raw string");
         return;
      }
   }
}

static void c2_tokenizer_Tokenizer_lex_string_literal(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   result->kind = token_Kind_StringLiteral;
   const char* start = t->cur;
   string_buffer_Buf_clear(t->buf);
   t->cur++;
   for (;;) {
      const char* p = t->cur;
      while (*p && *p != '\\' && *p != '"' && *p >= ' ' && *p < 0x7f) p++;
      string_buffer_Buf_add2(t->buf, t->cur, (uint32_t)(p - t->cur));
      t->cur = p;
      switch (*p) {
      case 0:
      case '\r':
      case '\n':
         c2_tokenizer_Tokenizer_error(t, result, "unterminated %s", "string");
         return;
      case '"': {
         t->cur++;
         uint32_t len = string_buffer_Buf_size(t->buf);
         result->text_len = len;
         result->text_idx = string_pool_Pool_add(t->pool, string_buffer_Buf_data(t->buf), len, true);
         result->len = (uint16_t)(t->cur - start);
         return;
      }
      case '\\': {
         t->cur++;
         uint32_t esc_len = c2_tokenizer_Tokenizer_lex_escaped_char(t, result, "string");
         if (esc_len == 0) return;
         t->cur += esc_len;
         break;
      }
      default:
         if (*p >= 0x80) {
            uint32_t cc;
            uint32_t nc = utf8_decode(p, 4, &cc);
            if (nc > 0) {
               string_buffer_Buf_add2(t->buf, p, nc);
               t->cur += nc;
               break;
            } else {
               c2_tokenizer_Tokenizer_error(t, result, "invalid UTF-8 sequence");
               return;
            }
         } else {
            c2_tokenizer_Tokenizer_error(t, result, "invalid character 0x%02X in %s", *p, "string");
            return;
         }
      }
   }
}

static bool c2_tokenizer_Tokenizer_lex_line_comment(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   t->cur += 1;
   const char* start = t->cur;
   const char* end = start;
   while (*end) {
      if (*end == '\r' || *end == '\n') break;
      end++;
   }
   uint32_t len = (uint32_t)(end - start);
   t->cur += len;
   if (t->raw_mode) {
      result->kind = token_Kind_LineComment;
      result->text_len = len;
      result->len = (uint16_t)(len + 2);
      result->text_idx = string_pool_Pool_add(t->pool, start, len, false);
      return true;
   }
   return false;
}

static bool c2_tokenizer_Tokenizer_lex_block_comment(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   t->cur += 1;
   const char* start = t->cur;
   while (1) {
      switch (*t->cur) {
      case 0:
         c2_tokenizer_Tokenizer_error(t, result, "un-terminated block comment");
         return true;
      case '/':
         if (t->cur[1] == '*' && !t->raw_mode) {
            c2_tokenizer_Tokenizer_error(t, result, "'/*' within block comment");
            return true;
         }
         break;
      case '*':
         if (t->cur[1] == '/') {
            t->cur += 2;
            if (t->raw_mode) {
               size_t len = (size_t)(t->cur - start - 2);
               result->kind = token_Kind_BlockComment;
               result->len = (uint16_t)(len + 4);
               result->text_len = (uint32_t)len;
               result->text_idx = string_pool_Pool_add(t->pool, start, len, false);
               return true;
            }
            return false;
         }
         break;
      default:
         break;
      }
      t->cur++;
   }
}

static bool c2_tokenizer_compare_word(const char* cur, const char* expect)
{
   while (*expect) {
      if (*cur != *expect) return false;
      cur++;
      expect++;
   }
   return !c2_tokenizer_Identifier_char[(uint8_t)(*cur)];
}

static bool c2_tokenizer_Tokenizer_lex_feature_cmd(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   const char* start = t->cur;
   t->cur = c2_tokenizer_skip_blanks(t->cur + 1);
   token_Kind kind;
   for (kind = token_Kind_Feat_if; kind < token_Kind_Invalid; kind++) {
      const char* word = token_Kind_str(kind) + 1;
      if (c2_tokenizer_compare_word(t->cur, word)) {
         t->cur += strlen(word);
         break;
      }
   }
   result->kind = kind;
   if (t->raw_mode) {
      if (kind == token_Kind_Invalid) {
         result->invalid[0] = '#';
         t->cur = start + 1;
      }
      result->len = (uint16_t)(t->cur - start);
      return true;
   }
   t->cur = c2_tokenizer_skip_blanks(t->cur);
   switch (kind) {
   case token_Kind_Feat_if:
   case token_Kind_Feat_ifdef:
   case token_Kind_Feat_ifndef:
   case token_Kind_Feat_elif:
      return c2_tokenizer_Tokenizer_handle_if(t, result, kind);
   case token_Kind_Feat_else:
      return c2_tokenizer_Tokenizer_handle_else(t, result);
   case token_Kind_Feat_endif:
      return c2_tokenizer_Tokenizer_handle_endif(t, result);
   case token_Kind_Feat_error:
   case token_Kind_Feat_warning:
      if (!c2_tokenizer_Tokenizer_is_enabled(t)) return false;
      return c2_tokenizer_Tokenizer_parse_error_warn(t, result, kind);
   default:
      if (!c2_tokenizer_Tokenizer_is_enabled(t)) return false;
      t->cur = start;
      c2_tokenizer_Tokenizer_error(t, result, "unknown feature-selection command");
      return true;
   }
}

static bool c2_tokenizer_Tokenizer_at_bol(c2_tokenizer_Tokenizer* t)
{
   const char* p = t->cur;
   while (p > t->line_start) {
      if (!isblank(*--p)) return false;
   }
   return true;
}

static bool c2_tokenizer_Tokenizer_parse_error_warn(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind)
{
   token_Token tok;
   string_buffer_Buf msg; string_buffer_Buf_init(&msg, t->error_msg, 256, false, false, 0);
   src_loc_SrcLoc last_loc = 0;
   while (c2_tokenizer_Tokenizer_lex_preproc(t, &tok) != token_Kind_Eof) {
      if (last_loc && last_loc < tok.loc) string_buffer_Buf_add1(&msg, ' ');
      if (tok.kind == token_Kind_StringLiteral) {
         string_buffer_Buf_add2(&msg, string_pool_Pool_idx2str(t->pool, tok.text_idx), tok.text_len);
      } else {
         string_buffer_Buf_add2(&msg, t->input_start + (tok.loc - t->loc_start), tok.len);
      }
      last_loc = tok.loc + tok.len;
   }
   string_buffer_Buf_data(&msg);
   if (kind == token_Kind_Feat_error) {
      const char* start = t->input_start + (result->loc - t->loc_start);
      result->kind = token_Kind_Error;
      result->done = true;
      result->len = (uint16_t)(t->cur - start);
      result->error_msg = t->error_msg;
      t->cur = start;
      if (t->on_error) t->on_error(t->on_error_arg, c2_tokenizer_ErrorLevel_FatalError, result->loc, t->error_msg);
      return true;
   } else {
      if (t->on_error) t->on_error(t->on_error_arg, c2_tokenizer_ErrorLevel_Warning, result->loc, t->error_msg);
      return false;
   }
}

static bool c2_tokenizer_Tokenizer_is_enabled(const c2_tokenizer_Tokenizer* t)
{
   return !t->feature_stack[t->feature_count].skipping;
}

static token_Kind c2_tokenizer_Tokenizer_lex_preproc(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   t->stop_at_eol = true;
   c2_tokenizer_Tokenizer_lex(t, result);
   t->stop_at_eol = false;
   return result->kind;
}

static int64_t c2_tokenizer_Tokenizer_parse_ppexpr(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   c2_tokenizer_Operand stack[16];
   c2_tokenizer_Operand* sp;
   token_Kind op;
   uint8_t prec;
   int64_t val = 0;
   bool prefix = true;
   for (sp = stack;;) {
      op = c2_tokenizer_Tokenizer_lex_preproc(t, result);
      if (prefix) {
         switch (op) {
         case token_Kind_Identifier: {
            val = 0;
            const char* id = string_pool_Pool_idx2str(t->pool, result->name_idx);
            if (!strcmp(id, "defined")) {
               bool has_paren = false;
               if (c2_tokenizer_Tokenizer_lex_preproc(t, result) == token_Kind_LParen) {
                  has_paren = true;
                  c2_tokenizer_Tokenizer_lex_preproc(t, result);
               }
               if (result->kind == token_Kind_Identifier) {
                  id = string_pool_Pool_idx2str(t->pool, result->name_idx);
               } else {
                  c2_tokenizer_Tokenizer_error(t, result, "missing identifier after 'defined'");
                  return 0;
               }
               if (has_paren) {
                  if (c2_tokenizer_Tokenizer_lex_preproc(t, result) != token_Kind_RParen) goto syntax_error;
               }
               val = string_list_List_contains(t->features, id);
            } else {
               val = string_list_List_contains(t->features, id);
            }
            prefix = false;
            continue;
         }
         case token_Kind_IntegerLiteral:
            val = (int64_t)(result->int_value);
            prefix = false;
            continue;
         case token_Kind_CharLiteral:
            val = result->char_value;
            prefix = false;
            continue;
         case token_Kind_LParen:
            if (sp >= stack + c2_tokenizer_MAX_LEVEL) goto too_deep;
            sp->op = op;
            sp->prec = 19;
            sp++;
            continue;
         case token_Kind_Exclaim:
         case token_Kind_Plus:
         case token_Kind_Minus:
         case token_Kind_Tilde:
            if (sp >= stack + c2_tokenizer_MAX_LEVEL) goto too_deep;
            sp->op = op;
            sp->prec = 1;
            sp++;
            continue;
         default:
            break;
         }
         c2_tokenizer_Tokenizer_error(t, result, "missing operand in preprocessor expression");
         return 0;
      }
      switch (op) {
      case token_Kind_Identifier:
      case token_Kind_IntegerLiteral:
      case token_Kind_CharLiteral:
      case token_Kind_LParen:
         c2_tokenizer_Tokenizer_error(t, result, "missing operator in preprocessor expression");
         return 0;
      default:
         break;
      }
      prefix = true;
   unary:
      while (sp > stack && sp[-1].prec == 1) {
         --sp;
         switch (sp->op) {
         case token_Kind_Exclaim:
            val = !val;
            break;
         case token_Kind_Plus:
            break;
         case token_Kind_Minus:
            val = -val;
            break;
         case token_Kind_Tilde:
            val = ~val;
            break;
         default:
            break;
         }
      }
      switch (op) {
      case token_Kind_None:
         prefix = false;
         continue;
      case token_Kind_Eof:
         prec = 20;
         break;
      case token_Kind_RParen:
         prec = 19;
         break;
      case token_Kind_Star:
      case token_Kind_Slash:
      case token_Kind_Percent:
         prec = 3;
         break;
      case token_Kind_Plus:
      case token_Kind_Minus:
         prec = 4;
         break;
      case token_Kind_LessLess:
      case token_Kind_GreaterGreater:
         prec = 5;
         break;
      case token_Kind_Less:
      case token_Kind_LessEqual:
      case token_Kind_Greater:
      case token_Kind_GreaterEqual:
         prec = 6;
         break;
      case token_Kind_EqualEqual:
      case token_Kind_ExclaimEqual:
         prec = 7;
         break;
      case token_Kind_Amp:
         prec = 8;
         break;
      case token_Kind_Caret:
         prec = 9;
         break;
      case token_Kind_Pipe:
         prec = 10;
         break;
      case token_Kind_AmpAmp:
         prec = 11;
         break;
      case token_Kind_PipePipe:
         prec = 12;
         break;
      case token_Kind_Question:
      case token_Kind_Colon:
         prec = 13;
         break;
      default:
         c2_tokenizer_Tokenizer_error(t, result, "invalid token in preprocessor expression '%s'", token_Kind_str(result->kind));
         return 0;
      }
      while (sp > stack && prec >= sp[-1].prec) {
         sp--;
         switch (sp->op) {
         case token_Kind_LParen:
            if (op != token_Kind_RParen) {
               c2_tokenizer_Tokenizer_error(t, result, "missing parenthesis in preprocessor expression");
               return 0;
            }
            op = token_Kind_None;
            goto unary;
         case token_Kind_Star:
            val = sp->val * val;
            continue;
         case token_Kind_Slash:
            if (val) val = sp->val / val;
            continue;
         case token_Kind_Percent:
            if (val && !(sp->val == c2_min_i64 && val == -1)) val = sp->val % val;
            continue;
         case token_Kind_Plus:
            val = sp->val + val;
            continue;
         case token_Kind_Minus:
            val = sp->val - val;
            continue;
         case token_Kind_LessLess:
            val = sp->val << val;
            continue;
         case token_Kind_GreaterGreater:
            val = sp->val >> val;
            continue;
         case token_Kind_Less:
            val = sp->val < val;
            continue;
         case token_Kind_LessEqual:
            val = sp->val <= val;
            continue;
         case token_Kind_Greater:
            val = sp->val > val;
            continue;
         case token_Kind_GreaterEqual:
            val = sp->val >= val;
            continue;
         case token_Kind_EqualEqual:
            val = sp->val == val;
            continue;
         case token_Kind_ExclaimEqual:
            val = sp->val != val;
            continue;
         case token_Kind_Amp:
            val = sp->val & val;
            continue;
         case token_Kind_Caret:
            val = sp->val ^ val;
            continue;
         case token_Kind_Pipe:
            val = sp->val | val;
            continue;
         case token_Kind_AmpAmp:
            val = sp->val && val;
            continue;
         case token_Kind_PipePipe:
            val = sp->val || val;
            continue;
         case token_Kind_Colon:
            if (sp > stack && sp[-1].op == token_Kind_Question) {
               sp--;
               val = sp->val ? sp[1].val : val;
               continue;
            }
            fallthrough;
         default:
            c2_tokenizer_Tokenizer_error(t, result, "invalid token in preprocessor expression '%s'", token_Kind_str(sp->op));
            return 0;
         }
      }
      if (op == token_Kind_Eof) break;
      if (sp >= stack + c2_tokenizer_MAX_LEVEL) {
      too_deep:
         c2_tokenizer_Tokenizer_error(t, result, "preprocessor expression too complex");
         return 0;
      }
      sp->val = val;
      sp->op = op;
      sp->prec = prec;
      sp++;
   }
   if (sp > stack) {
   syntax_error:
      c2_tokenizer_Tokenizer_error(t, result, "syntax error in preprocessor expression");
      return 0;
   }
   return val;
}

static bool c2_tokenizer_Tokenizer_handle_if(c2_tokenizer_Tokenizer* t, token_Token* result, token_Kind kind)
{
   c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
   if (kind == token_Kind_Feat_if || kind == token_Kind_Feat_ifdef || kind == token_Kind_Feat_ifndef) {
      if (t->feature_count >= constants_MaxFeatureDepth) {
         c2_tokenizer_Tokenizer_error(t, result, "feature nesting too much");
         return true;
      }
      t->feature_count++;
      top++;
      top->kind = kind;
      top->loc = result->loc;
      top->is_else = false;
      top->skipping = 0;
      if (top[-1].skipping) {
         top->skipping = 2;
         return false;
      }
   } else {
      if (t->feature_count == 0) {
         c2_tokenizer_Tokenizer_error(t, result, "%s without #if", token_Kind_str(kind));
         return true;
      }
      if (top->is_else) {
         c2_tokenizer_Tokenizer_error(t, result, "%s in #else", token_Kind_str(kind));
         return true;
      }
      top->skipping ^= 1;
      if (top->skipping) {
         top->skipping = 2;
         return false;
      }
   }
   if (kind == token_Kind_Feat_if || kind == token_Kind_Feat_elif) {
      if (!c2_tokenizer_Tokenizer_parse_ppexpr(t, result)) top->skipping = 1;
   } else {
      if (c2_tokenizer_Tokenizer_lex_preproc(t, result) == token_Kind_Identifier) {
         if (!string_list_List_contains(t->features, string_pool_Pool_idx2str(t->pool, result->name_idx))) top->skipping = 1;
         if (kind == token_Kind_Feat_ifndef) top->skipping ^= 1;
      } else {
         c2_tokenizer_Tokenizer_error(t, result, "missing identifier after %s, got %s", token_Kind_str(kind), token_Kind_str(result->kind));
         return true;
      }
   }
   return false;
}

static bool c2_tokenizer_Tokenizer_handle_else(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   if (t->feature_count == 0) {
      c2_tokenizer_Tokenizer_error(t, result, "#else without #if");
      return true;
   }
   c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
   if (top->is_else) {
      c2_tokenizer_Tokenizer_error(t, result, "#else in #else");
      return true;
   }
   top->is_else = true;
   top->skipping ^= 1;
   return false;
}

static bool c2_tokenizer_Tokenizer_handle_endif(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   if (t->feature_count == 0) {
      c2_tokenizer_Tokenizer_error(t, result, "#endif without #if");
      return true;
   }
   t->feature_count--;
   return false;
}

static bool c2_tokenizer_Tokenizer_skip_feature(c2_tokenizer_Tokenizer* t, token_Token* result)
{
   const char* p = t->cur;
   for (;;) {
      switch (*p++) {
      case '\0': {
         c2_tokenizer_Feature* top = &t->feature_stack[t->feature_count];
         t->cur = t->input_start + (top->loc - t->loc_start);
         c2_tokenizer_Tokenizer_error(t, result, "un-terminated %s", token_Kind_str(top->kind));
         return true;
      }
      case '\n':
         t->line_start = p;
         break;
      case '#':
         t->cur = p - 1;
         if (!c2_tokenizer_Tokenizer_at_bol(t)) break;
         if (c2_tokenizer_Tokenizer_lex_feature_cmd(t, result)) return true;
         if (c2_tokenizer_Tokenizer_is_enabled(t)) return false;
         p = t->cur;
         break;
      case '"':
      case '\'':
         p = c2_tokenizer_skip_string_literal(p - 1);
         break;
      case '`':
         p = c2_tokenizer_skip_raw_string_literal(p - 1);
         break;
      case '/':
         if (*p == '/') {
            p = c2_tokenizer_skip_line_comment(p + 1);
            break;
         }
         if (*p == '*') {
            p = c2_tokenizer_skip_block_comment(p + 1);
            break;
         }
         break;
      }
   }
}

static const char* c2_tokenizer_skip_blanks(const char* p)
{
   while (isblank(*p)) p++;
   return p;
}

static const char* c2_tokenizer_skip_string_literal(const char* p)
{
   char sep = *p++;
   for (;;) {
      switch (*p++) {
      case '\0':
      case '\n':
         return p - 1;
      case '\r':
         return p;
      case '"':
      case '\'':
         if (p[-1] == sep) return p;
         break;
      case '\\':
         if (*p == sep || *p == '\\') p++;
         break;
      }
   }
}

static const char* c2_tokenizer_skip_raw_string_literal(const char* p)
{
   uint32_t count;
   for (count = 0; *p == '`'; count++) p++;
   while (*p) {
      if (*p++ == '`') {
         uint32_t i;
         for (i = 1; *p == '`'; i++) p++;
         if (i >= count) break;
      }
   }
   return p;
}

static const char* c2_tokenizer_skip_line_comment(const char* p)
{
   while (*p != '\0' && *p != '\r' && *p != '\n') p++;
   return p;
}

static const char* c2_tokenizer_skip_block_comment(const char* p)
{
   while (*p != '\0') {
      if (*p == '*' && p[1] == '/') {
         p += 2;
         break;
      }
      p++;
   }
   return p;
}

static uint32_t c2_tokenizer_hexconv(const char* p, uint32_t maxn, uint32_t* pc)
{
   uint32_t cc = 0;
   uint32_t i;
   for (i = 0; i < maxn; i++) {
      int32_t xval = 0;
      char c = p[i];
      if (c >= '0' && c <= '9') xval = c - '0';
      else if (c >= 'a' && c <= 'f') xval = c - 'a' + 10;
      else if (c >= 'A' && c <= 'F') xval = c - 'A' + 10;
      else break;
      cc = cc * 16 + xval;
   }
   *pc = cc;
   return i;
}

static uint32_t c2_tokenizer_octconv(const char* p, uint32_t maxn, uint32_t* pc)
{
   uint32_t cc = 0;
   uint32_t i;
   for (i = 0; i < maxn; i++) {
      char c = p[i];
      if (c >= '0' && c <= '7') cc = cc * 8 + (c - '0');
      else break;
   }
   *pc = cc;
   return i;
}


// --- module plugin_info ---
typedef struct plugin_info_Info_ plugin_info_Info;
typedef struct plugin_info_Plugin_ plugin_info_Plugin;

typedef bool (*plugin_info_RegisterAttrFn)(void* arg, uint32_t name, ast_AttrHandlerFn func, void* arg2);

typedef void (*plugin_info_AddSourceFn)(void* arg, const char* name, string_buffer_Buf* content);

struct plugin_info_Info_ {
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   build_target_Target* target;
   component_List* components;
   string_pool_Pool* astPool;
   string_pool_Pool* auxPool;
   ast_context_Context* context;
   ast_builder_Builder* builder;
   ast_Globals* ast_globals;
   void* ast_builtins__;
   plugin_info_AddSourceFn addSource;
   plugin_info_RegisterAttrFn register_attr;
   void* fn_arg;
   char target_name[32];
   char output_dir[512];
};

typedef void* (*plugin_info_LoadFn)(const char* options, bool console_timing, bool console_debug);

typedef void (*plugin_info_UnloadFn)(void* arg);

typedef void (*plugin_info_InitFn)(void* arg, plugin_info_Info* info);

typedef void (*plugin_info_PostParseFn)(void* arg);

typedef void (*plugin_info_PostAnalysisFn)(void* arg);

struct plugin_info_Plugin_ {
   plugin_info_LoadFn load;
   plugin_info_UnloadFn unload;
   plugin_info_InitFn init;
   plugin_info_PostParseFn post_parse;
   plugin_info_PostAnalysisFn post_analysis;
   const char* name;
};

static bool plugin_info_Info_registerAttr(plugin_info_Info* info, uint32_t name, ast_AttrHandlerFn func, void* arg);

static bool plugin_info_Info_registerAttr(plugin_info_Info* info, uint32_t name, ast_AttrHandlerFn func, void* arg)
{
   return info->register_attr(info->fn_arg, name, func, arg);
}


// --- module conversion_checker ---
typedef struct conversion_checker_Checker_ conversion_checker_Checker;
typedef struct conversion_checker_ExprWidth_ conversion_checker_ExprWidth;

struct conversion_checker_Checker_ {
   diagnostics_Diags* diags;
   ast_builder_Builder* builder;
   ast_BuiltinKind native_kind;
   src_loc_SrcLoc loc;
   ast_QualType lhs;
   ast_QualType rhs;
   ast_Expr** expr_ptr;
};

static const uint8_t conversion_checker_Conversions[9][9] = {
   {
   2,
   3,
   1,
   1,
   13,
   15,
   17,
   0,
   0
},
   {
   4,
   5,
   1,
   1,
   1,
   6,
   17,
   0,
   0
},
   {
   1,
   7,
   8,
   1,
   1,
   1,
   17,
   0,
   0
},
   {
   1,
   1,
   1,
   9,
   1,
   1,
   17,
   0,
   0
},
   {
   10,
   1,
   1,
   1,
   14,
   1,
   17,
   0,
   0
},
   {
   16,
   11,
   1,
   1,
   1,
   12,
   17,
   0,
   0
},
   {
   1,
   1,
   1,
   1,
   1,
   1,
   17,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
}
};
static const uint8_t conversion_checker_BuiltinConversions[14][14] = {
   {
   0,
   3,
   1,
   1,
   1,
   7,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   7
},
   {
   3,
   0,
   1,
   1,
   1,
   3,
   3,
   3,
   3,
   1,
   1,
   1,
   3,
   7
},
   {
   4,
   4,
   0,
   1,
   1,
   4,
   3,
   3,
   3,
   1,
   1,
   1,
   3,
   7
},
   {
   4,
   4,
   4,
   7,
   1,
   4,
   4,
   3,
   3,
   1,
   1,
   1,
   3,
   7
},
   {
   4,
   4,
   4,
   4,
   7,
   4,
   4,
   4,
   3,
   1,
   1,
   7,
   3,
   7
},
   {
   1,
   3,
   1,
   1,
   1,
   0,
   1,
   1,
   1,
   1,
   1,
   3,
   1,
   7
},
   {
   4,
   4,
   3,
   1,
   1,
   4,
   0,
   1,
   1,
   1,
   1,
   3,
   1,
   7
},
   {
   4,
   4,
   4,
   3,
   1,
   4,
   4,
   7,
   1,
   1,
   1,
   3,
   1,
   7
},
   {
   4,
   4,
   4,
   4,
   3,
   4,
   4,
   4,
   7,
   1,
   1,
   3,
   7,
   7
},
   {
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   0,
   1,
   5,
   5,
   2
},
   {
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   6,
   0,
   5,
   5,
   2
},
   {
   4,
   4,
   4,
   4,
   7,
   4,
   4,
   4,
   3,
   1,
   1,
   0,
   3,
   7
},
   {
   4,
   4,
   4,
   4,
   3,
   4,
   4,
   4,
   7,
   1,
   1,
   3,
   0,
   7
},
   {
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   1,
   0
}
};
static const uint8_t conversion_checker_ConditionalOperatorResult[14][14] = {
   {
   0,
   2,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   0
},
   {
   2,
   1,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   1
},
   {
   2,
   2,
   2,
   3,
   4,
   2,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   2
},
   {
   3,
   3,
   3,
   3,
   4,
   3,
   3,
   7,
   8,
   9,
   10,
   11,
   12,
   3
},
   {
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   8,
   9,
   10,
   11,
   12,
   4
},
   {
   5,
   5,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   5
},
   {
   6,
   6,
   6,
   3,
   4,
   6,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   6
},
   {
   7,
   7,
   7,
   7,
   7,
   7,
   7,
   7,
   8,
   9,
   10,
   11,
   12,
   7
},
   {
   8,
   8,
   8,
   8,
   8,
   8,
   8,
   8,
   8,
   9,
   10,
   11,
   12,
   8
},
   {
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   9,
   10,
   9,
   9,
   9
},
   {
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10,
   10
},
   {
   11,
   11,
   11,
   11,
   11,
   11,
   11,
   11,
   8,
   9,
   10,
   11,
   12,
   11
},
   {
   12,
   12,
   12,
   12,
   12,
   12,
   12,
   12,
   8,
   9,
   10,
   12,
   12,
   12
},
   {
   0,
   1,
   2,
   3,
   4,
   5,
   6,
   7,
   8,
   9,
   10,
   11,
   12,
   13
}
};
static const uint8_t conversion_checker_UsualArithmeticConversions[14][14] = {
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
},
   {
   2,
   2,
   2,
   3,
   2,
   2,
   2,
   2,
   3,
   4,
   5,
   6,
   6,
   2
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
},
   {
   1,
   1,
   1,
   1,
   3,
   1,
   1,
   1,
   3,
   4,
   5,
   6,
   6,
   1
},
   {
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   3,
   4,
   5,
   6,
   6,
   3
},
   {
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   4,
   5,
   4,
   4,
   4
},
   {
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5,
   5
},
   {
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   3,
   4,
   5,
   6,
   6,
   6
},
   {
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   6,
   4,
   5,
   6,
   6,
   6
},
   {
   0,
   0,
   0,
   0,
   2,
   0,
   0,
   1,
   3,
   4,
   5,
   6,
   6,
   0
}
};
static void conversion_checker_Checker_init(conversion_checker_Checker* c, diagnostics_Diags* diags, ast_builder_Builder* builder);
static bool conversion_checker_Checker_conversionError(conversion_checker_Checker* c, const char* msg);
static bool conversion_checker_Checker_check(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, ast_Expr** e_ptr, src_loc_SrcLoc loc);
static bool conversion_checker_Checker_checkTypes(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkBuiltins(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkBuiltin2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkPointer2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkPointer2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkIntConversion(conversion_checker_Checker* c, const ast_BuiltinType* bi);
static bool conversion_checker_Checker_try_to_fix_type(conversion_checker_Checker* c);
static bool conversion_checker_pointer_conversion_allowed(ast_QualType linner, ast_QualType rinner);
static bool conversion_checker_Checker_checkPointers(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkFunc2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkEnum2Int(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkFunc2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_checkFunc2Func(const ast_FunctionDecl* fdl, const ast_FunctionDecl* fdr);
static bool conversion_checker_Checker_checkFunc2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon, bool explicit);
static bool conversion_checker_Checker_checkCast(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, src_loc_SrcLoc lhsLoc, src_loc_SrcLoc rhsLoc);
static bool conversion_checker_Checker_checkBuiltin2PointerCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static bool conversion_checker_Checker_checkPointer2BuiltinCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon);
static ast_QualType conversion_checker_get_common_arithmetic_type(ast_BuiltinType* bi1, ast_BuiltinType* bi2);
static ast_QualType conversion_checker_usual_arithmetic_conversion(const ast_BuiltinType* b1, const ast_BuiltinType* b2);
struct conversion_checker_ExprWidth_ {
   uint8_t width;
   bool is_signed;
};

static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeSmaller(conversion_checker_ExprWidth w1, conversion_checker_ExprWidth w2);
static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeWider(conversion_checker_ExprWidth w1, conversion_checker_ExprWidth w2);
static conversion_checker_ExprWidth conversion_checker_getExprWidth(const ast_Expr* e);
static conversion_checker_ExprWidth conversion_checker_getCondOpWidth(const ast_ConditionalOperator* c);
static conversion_checker_ExprWidth conversion_checker_getUnaryOpWidth(const ast_UnaryOperator* u);
static conversion_checker_ExprWidth conversion_checker_getBinOpWidth(const ast_BinaryOperator* b);
static conversion_checker_ExprWidth conversion_checker_getTypeWidth(ast_QualType qt);

static void conversion_checker_Checker_init(conversion_checker_Checker* c, diagnostics_Diags* diags, ast_builder_Builder* builder)
{
   c->diags = diags;
   c->builder = builder;
   c->native_kind = ast_getNativeKind();
}

static bool conversion_checker_Checker_conversionError(conversion_checker_Checker* c, const char* msg)
{
   diagnostics_Diags_error(c->diags, c->loc, "%s '%s' to '%s'", msg, ast_QualType_diagName(c->rhs), ast_QualType_diagName(c->lhs));
   return false;
}

static bool conversion_checker_Checker_check(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, ast_Expr** e_ptr, src_loc_SrcLoc loc)
{
   ;//assert(lhs.ptr);
   ;//assert(rhs.ptr);
   ;//assert(!ast_Expr_isNValue((*e_ptr)));
   ast_QualType t1 = ast_QualType_getCanonicalType(lhs);
   ast_QualType t2 = ast_QualType_getCanonicalType(rhs);
   if (ast_Expr_isCtv((*e_ptr)) && ast_QualType_isBuiltin(t1) && !ast_QualType_isPointer(t2)) {
      if (ast_QualType_isBool(t1)) return true;
      return ctv_analyser_checkRange(c->diags, lhs, *e_ptr);
   }
   const ast_Type* lcanon = ast_QualType_getTypeOrNil(t1);
   const ast_Type* rcanon = ast_QualType_getTypeOrNil(t2);
   if (lcanon == rcanon) {
      return true;
   }
   c->lhs = lhs;
   c->rhs = rhs;
   c->expr_ptr = e_ptr;
   c->loc = loc;
   return conversion_checker_Checker_checkTypes(c, lcanon, rcanon);
}

static bool conversion_checker_Checker_checkTypes(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   uint8_t res = conversion_checker_Conversions[ast_Type_getKind(rcanon)][ast_Type_getKind(lcanon)];
   switch (res) {
   case 0:
      diagnostics_Diags_error(c->diags, c->loc, "SHOULD NOT HAPPEN (%d - %d)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ast_QualType_dump_full(c->lhs);
      ast_QualType_dump_full(c->rhs);
      ;//assert(0);
      return false;
   case 1:
      return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
   case 2:
      return conversion_checker_Checker_checkBuiltins(c, lcanon, rcanon);
   case 3:
      return conversion_checker_Checker_checkBuiltin2Pointer(c, lcanon, rcanon);
   case 4:
      return conversion_checker_Checker_checkPointer2Builtin(c, lcanon, rcanon);
   case 5:
      return conversion_checker_Checker_checkPointers(c, lcanon, rcanon);
   case 6:
      return conversion_checker_Checker_checkPointer2Func(c, lcanon, rcanon);
   case 7:
      diagnostics_Diags_note(c->diags, c->loc, "SHOULD NOT HAPPEN (Array -> Ptr)");
      ast_QualType_dump_full(c->lhs);
      ast_QualType_dump_full(c->rhs);
      ;//assert(0);
      return false;
   case 8:
      return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
   case 9:
      return conversion_checker_Checker_conversionError(c, "conversion between struct of different types:");
   case 10:
      return conversion_checker_Checker_checkEnum2Int(c, lcanon, rcanon);
   case 11:
      return conversion_checker_Checker_checkFunc2Pointer(c, lcanon, rcanon);
   case 12:
      return conversion_checker_Checker_checkFunc2Func(c, lcanon, rcanon);
   case 13:
   case 14:
   case 15:
      return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
   case 16:
      return conversion_checker_Checker_checkFunc2Builtin(c, lcanon, rcanon, false);
   case 17:
      return true;
   default:
      diagnostics_Diags_note(c->diags, c->loc, "TODO CONVERSION  %d)", res);
      return false;
   }
}

static bool conversion_checker_Checker_checkBuiltins(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* lbuiltin = (ast_BuiltinType*)lcanon;
   const ast_BuiltinType* rbuiltin = (ast_BuiltinType*)rcanon;
   if (ast_Expr_isCtv((*c->expr_ptr))) {
      return true;
   }
   uint8_t res = conversion_checker_BuiltinConversions[ast_BuiltinType_getBaseKind(rbuiltin)][ast_BuiltinType_getBaseKind(lbuiltin)];
   switch (res) {
   case 0:
      diagnostics_Diags_error(c->diags, c->loc, "BUILTIN SHOULD NOT HAPPEN (%d - %d)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ;//assert(0);
      return false;
   case 1:
      ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      break;
   case 2:
      return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
   case 3:
      if (conversion_checker_Checker_checkIntConversion(c, lbuiltin)) {
         ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      } else {
         conversion_checker_Checker_conversionError(c, "implicit conversion changes signedness:");
      }
      break;
   case 4:
      if (conversion_checker_Checker_checkIntConversion(c, lbuiltin)) {
         ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      } else {
         conversion_checker_Checker_conversionError(c, "implicit conversion loses integer precision:");
      }
      break;
   case 5:
      conversion_checker_Checker_conversionError(c, "implicit conversion turns floating-point number into integer:");
      break;
   case 6:
      if (ast_Expr_isCtv((*c->expr_ptr))) {
         ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_IntegralCast, c->expr_ptr, c->lhs);
      } else {
         conversion_checker_Checker_conversionError(c, "implicit conversion loses floating-point precision:");
      }
      break;
   case 7:
      break;
   default:
      ;//assert(0);
      return false;
   }
   return true;
}

static bool conversion_checker_Checker_checkBuiltin2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_PointerType* ptr = (ast_PointerType*)lcanon;
   const ast_BuiltinType* bi = (ast_BuiltinType*)rcanon;
   ast_QualType inner = ast_PointerType_getInner(ptr);
   bool ok = ast_QualType_isVoid(inner);
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   ok &= (kind == ast_BuiltinKind_USize || kind == ast_BuiltinKind_UInt64);
   if (!ok) {
      return conversion_checker_Checker_conversionError(c, "incompatible integer to pointer conversion:");
   }
   return true;
}

static bool conversion_checker_Checker_checkPointer2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* bi = (ast_BuiltinType*)lcanon;
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if (kind == ast_BuiltinKind_Bool) {
      ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_PointerToBoolean, c->expr_ptr, ast_getBuiltinQT(ast_BuiltinKind_Bool));
      return true;
   }
   const ast_PointerType* ptr = (ast_PointerType*)rcanon;
   ast_QualType inner = ast_PointerType_getInner(ptr);
   bool ok = ast_QualType_isVoid(inner);
   ok &= (kind == ast_BuiltinKind_USize || kind == ast_BuiltinKind_UInt64);
   if (!ok) {
      if (conversion_checker_Checker_try_to_fix_type(c)) {
         return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
      } else {
         return conversion_checker_Checker_conversionError(c, "incompatible pointer to integer conversion:");
      }
   }
   ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_PointerToInteger, c->expr_ptr, ast_getBuiltinQT(ast_BuiltinKind_USize));
   return true;
}

static bool conversion_checker_Checker_checkPointer2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_PointerType* ptr = (ast_PointerType*)rcanon;
   ast_QualType inner = ast_PointerType_getInner(ptr);
   if (!ast_QualType_isVoid(inner)) {
      return conversion_checker_Checker_conversionError(c, "incompatible pointer to function conversion:");
   }
   ast_builder_Builder_insertImplicitCast(c->builder, ast_ImplicitCastKind_BitCast, c->expr_ptr, c->lhs);
   return true;
}

static bool conversion_checker_Checker_checkIntConversion(conversion_checker_Checker* c, const ast_BuiltinType* bi)
{
   ast_Expr* e = *c->expr_ptr;
   uint32_t wl = ast_BuiltinType_getWidth(bi);
   conversion_checker_ExprWidth w = conversion_checker_getExprWidth(e);
   if (w.width > wl) return false;
   if (w.is_signed != ast_BuiltinType_isSigned(bi)) {
      if (!w.is_signed) return w.width < wl;
      if (!ast_Expr_isPositiveOrUB(e)) return false;
   }
   return true;
}

static bool conversion_checker_Checker_try_to_fix_type(conversion_checker_Checker* c)
{
   ast_Expr* e = *c->expr_ptr;
   if (ast_Expr_isImplicitCast(e)) {
      const ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)e;
      if (ast_ImplicitCastExpr_isArrayToPointerDecay(ic)) {
         e = ast_ImplicitCastExpr_getInner(ic);
         c->rhs = ast_Expr_getType(e);
         return true;
      }
   }
   return false;
}

static bool conversion_checker_pointer_conversion_allowed(ast_QualType linner, ast_QualType rinner)
{
   const ast_Type* in1 = ast_QualType_getTypeOrNil(linner);
   const ast_Type* in2 = ast_QualType_getTypeOrNil(rinner);
   if (in1 == in2) return true;
   if (ast_Type_isVoidType(in1)) return true;
   if (ast_Type_isVoidType(in2)) return true;
   if (ast_QualType_isUInt8(linner) && ast_QualType_isChar(rinner)) return true;
   if (ast_QualType_isChar(linner) && ast_QualType_isUInt8(rinner)) return true;
   return false;
}

static bool conversion_checker_Checker_checkPointers(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_PointerType* ltype = (ast_PointerType*)lcanon;
   const ast_PointerType* rtype = (ast_PointerType*)rcanon;
   ast_QualType linner = ast_PointerType_getInner(ltype);
   ast_QualType rinner = ast_PointerType_getInner(rtype);
   if (!conversion_checker_pointer_conversion_allowed(linner, rinner)) {
      if (conversion_checker_Checker_try_to_fix_type(c)) {
         return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
      } else {
         return conversion_checker_Checker_conversionError(c, "invalid pointer conversion from");
      }
   }
   uint32_t rquals = ast_QualType_getQuals(rinner);
   if (rquals == 0) return true;
   uint32_t lquals = ast_QualType_getQuals(linner);
   uint32_t discarded = (rquals & ~lquals) & (ast_QualType_Const | ast_QualType_Volatile);
   if (discarded) {
      switch (discarded) {
      case ast_QualType_Const:
         diagnostics_Diags_error(c->diags, c->loc, "pointer conversion discards const qualifier");
         return false;
      case ast_QualType_Volatile:
         diagnostics_Diags_error(c->diags, c->loc, "pointer conversion discards volatile qualifier");
         return false;
      default:
         diagnostics_Diags_error(c->diags, c->loc, "pointer conversion discards qualifiers");
         return false;
      }
   }
   return true;
}

static bool conversion_checker_Checker_checkFunc2Pointer(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   ast_PointerType* pt = (ast_PointerType*)lcanon;
   ast_QualType inner = ast_PointerType_getInner(pt);
   if (ast_QualType_isVoid(inner)) return true;
   return conversion_checker_Checker_conversionError(c, "invalid pointer conversion from");
}

static bool conversion_checker_Checker_checkEnum2Int(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* bi = (ast_BuiltinType*)lcanon;
   uint32_t width = ast_BuiltinType_getWidth(bi);
   if (width == 64) return true;
   if (ast_Expr_isCtv((*c->expr_ptr))) {
      return ctv_analyser_checkRange(c->diags, c->lhs, *c->expr_ptr);
   } else {
      const ast_EnumType* et = (ast_EnumType*)rcanon;
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_QualType impl = ast_EnumTypeDecl_getImplType(etd);
      return conversion_checker_Checker_check(c, c->lhs, impl, c->expr_ptr, c->loc);
   }
}

static bool conversion_checker_Checker_checkFunc2Func(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   ast_FunctionType* ftl = (ast_FunctionType*)lcanon;
   ast_FunctionDecl* fdl = ast_FunctionType_getDecl(ftl);
   ast_FunctionType* ftr = (ast_FunctionType*)rcanon;
   ast_FunctionDecl* fdr = ast_FunctionType_getDecl(ftr);
   if (ast_FunctionDecl_getNumAutoArgs(fdr)) {
      diagnostics_Diags_error(c->diags, c->loc, "functions used as function pointers cannot have auto-arguments");
      return false;
   }
   if (!conversion_checker_checkFunc2Func(fdl, fdr)) {
      return conversion_checker_Checker_conversionError(c, "invalid function conversion from");
   }
   return true;
}

static bool conversion_checker_checkFunc2Func(const ast_FunctionDecl* fdl, const ast_FunctionDecl* fdr)
{
   ast_QualType ql = ast_FunctionDecl_getRType(fdl);
   ast_QualType qr = ast_FunctionDecl_getRType(fdr);
   if (ql.ptr != qr.ptr) return false;
   uint32_t num1 = ast_FunctionDecl_getNumParams(fdl);
   uint32_t num2 = ast_FunctionDecl_getNumParams(fdr);
   if (num1 != num2) return false;
   ast_Decl** args1 = (ast_Decl**)ast_FunctionDecl_getParams(fdl);
   ast_Decl** args2 = (ast_Decl**)ast_FunctionDecl_getParams(fdr);
   for (uint32_t i = 0; i < num1; i++) {
      ast_Decl* a1 = args1[i];
      ast_Decl* a2 = args2[i];
      ql = ast_Decl_getType(a1);
      qr = ast_Decl_getType(a2);
      if (ql.ptr != qr.ptr) {
         if (ast_QualType_isFunction(ql) && ast_QualType_isFunction(qr)) {
            ast_FunctionType* ft = ast_QualType_getFunctionType(ql);
            ast_FunctionDecl* fd1 = ast_FunctionType_getDecl(ft);
            ft = ast_QualType_getFunctionType(qr);
            ast_FunctionDecl* fd2 = ast_FunctionType_getDecl(ft);
            if (conversion_checker_checkFunc2Func(fd1, fd2)) continue;
         }
         return false;
      }
   }
   if (ast_FunctionDecl_isVariadic(fdl) != ast_FunctionDecl_isVariadic(fdr)) return false;
   return true;
}

static bool conversion_checker_Checker_checkFunc2Builtin(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon, bool explicit)
{
   const ast_BuiltinType* bi = (ast_BuiltinType*)lcanon;
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if (kind == ast_BuiltinKind_USize) return true;
   if (kind == ast_BuiltinKind_Bool) {
      ast_FunctionType* ft = (ast_FunctionType*)rcanon;
      ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      if (ast_FunctionDecl_canBeNil(fd)) return true;
      diagnostics_Diags_error(c->diags, c->loc, "comparison of function '%s' will always be true", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      return false;
   }
   if (kind == c->native_kind) return true;
   if (explicit) {
      diagnostics_Diags_error(c->diags, c->loc, "pointers may only be cast to integer type '%s'", ast_BuiltinKind_str(c->native_kind));
      return false;
   } else {
      return conversion_checker_Checker_conversionError(c, "invalid type conversion from");
   }
}

static bool conversion_checker_Checker_checkCast(conversion_checker_Checker* c, ast_QualType lhs, ast_QualType rhs, src_loc_SrcLoc lhsLoc, src_loc_SrcLoc rhsLoc)
{
   c->lhs = lhs;
   c->rhs = rhs;
   c->loc = lhsLoc;
   c->expr_ptr = NULL;
   if (lhsLoc == 0) c->loc = rhsLoc;
   ast_QualType t1 = ast_QualType_getCanonicalType(lhs);
   ast_QualType t2 = ast_QualType_getCanonicalType(rhs);
   const ast_Type* lcanon = ast_QualType_getTypeOrNil(t1);
   const ast_Type* rcanon = ast_QualType_getTypeOrNil(t2);
   uint8_t res = conversion_checker_Conversions[ast_Type_getKind(rcanon)][ast_Type_getKind(lcanon)];
   switch (res) {
   case 0:
      diagnostics_Diags_error(c->diags, lhsLoc, "SHOULD NOT HAPPEN (%d - %d)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ast_QualType_dump_full(c->lhs);
      ast_QualType_dump_full(c->rhs);
      ;//assert(0);
      return false;
   case 1:
      return conversion_checker_Checker_conversionError(c, "invalid cast from");
   case 2:
      return true;
   case 3:
      return conversion_checker_Checker_checkBuiltin2PointerCast(c, lcanon, rcanon);
   case 4:
      return conversion_checker_Checker_checkPointer2BuiltinCast(c, lcanon, rcanon);
   case 5:
      return true;
   case 6:
      return true;
   case 7:
      diagnostics_Diags_note(c->diags, c->loc, "SHOULD NOT HAPPEN (Array -> Ptr)");
      ;//assert(0);
      return false;
   case 8:
      diagnostics_Diags_error(c->diags, lhsLoc, "SHOULD NOT HAPPEN (%d - %d)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ;//assert(0);
      return false;
   case 9:
      diagnostics_Diags_error(c->diags, lhsLoc, "SHOULD NOT HAPPEN (%d - %d)\n", ast_Type_getKind(lcanon), ast_Type_getKind(rcanon));
      ;//assert(0);
      return false;
   case 10:
      return true;
   case 11:
      return true;
   case 12:
      return true;
   case 13:
      return true;
   case 14:
      return true;
   case 15:
      return conversion_checker_Checker_checkBuiltin2PointerCast(c, lcanon, rcanon);
   case 16:
      return conversion_checker_Checker_checkFunc2Builtin(c, lcanon, rcanon, true);
   default:
      diagnostics_Diags_note(c->diags, c->loc, "TODO CONVERSION  %d)", res);
      return false;
   }
}

static bool conversion_checker_Checker_checkBuiltin2PointerCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* bi = (ast_BuiltinType*)rcanon;
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if (kind == ast_BuiltinKind_USize) return true;
   if (kind == c->native_kind) return true;
   diagnostics_Diags_error(c->diags, c->loc, "only integers of type '%s' may be cast to a pointer", ast_BuiltinKind_str(c->native_kind));
   return false;
}

static bool conversion_checker_Checker_checkPointer2BuiltinCast(conversion_checker_Checker* c, const ast_Type* lcanon, const ast_Type* rcanon)
{
   const ast_BuiltinType* bi = (ast_BuiltinType*)lcanon;
   ast_BuiltinKind kind = ast_BuiltinType_getKind(bi);
   if (kind == ast_BuiltinKind_USize) return true;
   if (kind == c->native_kind) return true;
   diagnostics_Diags_error(c->diags, c->loc, "pointers may only be cast to integer type '%s'", ast_BuiltinKind_str(c->native_kind));
   return false;
}

static ast_QualType conversion_checker_get_common_arithmetic_type(ast_BuiltinType* bi1, ast_BuiltinType* bi2)
{
   ast_BuiltinKind kind = (ast_BuiltinKind)conversion_checker_ConditionalOperatorResult[ast_BuiltinType_getBaseKind(bi2)][ast_BuiltinType_getBaseKind(bi1)];
   return ast_getBuiltinQT(kind);
}

static ast_QualType conversion_checker_usual_arithmetic_conversion(const ast_BuiltinType* b1, const ast_BuiltinType* b2)
{
   ast_BuiltinKind k1 = ast_BuiltinType_getBaseKind(b1);
   ast_BuiltinKind k2 = ast_BuiltinType_getBaseKind(b2);
   switch (conversion_checker_UsualArithmeticConversions[k2][k1]) {
   case 0:
      return ast_getBuiltinQT(ast_BuiltinKind_Int32);
   case 1:
      return ast_getBuiltinQT(ast_BuiltinKind_UInt32);
   case 2:
      return ast_getBuiltinQT(ast_BuiltinKind_Int64);
   case 3:
      return ast_getBuiltinQT(ast_BuiltinKind_UInt64);
   case 4:
      return ast_getBuiltinQT(ast_BuiltinKind_Float32);
   case 5:
      return ast_getBuiltinQT(ast_BuiltinKind_Float64);
   case 6:
      break;
   }
   return ast_QualType_Invalid;
}

static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeSmaller(conversion_checker_ExprWidth w1, conversion_checker_ExprWidth w2)
{
   conversion_checker_ExprWidth result;
   result.width = (w1.width < w2.width) ? w1.width : w2.width;
   result.is_signed = w1.is_signed | w2.is_signed;
   return result;
}

static conversion_checker_ExprWidth conversion_checker_ExprWidth_mergeWider(conversion_checker_ExprWidth w1, conversion_checker_ExprWidth w2)
{
   conversion_checker_ExprWidth result;
   if (w1.is_signed != w2.is_signed) {
      if (w1.is_signed && w2.width < 32) w2.width += 1;
      if (w2.is_signed && w1.width < 32) w1.width += 1;
   }
   result.width = (w1.width > w2.width) ? w1.width : w2.width;
   result.is_signed = w1.is_signed | w2.is_signed;
   return result;
}

static conversion_checker_ExprWidth conversion_checker_getExprWidth(const ast_Expr* e)
{
   conversion_checker_ExprWidth result = { };
   if (ast_Expr_isCtv(e)) {
      ast_Value v = ast_evalExpr(e);
      result.width = ast_Value_getWidth(&v);
      result.is_signed = ast_Value_isNegative(&v);
      return result;
   }
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier:
      return conversion_checker_getTypeWidth(ast_Expr_getType(e));
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      return conversion_checker_getTypeWidth(ast_Expr_getType(e));
   case ast_ExprKind_InitList:
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      return conversion_checker_getBinOpWidth((ast_BinaryOperator*)e);
   case ast_ExprKind_UnaryOperator:
      return conversion_checker_getUnaryOpWidth((ast_UnaryOperator*)e);
   case ast_ExprKind_ConditionalOperator:
      return conversion_checker_getCondOpWidth((ast_ConditionalOperator*)e);
   case ast_ExprKind_Builtin:
      break;
   case ast_ExprKind_ArraySubscript:
      fallthrough;
   case ast_ExprKind_Member:
      return conversion_checker_getTypeWidth(ast_Expr_getType(e));
   case ast_ExprKind_Paren: {
      const ast_ParenExpr* p = (ast_ParenExpr*)e;
      return conversion_checker_getExprWidth(ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast:
      return conversion_checker_getTypeWidth(ast_Expr_getType(e));
   case ast_ExprKind_ImplicitCast: {
      const ast_ImplicitCastExpr* c = (ast_ImplicitCastExpr*)e;
      return conversion_checker_getExprWidth(ast_ImplicitCastExpr_getInner(c));
   }
   case ast_ExprKind_Range: {
      ast_RangeExpr* b = (ast_RangeExpr*)e;
      conversion_checker_ExprWidth lhs = conversion_checker_getExprWidth(ast_RangeExpr_getLHS(b));
      conversion_checker_ExprWidth rhs = conversion_checker_getExprWidth(ast_RangeExpr_getRHS(b));
      return conversion_checker_ExprWidth_mergeWider(lhs, rhs);
   }
   case ast_ExprKind_NamedArgument: {
      const ast_NamedArgument* n = (ast_NamedArgument*)e;
      return conversion_checker_getExprWidth(ast_NamedArgument_getInner(n));
   }
   case ast_ExprKind_Alternate: {
      const ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      return conversion_checker_getExprWidth(ast_AlternateExpr_getOriginal(n));
   }
   }
   ast_Expr_dump(e);
   ;//assert(0);
   return result;
}

static conversion_checker_ExprWidth conversion_checker_getCondOpWidth(const ast_ConditionalOperator* c)
{
   conversion_checker_ExprWidth lhs = conversion_checker_getExprWidth(ast_ConditionalOperator_getLHS(c));
   conversion_checker_ExprWidth rhs = conversion_checker_getExprWidth(ast_ConditionalOperator_getRHS(c));
   return conversion_checker_ExprWidth_mergeWider(lhs, rhs);
}

static conversion_checker_ExprWidth conversion_checker_getUnaryOpWidth(const ast_UnaryOperator* u)
{
   conversion_checker_ExprWidth w;
   switch (ast_UnaryOperator_getOpcode(u)) {
   case ast_UnaryOpcode_PostInc:
   case ast_UnaryOpcode_PostDec:
   case ast_UnaryOpcode_PreInc:
   case ast_UnaryOpcode_PreDec:
   case ast_UnaryOpcode_Plus:
      return conversion_checker_getExprWidth(ast_UnaryOperator_getInner(u));
   case ast_UnaryOpcode_AddrOf:
      w.width = (uint8_t)(ast_getWordSize() * 8);
      w.is_signed = false;
      break;
   case ast_UnaryOpcode_Deref: {
      ast_Expr* e = (ast_Expr*)u;
      return conversion_checker_getTypeWidth(ast_Expr_getType(e));
   }
   case ast_UnaryOpcode_Minus:
      w = conversion_checker_getExprWidth(ast_UnaryOperator_getInner(u));
      w.is_signed = true;
      break;
   case ast_UnaryOpcode_Not:
      w = conversion_checker_getExprWidth(ast_UnaryOperator_getInner(u));
      w.is_signed = false;
      break;
   case ast_UnaryOpcode_LNot:
      w.width = 1;
      w.is_signed = false;
      break;
   }
   return w;
}

static conversion_checker_ExprWidth conversion_checker_getBinOpWidth(const ast_BinaryOperator* b)
{
   switch (ast_BinaryOperator_getOpcode(b)) {
   case ast_BinaryOpcode_Multiply:
      break;
   case ast_BinaryOpcode_Divide:
      return conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
   case ast_BinaryOpcode_Remainder:
      return conversion_checker_getExprWidth(ast_BinaryOperator_getRHS(b));
   case ast_BinaryOpcode_Add:
   case ast_BinaryOpcode_Subtract:
      break;
   case ast_BinaryOpcode_ShiftLeft: {
      conversion_checker_ExprWidth result = conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
      if (result.width < 32) {
         result.width = 32;
         result.is_signed = true;
      }
      return result;
   }
   case ast_BinaryOpcode_ShiftRight:
      return conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
   case ast_BinaryOpcode_LessThan:
   case ast_BinaryOpcode_GreaterThan:
   case ast_BinaryOpcode_LessEqual:
   case ast_BinaryOpcode_GreaterEqual:
   case ast_BinaryOpcode_Equal:
   case ast_BinaryOpcode_NotEqual: {
      conversion_checker_ExprWidth result = { .width = 1, .is_signed = false };
      return result;
   }
   case ast_BinaryOpcode_And: {
      conversion_checker_ExprWidth l = conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
      conversion_checker_ExprWidth r = conversion_checker_getExprWidth(ast_BinaryOperator_getRHS(b));
      return conversion_checker_ExprWidth_mergeSmaller(l, r);
   }
   case ast_BinaryOpcode_Xor:
   case ast_BinaryOpcode_Or:
      break;
   case ast_BinaryOpcode_LAnd:
   case ast_BinaryOpcode_LOr: {
      conversion_checker_ExprWidth result = { .width = 1, .is_signed = false };
      return result;
   }
   case ast_BinaryOpcode_Assign:
   case ast_BinaryOpcode_MulAssign:
   case ast_BinaryOpcode_DivAssign:
   case ast_BinaryOpcode_RemAssign:
   case ast_BinaryOpcode_AddAssign:
   case ast_BinaryOpcode_SubAssign:
   case ast_BinaryOpcode_ShlAssign:
   case ast_BinaryOpcode_ShrAssign:
   case ast_BinaryOpcode_AndAssign:
   case ast_BinaryOpcode_XorAssign:
   case ast_BinaryOpcode_OrAssign:
      return conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
   }
   conversion_checker_ExprWidth lhs = conversion_checker_getExprWidth(ast_BinaryOperator_getLHS(b));
   conversion_checker_ExprWidth rhs = conversion_checker_getExprWidth(ast_BinaryOperator_getRHS(b));
   return conversion_checker_ExprWidth_mergeWider(lhs, rhs);
}

static conversion_checker_ExprWidth conversion_checker_getTypeWidth(ast_QualType qt)
{
   qt = ast_QualType_getCanonicalType(qt);
   if (ast_QualType_isEnum(qt)) {
      ast_EnumType* et = ast_QualType_getEnumType(qt);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      uint32_t num = ast_EnumTypeDecl_getNumConstants(etd);
      ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
      ast_Value vmax = ast_EnumConstantDecl_getValue(constants[num - 1]);
      conversion_checker_ExprWidth result = { .width = ast_Value_getWidth(&vmax) };
      return result;
   }
   if (ast_QualType_isBuiltin(qt)) {
      const ast_BuiltinType* bi = ast_QualType_getBuiltin(qt);
      conversion_checker_ExprWidth result = { .width = (uint8_t)(ast_BuiltinType_getWidth(bi)), .is_signed = ast_BuiltinType_isSigned(bi) };
      return result;
   }
   conversion_checker_ExprWidth result = { .width = (uint8_t)(ast_getWordSize() * 8), .is_signed = false };
   return result;
}


// --- module module_analyser ---
typedef struct module_analyser_Analyser_ module_analyser_Analyser;
typedef struct module_analyser_StackLayer_ module_analyser_StackLayer;
typedef struct module_analyser_MainMarker_ module_analyser_MainMarker;
typedef struct module_analyser_FindMemberOffsetContext_ module_analyser_FindMemberOffsetContext;
typedef struct module_analyser_FormatAnalyser_ module_analyser_FormatAnalyser;
typedef struct module_analyser_FillInfo_ module_analyser_FillInfo;
typedef struct module_analyser_StructFieldInitChecker_ module_analyser_StructFieldInitChecker;

struct module_analyser_StackLayer_ {
   ast_Decl* decl;
   scope_Scope* scope;
   ast_FunctionDecl* function;
   bool usedPublic;
};

#define module_analyser_MaxDepth 8
struct module_analyser_Analyser_ {
   diagnostics_Diags* diags;
   conversion_checker_Checker checker;
   ast_context_Context* context;
   string_pool_Pool* astPool;
   ast_builder_Builder* builder;
   module_list_List* allmodules;
   const warning_flags_Flags* warnings;
   ast_Module* mod;
   bool usedPublic;
   uint32_t prefix_cache_name;
   uint32_t prefix_cache_idx;
   name_vector_NameVector prefixes;
   struct_func_list_List* type_fn_decls;
   incr_array_list_List* incr_values;
   label_vector_LabelVector labels;
   module_analyser_StackLayer checkStack[8];
   uint32_t checkIndex;
   scope_Scope* scope;
   ast_FunctionDecl* curFunction;
   bool has_error;
   uint32_t check_idx;
   init_checker_Checker init_checkers[4];
   uint32_t min_idx;
   uint32_t max_idx;
};

struct module_analyser_MainMarker_ {
   uint32_t name_idx;
   ast_Decl* main;
};

#define module_analyser_LHS 0x1
#define module_analyser_RHS 0x2
static module_analyser_Analyser* module_analyser_create(diagnostics_Diags* diags, ast_context_Context* context, string_pool_Pool* astPool, ast_builder_Builder* builder, module_list_List* allmodules, const warning_flags_Flags* warnings);
static void module_analyser_Analyser_free(module_analyser_Analyser* ma);
static void module_analyser_Analyser_check(module_analyser_Analyser* ma, ast_Module* mod);
static init_checker_Checker* module_analyser_Analyser_getInitChecker(module_analyser_Analyser* ma);
static void module_analyser_Analyser_putInitChecker(module_analyser_Analyser* ma, init_checker_Checker* c);
static void module_analyser_Analyser_collectTypeFunctions(module_analyser_Analyser* ma);
static void module_analyser_Analyser_handleArrayValue(void* arg, ast_ArrayValue* avd);
static void module_analyser_Analyser_collectIncrementalArrays(module_analyser_Analyser* ma);
static void module_analyser_Analyser_handleIncrEntry(module_analyser_Analyser* ma, incr_array_list_Info* entry);
static void module_analyser_Analyser_handleImport(void* arg, ast_ImportDecl* id);
static void module_analyser_Analyser_setMod(module_analyser_Analyser* ma, ast_Module* mod);
__attribute__((__format__(printf, 3, 4)))
static void module_analyser_Analyser_note(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...);
__attribute__((__format__(printf, 3, 4)))
static void module_analyser_Analyser_warn(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...);
__attribute__((__format__(printf, 3, 4)))
static void module_analyser_Analyser_error(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...);
__attribute__((__format__(printf, 4, 5)))
static void module_analyser_Analyser_errorRange(module_analyser_Analyser* ma, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...);
static void module_analyser_Analyser_createGlobalScope(void* arg, ast_AST* a);
static void module_analyser_Analyser_deleteScope(void* _arg0, ast_AST* a);
static void module_analyser_Analyser_handleStructFunc(void* arg, ast_FunctionDecl* fd);
static void module_analyser_Analyser_analyseFunctionProto(void* arg, ast_FunctionDecl* d);
static void module_analyser_Analyser_analyseFunctionBodies(void* arg, ast_FunctionDecl* d);
static bool module_analyser_Analyser_analyseGlobalDecl(module_analyser_Analyser* ma, ast_Decl* d);
static void module_analyser_Analyser_handleTypeDecl(void* arg, ast_Decl* d);
static void module_analyser_Analyser_handleStaticAssert(void* arg, ast_StaticAssert* d);
static void module_analyser_Analyser_handleVarDecl(void* arg, ast_VarDecl* v);
static void module_analyser_Analyser_checkName(module_analyser_Analyser* ma, ast_Decl* d, bool is_constant);
static void module_analyser_Analyser_analyseGlobalVarDecl(module_analyser_Analyser* ma, ast_VarDecl* v);
static void module_analyser_Analyser_checkVarDeclAttributes(module_analyser_Analyser* ma, ast_VarDecl* v);
static bool module_analyser_Analyser_pushCheck(module_analyser_Analyser* ma, ast_Decl* d, scope_Scope* s, ast_FunctionDecl* fd);
static void module_analyser_Analyser_popCheck(module_analyser_Analyser* ma);
static bool module_analyser_Analyser_globalScope(const module_analyser_Analyser* ma);
static void module_analyser_findMainFunction(void* arg, ast_FunctionDecl* fd);
static ast_Decl* module_analyser_Analyser_findMain(module_analyser_Analyser* ma, ast_Module* top, uint32_t name_idx);
static const uint32_t module_analyser_Binop_lhs[29] = {
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_RHS,
   module_analyser_LHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS,
   module_analyser_LHS | module_analyser_RHS
};
static const uint8_t module_analyser_BinOpConvAddSubAss[9][9] = {
   {
   4,
   2,
   0,
   2,
   5,
   2,
   2,
   0,
   0
},
   {
   6,
   3,
   0,
   2,
   6,
   2,
   2,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
},
   {
   7,
   1,
   0,
   2,
   8,
   2,
   2,
   0,
   0
},
   {
   1,
   3,
   0,
   3,
   1,
   3,
   3,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
}
};
static const uint8_t module_analyser_BinOpConvAdd[9][9] = {
   {
   4,
   7,
   0,
   2,
   5,
   2,
   2,
   0,
   0
},
   {
   8,
   3,
   0,
   2,
   8,
   3,
   2,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
},
   {
   6,
   7,
   0,
   2,
   3,
   2,
   2,
   0,
   0
},
   {
   1,
   3,
   0,
   3,
   1,
   3,
   3,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
}
};
static const uint8_t module_analyser_BinOpConvSub[9][9] = {
   {
   4,
   3,
   0,
   2,
   5,
   2,
   2,
   0,
   0
},
   {
   8,
   9,
   0,
   1,
   8,
   2,
   2,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
},
   {
   6,
   3,
   0,
   2,
   7,
   2,
   2,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
},
   {
   1,
   1,
   0,
   3,
   1,
   3,
   3,
   0,
   0
}
};
static const uint8_t module_analyser_BinOpConvComparison[9][9] = {
   {
   2,
   1,
   0,
   11,
   3,
   0,
   11,
   0,
   0
},
   {
   1,
   4,
   0,
   11,
   1,
   7,
   11,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   10,
   10,
   0,
   1,
   10,
   10,
   1,
   0,
   0
},
   {
   5,
   1,
   0,
   11,
   6,
   1,
   11,
   0,
   0
},
   {
   1,
   8,
   0,
   11,
   1,
   9,
   1,
   0,
   0
},
   {
   10,
   10,
   0,
   1,
   10,
   1,
   1,
   0,
   0
}
};
static bool module_analyser_validArithType(ast_QualType t);
static bool module_analyser_validIntegerType(ast_QualType t);
static bool module_analyser_validTestType(ast_QualType t);
static ast_QualType module_analyser_Analyser_invalidBinOp1(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_Expr* sub, ast_QualType qt);
static ast_QualType module_analyser_Analyser_invalidBinOp2(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_invalidFuncCompare(module_analyser_Analyser* ma, ast_BinaryOperator* b);
static ast_QualType module_analyser_Analyser_checkBinopArithArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, bool assign);
static ast_QualType module_analyser_Analyser_checkBinopIntArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, bool assign);
static ast_QualType module_analyser_Analyser_checkBinopShiftArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType ltype, ast_QualType rtype, bool assign);
static ast_QualType module_analyser_Analyser_checkBinopLogical(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopAddSubAssign(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopAddArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopSubArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs);
static ast_QualType module_analyser_Analyser_checkBinopComparison(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, bool is_relative);
static ast_QualType module_analyser_Analyser_checkFuncTest(module_analyser_Analyser* ma, ast_FunctionType* ft, src_loc_SrcLoc loc);
static bool module_analyser_incompatible_opcodes(ast_BinaryOpcode op1, ast_BinaryOpcode op2);
static bool module_analyser_Analyser_checkAmbiguousOperators(module_analyser_Analyser* ma, ast_BinaryOpcode opcode, ast_Expr* sub);
static ast_QualType module_analyser_Analyser_analyseBinaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static bool module_analyser_Analyser_checkZero(module_analyser_Analyser* ma, ast_Expr* e, const char* operation);
struct module_analyser_FindMemberOffsetContext_ {
   ast_StructTypeDecl* std;
   uint32_t base_offset;
};

static ast_QualType module_analyser_Analyser_analyseBuiltin(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static ast_QualType module_analyser_Analyser_analyseSizeof(module_analyser_Analyser* ma, ast_BuiltinExpr* e);
static ast_QualType module_analyser_Analyser_analyseElemsof(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_QualType module_analyser_Analyser_analyseEnumMinMax(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_QualType module_analyser_Analyser_analyseOffsetOf(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_QualType module_analyser_Analyser_analyseToContainer(module_analyser_Analyser* ma, ast_BuiltinExpr* b);
static ast_Decl* module_analyser_Analyser_findMemberOffsetAux(module_analyser_Analyser* ma, module_analyser_FindMemberOffsetContext* ctx, ast_Expr* member);
static ast_Decl* module_analyser_Analyser_findMemberOffset(module_analyser_Analyser* ma, ast_BuiltinExpr* b, ast_StructTypeDecl* std, ast_Expr* member);
static ast_Decl* module_analyser_Analyser_findStructMemberOffset(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc, uint32_t* base);
struct module_analyser_FormatAnalyser_ {
   module_analyser_Analyser* ma;
   const char* format;
   ast_Expr** args;
   uint32_t num_args;
   uint32_t idx;
   src_loc_SrcLoc loc;
   uint32_t last_offset;
   string_buffer_Buf* out;
   ast_FormatAttr format_attr;
};

static const char module_analyser_DiagTooManyArgs[60] = "too many arguments to %sfunction call, expected %d, have %d";
static const char module_analyser_DiagTooFewArgs[59] = "too few arguments to %sfunction call, expected %d, have %d";
static const char module_analyser_NoteDeclaredHere[21] = "'%s' is defined here";
static ast_QualType module_analyser_Analyser_analyseCallExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static bool module_analyser_on_printf_specifier(void* context, uint32_t offset, printf_utils_PrintfSpecifier specifier, printf_utils_PrintfConversion* conv);
static bool module_analyser_on_scanf_specifier(void* context, uint32_t offset, printf_utils_ScanfSpecifier specifier, printf_utils_ScanfConversion* conv);
static const char* module_analyser_get_format(ast_Expr* format, src_loc_SrcLoc* format_loc);
static bool module_analyser_Analyser_checkFormatArgs(module_analyser_Analyser* ma, ast_Expr** format_ptr, uint32_t num_args, ast_Expr** args, ast_FormatAttr format_attr);
static void module_analyser_create_template_name(char* name, const char* orig, uint16_t idx);
static void module_analyser_Analyser_opaque_callback(void* arg, src_loc_SrcLoc loc, ast_Decl* d);
static ast_FunctionDecl* module_analyser_Analyser_instantiateTemplateFunction(module_analyser_Analyser* ma, ast_CallExpr* call, ast_FunctionDecl* fd);
static ast_QualType module_analyser_Analyser_analysePureCallExpr(module_analyser_Analyser* ma, ast_Expr* e);
static const uint8_t module_analyser_CondOpTable[9][9] = {
   {
   2,
   1,
   0,
   1,
   3,
   0,
   1,
   0,
   0
},
   {
   1,
   4,
   0,
   1,
   1,
   7,
   1,
   0,
   0
},
   {
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0
},
   {
   1,
   1,
   0,
   10,
   1,
   1,
   1,
   0,
   0
},
   {
   5,
   1,
   0,
   1,
   6,
   1,
   1,
   0,
   0
},
   {
   1,
   8,
   0,
   1,
   1,
   9,
   1,
   0,
   0
},
   {
   1,
   1,
   0,
   1,
   1,
   1,
   11,
   0,
   0
}
};
static ast_QualType module_analyser_Analyser_analyseExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, bool need_rvalue, uint32_t side);
static ast_QualType module_analyser_Analyser_convertRvalue(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType result);
static ast_QualType module_analyser_Analyser_analyseExprInner(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static const char* module_analyser_type2str(ast_QualType q);
static ast_Decl* module_analyser_Analyser_analyseIdentifier(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static ast_IdentifierKind module_analyser_Analyser_setExprFlags(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_Decl* d);
static ast_QualType module_analyser_Analyser_analyseConditionalOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static bool module_analyser_Analyser_checkAssignment(module_analyser_Analyser* ma, ast_Expr* assignee, ast_QualType tleft, const char* msg, src_loc_SrcLoc loc);
static ast_QualType module_analyser_usualUnaryConversions(ast_Expr* e);
static ast_QualType module_analyser_Analyser_analyseExplicitCast(module_analyser_Analyser* ma, ast_Expr** e_ptr);
static ast_QualType module_analyser_Analyser_analyseArraySubscriptExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static ast_QualType module_analyser_Analyser_analyseBitOffsetExpr(module_analyser_Analyser* ma, ast_QualType ltype, ast_Expr* base, ast_Expr* e);
static bool module_analyser_Analyser_analyseBitOffsetIndex(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType baseType, ast_Value* result);
static void module_analyser_Analyser_memberError(module_analyser_Analyser* ma, uint32_t name_idx, src_loc_SrcLoc loc, ast_StructTypeDecl* s);
static ast_Decl* module_analyser_Analyser_findStructMember(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc);
static ast_QualType module_analyser_getPointerFromArray(ast_builder_Builder* builder, ast_QualType q);
static void module_analyser_Analyser_analyseFunction(module_analyser_Analyser* ma, ast_FunctionDecl* fd);
static void module_analyser_Analyser_analyseFunctionBody(module_analyser_Analyser* ma, ast_FunctionDecl* fd, scope_Scope* s);
static void module_analyser_Analyser_checkFormatArgument(module_analyser_Analyser* ma, ast_VarDecl* vd, ast_QualType qt, uint32_t idx, ast_FunctionDecl* fd, ast_FormatAttr format_attr);
struct module_analyser_FillInfo_ {
   ast_FieldInitInfo* fii;
   uint32_t member_idx;
   uint32_t idx;
};

static bool module_analyser_Analyser_analyseInitExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType, src_loc_SrcLoc assignLoc, bool is_bitfield, bool is_default_param);
static bool module_analyser_Analyser_checkEnumArg(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType);
static bool module_analyser_Analyser_analyseInitListExpr(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType);
static bool module_analyser_Analyser_analyseArrayDesignatedInit(module_analyser_Analyser* ma, ast_Expr* e, ast_QualType expectedType, bool isEnumIndex, ast_QualType indexType);
static bool module_analyser_Analyser_analyseInitListArray(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType);
static bool module_analyser_Analyser_checkArrayDesignators(module_analyser_Analyser* ma, ast_InitListExpr* ile, bool has_size, uint32_t* size, init_checker_Checker* checker);
static void module_analyser_fillFieldInfo(ast_StructTypeDecl* std, module_analyser_FillInfo* fi, uint32_t base_offset);
static const ast_FieldInitInfo* module_analyser_Analyser_getFieldInfo(module_analyser_Analyser* ma, ast_StructTypeDecl* std);
static bool module_analyser_Analyser_analyseStructFieldInit(module_analyser_Analyser* ma, ast_StructTypeDecl* std, ast_InitListExpr* ile, ast_QualType expectedType);
static bool module_analyser_Analyser_analyseInitListStruct(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType);
static const char module_analyser_DiagStaticThoughVar[52] = "cannot access static type-function through variable";
static ast_QualType module_analyser_Analyser_analyseMemberExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static ast_Decl* module_analyser_Analyser_analyseStructMemberAccess(module_analyser_Analyser* ma, ast_StructTypeDecl* std, uint32_t name_idx, src_loc_SrcLoc loc, ast_ValType valtype, uint32_t side, ast_CallKind* ck);
static ast_TypeKind module_analyser_Analyser_analyseBaseType(module_analyser_Analyser* ma, ast_QualType baseType);
static ast_ValType module_analyser_decl2valtype(const ast_Decl* d);
typedef uint8_t module_analyser_Flow;
enum module_analyser_Flow {
   module_analyser_Flow_Next,
   module_analyser_Flow_Return,
   module_analyser_Flow_Break,
   module_analyser_Flow_Continue,
   module_analyser_Flow_Goto,
   module_analyser_Flow_NoReturn,
   module_analyser_Flow_Error,
};

typedef uint32_t module_analyser_FlowBits;
#define module_analyser_FlowNext (1 << module_analyser_Flow_Next)
#define module_analyser_FlowReturn (1 << module_analyser_Flow_Return)
#define module_analyser_FlowBreak (1 << module_analyser_Flow_Break)
#define module_analyser_FlowContinue (1 << module_analyser_Flow_Continue)
#define module_analyser_FlowGoto (1 << module_analyser_Flow_Goto)
#define module_analyser_FlowNoReturn (1 << module_analyser_Flow_NoReturn)
#define module_analyser_FlowError (1 << module_analyser_Flow_Error)
static ast_Expr* module_analyser_getCondExpr(const ast_Stmt* cond);
static bool module_analyser_Analyser_isNoReturn(module_analyser_Analyser* ma, ast_Expr* e);
static module_analyser_FlowBits module_analyser_Analyser_analyseStmt(module_analyser_Analyser* ma, ast_Stmt* s, bool checkEffect);
static void module_analyser_Analyser_analyseBreakStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseContinueStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseFallthroughStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static module_analyser_FlowBits module_analyser_Analyser_analyseLabelStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseGotoStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static module_analyser_FlowBits module_analyser_Analyser_analyseCompoundStmt(module_analyser_Analyser* ma, ast_CompoundStmt* c);
static ast_QualType module_analyser_Analyser_analyseCondition(module_analyser_Analyser* ma, ast_Stmt** s_ptr, bool check_assign);
static module_analyser_FlowBits module_analyser_Analyser_analyseIfStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static module_analyser_FlowBits module_analyser_Analyser_analyseForStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static module_analyser_FlowBits module_analyser_Analyser_analyseWhileStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static ast_QualType module_analyser_Analyser_analyseDeclStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static ast_QualType module_analyser_Analyser_analyseDecl(module_analyser_Analyser* ma, ast_VarDecl* vd);
static void module_analyser_Analyser_analyseAsmStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseAssertStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_analyseReturnStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static void module_analyser_Analyser_checkReturnAddrOfLocal(module_analyser_Analyser* ma, ast_Expr* arg);
static void module_analyser_Analyser_analyseStructType(module_analyser_Analyser* ma, ast_StructTypeDecl* d);
static void module_analyser_Analyser_analyseStructMembers(module_analyser_Analyser* ma, ast_StructTypeDecl* d);
static void module_analyser_Analyser_analyseStructMember(module_analyser_Analyser* ma, ast_VarDecl* v);
static void module_analyser_Analyser_analyseStructNames(module_analyser_Analyser* ma, ast_StructTypeDecl* d, name_vector_NameVector* names, name_vector_NameVector* locs);
static ast_QualType module_analyser_Analyser_analyseSwitchExpr(module_analyser_Analyser* ma, ast_Stmt** s_ptr);
static module_analyser_FlowBits module_analyser_Analyser_analyseSwitchStmt(module_analyser_Analyser* ma, ast_Stmt* s);
static module_analyser_FlowBits module_analyser_Analyser_analyseCase(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, bool is_string, bool is_last);
static bool module_analyser_Analyser_analyseCaseCondition(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, bool is_string);
static bool module_analyser_Analyser_analyseCaseExpr(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, bool is_string, src_loc_SrcLoc loc, ast_Expr* cond, uint32_t* indexp, uint32_t* name_idxp);
static bool module_analyser_Analyser_checkEnumConstantCase(module_analyser_Analyser* ma, ast_IdentifierExpr* id, init_checker_Checker* checker, ast_EnumTypeDecl* etd, src_loc_SrcLoc loc, uint32_t* ip, uint32_t* name_idxp);
static void module_analyser_Analyser_analyseFunctionType(module_analyser_Analyser* ma, ast_Decl* d);
static void module_analyser_Analyser_analyseAliasType(module_analyser_Analyser* ma, ast_AliasTypeDecl* a);
static void module_analyser_Analyser_analyseEnumType(module_analyser_Analyser* ma, ast_EnumTypeDecl* d);
static ast_QualType module_analyser_Analyser_analyseStructMemberTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref);
static ast_QualType module_analyser_Analyser_analyseUserTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref);
static ast_QualType module_analyser_Analyser_analyseTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref);
static ast_QualType module_analyser_Analyser_analyseIncrTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref, uint32_t size);
static bool module_analyser_Analyser_checkOpaque(module_analyser_Analyser* ma, const ast_StructTypeDecl* std, src_loc_SrcLoc loc);
static ast_VarDecl* module_analyser_getVarDecl(const ast_Expr* e);
static ast_QualType module_analyser_Analyser_analyseUnaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side);
static bool module_analyser_Analyser_checkIncrDecr(module_analyser_Analyser* ma, ast_Expr* inner, ast_QualType t, bool is_incr, src_loc_SrcLoc loc);
static bool module_analyser_Analyser_getIdentifierKind(module_analyser_Analyser* ma, const ast_Expr* e);
static ast_IdentifierKind module_analyser_getInnerExprAddressOf(const ast_Expr* e);
static ast_QualType module_analyser_getMinusType(ast_QualType qt);
struct module_analyser_StructFieldInitChecker_ {
   src_loc_SrcLoc* inits;
};

static void module_analyser_StructFieldInitChecker_init(module_analyser_StructFieldInitChecker* c, uint32_t capacity);
static void module_analyser_StructFieldInitChecker_free(module_analyser_StructFieldInitChecker* c);
static src_loc_SrcLoc module_analyser_StructFieldInitChecker_add(module_analyser_StructFieldInitChecker* c, uint32_t idx, src_loc_SrcLoc loc);

static module_analyser_Analyser* module_analyser_create(diagnostics_Diags* diags, ast_context_Context* context, string_pool_Pool* astPool, ast_builder_Builder* builder, module_list_List* allmodules, const warning_flags_Flags* warnings)
{
   module_analyser_Analyser* ma = calloc(1, 560);
   ma->diags = diags;
   conversion_checker_Checker_init(&ma->checker, diags, builder);
   ma->context = context;
   ma->astPool = astPool;
   ma->builder = builder;
   ma->allmodules = allmodules;
   ma->warnings = warnings;
   ma->min_idx = string_pool_Pool_addStr(astPool, "min", true);
   ma->max_idx = string_pool_Pool_addStr(astPool, "max", true);
   return ma;
}

static void module_analyser_Analyser_free(module_analyser_Analyser* ma)
{
   for (uint32_t i = 0; i < 4; i++) {
      init_checker_Checker_free(&ma->init_checkers[i]);
   }
   name_vector_NameVector_free(&ma->prefixes);
   label_vector_LabelVector_free(&ma->labels);
   free(ma);
}

static void module_analyser_Analyser_check(module_analyser_Analyser* ma, ast_Module* mod)
{
   ma->mod = mod;
   ma->prefix_cache_name = 0;
   ma->prefix_cache_idx = 0;
   name_vector_NameVector_clear(&ma->prefixes);
   label_vector_LabelVector_reset(&ma->labels);
   ma->checkIndex = 0;
   ma->scope = NULL;
   ma->curFunction = NULL;
   ma->has_error = false;
   ma->usedPublic = false;
   ast_Module_visitASTs(mod, module_analyser_Analyser_createGlobalScope, ma);
   if (diagnostics_Diags_hasErrors(ma->diags)) return;
   module_analyser_Analyser_collectTypeFunctions(ma);
   if (ma->has_error) return;
   module_analyser_Analyser_collectIncrementalArrays(ma);
   if (ma->has_error) return;
   ast_Module_visitTypeDecls(mod, module_analyser_Analyser_handleTypeDecl, ma);
   if (ma->has_error) return;
   ast_Module_visitStaticAsserts(mod, module_analyser_Analyser_handleStaticAssert, ma);
   if (ma->has_error) return;
   ast_Module_visitFunctions(mod, module_analyser_Analyser_analyseFunctionProto, ma);
   if (ma->has_error) return;
   ast_Module_visitVarDecls(mod, module_analyser_Analyser_handleVarDecl, ma);
   if (ma->has_error) return;
   ast_Module_visitFunctions(mod, module_analyser_Analyser_analyseFunctionBodies, ma);
   if (ma->has_error) return;
   if (!ast_Module_isExternal(mod) && ast_Module_isExported(mod)) {
      ast_Module_visitImports(mod, module_analyser_Analyser_handleImport, ma);
   }
   ast_Module_visitASTs(mod, module_analyser_Analyser_deleteScope, ma);
}

static init_checker_Checker* module_analyser_Analyser_getInitChecker(module_analyser_Analyser* ma)
{
   if (ma->check_idx >= 4) {
      ma->check_idx++;
      return calloc(1, 24);
   } else {
      init_checker_Checker* c = &ma->init_checkers[ma->check_idx++];
      init_checker_Checker_clear(c);
      return c;
   }
}

static void module_analyser_Analyser_putInitChecker(module_analyser_Analyser* ma, init_checker_Checker* c)
{
   ;//assert(ma->check_idx > 0);
   ma->check_idx--;
   if (ma->check_idx >= 4) {
      init_checker_Checker_free(c);
      free(c);
   }
}

static void module_analyser_Analyser_collectTypeFunctions(module_analyser_Analyser* ma)
{
   struct_func_list_List type_fn_decls = { };
   ma->type_fn_decls = &type_fn_decls;
   ast_Module_visitTypeFunctions(ma->mod, module_analyser_Analyser_handleStructFunc, ma);
   if (ma->has_error) return;
   for (uint32_t i = 0; i < type_fn_decls.count; i++) {
      const struct_func_list_Info* info = &type_fn_decls.data[i];
      if (ast_Decl_isStructType(info->decl)) {
         ast_StructTypeDecl* fd = (ast_StructTypeDecl*)info->decl;
         ast_StructTypeDecl_setStructFunctions(fd, ma->context, ast_FunctionDeclList_getDecls(&info->functions), ast_FunctionDeclList_size(&info->functions));
      } else {
         ast_EnumTypeDecl* etd = (ast_EnumTypeDecl*)info->decl;
         ast_EnumTypeDecl_setEnumFunctions(etd, ma->context, ast_FunctionDeclList_getDecls(&info->functions), ast_FunctionDeclList_size(&info->functions));
      }
   }
   name_vector_NameVector_free(&ma->prefixes);
   struct_func_list_List_free(&type_fn_decls);
   ma->type_fn_decls = NULL;
}

static void module_analyser_Analyser_handleArrayValue(void* arg, ast_ArrayValue* avd)
{
   module_analyser_Analyser* ma = arg;
   incr_array_list_List_add(ma->incr_values, ast_ArrayValue_getNameIdx(avd), ast_ArrayValue_getLoc(avd), ast_ArrayValue_getValue(avd));
}

static void module_analyser_Analyser_collectIncrementalArrays(module_analyser_Analyser* ma)
{
   incr_array_list_List ialist = { };
   ma->incr_values = &ialist;
   ast_Module_visitArrayValues(ma->mod, module_analyser_Analyser_handleArrayValue, ma);
   for (uint32_t i = 0; i < ialist.count; i++) {
      module_analyser_Analyser_handleIncrEntry(ma, &ialist.entries[i]);
   }
   incr_array_list_List_free(&ialist);
   ma->incr_values = NULL;
}

static void module_analyser_Analyser_handleIncrEntry(module_analyser_Analyser* ma, incr_array_list_Info* entry)
{
   uint32_t name = entry->name;
   ast_Decl* d = ast_Module_findSymbol(ma->mod, name);
   if (!d) {
      module_analyser_Analyser_error(ma, entry->loc, "module '%s' has no symbol '%s'", ast_Module_getName(ma->mod), ast_idx2name(name));
      return;
   }
   if (ast_Decl_isVariable(d)) {
      ast_VarDecl* vd = (ast_VarDecl*)d;
      ast_TypeRef* ref = ast_VarDecl_getTypeRef(vd);
      if (!ast_TypeRef_isIncrArray(ref)) {
         module_analyser_Analyser_error(ma, entry->loc, "'%s' is not an incremental array", ast_idx2name(name));
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "'%s' is defined here", ast_idx2name(name));
         return;
      }
      uint32_t num_values = ast_ExprList_size(&entry->values);
      ast_Expr** values = ast_ExprList_getExprs(&entry->values);
      ast_Expr* init_expr = ast_builder_Builder_actOnInitList(ma->builder, 0, 0, values, num_values);
      ast_VarDecl_setInit(vd, init_expr);
   } else if (ast_Decl_isEnum(d)) {
      ast_EnumTypeDecl* etd = (ast_EnumTypeDecl*)d;
      if (!ast_EnumTypeDecl_isIncremental(etd)) {
         module_analyser_Analyser_error(ma, entry->loc, "'%s' is not an incremental enum", ast_idx2name(name));
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "'%s' is defined here", ast_idx2name(name));
         return;
      }
      uint32_t num_values = ast_ExprList_size(&entry->values);
      ast_Expr** values = ast_ExprList_getExprs(&entry->values);
      for (uint32_t j = 0; j < num_values; j++) {
         ast_Expr* e = values[j];
         if (!ast_Expr_isIdentifier(e)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "expected identifier");
            return;
         }
      }
      ast_EnumTypeDecl_setIncrConstants(etd, ma->context, (ast_IdentifierExpr**)values, num_values);
   } else {
      module_analyser_Analyser_error(ma, entry->loc, "'%s' is not an incremental array/enum", ast_idx2name(name));
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "'%s' is defined here", ast_idx2name(name));
   }
}

static void module_analyser_Analyser_handleImport(void* arg, ast_ImportDecl* id)
{
   module_analyser_Analyser* ma = arg;
   ast_Decl* d = (ast_Decl*)id;
   if (!ast_Decl_isUsedPublic(d)) return;
   ast_Module* dest = ast_ImportDecl_getDest(id);
   if (ast_Module_isExternal(dest)) return;
   if (!ast_Module_isExported(dest)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "exported module '%s' publicly uses non-exported module '%s'", ast_Module_getName(ma->mod), ast_Module_getName(dest));
   }
}

static void module_analyser_Analyser_setMod(module_analyser_Analyser* ma, ast_Module* mod)
{
   ma->mod = mod;
}

__attribute__((__format__(printf, 3, 4)))
static void module_analyser_Analyser_note(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_note2(ma->diags, loc, format, args);
   va_end(args);
}

__attribute__((__format__(printf, 3, 4)))
static void module_analyser_Analyser_warn(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_warn2(ma->diags, loc, format, args);
   va_end(args);
}

__attribute__((__format__(printf, 3, 4)))
static void module_analyser_Analyser_error(module_analyser_Analyser* ma, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_error2(ma->diags, loc, format, args);
   va_end(args);
   ma->has_error = true;
}

__attribute__((__format__(printf, 4, 5)))
static void module_analyser_Analyser_errorRange(module_analyser_Analyser* ma, src_loc_SrcLoc loc, src_loc_SrcRange range, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_errorRange2(ma->diags, loc, range, format, args);
   va_end(args);
   ma->has_error = true;
}

static void module_analyser_Analyser_createGlobalScope(void* arg, ast_AST* a)
{
   module_analyser_Analyser* ma = arg;
   scope_Scope* s = scope_create(ma->allmodules, ma->diags, ast_AST_getImports(a), ma->mod, ast_Module_getSymbols(ma->mod), !ma->warnings->no_unused_variable);
   ast_AST_setPtr(a, s);
}

static void module_analyser_Analyser_deleteScope(void* _arg0, ast_AST* a)
{
   scope_Scope* s = ast_AST_getPtr(a);
   ast_AST_setPtr(a, NULL);
   scope_Scope_free(s);
}

static void module_analyser_Analyser_handleStructFunc(void* arg, ast_FunctionDecl* fd)
{
   module_analyser_Analyser* ma = arg;
   ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
   ast_Decl* d = (ast_Decl*)fd;
   ;//assert(prefix);
   uint32_t prefix_name_idx = prefix->name_idx;
   ;//assert(ma->type_fn_decls);
   uint32_t index = 0;
   if (prefix_name_idx == ma->prefix_cache_name) {
      index = ma->prefix_cache_idx;
   } else {
      bool found = false;
      found = name_vector_NameVector_find(&ma->prefixes, prefix_name_idx, &index);
      if (!found) {
         const char* msg = "a type-function type must be a struct/union/enum";
         ast_Decl* decl = ast_Module_findType(ma->mod, prefix_name_idx);
         if (!decl) {
            decl = ast_Module_findSymbol(ma->mod, prefix_name_idx);
            if (decl) {
               module_analyser_Analyser_error(ma, prefix->loc, "%s", msg);
            } else {
               module_analyser_Analyser_error(ma, prefix->loc, "module '%s' has no symbol '%s'", ast_Module_getName(ma->mod), ast_Ref_getName(prefix));
            }
            return;
         }
         if (!ast_Decl_isStructType(decl) && !ast_Decl_isEnum(decl)) {
            module_analyser_Analyser_error(ma, prefix->loc, "%s", msg);
            return;
         }
         if (ast_Decl_isPublic(d) && !ast_Decl_isPublic(decl)) {
            module_analyser_Analyser_error(ma, prefix->loc, "public type-functions need a public type");
            return;
         }
         index = name_vector_NameVector_add(&ma->prefixes, prefix_name_idx);
         struct_func_list_List_addDecl(ma->type_fn_decls, decl);
      }
      ma->prefix_cache_name = prefix_name_idx;
      ma->prefix_cache_idx = index;
   }
   ast_FunctionDecl* other = struct_func_list_List_findFunc(ma->type_fn_decls, index, ast_Decl_getNameIdx(d));
   if (other) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "redefinition of '%s'", ast_Decl_getFullName(d));
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(other)), "previous definition is here");
      return;
   }
   prefix->decl = struct_func_list_List_getDecl(ma->type_fn_decls, index);
   if (ast_Decl_isStructType(prefix->decl)) {
      ast_StructTypeDecl* std = (ast_StructTypeDecl*)prefix->decl;
      ast_Decl* match = ast_StructTypeDecl_findMember(std, ast_Decl_getNameIdx(d), NULL);
      if (match) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(match), "member '%s' conflicts with type-function '%s'", ast_Decl_getName(match), ast_Decl_getFullName(d));
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "previous declaration is here");
         return;
      }
   }
   struct_func_list_List_addFunc(ma->type_fn_decls, index, fd);
}

static void module_analyser_Analyser_analyseFunctionProto(void* arg, ast_FunctionDecl* d)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseGlobalDecl(ma, (ast_Decl*)d);
}

static void module_analyser_Analyser_analyseFunctionBodies(void* arg, ast_FunctionDecl* d)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseFunctionBody(ma, d, ast_AST_getPtr(ast_Decl_getAST(ast_FunctionDecl_asDecl(d))));
}

static bool module_analyser_Analyser_analyseGlobalDecl(module_analyser_Analyser* ma, ast_Decl* d)
{
   if (ast_Decl_isChecked(d)) return true;
   if (ast_Decl_isCheckInProgress(d) && ast_Decl_isEnum(d)) {
      module_analyser_StackLayer* top = &ma->checkStack[ma->checkIndex - 1];
      if (top->decl == d) return true;
   }
   if (!module_analyser_Analyser_pushCheck(ma, d, ast_AST_getPtr(ast_Decl_getAST(d)), NULL)) return false;
   if (ast_Decl_isExported(d) && !ast_Decl_isPublic(d)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "attribute 'export' can only be applied to public declarations");
      return false;
   }
   bool saved = ma->has_error;
   ma->has_error = false;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      module_analyser_Analyser_analyseFunction(ma, (ast_FunctionDecl*)d);
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType:
      module_analyser_Analyser_analyseStructType(ma, (ast_StructTypeDecl*)d);
      break;
   case ast_DeclKind_EnumType:
      module_analyser_Analyser_analyseEnumType(ma, (ast_EnumTypeDecl*)d);
      break;
   case ast_DeclKind_EnumConstant:
      ;//assert(0);
      break;
   case ast_DeclKind_FunctionType:
      module_analyser_Analyser_analyseFunctionType(ma, d);
      break;
   case ast_DeclKind_AliasType:
      module_analyser_Analyser_analyseAliasType(ma, (ast_AliasTypeDecl*)d);
      break;
   case ast_DeclKind_Variable:
      module_analyser_Analyser_analyseGlobalVarDecl(ma, (ast_VarDecl*)d);
      break;
   }
   ast_Decl_setChecked(d);
   module_analyser_Analyser_popCheck(ma);
   bool ok = !ma->has_error;
   ma->has_error |= saved;
   return ok;
}

static void module_analyser_Analyser_handleTypeDecl(void* arg, ast_Decl* d)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseGlobalDecl(ma, d);
}

static void module_analyser_Analyser_handleStaticAssert(void* arg, ast_StaticAssert* d)
{
   module_analyser_Analyser* ma = arg;
   ast_StaticAssert* sa = (ast_StaticAssert*)d;
   ast_Expr* lhs = ast_StaticAssert_getLhs(sa);
   ast_Expr* rhs = ast_StaticAssert_getRhs(sa);
   if (!module_analyser_Analyser_pushCheck(ma, NULL, ast_AST_getPtr(ast_StaticAssert_getAST(d)), NULL)) return;
   ast_QualType t1 = module_analyser_Analyser_analyseExpr(ma, &lhs, false, module_analyser_RHS);
   ast_QualType t2 = module_analyser_Analyser_analyseExpr(ma, &rhs, false, module_analyser_RHS);
   module_analyser_Analyser_popCheck(ma);
   if (ast_QualType_isInvalid(t1) || ast_QualType_isInvalid(t2)) return;
   bool error = false;
   if (!ast_Expr_isCtv(lhs)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(lhs), ast_Expr_getRange(lhs), "static_assert element is not a compile-time value");
      error = true;
   }
   if (!ast_Expr_isCtv(rhs)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(rhs), ast_Expr_getRange(rhs), "static_assert element is not a compile-time value");
      error = true;
   }
   if (error) return;
   ast_Value val1 = ast_evalExpr(lhs);
   ast_Value val2 = ast_evalExpr(rhs);
   if (!ast_Value_is_equal(&val1, &val2)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getStartLoc(rhs), ast_Expr_getRange(rhs), "static_assert failed, expected %s, got %s", ast_Value_str(&val1), ast_Value_str(&val2));
   }
}

static void module_analyser_Analyser_handleVarDecl(void* arg, ast_VarDecl* v)
{
   module_analyser_Analyser* ma = arg;
   module_analyser_Analyser_analyseGlobalDecl(ma, ast_VarDecl_asDecl(v));
}

static void module_analyser_Analyser_checkName(module_analyser_Analyser* ma, ast_Decl* d, bool is_constant)
{
   const char* name = ast_Decl_getName(d);
   if (is_constant) {
      if (islower(name[0])) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "a global constant name must start with an upper case character");
      }
   } else {
      if (isupper(name[0])) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "a variable name must start with a lower case character");
      }
   }
}

static void module_analyser_Analyser_analyseGlobalVarDecl(module_analyser_Analyser* ma, ast_VarDecl* v)
{
   ast_Decl* d = (ast_Decl*)v;
   ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
   ast_Expr* init_expr = ast_VarDecl_getInit(v);
   ast_QualType res;
   if (ast_TypeRef_isIncrArray(ref)) {
      uint32_t size = 0;
      if (init_expr) {
         ast_InitListExpr* ile = (ast_InitListExpr*)init_expr;
         size = ast_InitListExpr_getNumValues(ile);
      }
      res = module_analyser_Analyser_analyseIncrTypeRef(ma, ref, size);
   } else {
      res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   }
   if (ast_QualType_isInvalid(res)) return;
   ast_QualType canon = ast_QualType_getCanonicalType(res);
   if (ast_QualType_isVoid(canon)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "%s has invalid type 'void'", ast_QualType_isConst(res) ? "constant" : "variable");
      return;
   }
   const ast_AST* a = ast_Decl_getAST(d);
   const attr_Attr* embed = ast_AST_getAttr(a, d, attr_AttrKind_Embed);
   if (ast_QualType_isArray(canon) && !ast_TypeRef_isIncrArray(ref)) {
      const ast_ArrayType* at = ast_QualType_getArrayType(canon);
      if (ast_ArrayType_hasSize(at)) {
         if (ast_ArrayType_getSize(at) == 0) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "only struct members may have array size zero");
            return;
         }
      } else {
         if (!init_expr && !ast_Decl_isExternal(d) && !embed) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "array-type variable '%s' needs an explicit size or an initializer", ast_Decl_getFullName(d));
            return;
         }
      }
   }
   ast_Decl_setType(d, res);
   if (embed) {
      bool is_char = false;
      if (!ast_QualType_isEmbedType(canon, &is_char)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "variables with 'embed' attribute must be type 'const char[]' or 'const u8[]'");
         return;
      }
      if (init_expr) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "variables with 'embed' attribute cannot have an initializer");
         return;
      }
      const char* filename = string_pool_Pool_idx2str(ma->astPool, embed->value.text);
      file_utils_File reader; file_utils_File_init(&reader, "", filename);
      if (!file_utils_File_load(&reader)) {
         module_analyser_Analyser_error(ma, embed->loc, "error opening embedded file '%s': %s", filename, file_utils_File_getError(&reader));
         return;
      }
      uint32_t src_len = 8;
      uint32_t len = file_utils_File_data_size(&reader);
      uint32_t value = string_pool_Pool_add(ma->astPool, file_utils_File_data(&reader), len, false);
      if (!is_char) len--;
      ast_Expr* init = ast_builder_Builder_actOnStringLiteral(ma->builder, embed->loc, src_len, value, len);
      ast_VarDecl_setInit(v, init);
      ast_Decl_setType(d, ast_Expr_getType(init));
      file_utils_File_close(&reader);
   }
   if (!ast_AST_isInterface(ast_Decl_getAST(d))) module_analyser_Analyser_checkName(ma, d, ast_QualType_isConstant(res));
   if (ast_Decl_isPublic(d)) ast_setTypePublicUsed(res);
   if (init_expr) {
      if (!ast_QualType_isConstant(res)) {
         ma->checkStack[ma->checkIndex - 1].usedPublic = false;
         ma->usedPublic = false;
      }
      module_analyser_Analyser_analyseInitExpr(ma, ast_VarDecl_getInit2(v), res, ast_VarDecl_getAssignLoc(v), false, false);
   } else {
      if (ast_QualType_isConstant(res) && !embed) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "constant variable '%s' must be initialized", ast_Decl_getFullName(d));
      }
   }
   module_analyser_Analyser_checkVarDeclAttributes(ma, v);
}

static void module_analyser_Analyser_checkVarDeclAttributes(module_analyser_Analyser* ma, ast_VarDecl* v)
{
   ast_Decl* d = (ast_Decl*)v;
   ast_QualType qt = ast_Decl_getType(d);
   if (ast_QualType_isConst(qt) && ast_QualType_isBuiltin(qt)) {
      if (ast_VarDecl_hasAttrWeak(v)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "attribute 'weak' cannot be applied to constants");
      }
      if (!ast_Decl_hasAttr(d)) return;
      const ast_AST* a = ast_Decl_getAST(d);
      const attr_Attr* section = ast_AST_getAttr(a, d, attr_AttrKind_Section);
      if (section) {
         module_analyser_Analyser_error(ma, section->loc, "attribute 'section' cannot be applied to constants");
      }
      const attr_Attr* aligned = ast_AST_getAttr(a, d, attr_AttrKind_Aligned);
      if (aligned) {
         module_analyser_Analyser_error(ma, aligned->loc, "attribute 'aligned' cannot be applied to constants");
      }
   }
}

static bool module_analyser_Analyser_pushCheck(module_analyser_Analyser* ma, ast_Decl* d, scope_Scope* s, ast_FunctionDecl* fd)
{
   if (d) {
      for (uint32_t i = 0; i < ma->checkIndex; i++) {
         if (ma->checkStack[i].decl == d) {
            for (uint32_t j = i; j < ma->checkIndex; j++) {
               const ast_Decl* other = ma->checkStack[j].decl;
               if (other) {
                  module_analyser_Analyser_error(ma, ast_Decl_getLoc(other), "circular declaration dependency '%s'", ast_Decl_getName(other));
               }
            }
            return false;
         }
      }
   }
   ma->scope = s;
   ;//assert(ma->checkIndex <= module_analyser_MaxDepth);
   module_analyser_StackLayer* top = &ma->checkStack[ma->checkIndex];
   top->decl = d;
   top->scope = s;
   top->function = fd;
   top->usedPublic = d && ast_Decl_isPublic(d);
   if (fd) ma->curFunction = fd;
   ma->usedPublic = top->usedPublic;
   ma->checkIndex++;
   if (d && !ast_Decl_isChecked(d)) ast_Decl_setCheckInProgress(d);
   return true;
}

static void module_analyser_Analyser_popCheck(module_analyser_Analyser* ma)
{
   ;//assert(ma->checkIndex > 0);
   ma->checkIndex--;
   if (ma->checkIndex > 0) {
      module_analyser_StackLayer* top = &ma->checkStack[ma->checkIndex - 1];
      ma->scope = top->scope;
      ma->curFunction = top->function;
      ma->usedPublic = top->usedPublic;
   } else {
      ma->scope = NULL;
      ma->curFunction = NULL;
   }
}

static bool module_analyser_Analyser_globalScope(const module_analyser_Analyser* ma)
{
   return ma->curFunction == NULL;
}

static void module_analyser_findMainFunction(void* arg, ast_FunctionDecl* fd)
{
   module_analyser_MainMarker* m = arg;
   ast_Decl* d = (ast_Decl*)fd;
   if (ast_Decl_getNameIdx(d) == m->name_idx) {
      if (m->main) {
         return;
      }
      m->main = d;
   }
}

static ast_Decl* module_analyser_Analyser_findMain(module_analyser_Analyser* ma, ast_Module* top, uint32_t name_idx)
{
   ast_Module_setUsed(top);
   module_analyser_MainMarker marker = { name_idx, NULL };
   ast_Module_visitFunctions(top, module_analyser_findMainFunction, &marker);
   if (marker.main) {
      ast_Decl_setUsed(marker.main);
      ast_Decl_setUsedPublic(marker.main);
      ast_Decl_setAttrExport(marker.main);
   }
   return marker.main;
}

static bool module_analyser_validArithType(ast_QualType t)
{
   t = ast_QualType_getCanonicalType(t);
   switch (ast_QualType_getKind(t)) {
   case ast_TypeKind_Builtin:
   case ast_TypeKind_Enum:
      return true;
   default:
      return false;
   }
}

static bool module_analyser_validIntegerType(ast_QualType t)
{
   t = ast_QualType_getCanonicalType(t);
   switch (ast_QualType_getKind(t)) {
   case ast_TypeKind_Builtin:
      return !ast_QualType_isFloat(t);
   case ast_TypeKind_Enum:
      return true;
   default:
      return false;
   }
}

static bool module_analyser_validTestType(ast_QualType t)
{
   t = ast_QualType_getCanonicalType(t);
   if (!ast_QualType_isValid(t)) return false;
   switch (ast_QualType_getKind(t)) {
   case ast_TypeKind_Builtin:
   case ast_TypeKind_Pointer:
   case ast_TypeKind_Enum:
   case ast_TypeKind_Function:
      return true;
   default:
      return false;
   }
}

static ast_QualType module_analyser_Analyser_invalidBinOp1(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_Expr* sub, ast_QualType qt)
{
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(sub), "invalid operand type '%s' for binary expression '%s'", ast_QualType_diagName(qt), ast_BinaryOpcode_str(ast_BinaryOperator_getOpcode(b)));
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_invalidBinOp2(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(((ast_Expr*)b)), "invalid operands to binary expression ('%s' and '%s')", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_invalidFuncCompare(module_analyser_Analyser* ma, ast_BinaryOperator* b)
{
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(((ast_Expr*)b)), "comparing functions may only be done with '!=' or '=='");
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopArithArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, bool assign)
{
   ast_QualType lcanon = ast_QualType_getImplType(&lhs);
   ast_QualType rcanon = ast_QualType_getImplType(&rhs);
   if (!module_analyser_validArithType(lcanon)) {
      if (!module_analyser_validArithType(rcanon)) return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   }
   if (!module_analyser_validArithType(rcanon)) return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   ast_BuiltinType* bl = ast_QualType_getBuiltinTypeOrNil(lcanon);
   ast_BuiltinType* br = ast_QualType_getBuiltinTypeOrNil(rcanon);
   ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(optype);
   if (br != bi) {
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
   }
   if (assign) {
      if (ast_QualType_isFloat(rcanon) && !ast_QualType_isFloat(lcanon)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(((ast_Expr*)b)), "implicit conversion turns floating-point number into integer:");
         return ast_QualType_Invalid;
      }
      return lhs;
   }
   if (bl != bi) {
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
   }
   return optype;
}

static ast_QualType module_analyser_Analyser_checkBinopIntArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, bool assign)
{
   ast_QualType lcanon = ast_QualType_getImplType(&lhs);
   ast_QualType rcanon = ast_QualType_getImplType(&rhs);
   if (!module_analyser_validIntegerType(lcanon)) {
      if (!module_analyser_validIntegerType(rcanon)) return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   }
   if (!module_analyser_validIntegerType(rcanon)) return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   ast_BuiltinType* bl = ast_QualType_getBuiltinTypeOrNil(lcanon);
   ast_BuiltinType* br = ast_QualType_getBuiltinTypeOrNil(rcanon);
   ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(optype);
   if (br != bi) {
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
   }
   if (assign) return lhs;
   if (bl != bi) {
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
   }
   return optype;
}

static ast_QualType module_analyser_Analyser_checkBinopShiftArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType ltype, ast_QualType rtype, bool assign)
{
   ast_QualType lcanon = ast_QualType_getImplType(&ltype);
   ast_QualType rcanon = ast_QualType_getImplType(&rtype);
   if (!module_analyser_validIntegerType(lcanon)) {
      if (!module_analyser_validIntegerType(rcanon)) return module_analyser_Analyser_invalidBinOp2(ma, b, ltype, rtype);
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), ltype);
   }
   if (!module_analyser_validIntegerType(rcanon)) return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rtype);
   ast_BuiltinType* bl = ast_QualType_getBuiltinTypeOrNil(lcanon);
   ast_BuiltinType* br = ast_QualType_getBuiltinTypeOrNil(rcanon);
   uint32_t width = ast_BuiltinType_getWidth(bl);
   if (ast_BuiltinType_isPromotableIntegerType(bl)) {
      lcanon = ast_getBuiltinQT(ast_BuiltinKind_Int32);
      width = 32;
      if (!assign) ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), lcanon);
   }
   if (ast_BuiltinType_isPromotableIntegerType(br)) {
      rcanon = ast_getBuiltinQT(ast_BuiltinKind_Int32);
      ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), rcanon);
   }
   ast_Expr* lhs = ast_BinaryOperator_getLHS(b);
   if (ast_Expr_isCtv(lhs)) {
      ast_Value val = ast_evalExpr(lhs);
      if (ast_Value_isNegative(&val)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(lhs), "shifting a negative signed value is undefined");
         return ast_QualType_Invalid;
      }
   }
   ast_Expr* rhs = ast_BinaryOperator_getRHS(b);
   if (ast_Expr_isCtv(rhs)) {
      ast_Value val = ast_evalExpr(rhs);
      if (ast_Value_isNegative(&val)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(rhs), "shift count is negative");
         return ast_QualType_Invalid;
      }
      if (ast_Value_as_u64(&val) >= width) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(rhs), "shift count >= width of type");
         return ast_QualType_Invalid;
      }
   }
   if (assign) return ltype;
   return lcanon;
}

static ast_QualType module_analyser_Analyser_checkBinopLogical(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   if (!module_analyser_validTestType(lhs)) {
      if (!module_analyser_validTestType(rhs)) return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   }
   if (!module_analyser_validTestType(rhs)) return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   return ast_getBuiltinQT(ast_BuiltinKind_Bool);
}

static ast_QualType module_analyser_Analyser_checkBinopAddSubAssign(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(rhs);
   ;//assert(ast_QualType_isValid(lcanon));
   ;//assert(ast_QualType_isValid(rcanon));
   uint8_t res = module_analyser_BinOpConvAddSubAss[ast_QualType_getKind(lcanon)][ast_QualType_getKind(rcanon)];
   switch (res) {
   case 0:
      break;
   case 1:
   invalid_lhs:
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   case 2:
   invalid_rhs:
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   case 3:
      return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
   case 4:
   case 5:
      return module_analyser_Analyser_checkBinopArithArgs(ma, b, lhs, rhs, true);
   case 6:
      if (ast_QualType_isVoidPtr(lcanon)) goto invalid_lhs;
      if (!module_analyser_validIntegerType(rcanon)) goto invalid_rhs;
      return lhs;
   case 7:
      return module_analyser_Analyser_checkBinopIntArgs(ma, b, lhs, rhs, true);
   case 8:
      return module_analyser_Analyser_checkBinopIntArgs(ma, b, lhs, rhs, true);
   }
   ;//assert(0);
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopAddArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(rhs);
   ;//assert(ast_QualType_isValid(lcanon));
   ;//assert(ast_QualType_isValid(rcanon));
   uint8_t res = module_analyser_BinOpConvAdd[ast_QualType_getKind(lcanon)][ast_QualType_getKind(rcanon)];
   switch (res) {
   case 0:
      break;
   case 1:
   invalid_lhs:
      if (ast_QualType_isVoidPtr(rcanon)) goto invalid;
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   case 2:
   invalid_rhs:
      if (ast_QualType_isVoidPtr(lcanon)) goto invalid;
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   case 3:
   invalid:
      return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
   case 4: {
   builtin:;
      ast_BuiltinType* bl = ast_QualType_getBuiltin(lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(rcanon);
      ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
      if (!ast_QualType_isValid(optype)) goto invalid;
      ast_BuiltinType* bi = ast_QualType_getBuiltin(optype);
      if (bl != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
      }
      if (br != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
      }
      return optype;
   }
   case 5:
      rcanon = ast_QualType_getImplType(&rcanon);
      goto builtin;
   case 6:
      lcanon = ast_QualType_getImplType(&lcanon);
      goto builtin;
   case 7:
      if (!module_analyser_validIntegerType(lcanon)) goto invalid_lhs;
      if (ast_QualType_isVoidPtr(rcanon)) goto invalid_rhs;
      return rhs;
   case 8:
      if (ast_QualType_isVoidPtr(lcanon)) goto invalid_lhs;
      if (!module_analyser_validIntegerType(rcanon)) goto invalid_rhs;
      return lhs;
   }
   ;//assert(0);
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkBinopSubArgs(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(rhs);
   ;//assert(ast_QualType_isValid(lcanon));
   ;//assert(ast_QualType_isValid(rcanon));
   uint8_t res = module_analyser_BinOpConvSub[ast_QualType_getKind(lcanon)][ast_QualType_getKind(rcanon)];
   switch (res) {
   case 0:
      break;
   case 1:
   invalid_lhs:
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   case 2:
   invalid_rhs:
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   case 3:
   invalid:
      return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
   case 4: {
   builtin:;
      ast_BuiltinType* bl = ast_QualType_getBuiltin(lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(rcanon);
      ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
      if (!ast_QualType_isValid(optype)) goto invalid;
      ast_BuiltinType* bi = ast_QualType_getBuiltin(optype);
      if (bl != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
      }
      if (br != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
      }
      return optype;
   }
   case 5:
      rcanon = ast_QualType_getImplType(&rcanon);
      goto builtin;
   case 6:
      lcanon = ast_QualType_getImplType(&lcanon);
      goto builtin;
   case 7: {
      ast_EnumType* et1 = (ast_EnumType*)ast_QualType_getTypeOrNil(lcanon);
      ast_EnumType* et2 = (ast_EnumType*)ast_QualType_getTypeOrNil(rcanon);
      lcanon = ast_EnumType_getImplType(et1);
      rcanon = ast_EnumType_getImplType(et2);
      goto builtin;
   }
   case 8:
      if (ast_QualType_isVoidPtr(lcanon)) goto invalid_lhs;
      if (!module_analyser_validIntegerType(rcanon)) goto invalid_rhs;
      return lhs;
   case 9: {
      ast_PointerType* pt1 = ast_QualType_getPointerType(lcanon);
      ast_PointerType* pt2 = ast_QualType_getPointerType(rcanon);
      ast_QualType t1 = ast_PointerType_getInner(pt1);
      ast_QualType t2 = ast_PointerType_getInner(pt2);
      if (ast_QualType_getTypeOrNil(t1) != ast_QualType_getTypeOrNil(t2) || ast_QualType_isVoid(t1) || ast_QualType_isVoid(t2)) goto invalid;
      return ast_getBuiltinQT(ast_BuiltinKind_ISize);
   }
   }
   return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
}

static ast_QualType module_analyser_Analyser_checkBinopComparison(module_analyser_Analyser* ma, ast_BinaryOperator* b, ast_QualType lhs, ast_QualType rhs, bool is_relative)
{
   ast_QualType lcanon = ast_QualType_getCanonicalType(lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(rhs);
   ast_Expr* e = (ast_Expr*)b;
   ;//assert(ast_QualType_isValid(lcanon));
   ;//assert(ast_QualType_isValid(rcanon));
   uint8_t res = module_analyser_BinOpConvComparison[ast_QualType_getKind(lcanon)][ast_QualType_getKind(rcanon)];
   switch (res) {
   case 0:
   case 1:
   invalid:
      return module_analyser_Analyser_invalidBinOp2(ma, b, lhs, rhs);
   case 2: {
   builtin:;
      ast_BuiltinType* bl = ast_QualType_getBuiltin(lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(rcanon);
      ast_QualType optype = conversion_checker_usual_arithmetic_conversion(bl, br);
      if (!ast_QualType_isValid(optype)) goto invalid;
      ast_BuiltinType* bi = ast_QualType_getBuiltin(optype);
      if (bl != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getLHS2(b), optype);
      }
      if (br != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_BinaryOperator_getRHS2(b), optype);
      }
      return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   }
   case 3:
      rcanon = ast_QualType_getImplType(&rcanon);
      goto builtin;
   case 4: {
      ast_PointerType* pt1 = ast_QualType_getPointerType(lcanon);
      ast_PointerType* pt2 = ast_QualType_getPointerType(rcanon);
      ast_QualType t1 = ast_PointerType_getInner(pt1);
      ast_QualType t2 = ast_PointerType_getInner(pt2);
      if (ast_QualType_isVoid(t1) || ast_QualType_isVoid(t2)) {
         if (is_relative) goto invalid;
      } else if (ast_QualType_getTypeOrNil(t1) != ast_QualType_getTypeOrNil(t2)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "comparing pointers to different types ('%s' and '%s')", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
         return ast_QualType_Invalid;
      }
      return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   }
   case 5:
      lcanon = ast_QualType_getImplType(&lcanon);
      goto builtin;
   case 6:
      if (ast_QualType_getTypeOrNil(lcanon) != ast_QualType_getTypeOrNil(rcanon)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "comparing enums of different types ('%s' and '%s')", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
         return ast_QualType_Invalid;
      }
      return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   case 7:
      if (is_relative) return module_analyser_Analyser_invalidFuncCompare(ma, b);
      if (ast_Expr_getKind(ast_BinaryOperator_getLHS(b)) != ast_ExprKind_Nil) goto invalid;
      return module_analyser_Analyser_checkFuncTest(ma, ast_QualType_getFunctionType(rcanon), ast_Expr_getLoc(e));
   case 8:
      if (is_relative) return module_analyser_Analyser_invalidFuncCompare(ma, b);
      if (ast_Expr_getKind(ast_BinaryOperator_getRHS(b)) != ast_ExprKind_Nil) goto invalid;
      return module_analyser_Analyser_checkFuncTest(ma, ast_QualType_getFunctionType(lcanon), ast_Expr_getLoc(e));
   case 9:
      if (is_relative) return module_analyser_Analyser_invalidFuncCompare(ma, b);
      return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   case 10:
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getLHS(b), lhs);
   case 11:
      return module_analyser_Analyser_invalidBinOp1(ma, b, ast_BinaryOperator_getRHS(b), rhs);
   }
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "TODO BINOP %d", res);
   ;//assert(0);
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_checkFuncTest(module_analyser_Analyser* ma, ast_FunctionType* ft, src_loc_SrcLoc loc)
{
   ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   if (ast_FunctionDecl_isType(fd) || ast_FunctionDecl_hasAttrWeak(fd)) return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   module_analyser_Analyser_error(ma, loc, "comparison of function '%s' will always be true", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
   return ast_QualType_Invalid;
}

static bool module_analyser_incompatible_opcodes(ast_BinaryOpcode op1, ast_BinaryOpcode op2)
{
   c_prec_C_Prec c_p1 = c_prec_C_Prec_table[op1];
   c_prec_C_Prec c_p2 = c_prec_C_Prec_table[op2];
   c2_prec_Prec c2_p1 = c2_prec_Prec_table[op1];
   c2_prec_Prec c2_p2 = c2_prec_Prec_table[op2];
   if (c2_p1 == c2_p2) return c2_p1 == c2_prec_Prec_Relational || c_p1 != c_p2;
   if (c2_p1 < c2_p2) return c_p1 >= c_p2;
   return c_p1 <= c_p2;
}

static bool module_analyser_Analyser_checkAmbiguousOperators(module_analyser_Analyser* ma, ast_BinaryOpcode opcode, ast_Expr* sub)
{
   if (ast_Expr_isBinaryOperator(sub)) {
      ast_BinaryOperator* b = (ast_BinaryOperator*)sub;
      ast_BinaryOpcode op1 = ast_BinaryOperator_getOpcode(b);
      if (module_analyser_incompatible_opcodes(opcode, op1)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(sub), "operators '%s' and '%s' do not combine without parentheses", ast_BinaryOpcode_str(opcode), ast_BinaryOpcode_str(op1));
         return false;
      }
   }
   return true;
}

static ast_QualType module_analyser_Analyser_analyseBinaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_BinaryOperator* b = (ast_BinaryOperator*)e;
   ast_BinaryOpcode opcode = ast_BinaryOperator_getOpcode(b);
   bool need_lhs_rvalue = true;
   if (opcode >= ast_BinaryOpcode_Assign) need_lhs_rvalue = false;
   ast_QualType ltype = module_analyser_Analyser_analyseExpr(ma, ast_BinaryOperator_getLHS2(b), need_lhs_rvalue, module_analyser_Binop_lhs[opcode]);
   if (ast_QualType_isInvalid(ltype)) return ast_QualType_Invalid;
   if (!need_lhs_rvalue) {
      if (!module_analyser_Analyser_checkAssignment(ma, ast_BinaryOperator_getLHS(b), ltype, "left operand of assignment", ast_Expr_getLoc(e))) {
         return ast_QualType_Invalid;
      }
   }
   if (ast_BinaryOpcode_isComparison(opcode)) {
      if (module_analyser_Analyser_checkEnumArg(ma, ast_BinaryOperator_getRHS2(b), ltype)) return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   }
   ast_QualType rtype;
   if (opcode == ast_BinaryOpcode_Assign) {
      ast_Expr* rhs = ast_BinaryOperator_getRHS(b);
      if (ast_QualType_isStruct(ltype) && ast_Expr_isInitList(rhs)) {
         ast_StructType* st = ast_QualType_getStructType(ltype);
         ast_StructTypeDecl* std = ast_StructType_getDecl(st);
         if (!ast_StructTypeDecl_isGlobal(std)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot assign a sub-struct with an initializer list");
            return ast_QualType_Invalid;
         }
      }
      if (!module_analyser_Analyser_analyseInitExpr(ma, ast_BinaryOperator_getRHS2(b), ltype, ast_Expr_getLoc(e), false, false)) return ast_QualType_Invalid;
      return ltype;
   } else {
      rtype = module_analyser_Analyser_analyseExpr(ma, ast_BinaryOperator_getRHS2(b), true, module_analyser_RHS);
   }
   if (ast_QualType_isInvalid(rtype)) return ast_QualType_Invalid;
   ast_Expr* lhs = ast_BinaryOperator_getLHS(b);
   ast_Expr* rhs = ast_BinaryOperator_getRHS(b);
   if (!module_analyser_Analyser_checkAmbiguousOperators(ma, opcode, lhs) || !module_analyser_Analyser_checkAmbiguousOperators(ma, opcode, rhs)) {
      return ast_QualType_Invalid;
   }
   ast_QualType result = ast_QualType_Invalid;
   switch (opcode) {
   case ast_BinaryOpcode_Multiply:
      result = module_analyser_Analyser_checkBinopArithArgs(ma, b, ltype, rtype, false);
      break;
   case ast_BinaryOpcode_Divide:
      result = module_analyser_Analyser_checkBinopArithArgs(ma, b, ltype, rtype, false);
      if (!module_analyser_Analyser_checkZero(ma, ast_BinaryOperator_getRHS(b), "division")) return ast_QualType_Invalid;
      break;
   case ast_BinaryOpcode_Remainder:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype, false);
      if (!module_analyser_Analyser_checkZero(ma, ast_BinaryOperator_getRHS(b), "remainder")) return ast_QualType_Invalid;
      break;
   case ast_BinaryOpcode_Add:
      result = module_analyser_Analyser_checkBinopAddArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Subtract:
      result = module_analyser_Analyser_checkBinopSubArgs(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_ShiftLeft:
   case ast_BinaryOpcode_ShiftRight:
      result = module_analyser_Analyser_checkBinopShiftArgs(ma, b, ltype, rtype, false);
      break;
   case ast_BinaryOpcode_LessThan:
   case ast_BinaryOpcode_GreaterThan:
   case ast_BinaryOpcode_LessEqual:
   case ast_BinaryOpcode_GreaterEqual:
      result = module_analyser_Analyser_checkBinopComparison(ma, b, ltype, rtype, true);
      break;
   case ast_BinaryOpcode_Equal:
   case ast_BinaryOpcode_NotEqual:
      result = module_analyser_Analyser_checkBinopComparison(ma, b, ltype, rtype, false);
      break;
   case ast_BinaryOpcode_And:
   case ast_BinaryOpcode_Xor:
   case ast_BinaryOpcode_Or:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype, false);
      break;
   case ast_BinaryOpcode_LAnd:
   case ast_BinaryOpcode_LOr:
      result = module_analyser_Analyser_checkBinopLogical(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_Assign:
      result = ltype;
      break;
   case ast_BinaryOpcode_MulAssign:
      result = module_analyser_Analyser_checkBinopArithArgs(ma, b, ltype, rtype, true);
      break;
   case ast_BinaryOpcode_DivAssign:
      result = module_analyser_Analyser_checkBinopArithArgs(ma, b, ltype, rtype, true);
      if (!module_analyser_Analyser_checkZero(ma, ast_BinaryOperator_getRHS(b), "division")) return ast_QualType_Invalid;
      break;
   case ast_BinaryOpcode_RemAssign:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype, true);
      if (!module_analyser_Analyser_checkZero(ma, ast_BinaryOperator_getRHS(b), "remainder")) return ast_QualType_Invalid;
      break;
   case ast_BinaryOpcode_AddAssign:
   case ast_BinaryOpcode_SubAssign:
      result = module_analyser_Analyser_checkBinopAddSubAssign(ma, b, ltype, rtype);
      break;
   case ast_BinaryOpcode_ShlAssign:
   case ast_BinaryOpcode_ShrAssign:
      result = module_analyser_Analyser_checkBinopShiftArgs(ma, b, ltype, rtype, true);
      break;
   case ast_BinaryOpcode_AndAssign:
   case ast_BinaryOpcode_XorAssign:
   case ast_BinaryOpcode_OrAssign:
      result = module_analyser_Analyser_checkBinopIntArgs(ma, b, ltype, rtype, true);
      break;
   }
   ast_Expr_combineConstantFlags(e, lhs, rhs);
   return result;
}

static bool module_analyser_Analyser_checkZero(module_analyser_Analyser* ma, ast_Expr* e, const char* operation)
{
   if (!ast_Expr_isCtv(e)) return true;
   ast_Value val = ast_evalExpr(e);
   if (ast_Value_isDecimal(&val) && ast_Value_isZero(&val)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "%s by zero is undefined", operation);
      return false;
   }
   return true;
}

static ast_QualType module_analyser_Analyser_analyseBuiltin(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_BuiltinExpr* b = (ast_BuiltinExpr*)e;
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof:
      return module_analyser_Analyser_analyseSizeof(ma, b);
   case ast_BuiltinExprKind_Elemsof:
      return module_analyser_Analyser_analyseElemsof(ma, b);
   case ast_BuiltinExprKind_EnumMin:
   case ast_BuiltinExprKind_EnumMax:
      return module_analyser_Analyser_analyseEnumMinMax(ma, b);
   case ast_BuiltinExprKind_OffsetOf:
      return module_analyser_Analyser_analyseOffsetOf(ma, b);
   case ast_BuiltinExprKind_ToContainer:
      return module_analyser_Analyser_analyseToContainer(ma, b);
   }
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseSizeof(module_analyser_Analyser* ma, ast_BuiltinExpr* e)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(e);
   ;//assert(inner);
   bool savedPublic = ma->usedPublic;
   ma->usedPublic = false;
   ast_QualType qt;
   if (ast_Expr_isType(inner)) {
      ast_TypeExpr* te = (ast_TypeExpr*)inner;
      ast_TypeRef* ref = ast_TypeExpr_getTypeRef(te);
      qt = module_analyser_Analyser_analyseTypeRef(ma, ref);
      ast_Expr_setType(inner, qt);
   } else {
      qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, 0);
      if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
      if (ast_QualType_isArray(qt)) {
         const ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(qt);
         if (at && !ast_ArrayType_hasSize(at)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "sizeof cannot be used on arrays of unknown length");
            return ast_QualType_Invalid;
         }
      }
      if (ast_QualType_isStruct(qt)) {
         ast_StructType* st = ast_QualType_getStructType(qt);
         const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
         if (ast_StructTypeDecl_isOpaque(std)) {
            const ast_Decl* d = (ast_Decl*)std;
            bool is_external = ma->mod != ast_Decl_getModule(d);
            if (ma->curFunction && ast_FunctionDecl_getInstanceModule(ma->curFunction) == ast_Decl_getModule(d)) {
               is_external = false;
            }
            if (is_external) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "opaque type '%s' used by value", ast_QualType_diagName(qt));
            }
         }
      }
   }
   ma->usedPublic = savedPublic;
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   size_analyser_TypeSize info = size_analyser_sizeOfType(qt);
   ast_BuiltinExpr_setUValue(e, info.size);
   return ast_getBuiltinQT(ast_BuiltinKind_UInt32);
}

static ast_QualType module_analyser_Analyser_analyseElemsof(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   bool savedPublic = ma->usedPublic;
   ma->usedPublic = false;
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   ma->usedPublic = savedPublic;
   if (ast_QualType_isInvalid(qt)) return qt;
   const ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(qt);
   if (at) {
      if (!ast_ArrayType_hasSize(at)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "elemsof cannot be used on arrays of unknown length");
         return ast_QualType_Invalid;
      }
      ast_BuiltinExpr_setUValue(b, ast_ArrayType_getSize(at));
      return ast_getBuiltinQT(ast_BuiltinKind_UInt32);
   }
   const ast_EnumType* et = ast_QualType_getEnumTypeOrNil(qt);
   if (et) {
      const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      ast_BuiltinExpr_setUValue(b, ast_EnumTypeDecl_getNumConstants(etd));
      return ast_getBuiltinQT(ast_BuiltinKind_UInt32);
   }
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "elemsof can only be used on arrays/enums");
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseEnumMinMax(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   ast_EnumType* et = ast_QualType_getEnumTypeOrNil(qt);
   if (!et) {
      const char* kind = (ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_EnumMin) ? "enum_min" : "enum_max";
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "%s can only be used on enum types", kind);
      return ast_QualType_Invalid;
   }
   ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
   uint32_t num = ast_EnumTypeDecl_getNumConstants(etd);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
   uint32_t index = 0;
   if (ast_BuiltinExpr_getKind(b) == ast_BuiltinExprKind_EnumMax) index = num - 1;
   ast_BuiltinExpr_setValue(b, ast_EnumConstantDecl_getValue(constants[index]));
   return ast_EnumTypeDecl_getImplType(etd);
}

static ast_QualType module_analyser_Analyser_analyseOffsetOf(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* e = (ast_Expr*)b;
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   ast_Expr_setType(e, ast_getBuiltinQT(ast_BuiltinKind_UInt32));
   ast_StructType* st = ast_QualType_getStructTypeOrNil(qt);
   if (!st) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "offsetof can only be used on struct types");
      return ast_QualType_Invalid;
   }
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   if (!module_analyser_Analyser_checkOpaque(ma, std, ast_Expr_getLoc(inner))) return ast_QualType_Invalid;
   ast_Expr* member = ast_BuiltinExpr_getOffsetOfMember(b);
   ast_Decl* d = module_analyser_Analyser_findMemberOffset(ma, b, std, member);
   if (!d) return ast_QualType_Invalid;
   return ast_Expr_getType(e);
}

static ast_QualType module_analyser_Analyser_analyseToContainer(module_analyser_Analyser* ma, ast_BuiltinExpr* b)
{
   ast_Expr* inner = ast_BuiltinExpr_getInner(b);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &inner, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   ast_StructType* st = ast_QualType_getStructTypeOrNil(qt);
   if (!st) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(inner), "to_container can only be used on struct types");
      return ast_QualType_Invalid;
   }
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   if (!module_analyser_Analyser_checkOpaque(ma, std, ast_Expr_getLoc(inner))) return ast_QualType_Invalid;
   ast_Expr* member = ast_BuiltinExpr_getToContainerMember(b);
   ast_Decl* d = module_analyser_Analyser_findMemberOffset(ma, b, std, member);
   if (!d) return ast_QualType_Invalid;
   ast_Expr** pptr = ast_BuiltinExpr_getToContainerPointer2(b);
   ast_QualType qptr = module_analyser_Analyser_analyseExpr(ma, pptr, false, module_analyser_RHS);
   if (ast_QualType_isInvalid(qptr)) return ast_QualType_Invalid;
   ast_PointerType* pt = ast_QualType_getPointerType(qptr);
   ast_QualType_copyQuals(&qt, ast_PointerType_getInner(pt));
   ast_QualType qmem = ast_Decl_getType(d);
   ast_QualType_copyQuals(&qmem, ast_PointerType_getInner(pt));
   ast_QualType expectedType = ast_builder_Builder_actOnPointerType(ma->builder, qmem);
   if (!conversion_checker_Checker_check(&ma->checker, expectedType, qptr, pptr, ast_Expr_getLoc((*pptr)))) {
      return ast_QualType_Invalid;
   }
   return ast_builder_Builder_actOnPointerType(ma->builder, qt);
}

static ast_Decl* module_analyser_Analyser_findMemberOffsetAux(module_analyser_Analyser* ma, module_analyser_FindMemberOffsetContext* ctx, ast_Expr* member)
{
   ast_Decl* d = NULL;
   if (ast_Expr_isIdentifier(member)) {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)member;
      uint32_t name_idx = ast_IdentifierExpr_getNameIdx(i);
      d = module_analyser_Analyser_findStructMemberOffset(ma, ctx->std, name_idx, ast_Expr_getLoc(member), &ctx->base_offset);
      if (!d) return NULL;
      ast_IdentifierExpr_setDecl(i, d);
      ast_Decl_setUsed(d);
      ast_Expr_setLValue(member);
      ast_IdentifierExpr_setKind(i, ast_IdentifierKind_StructMember);
   } else {
      ;//assert(ast_Expr_isMember(member));
      ast_MemberExpr* m = (ast_MemberExpr*)member;
      uint32_t start = 0;
      if (ast_MemberExpr_hasExpr(m)) {
         d = module_analyser_Analyser_findMemberOffsetAux(ma, ctx, ast_MemberExpr_getBaseExpr(m));
         if (!d) return NULL;
         if (ast_Decl_isStructType(d)) ctx->std = (ast_StructTypeDecl*)d;
         start = 1;
      }
      for (uint32_t i = start; i < 2; i++) {
         uint32_t name_idx = ast_MemberExpr_getNameIdx(m, i);
         src_loc_SrcLoc loc = ast_MemberExpr_getLoc(m, i);
         d = module_analyser_Analyser_findStructMemberOffset(ma, ctx->std, name_idx, loc, &ctx->base_offset);
         if (!d) return NULL;
         if (ast_Decl_isStructType(d)) ctx->std = (ast_StructTypeDecl*)d;
         ast_Decl_setUsed(d);
         ast_MemberExpr_setDecl(m, d, i);
      }
      ast_MemberExpr_setKind(m, ast_IdentifierKind_StructMember);
   }
   ast_Expr_setType(member, ast_Decl_getType(d));
   return d;
}

static ast_Decl* module_analyser_Analyser_findMemberOffset(module_analyser_Analyser* ma, ast_BuiltinExpr* b, ast_StructTypeDecl* std, ast_Expr* member)
{
   module_analyser_FindMemberOffsetContext ctx = { std, 0 };
   ast_Decl* d = module_analyser_Analyser_findMemberOffsetAux(ma, &ctx, member);
   if (d) ast_BuiltinExpr_setUValue(b, ctx.base_offset);
   return d;
}

static ast_Decl* module_analyser_Analyser_findStructMemberOffset(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc, uint32_t* base)
{
   ast_Decl* d = ast_StructTypeDecl_findMember(s, name_idx, base);
   if (!d) module_analyser_Analyser_memberError(ma, name_idx, loc, s);
   return d;
}

static ast_QualType module_analyser_Analyser_analyseCallExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_CallExpr* call = (ast_CallExpr*)e;
   ast_Expr** func = ast_CallExpr_getFunc2(call);
   ast_Expr* origFn = ast_CallExpr_getFunc(call);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, func, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   if (ast_Expr_isNValue(origFn)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(origFn), ast_Expr_getRange(origFn), "called object is not a function or function pointer");
      return ast_QualType_Invalid;
   }
   ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(qt);
   if (!ft) {
      ast_Expr* fn2 = ast_CallExpr_getFunc(call);
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(fn2), ast_Expr_getRange(fn2), "called object type %s is not a function or function pointer", ast_QualType_diagName(qt));
      return ast_QualType_Invalid;
   }
   ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   if (fd != ma->curFunction) ast_Decl_setUsed(ast_FunctionDecl_asDecl(fd));
   if (ast_FunctionDecl_hasAttrNoReturn(fd)) ast_CallExpr_setNoreturn(call);
   if (ast_FunctionDecl_isTemplate(fd)) {
      if (!ast_CallExpr_getTemplateArg(call)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "function %s requires a template argument", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
      fd = module_analyser_Analyser_instantiateTemplateFunction(ma, call, fd);
      if (!fd) return ast_QualType_Invalid;
   } else {
      if (ast_CallExpr_getTemplateArg(call)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "function %s is not a template function", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
   }
   if (ast_FunctionDecl_hasAttrDeprecated(fd) && !ma->warnings->no_deprecated) {
      const ast_AST* a = ast_Decl_getAST(((ast_Decl*)fd));
      const attr_Attr* deprecated = ast_AST_getAttr(a, ((ast_Decl*)fd), attr_AttrKind_Deprecated);
      const char* msg = string_pool_Pool_idx2str(ma->astPool, deprecated->value.text);
      module_analyser_Analyser_warn(ma, ast_Expr_getLoc(origFn), "function %s is deprecated: %s", ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)), msg);
   }
   uint32_t func_num_args = ast_FunctionDecl_getNumParams(fd);
   uint32_t call_num_args = ast_CallExpr_getNumArgs(call);
   bool isTypeFuncCall = false;
   src_loc_SrcLoc loc = ast_Expr_getLoc(e);
   ast_QualType baseType;
   ast_MemberExpr* m = NULL;
   if (ast_Expr_isMember(origFn)) {
      m = (ast_MemberExpr*)origFn;
      ast_Decl* fdd = (ast_Decl*)fd;
      switch (ast_FunctionDecl_getCallKind(fd)) {
      case ast_CallKind_Invalid:
         ;//assert(0);
         break;
      case ast_CallKind_Normal:
         break;
      case ast_CallKind_TypeFunc:
         if (!ast_MemberExpr_isStaticTypeFunc(m)) {
            isTypeFuncCall = true;
            ast_CallExpr_setCallsTypeFunc(call);
            baseType = ast_MemberExpr_getBaseType(m);
            loc = ast_MemberExpr_getMemberLoc(m);
         }
         break;
      case ast_CallKind_StaticTypeFunc:
         if (!ast_MemberExpr_isStaticTypeFunc(m)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "'%s' is a static type-function; use '%s()'", ast_Decl_getFullName(fdd), ast_Decl_getFullName(fdd));
            module_analyser_Analyser_note(ma, ast_Decl_getLoc(fdd), "'%s' is defined here", ast_Decl_getFullName(fdd));
            return ast_QualType_Invalid;
         }
         ast_CallExpr_setCallsStaticTypeFunc(call);
         break;
      }
   }
   uint32_t num_auto_args = ast_FunctionDecl_getNumAutoArgs(fd);
   if (num_auto_args) ast_CallExpr_setHasAutoArgs(call);
   ast_VarDecl** func_args = ast_FunctionDecl_getParams(fd);
   ast_Expr** call_args = ast_CallExpr_getArgs(call);
   uint32_t func_arg_index = 0;
   uint32_t call_arg_index = 0;
   if (isTypeFuncCall) {
      ;//assert(ast_FunctionDecl_getNumParams(fd) >= 1);
      ;//assert(m);
      ast_VarDecl* arg0 = func_args[0];
      ast_QualType expectedType = ast_Decl_getType(ast_VarDecl_asDecl(arg0));
      if (ast_QualType_isPointer(expectedType)) {
         if (!ast_QualType_isPointer(baseType)) {
            ast_Expr* base = ast_MemberExpr_getBaseExpr(m);
            if (base && !ast_Expr_isLValue(base)) {
               module_analyser_Analyser_errorRange(ma, ast_MemberExpr_getLoc(m, 0), ast_Expr_getRange(base), "type function needs lvalue");
               return ast_QualType_Invalid;
            }
            baseType = ast_builder_Builder_actOnPointerType(ma->builder, baseType);
            ast_MemberExpr_setConversion(m, ast_MemberConversion_Addr);
         }
      } else {
         if (ast_QualType_isPointer(baseType)) {
            baseType = ast_QualType_getPointerBaseType(baseType);
            ast_MemberExpr_setConversion(m, ast_MemberConversion_Deref);
         }
      }
      bool ok = conversion_checker_Checker_check(&ma->checker, expectedType, baseType, e_ptr, loc);
      if (!ok) return ast_QualType_Invalid;
      func_arg_index++;
   }
   uint8_t format_arg_idx = 0;
   ast_FormatAttr format_attr = ast_FunctionDecl_getFormatAttr(fd, &format_arg_idx);
   while (1) {
      if (func_arg_index >= func_num_args) break;
      ast_VarDecl* vd = func_args[func_arg_index];
      ast_Decl* d = ast_VarDecl_asDecl(vd);
      if (ast_VarDecl_hasAutoAttr(vd)) {
         func_arg_index++;
         continue;
      }
      if (call_arg_index >= call_num_args) break;
      ast_Expr* arg = call_args[call_arg_index];
      if (ast_Expr_isNamedArgument(arg)) {
         ast_NamedArgument* n = (ast_NamedArgument*)arg;
         uint32_t arg_name_idx = ast_NamedArgument_getNameIdx(n);
         uint32_t param_name_idx;
         bool found = false;
         while (func_arg_index < func_num_args) {
            vd = func_args[func_arg_index];
            d = ast_VarDecl_asDecl(vd);
            param_name_idx = ast_Decl_getNameIdx(d);
            found = (param_name_idx == arg_name_idx);
            if (found) break;
            if (!ast_VarDecl_hasInit(vd)) break;
            func_arg_index++;
         }
         if (!found) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(arg), "unexpected named argument '%s'", string_pool_Pool_idx2str(ma->astPool, arg_name_idx));
            if (func_arg_index < func_num_args) {
               if (param_name_idx) {
                  module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "expected argument '%s' instead", string_pool_Pool_idx2str(ma->astPool, param_name_idx));
               } else {
                  module_analyser_Analyser_note(ma, ast_Decl_getLoc(d), "expected unnamed argument");
               }
            }
            return ast_QualType_Invalid;
         }
      }
      if (!module_analyser_Analyser_analyseInitExpr(ma, &call_args[call_arg_index], ast_Decl_getType(d), ast_Expr_getLoc(arg), false, false)) return ast_QualType_Invalid;
      func_arg_index++;
      call_arg_index++;
   }
   uint32_t expected_args = func_num_args - num_auto_args - isTypeFuncCall;
   if (func_arg_index < func_num_args) {
      uint32_t missing_args = 0;
      for (uint32_t i = func_arg_index; i < func_num_args; i++) {
         if (!ast_VarDecl_hasInit(func_args[i])) missing_args++;
      }
      if (missing_args) {
         module_analyser_Analyser_error(ma, ast_CallExpr_getEndLoc(call) - 1, "too few arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), expected_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
   }
   if (call_arg_index != call_num_args || ast_FunctionDecl_isVariadic(fd)) {
      if (!ast_FunctionDecl_isVariadic(fd)) {
         ast_Expr* call_arg = call_args[call_arg_index];
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(call_arg), "too many arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), expected_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
         return ast_QualType_Invalid;
      }
      while (call_arg_index != call_num_args) {
         ast_QualType callType = module_analyser_Analyser_analyseExpr(ma, &call_args[call_arg_index], true, module_analyser_RHS);
         if (ast_QualType_isInvalid(callType)) return ast_QualType_Invalid;
         if (ast_QualType_isVoid(callType)) {
            ast_Expr* call_arg = call_args[call_arg_index];
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(call_arg), "passing 'void' as variadic argument is invalid");
            return ast_QualType_Invalid;
         }
         call_arg_index++;
      }
      if (format_attr) {
         format_arg_idx -= num_auto_args + isTypeFuncCall;
         uint32_t num_args = call_num_args - format_arg_idx - 1;
         ast_CallExpr_setFormatAttr(call, format_attr);
         if (!module_analyser_Analyser_checkFormatArgs(ma, &call_args[format_arg_idx], num_args, &call_args[format_arg_idx + 1], format_attr)) return ast_QualType_Invalid;
      }
   }
   return ast_FunctionDecl_getRType(fd);
}

static bool module_analyser_on_printf_specifier(void* context, uint32_t offset, printf_utils_PrintfSpecifier specifier, printf_utils_PrintfConversion* conv)
{
   if (specifier == printf_utils_PrintfSpecifier_Percent) return true;
   module_analyser_FormatAnalyser* fa = context;
   module_analyser_Analyser* ma = fa->ma;
   ast_Expr** args = fa->args;
   offset += conv->len;
   string_buffer_Buf_add2(fa->out, fa->format + fa->last_offset, offset - fa->last_offset);
   char c = conv->c;
   if (specifier == printf_utils_PrintfSpecifier_Invalid) {
      src_loc_SrcLoc loc = fa->loc + offset;
      switch (c) {
      case '\0':
         module_analyser_Analyser_error(ma, loc, "missing conversion specifier at end of format string");
         break;
      case '%':
         module_analyser_Analyser_error(ma, loc, "invalid '%%%%' conversion specifier");
         break;
      case 'h':
      case 'j':
      case 'l':
      case 't':
      case 'w':
      case 'z':
      case 'L':
         module_analyser_Analyser_error(ma, loc, "format length modifier '%c' should be omitted", c);
         break;
      case 'i':
      case 'u':
         module_analyser_Analyser_error(ma, loc, "invalid format specifier '%%%c', should use '%%d'", c);
         break;
      default:
         module_analyser_Analyser_error(ma, loc, "invalid format specifier '%%%c'", c);
         break;
      }
      return false;
   }
   uint32_t stars = conv->has_width_star + conv->has_prec_star;
   if (fa->idx + stars >= fa->num_args) {
      module_analyser_Analyser_error(ma, fa->loc + offset, "too many format specifiers or not enough arguments");
      return false;
   }
   for (uint32_t i = 0; i < stars; i++) {
      ast_Expr* arg = args[fa->idx];
      ast_QualType qt = ast_Expr_getType(arg);
      qt = ast_QualType_getCanonicalType(qt);
      if (!ast_QualType_promotesToInt32(qt)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(arg), "argument for '*' width/precision specifier must be an i32");
      }
      fa->idx++;
   }
   ast_Expr* arg = args[fa->idx];
   ast_QualType qt = ast_Expr_getType(arg);
   qt = ast_QualType_getCanonicalType(qt);
   switch (specifier) {
   case printf_utils_PrintfSpecifier_Invalid:
      break;
   case printf_utils_PrintfSpecifier_String:
      if (!ast_QualType_isCharPointer(qt)) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%s' expects a string argument");
      }
      break;
   case printf_utils_PrintfSpecifier_Char:
      if (!ast_QualType_isCharCompatible(qt)) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%c' expects a character argument");
      }
      break;
   case printf_utils_PrintfSpecifier_Integer: {
      if (ast_QualType_isEnum(qt)) {
         ast_EnumType* et = ast_QualType_getEnumType(qt);
         qt = ast_EnumType_getImplType(et);
      }
      ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(qt);
      if (!bi || !ast_BuiltinType_isIntegerOrBool(bi)) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%%c' expects an integer argument", c);
         break;
      }
      uint32_t width = ast_BuiltinType_getWidth(bi);
      if (width > 32) string_buffer_Buf_add1(fa->out, 'l');
      if (c == 'd' && width >= 32 && ast_BuiltinType_isUnsigned(bi)) c = 'u';
      break;
   }
   case printf_utils_PrintfSpecifier_FloatingPoint: {
      ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(qt);
      if (!bi || !ast_BuiltinType_isFloatingPoint(bi)) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%%c' expects a floating-point argument", c);
      }
      break;
   }
   case printf_utils_PrintfSpecifier_Pointer:
      if (!ast_QualType_isPointer(qt) && !ast_QualType_isFunction(qt)) {
         module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%p' expects a pointer argument");
      }
      break;
   case printf_utils_PrintfSpecifier_Offset:
      if (ast_QualType_isPointer(qt)) {
         const ast_PointerType* p = ast_QualType_getPointerType(qt);
         ast_QualType t = ast_PointerType_getInner(p);
         ast_BuiltinType* bi = ast_QualType_getBuiltinTypeOrNil(t);
         if (bi && ast_BuiltinType_isInteger(bi)) {
            uint32_t width = ast_BuiltinType_getWidth(bi);
            if (width < 16) string_buffer_Buf_add1(fa->out, 'h');
            if (width < 32) string_buffer_Buf_add1(fa->out, 'h');
            if (width > 32) string_buffer_Buf_add1(fa->out, 'l');
            break;
         }
      }
      module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "format '%%n' expects an integer pointer argument");
      break;
   case printf_utils_PrintfSpecifier_Percent:
      break;
   }
   string_buffer_Buf_add1(fa->out, c);
   fa->last_offset = offset + 1;
   fa->idx++;
   return true;
}

static bool module_analyser_on_scanf_specifier(void* context, uint32_t offset, printf_utils_ScanfSpecifier specifier, printf_utils_ScanfConversion* conv)
{
   module_analyser_FormatAnalyser* fa = context;
   module_analyser_Analyser* ma = fa->ma;
   ast_Expr** args = fa->args;
   offset += conv->len;
   string_buffer_Buf_add2(fa->out, fa->format + fa->last_offset, offset - fa->last_offset);
   char c = conv->c;
   if (specifier == printf_utils_ScanfSpecifier_Invalid) {
      src_loc_SrcLoc loc = fa->loc + offset;
      switch (c) {
      case '\0':
         module_analyser_Analyser_error(ma, loc, "missing conversion specifier at end of format string");
         break;
      case '%':
         module_analyser_Analyser_error(ma, loc, "invalid '%%%%' conversion specifier");
         break;
      case 'h':
      case 'j':
      case 'l':
      case 't':
      case 'w':
      case 'z':
      case 'L':
         module_analyser_Analyser_error(ma, loc, "conversion length modifier '%c' should be omitted", c);
         break;
      case 'i':
      case 'u':
         module_analyser_Analyser_error(ma, loc, "invalid conversion specifier '%%%c', should use '%%d'", c);
         break;
      default:
         module_analyser_Analyser_error(ma, loc, "invalid conversion specifier '%%%c'", c);
         break;
      }
      return false;
   }
   if (!conv->has_star) {
      if (fa->idx >= fa->num_args) {
         module_analyser_Analyser_error(ma, fa->loc + offset, "too many conversion specifiers or not enough arguments");
         return false;
      }
      ast_Expr* arg = args[fa->idx++];
      ast_QualType qt = ast_Expr_getType(arg);
      qt = ast_QualType_getCanonicalType(qt);
      ast_QualType tt = ast_QualType_Invalid;
      ast_BuiltinType* bi = NULL;
      if (ast_QualType_isPointer(qt)) {
         const ast_PointerType* p = ast_QualType_getPointerType(qt);
         tt = ast_PointerType_getInner(p);
         tt = ast_QualType_getImplType(&tt);
         bi = ast_QualType_getBuiltinTypeOrNil(tt);
      }
      switch (specifier) {
      case printf_utils_ScanfSpecifier_Invalid:
         break;
      case printf_utils_ScanfSpecifier_String:
      case printf_utils_ScanfSpecifier_Scanset:
         if (!ast_QualType_isCharPointer(qt)) {
            module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "conversion '%%s' expects a string argument");
         }
         break;
      case printf_utils_ScanfSpecifier_Char:
         if (!bi || !ast_QualType_isCharCompatible(tt)) {
            module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "conversion '%%c' expects a character pointer argument");
         }
         break;
      case printf_utils_ScanfSpecifier_Integer:
      case printf_utils_ScanfSpecifier_Offset: {
         if (!bi || !ast_BuiltinType_isIntegerOrBool(bi)) {
            module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "conversion '%%%c' expects an integer pointer argument", c);
            break;
         }
         uint32_t width = ast_BuiltinType_getWidth(bi);
         if (width < 16) string_buffer_Buf_add1(fa->out, 'h');
         if (width < 32) string_buffer_Buf_add1(fa->out, 'h');
         if (width > 32) string_buffer_Buf_add1(fa->out, 'l');
         if (c == 'd' && ast_BuiltinType_isUnsigned(bi)) c = 'u';
         break;
      }
      case printf_utils_ScanfSpecifier_FloatingPoint:
         if (!bi || !ast_BuiltinType_isFloatingPoint(bi)) {
            module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "conversion '%%%c' expects a floating-point pointer argument", c);
         }
         if (ast_BuiltinType_getWidth(bi) > 32) string_buffer_Buf_add1(fa->out, 'l');
         break;
      case printf_utils_ScanfSpecifier_Pointer:
         if (!bi || (!ast_QualType_isPointer(tt) && !ast_QualType_isFunction(tt))) {
            module_analyser_Analyser_error(ma, ast_Expr_getStartLoc(arg), "conversion '%%p' expects a pointer to a pointer argument");
         }
         break;
      case printf_utils_ScanfSpecifier_Percent:
         break;
      }
   }
   string_buffer_Buf_add1(fa->out, c);
   if (conv->len2) string_buffer_Buf_add2(fa->out, fa->format + offset + 1, conv->len2);
   fa->last_offset = offset + 1 + conv->len2;
   return true;
}

static const char* module_analyser_get_format(ast_Expr* format, src_loc_SrcLoc* format_loc)
{
   if (!ast_Expr_isImplicitCast(format)) return NULL;
   ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)format;
   if (!ast_ImplicitCastExpr_isArrayToPointerDecay(ic)) return NULL;
   format = ast_ImplicitCastExpr_getInner(ic);
   *format_loc = ast_Expr_getLoc(format);
   for (;;) {
      switch (ast_Expr_getKind(format)) {
      case ast_ExprKind_StringLiteral: {
         *format_loc = ast_Expr_getLoc(format) + 1;
         ast_StringLiteral* s = (ast_StringLiteral*)format;
         return ast_StringLiteral_getText(s);
      }
      case ast_ExprKind_Identifier: {
         ast_QualType qt = ast_Expr_getType(format);
         ;//assert(ast_QualType_isArray(qt));
         ast_ArrayType* at = ast_QualType_getArrayType(qt);
         qt = ast_ArrayType_getElemType(at);
         if (!ast_QualType_isConst(qt)) return NULL;
         ast_IdentifierExpr* id = (ast_IdentifierExpr*)format;
         ast_Decl* decl = ast_IdentifierExpr_getDecl(id);
         ;//assert(ast_Decl_isVariable(decl));
         ast_VarDecl* vd = (ast_VarDecl*)decl;
         format = ast_VarDecl_getInit(vd);
         ;//assert(format);
         continue;
      }
      case ast_ExprKind_Member: {
         ast_QualType qt = ast_Expr_getType(format);
         ;//assert(ast_QualType_isArray(qt));
         ast_ArrayType* at = ast_QualType_getArrayType(qt);
         qt = ast_ArrayType_getElemType(at);
         if (!ast_QualType_isConst(qt)) return NULL;
         ast_MemberExpr* m = (ast_MemberExpr*)format;
         ast_Decl* decl = ast_MemberExpr_getFullDecl(m);
         ;//assert(ast_Decl_isVariable(decl));
         ast_VarDecl* vd = (ast_VarDecl*)decl;
         format = ast_VarDecl_getInit(vd);
         ;//assert(format);
         continue;
      }
      default:
         ;//assert(0);
         return NULL;
      }
   }
}

static bool module_analyser_Analyser_checkFormatArgs(module_analyser_Analyser* ma, ast_Expr** format_ptr, uint32_t num_args, ast_Expr** args, ast_FormatAttr format_attr)
{
   ast_Expr* format = *format_ptr;
   src_loc_SrcLoc format_loc = ast_Expr_getLoc(format);
   const char* format_text = module_analyser_get_format(format, &format_loc);
   if (!format_text) {
      module_analyser_Analyser_error(ma, format_loc, "format argument is not a constant string");
      return false;
   }
   string_buffer_Buf* out = string_buffer_create(256, false, 0);
   module_analyser_FormatAnalyser fa = {
   ma,
   format_text,
   args,
   num_args,
   0,
   format_loc,
   0,
   out,
   format_attr
};
   switch (format_attr) {
   case ast_FormatAttr_None:
      break;
   case ast_FormatAttr_Printf:
      if (!printf_utils_parsePrintfFormat(format_text, module_analyser_on_printf_specifier, &fa)) {
         string_buffer_Buf_free(out);
         return false;
      }
      break;
   case ast_FormatAttr_Scanf:
      if (!printf_utils_parseScanfFormat(format_text, module_analyser_on_scanf_specifier, &fa)) {
         string_buffer_Buf_free(out);
         return false;
      }
      break;
   }
   string_buffer_Buf_add(out, format_text + fa.last_offset);
   if (fa.idx < num_args) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(args[fa.idx]), "too many arguments for format");
      string_buffer_Buf_free(out);
      return false;
   }
   const char* new_format_text = string_buffer_Buf_data(out);
   if (strcmp(format_text, new_format_text)) {
      uint32_t len = string_buffer_Buf_size(out);
      ast_Expr* new_format = ast_builder_Builder_actOnStringLiteral(ma->builder, 0, len, string_pool_Pool_add(ma->astPool, new_format_text, len, true), len);
      ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)*format_ptr;
      ast_Expr* orig = ast_ImplicitCastExpr_getInner(ic);
      ast_ImplicitCastExpr_setInner(ic, new_format);
      *format_ptr = ast_builder_Builder_actOnAlternate(ma->builder, orig, *format_ptr);
   }
   string_buffer_Buf_free(out);
   return true;
}

static void module_analyser_create_template_name(char* name, const char* orig, uint16_t idx)
{
   sprintf(name, "%s_%d_", orig, idx);
}

static void module_analyser_Analyser_opaque_callback(void* arg, src_loc_SrcLoc loc, ast_Decl* d)
{
   module_analyser_Analyser* ma = arg;
   ast_QualType qt = ast_Decl_getType(d);
   module_analyser_Analyser_error(ma, loc, " using opaque type '%s'", ast_QualType_diagName(qt));
}

static ast_FunctionDecl* module_analyser_Analyser_instantiateTemplateFunction(module_analyser_Analyser* ma, ast_CallExpr* call, ast_FunctionDecl* fd)
{
   ast_TypeRef* template_arg = ast_CallExpr_getTemplateArg(call);
   ast_QualType templateType = module_analyser_Analyser_analyseTypeRef(ma, template_arg);
   if (ast_QualType_isInvalid(templateType)) return NULL;
   ast_FunctionDecl* instance = ast_Module_findInstance(ma->mod, fd, templateType);
   if (!instance) {
      bool used_opaque = false;
      ast_StructType* st = ast_QualType_getStructTypeOrNil(templateType);
      if (st) {
         ast_StructTypeDecl* std = ast_StructType_getDecl(st);
         ast_Decl* d = (ast_Decl*)std;
         used_opaque = (ast_StructTypeDecl_isOpaque(std) && ast_Decl_getModule(d) != ma->mod);
      }
      ast_Instantiator inst = {
   .c = ma->context,
   .ref = template_arg,
   .template_name = ast_FunctionDecl_getTemplateNameIdx(fd),
   .instance_ast_idx = ast_CallExpr_getInstanceASTIdx(call),
   .used_opaque = used_opaque,
   .arg = ma,
   .on_error = module_analyser_Analyser_opaque_callback
};
      instance = ast_FunctionDecl_instantiate(fd, &inst);
      ast_Decl* d = (ast_Decl*)instance;
      module_analyser_Analyser_analyseFunction(ma, instance);
      if (ma->has_error) return NULL;
      ast_Decl_setChecked(d);
      ast_Module* template_mod = ast_Decl_getModule(ast_FunctionDecl_asDecl(fd));
      module_analyser_Analyser* analyser = module_analyser_create(ma->diags, ma->context, ma->astPool, ma->builder, ma->allmodules, ma->warnings);
      module_analyser_Analyser_setMod(analyser, template_mod);
      scope_Scope* tmpScope = scope_create(ma->allmodules, ma->diags, ast_AST_getImports(ast_Decl_getAST(d)), template_mod, ast_Module_getSymbols(template_mod), !ma->warnings->no_unused_variable);
      module_analyser_Analyser_analyseFunctionBody(analyser, instance, tmpScope);
      scope_Scope_free(tmpScope);
      module_analyser_Analyser_free(analyser);
      if (ma->has_error) return NULL;
      uint16_t instance_idx = ast_Module_addInstance(ma->mod, fd, templateType, instance);
      ast_FunctionDecl_setTemplateInstanceIdx(instance, instance_idx);
      char name[64];
      module_analyser_create_template_name(name, ast_Decl_getName(d), instance_idx);
      ast_FunctionDecl_setInstanceName(instance, string_pool_Pool_addStr(ma->astPool, name, true));
   }
   ast_CallExpr_setTemplateIdx(call, ast_FunctionDecl_getTemplateInstanceIdx(instance));
   return instance;
}

static ast_QualType module_analyser_Analyser_analysePureCallExpr(module_analyser_Analyser* ma, ast_Expr* e)
{
   ast_CallExpr* call = (ast_CallExpr*)e;
   ast_Expr** func = ast_CallExpr_getFunc2(call);
   ast_Expr* origFn = ast_CallExpr_getFunc(call);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, func, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   if (ast_Expr_isNValue(origFn)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(origFn), ast_Expr_getRange(origFn), "called object is not a function or function pointer");
      return ast_QualType_Invalid;
   }
   ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(qt);
   if (!ft) {
      ast_Expr* fn2 = ast_CallExpr_getFunc(call);
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(fn2), ast_Expr_getRange(fn2), "called object type %s is not a function or function pointer", ast_QualType_diagName(qt));
      return ast_QualType_Invalid;
   }
   ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   if (fd != ma->curFunction) ast_Decl_setUsed(ast_FunctionDecl_asDecl(fd));
   if (!ast_FunctionDecl_hasAttrPure(fd)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "only pure functions can be called in global initializers");
      module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      return ast_QualType_Invalid;
   }
   uint32_t func_num_args = ast_FunctionDecl_getNumParams(fd);
   uint32_t call_num_args = ast_CallExpr_getNumArgs(call);
   ast_Expr** call_args = ast_CallExpr_getArgs(call);
   if (func_num_args != call_num_args) {
      if (call_num_args > func_num_args) {
         src_loc_SrcLoc loc = func_num_args ? ast_Expr_getEndLoc(call_args[func_num_args - 1]) : ast_CallExpr_getEndLoc(call) - 1;
         module_analyser_Analyser_error(ma, loc, "too many arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), func_num_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      } else {
         module_analyser_Analyser_error(ma, ast_CallExpr_getEndLoc(call) - 1, "too few arguments to %sfunction call, expected %u, have %u", ast_FunctionDecl_getDiagKind(fd), func_num_args, call_num_args);
         module_analyser_Analyser_note(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), module_analyser_NoteDeclaredHere, ast_Decl_getFullName(ast_FunctionDecl_asDecl(fd)));
      }
      return ast_QualType_Invalid;
   }
   return ast_QualType_Invalid;
}

static ast_QualType module_analyser_Analyser_analyseExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, bool need_rvalue, uint32_t side)
{
   ;//assert(e_ptr);
   ast_QualType result = module_analyser_Analyser_analyseExprInner(ma, e_ptr, side);
   if (ast_QualType_isInvalid(result)) return result;
   ast_Expr_setType((*e_ptr), result);
   if (need_rvalue) return module_analyser_Analyser_convertRvalue(ma, e_ptr, result);
   return result;
}

static ast_QualType module_analyser_Analyser_convertRvalue(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType result)
{
   ast_Expr* e = *e_ptr;
   if (ast_Expr_isLValue(e)) {
      ast_QualType canon = ast_QualType_getCanonicalType(result);
      ;//assert(ast_QualType_isValid(canon));
      if (ast_QualType_isArray(canon)) {
         result = module_analyser_getPointerFromArray(ma->builder, canon);
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_ArrayToPointerDecay, e_ptr, result);
      } else {
         ast_QualType_unsetConst(&result);
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_LValueToRValue, e_ptr, result);
      }
   } else if (ast_Expr_isNValue(e)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "lvalue/rvalue required");
      return ast_QualType_Invalid;
   }
   return result;
}

static ast_QualType module_analyser_Analyser_analyseExprInner(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
      return ast_Expr_getType(e);
   case ast_ExprKind_Identifier: {
      ast_Decl* d = module_analyser_Analyser_analyseIdentifier(ma, e_ptr, side);
      if (!d) break;
      return ast_Decl_getType(d);
   }
   case ast_ExprKind_Type:
      break;
   case ast_ExprKind_Call:
      return module_analyser_Analyser_analyseCallExpr(ma, e_ptr);
   case ast_ExprKind_InitList:
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      ast_Expr_dump((*e_ptr));
      ;//assert(0);
      break;
   case ast_ExprKind_BinaryOperator:
      return module_analyser_Analyser_analyseBinaryOperator(ma, e_ptr);
   case ast_ExprKind_UnaryOperator:
      return module_analyser_Analyser_analyseUnaryOperator(ma, e_ptr, side);
   case ast_ExprKind_ConditionalOperator:
      return module_analyser_Analyser_analyseConditionalOperator(ma, e_ptr);
   case ast_ExprKind_Builtin:
      return module_analyser_Analyser_analyseBuiltin(ma, e_ptr);
   case ast_ExprKind_ArraySubscript:
      return module_analyser_Analyser_analyseArraySubscriptExpr(ma, e_ptr, side);
   case ast_ExprKind_Member:
      return module_analyser_Analyser_analyseMemberExpr(ma, e_ptr, side);
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = (ast_ParenExpr*)e;
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_ParenExpr_getInner2(p), false, side);
      ast_Expr* inner = ast_ParenExpr_getInner(p);
      ast_Expr_copyConstantFlags(e, inner);
      ast_Expr_copyValType(e, inner);
      return qt;
   }
   case ast_ExprKind_BitOffset:
      break;
   case ast_ExprKind_ExplicitCast:
      return module_analyser_Analyser_analyseExplicitCast(ma, e_ptr);
   case ast_ExprKind_ImplicitCast:
      break;
   case ast_ExprKind_Range:
      ast_Expr_dump((*e_ptr));
      ;//assert(0);
      break;
   case ast_ExprKind_NamedArgument: {
      ast_NamedArgument* n = (ast_NamedArgument*)e;
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_NamedArgument_getInner2(n), false, side);
      ast_Expr* inner = ast_NamedArgument_getInner(n);
      ast_Expr_copyConstantFlags(e, inner);
      ast_Expr_copyValType(e, inner);
      return qt;
   }
   case ast_ExprKind_Alternate:
      break;
   }
   return ast_QualType_Invalid;
}

static const char* module_analyser_type2str(ast_QualType q)
{
   if (ast_QualType_isFunction(q)) return "function";
   if (ast_QualType_isConst(q)) return "constant";
   return "variable";
}

static ast_Decl* module_analyser_Analyser_analyseIdentifier(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
   if (ast_IdentifierExpr_hasDecl(i)) return ast_IdentifierExpr_getDecl(i);
   ast_Decl* d = scope_Scope_find(ma->scope, ast_IdentifierExpr_getNameIdx(i), ast_Expr_getLoc(e), ma->usedPublic);
   if (!d) {
      ma->has_error = true;
      return NULL;
   }
   if (!ast_Decl_isChecked(d)) {
      if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) {
         return NULL;
      }
   }
   ast_QualType qt = ast_Decl_getType(d);
   if (ast_QualType_isInvalid(qt)) return NULL;
   ast_Expr_setType(e, qt);
   ast_IdentifierExpr_setDecl(i, d);
   if (side & module_analyser_RHS || side == 0) {
      if (d != (ast_Decl*)ma->curFunction) ast_Decl_setUsed(d);
   } else {
      if (ast_Decl_isVarDecl(d)) {
         ast_VarDecl* vd = (ast_VarDecl*)d;
         if (ast_VarDecl_isParameter(vd)) ast_Decl_setUsed(d);
      }
   }
   ast_IdentifierKind kind = module_analyser_Analyser_setExprFlags(ma, e_ptr, d);
   ast_IdentifierExpr_setKind(i, kind);
   if (ma->usedPublic && !ast_Decl_isPublic(d) && ast_Decl_isGlobal(d) && !ast_Decl_isImport(d)) {
      const char* kind_str = module_analyser_type2str(qt);
      if (scope_Scope_inFunction(ma->scope)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "public inline function using non-public %s '%s'", kind_str, ast_Decl_getFullName(d));
      } else {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "public declaration using non-public %s '%s'", kind_str, ast_Decl_getFullName(d));
      }
      return NULL;
   }
   return d;
}

static ast_IdentifierKind module_analyser_Analyser_setExprFlags(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_Decl* d)
{
   ast_Expr* e = *e_ptr;
   ast_IdentifierKind kind = ast_IdentifierKind_Unresolved;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      ast_Expr_setCtc(e);
      ast_Expr_setRValue(e);
      kind = ast_IdentifierKind_Function;
      break;
   case ast_DeclKind_Import:
      ast_Expr_setCtc(e);
      kind = ast_IdentifierKind_Module;
      break;
   case ast_DeclKind_StructType:
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_EnumType:
      ast_Expr_setCtc(e);
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_EnumConstant:
      ast_Expr_setCtc(e);
      ast_Expr_setCtv(e);
      ast_Expr_setRValue(e);
      kind = ast_IdentifierKind_EnumConstant;
      break;
   case ast_DeclKind_FunctionType:
      ast_Expr_setCtc(e);
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_AliasType:
      kind = ast_IdentifierKind_Type;
      break;
   case ast_DeclKind_Variable: {
      ast_VarDecl* vd = (ast_VarDecl*)d;
      if (ast_VarDecl_isGlobal(vd) || ast_VarDecl_hasLocalQualifier(vd)) ast_Expr_setCtc(e);
      ast_Expr_setLValue(e);
      const ast_Expr* init = ast_VarDecl_getInit(vd);
      ast_QualType t = ast_Decl_getType(d);
      if (init && ast_QualType_isConst(t) && ast_Expr_isCtv(init)) ast_Expr_setCtv(e);
      switch (ast_VarDecl_getKind(vd)) {
      case ast_VarDeclKind_GlobalVar:
      case ast_VarDeclKind_LocalVar:
      case ast_VarDeclKind_FunctionParam:
         kind = ast_IdentifierKind_Var;
         break;
      case ast_VarDeclKind_StructMember:
         kind = ast_IdentifierKind_StructMember;
         break;
      }
      break;
   }
   }
   return kind;
}

static ast_QualType module_analyser_Analyser_analyseConditionalOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_ConditionalOperator* cond = (ast_ConditionalOperator*)e;
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_ConditionalOperator_getCond2(cond), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return ast_QualType_Invalid;
   if (!module_analyser_validTestType(qt)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(ast_ConditionalOperator_getCond(cond)), "invalid condition expression (%s)", ast_QualType_diagName(qt));
      return ast_QualType_Invalid;
   }
   ast_QualType lhs = module_analyser_Analyser_analyseExpr(ma, ast_ConditionalOperator_getLHS2(cond), true, module_analyser_RHS);
   ast_QualType rhs = module_analyser_Analyser_analyseExpr(ma, ast_ConditionalOperator_getRHS2(cond), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(lhs) || ast_QualType_isInvalid(rhs)) return ast_QualType_Invalid;
   ast_QualType lcanon = ast_QualType_getCanonicalType(lhs);
   ast_QualType rcanon = ast_QualType_getCanonicalType(rhs);
   ;//assert(ast_QualType_isValid(lcanon));
   ;//assert(ast_QualType_isValid(rcanon));
   if (ast_Expr_isCtv(ast_ConditionalOperator_getCond(cond))) ast_Expr_combineConstantFlags(e, ast_ConditionalOperator_getLHS(cond), ast_ConditionalOperator_getRHS(cond));
   uint8_t res = module_analyser_CondOpTable[ast_QualType_getKind(lcanon)][ast_QualType_getKind(rcanon)];
   switch (res) {
   case 0:
      break;
   case 1:
   invalid:
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid operands to ternary operator (%s and %s)", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
      return ast_QualType_Invalid;
   case 2: {
   builtin:;
      ast_BuiltinType* bl = ast_QualType_getBuiltin(lcanon);
      ast_BuiltinType* br = ast_QualType_getBuiltin(rcanon);
      ast_QualType optype = conversion_checker_get_common_arithmetic_type(bl, br);
      if (!ast_QualType_isValid(optype)) goto invalid;
      ast_BuiltinType* bi = ast_QualType_getBuiltin(optype);
      if (bl != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_ConditionalOperator_getLHS2(cond), optype);
      }
      if (br != bi) {
         ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, ast_ConditionalOperator_getRHS2(cond), optype);
      }
      return optype;
   }
   case 3:
      rcanon = ast_QualType_getImplType(&rcanon);
      goto builtin;
   case 4: {
      ast_PointerType* pt1 = ast_QualType_getPointerType(lcanon);
      ast_PointerType* pt2 = ast_QualType_getPointerType(rcanon);
      ast_QualType t1 = ast_PointerType_getInner(pt1);
      ast_QualType t2 = ast_PointerType_getInner(pt2);
      if (ast_QualType_getTypeOrNil(t1) != ast_QualType_getTypeOrNil(t2) && !ast_QualType_isVoid(t1) && !ast_QualType_isVoid(t2)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "ternary operands are pointers of different types ('%s' and '%s')", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
         return ast_QualType_Invalid;
      }
      return ast_QualType_isConst(t1) ? lhs : rhs;
   }
   case 5:
      lcanon = ast_QualType_getImplType(&lcanon);
      goto builtin;
   case 6:
      if (ast_QualType_getTypeOrNil(lcanon) != ast_QualType_getTypeOrNil(rcanon)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "ternary operands are enums of different types ('%s' and '%s')", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
         return ast_QualType_Invalid;
      }
      return lhs;
   case 7:
      if (ast_Expr_getKind(ast_ConditionalOperator_getLHS(cond)) != ast_ExprKind_Nil) goto invalid;
      return rhs;
   case 8:
      if (ast_Expr_getKind(ast_ConditionalOperator_getRHS(cond)) != ast_ExprKind_Nil) goto invalid;
      return lhs;
   case 9:
      return lhs;
   case 10:
      if (ast_QualType_getTypeOrNil(lcanon) != ast_QualType_getTypeOrNil(rcanon)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "ternary operands are structs or unions of different types ('%s' and '%s')", ast_QualType_diagName(lhs), ast_QualType_diagName(rhs));
         return ast_QualType_Invalid;
      }
      return lhs;
   case 11:
      return lhs;
   }
   ast_Expr_dump(e);
   ;//assert(0);
   return ast_QualType_Invalid;
}

static bool module_analyser_Analyser_checkAssignment(module_analyser_Analyser* ma, ast_Expr* assignee, ast_QualType tleft, const char* msg, src_loc_SrcLoc loc)
{
   if (!ast_Expr_isLValue(assignee)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(assignee), ast_Expr_getRange(assignee), "lvalue required as %s", msg);
      return false;
   }
   if (ast_QualType_isArray(tleft)) {
      module_analyser_Analyser_error(ma, loc, "array type '%s' is not assignable", ast_QualType_diagName(tleft));
      return false;
   }
   if (ast_QualType_isConst(tleft)) {
      if (ast_Expr_isIdentifier(assignee)) {
         ast_IdentifierExpr* i = (ast_IdentifierExpr*)assignee;
         module_analyser_Analyser_error(ma, loc, "cannot assign to read-only variable '%s'", ast_Decl_getFullName(ast_IdentifierExpr_getDecl(i)));
         return false;
      }
      if (ast_Expr_isMember(assignee)) {
         ast_MemberExpr* m = (ast_MemberExpr*)assignee;
         switch (ast_MemberExpr_getKind(m)) {
         case ast_IdentifierKind_Unresolved:
            ;//assert(0);
            break;
         case ast_IdentifierKind_Module:
            ;//assert(0);
            break;
         case ast_IdentifierKind_Function:
            break;
         case ast_IdentifierKind_Type:
            break;
         case ast_IdentifierKind_Var:
            module_analyser_Analyser_error(ma, loc, "cannot assign to read-only variable '%s'", ast_MemberExpr_getMemberName(m));
            return false;
         case ast_IdentifierKind_EnumConstant:
            break;
         case ast_IdentifierKind_StructMember:
            module_analyser_Analyser_error(ma, loc, "assignment of member '%s' in read-only object", ast_MemberExpr_getMemberName(m));
            return false;
         case ast_IdentifierKind_Label:
            break;
         }
      }
      module_analyser_Analyser_error(ma, loc, "cannot assign to variable with const-qualified type '%s'", ast_QualType_diagName(tleft));
      return false;
   }
   return true;
}

static ast_QualType module_analyser_usualUnaryConversions(ast_Expr* e)
{
   ast_QualType qt = ast_Expr_getType(e);
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   if (!ast_QualType_isBuiltin(canon)) return ast_QualType_Invalid;
   ast_BuiltinType* bi = ast_QualType_getBuiltin(canon);
   if (ast_BuiltinType_isPromotableIntegerType(bi)) return ast_getBuiltinQT(ast_BuiltinKind_Int32);
   return qt;
}

static ast_QualType module_analyser_Analyser_analyseExplicitCast(module_analyser_Analyser* ma, ast_Expr** e_ptr)
{
   ast_Expr* e = *e_ptr;
   ast_ExplicitCastExpr* c = (ast_ExplicitCastExpr*)e;
   ast_TypeRef* ref = ast_ExplicitCastExpr_getTypeRef(c);
   ast_QualType destType = module_analyser_Analyser_analyseTypeRef(ma, ref);
   ast_QualType srcType = module_analyser_Analyser_analyseExpr(ma, ast_ExplicitCastExpr_getInner2(c), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(srcType) || ast_QualType_isInvalid(destType)) return ast_QualType_Invalid;
   ast_Expr* inner = ast_ExplicitCastExpr_getInner(c);
   ast_Expr_copyConstantFlags(e, inner);
   ast_Expr_copyValType(e, inner);
   ast_ExplicitCastExpr_setDestType(c, destType);
   if (!ast_QualType_isScalar(destType)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "used type '%s' where arithmetic or pointer type is required", ast_QualType_diagName(destType));
      return ast_QualType_Invalid;
   }
   if (!conversion_checker_Checker_checkCast(&ma->checker, destType, srcType, ast_TypeRef_getLoc(ref), ast_Expr_getLoc(inner))) return ast_QualType_Invalid;
   return destType;
}

static ast_QualType module_analyser_Analyser_analyseArraySubscriptExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_ArraySubscriptExpr* sub = (ast_ArraySubscriptExpr*)e;
   ast_Expr* orig = ast_ArraySubscriptExpr_getBase(sub);
   ast_QualType q = module_analyser_Analyser_analyseExpr(ma, ast_ArraySubscriptExpr_getBase2(sub), true, side | module_analyser_RHS);
   if (ast_QualType_isInvalid(q)) return q;
   ast_Expr* index = ast_ArraySubscriptExpr_getIndex(sub);
   if (ast_Expr_isBitOffset(index)) {
      if (side & module_analyser_LHS) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "bitoffset cannot be used as left hand side expression");
         return ast_QualType_Invalid;
      }
      ast_Expr* base = ast_ArraySubscriptExpr_getBase(sub);
      q = module_analyser_Analyser_analyseBitOffsetExpr(ma, q, base, index);
      ast_Expr_combineConstantFlags(e, base, index);
      return q;
   }
   q = ast_QualType_getCanonicalType(q);
   if (!ast_QualType_isPointer(q)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "subscripted value is not an array or pointer");
      return ast_QualType_Invalid;
   }
   bool is_enum_index = false;
   ast_QualType index_type = ast_QualType_Invalid;
   ast_QualType qidx;
   ast_QualType otype = ast_Expr_getType(orig);
   otype = ast_QualType_getCanonicalType(otype);
   if (ast_QualType_isArray(otype)) {
      const ast_ArrayType* at = ast_QualType_getArrayType(otype);
      is_enum_index = ast_ArrayType_isEnumIndex(at);
      index_type = ast_ArrayType_getIndexType(at);
   }
   if (is_enum_index && module_analyser_Analyser_checkEnumArg(ma, ast_ArraySubscriptExpr_getIndex2(sub), index_type)) {
      qidx = index_type;
   } else {
      qidx = module_analyser_Analyser_analyseExpr(ma, ast_ArraySubscriptExpr_getIndex2(sub), true, module_analyser_RHS);
   }
   if (ast_QualType_isInvalid(qidx)) return qidx;
   ast_QualType canon = ast_QualType_getCanonicalType(qidx);
   index = ast_ArraySubscriptExpr_getIndex(sub);
   if (!ast_QualType_isInteger(canon) && !ast_QualType_isEnum(canon)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(index), "array subscript is not an integer");
      return ast_QualType_Invalid;
   }
   if (is_enum_index && ast_QualType_getTypeOrNil(index_type) != ast_QualType_getTypeOrNil(canon)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(index), "array subscript must have enum type '%s'", ast_QualType_diagName(index_type));
      return ast_QualType_Invalid;
   }
   if (ast_Expr_isCtv(index)) {
      ast_QualType q2 = ast_Expr_getType(orig);
      ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(q2);
      if (at) {
         uint32_t size = ast_ArrayType_getSize(at);
         if (size != 0) {
            ast_Value val = ast_evalExpr(index);
            uint64_t idx = ast_Value_as_u64(&val);
            if (idx >= size) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(index), "array out-of-bounds access [%lu] in array of [%u]", idx, size);
               return ast_QualType_Invalid;
            }
         }
      }
   }
   ast_PointerType* pt = ast_QualType_getPointerType(q);
   return ast_PointerType_getInner(pt);
}

static ast_QualType module_analyser_Analyser_analyseBitOffsetExpr(module_analyser_Analyser* ma, ast_QualType ltype, ast_Expr* base, ast_Expr* e)
{
   ast_BitOffsetExpr* bo = (ast_BitOffsetExpr*)e;
   ast_QualType canon = ast_QualType_getCanonicalType(ltype);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(canon);
   if (!ast_QualType_isBuiltin(canon) || !ast_BuiltinType_isUnsigned(bi)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(base), "bitoffsets are only allowed on unsigned integer type");
      return ast_QualType_Invalid;
   }
   ast_Value lval;
   ast_Value rval;
   bool lvalid = module_analyser_Analyser_analyseBitOffsetIndex(ma, ast_BitOffsetExpr_getLHS2(bo), canon, &lval);
   bool rvalid = module_analyser_Analyser_analyseBitOffsetIndex(ma, ast_BitOffsetExpr_getRHS2(bo), canon, &rval);
   if (lvalid && rvalid) {
      if (ast_Value_is_less(&lval, &rval)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "left bitoffset index is smaller than right index");
         return ast_QualType_Invalid;
      }
      ast_Value width = ast_Value_minus(&lval, &rval);
      uint64_t w = ast_Value_as_u64(&width) + 1;
      if (w <= 8) {
         ltype = ast_getBuiltinQT(ast_BuiltinKind_UInt8);
      } else if (w <= 16) {
         ltype = ast_getBuiltinQT(ast_BuiltinKind_UInt16);
      } else if (w <= 32) {
         ltype = ast_getBuiltinQT(ast_BuiltinKind_UInt32);
      } else {
         ltype = ast_getBuiltinQT(ast_BuiltinKind_UInt64);
      }
      ast_BitOffsetExpr_setWidth(bo, (uint8_t)w);
      ast_Expr_setType(e, ltype);
   }
   ast_Expr_combineConstantFlags(e, ast_BitOffsetExpr_getLHS(bo), ast_BitOffsetExpr_getRHS(bo));
   return ltype;
}

static bool module_analyser_Analyser_analyseBitOffsetIndex(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType baseType, ast_Value* result)
{
   ast_BuiltinType* base_bi = ast_QualType_getBuiltin(baseType);
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, e_ptr, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return false;
   ast_Expr* e = *e_ptr;
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   ast_BuiltinType* bi = ast_QualType_getBuiltin(canon);
   if (!ast_QualType_isBuiltin(canon) || !ast_BuiltinType_isInteger(bi)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "index of bitoffset has non-integer type '%s'", ast_QualType_diagName(qt));
      return false;
   }
   if (!ast_Expr_isCtv(e)) return false;
   ast_Value val = ast_evalExpr(e);
   if (ast_Value_isNegative(&val)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "bitoffset index value '%s' is negative", ast_Value_str(&val));
      return false;
   }
   if (ast_Value_isFloat(&val)) {
      return false;
   }
   if (ast_Value_as_u64(&val) >= ast_BuiltinType_getWidth(base_bi)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "bitoffset index value '%s' too large for type '%s'", ast_Value_str(&val), ast_QualType_diagName(baseType));
      return false;
   }
   *result = val;
   return true;
}

static void module_analyser_Analyser_memberError(module_analyser_Analyser* ma, uint32_t name_idx, src_loc_SrcLoc loc, ast_StructTypeDecl* s)
{
   module_analyser_Analyser_error(ma, loc, "no member named '%s' in %s '%s'", ast_idx2name(name_idx), ast_StructTypeDecl_isStruct(s) ? "struct" : "union", ast_Decl_getFullName(ast_StructTypeDecl_asDecl(s)));
}

static ast_Decl* module_analyser_Analyser_findStructMember(module_analyser_Analyser* ma, ast_StructTypeDecl* s, uint32_t name_idx, src_loc_SrcLoc loc)
{
   ast_Decl* d = ast_StructTypeDecl_findAny(s, name_idx);
   if (!d) {
      module_analyser_Analyser_memberError(ma, name_idx, loc, s);
      return NULL;
   }
   return d;
}

static ast_QualType module_analyser_getPointerFromArray(ast_builder_Builder* builder, ast_QualType q)
{
   const ast_ArrayType* a = (ast_ArrayType*)ast_QualType_getTypeOrNil(q);
   ast_QualType elem = ast_ArrayType_getElemType(a);
   if (ast_QualType_isConst(q)) ast_QualType_setConst(&elem);
   ast_QualType res = ast_builder_Builder_actOnPointerType(builder, elem);
   return res;
}

static void module_analyser_Analyser_analyseFunction(module_analyser_Analyser* ma, ast_FunctionDecl* fd)
{
   if (ast_FunctionDecl_isTemplate(fd)) {
      scope_Scope_checkGlobalSymbol(ma->scope, ast_FunctionDecl_getTemplateNameIdx(fd), ast_FunctionDecl_getTemplateLoc(fd));
      ast_TypeRef* rtype = ast_FunctionDecl_getReturnTypeRef(fd);
      if (ast_TypeRef_isArray(rtype)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions are not allowed to return array types");
      }
      uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
      ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
      for (uint32_t i = 0; i < num_params; i++) {
         ast_VarDecl* v = params[i];
         ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
         if (ast_TypeRef_isArray(ref)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array types are not allowed here");
         }
      }
      return;
   }
   ast_TypeRef* rtype = ast_FunctionDecl_getReturnTypeRef(fd);
   ast_QualType qt = module_analyser_Analyser_analyseTypeRef(ma, rtype);
   if (ast_QualType_isInvalid(qt)) return;
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   if (ast_QualType_isArray(canon)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions are not allowed to return array types");
   }
   if (ast_QualType_isConst(canon) && !ast_QualType_isPointer(canon)) {
      module_analyser_Analyser_warn(ma, ast_TypeRef_getLoc(rtype), "'const' type qualifier on return type has no effect");
   }
   bool is_public = ast_Decl_isPublic(ast_FunctionDecl_asDecl(fd));
   if (is_public) ast_setTypePublicUsed(qt);
   ast_FunctionDecl_setRType(fd, qt);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   uint32_t auto_arg_count = 0;
   uint32_t first_auto_arg = 0;
   for (uint32_t i = 0; i < num_params; i++) {
      ast_VarDecl* vd = params[i];
      ast_TypeRef* ref = ast_VarDecl_getTypeRef(vd);
      ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
      if (ast_QualType_isInvalid(res)) continue;
      canon = ast_QualType_getCanonicalType(res);
      if (ast_QualType_isArray(canon)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array types are not allowed here");
         continue;
      }
      if (ast_QualType_isVoid(canon)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "parameter has invalid type 'void'");
         continue;
      }
      if (is_public) ast_setTypePublicUsed(res);
      if (ast_VarDecl_hasInit(vd)) {
         if (ast_VarDecl_hasAutoAttr(vd)) {
            module_analyser_Analyser_error(ma, ast_VarDecl_getAssignLoc(vd), "automatic argument cannot have default value");
         }
         ast_Expr** initExpr = ast_VarDecl_getInit2(vd);
         module_analyser_Analyser_analyseInitExpr(ma, initExpr, res, ast_VarDecl_getAssignLoc(vd), false, true);
      }
      if (ast_VarDecl_hasAutoAttr(vd)) {
         if (auto_arg_count == 0) first_auto_arg = i;
         auto_arg_count++;
         if (auto_arg_count > 3) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "too many automatic arguments");
         }
         if (ast_VarDecl_hasAttrAutoFile(vd) && !ast_TypeRef_isConstCharPtr(ref)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "attribute 'auto_file' requires a parameter of type 'const char*'");
         }
         if (ast_VarDecl_hasAttrAutoLine(vd) && !ast_TypeRef_isU32(ref)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "attribute 'auto_line' requires a parameter of type 'u32'");
         }
         if (ast_VarDecl_hasAttrAutoFunc(vd) && !ast_TypeRef_isConstCharPtr(ref)) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "attribute 'auto_func' requires a parameter of type 'const char*'");
         }
      }
      {
         ast_FormatAttr format_attr = ast_VarDecl_getFormatAttr(vd);
         if (format_attr) {
            module_analyser_Analyser_checkFormatArgument(ma, vd, res, i, fd, format_attr);
            ast_FunctionDecl_setFormatAttr(fd, format_attr, (uint8_t)i);
         }
      }
      ast_Decl* d = (ast_Decl*)vd;
      ast_Decl_setType(d, res);
      ast_Decl_setChecked(d);
   }
   bool is_typefn = false;
   if (num_params && ast_FunctionDecl_hasPrefix(fd)) {
      const ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
      const ast_Decl* pd = prefix->decl;
      ;//assert(pd);
      ast_QualType prefixType = ast_Decl_getType(pd);
      ast_TypeRef* ref = ast_VarDecl_getTypeRef(params[0]);
      const ast_Ref* param_ref = ast_TypeRef_getUser(ref);
      bool is_non_static = ((param_ref && param_ref->decl == prefix->decl) || ast_TypeRef_isPointerTo(ref, ast_QualType_getIndex(prefixType)));
      if (is_non_static) {
         ast_FunctionDecl_setCallKind(fd, ast_CallKind_TypeFunc);
         is_typefn = true;
      }
   }
   if (auto_arg_count) {
      ast_FunctionDecl_setNumAutoArgs(fd, auto_arg_count);
      bool seen_normal_arg = false;
      uint32_t start = 0;
      if (is_typefn) start = 1;
      for (uint32_t i = start; i < num_params; i++) {
         ast_VarDecl* v = params[i];
         if (ast_VarDecl_hasAutoAttr(v)) {
            if (seen_normal_arg) {
               module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(v)), "auto-arguments must come before normal arguments");
            }
         } else {
            seen_normal_arg = true;
         }
      }
   }
   if (ast_FunctionDecl_hasAttrConstructor(fd) || ast_FunctionDecl_hasAttrDestructor(fd)) {
      if (!ast_TypeRef_isVoid(rtype)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions marked with '%s' cannot return a value", ast_FunctionDecl_hasAttrConstructor(fd) ? "constructor" : "destructor");
      }
      if (num_params || ast_FunctionDecl_isVariadic(fd)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "functions marked with '%s' cannot have arguments", ast_FunctionDecl_hasAttrConstructor(fd) ? "constructor" : "destructor");
      }
   }
   if (ast_FunctionDecl_hasAttrPure(fd)) {
      if (num_params == 0) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), "pure functions must have arguments");
         return;
      }
      if (ast_FunctionDecl_isVariadic(fd)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_FunctionDecl_asDecl(fd)), "pure functions cannot be variadic");
         return;
      }
      if (ast_TypeRef_isVoid(rtype)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(rtype), "pure functions must return a value");
         return;
      }
      if (auto_arg_count) {
         ast_VarDecl* v = params[first_auto_arg];
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(v)), "pure functions cannot have auto-arguments");
         return;
      }
   }
   ast_Decl* d = (ast_Decl*)fd;
   if (ast_Decl_hasCName(d)) {
      if (!ast_Module_isForeign(ma->mod)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "the cname attribute is only allowed for foreign functions");
         return;
      }
      if (ast_FunctionDecl_hasBody(fd)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "inline functions cannot have a cname attribute");
         return;
      }
   } else {
      if (ast_Module_isForeign(ma->mod) && !ast_FunctionDecl_hasBody(fd) && ast_FunctionDecl_isTypeFunc(fd)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "type functions for foreign functions require a cname attribute");
         return;
      }
   }
}

static void module_analyser_Analyser_analyseFunctionBody(module_analyser_Analyser* ma, ast_FunctionDecl* fd, scope_Scope* s)
{
   if (ast_FunctionDecl_isTemplate(fd)) return;
   ast_CompoundStmt* body = ast_FunctionDecl_getBody(fd);
   if (!body) return;
   ast_Decl* d = (ast_Decl*)fd;
   module_analyser_Analyser_pushCheck(ma, d, s, fd);
   ma->checkStack[0].usedPublic = false;
   ma->usedPublic = ast_FunctionDecl_isInline(fd);
   scope_Scope_reset(ma->scope);
   scope_Scope_enter(ma->scope, scope_Function | scope_Decl);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; i < num_params; i++) {
      ast_Decl* p = (ast_Decl*)params[i];
      if (ast_Decl_getNameIdx(p)) {
         bool error = scope_Scope_add(ma->scope, p);
         if (error) return;
      }
   }
   ma->has_error = false;
   label_vector_LabelVector_reset(&ma->labels);
   module_analyser_FlowBits flow = module_analyser_Analyser_analyseCompoundStmt(ma, body);
   ast_QualType rtype = ast_FunctionDecl_getRType(fd);
   if (!ast_QualType_isVoid(rtype)) {
      if (flow & module_analyser_FlowNext) {
         module_analyser_Analyser_error(ma, ast_CompoundStmt_getEndLoc(body) - 1, "control reaches end of non-void function");
      }
   }
   if (!ma->warnings->no_unused_parameter && !ast_FunctionDecl_hasAttrUnusedParams(fd)) {
      for (uint32_t i = 0; i < num_params; i++) {
         ast_Decl* p = (ast_Decl*)params[i];
         if (!ast_Decl_isUsed(p) && ast_Decl_getNameIdx(p)) {
            module_analyser_Analyser_warn(ma, ast_Decl_getLoc(p), "unused parameter '%s'", ast_Decl_getName(p));
         }
      }
   }
   scope_Scope_exit(ma->scope, ma->has_error);
   uint32_t num_labels = label_vector_LabelVector_getCount(&ma->labels);
   const label_vector_Label* labels = label_vector_LabelVector_getLabels(&ma->labels);
   for (uint32_t i = 0; i < num_labels; i++) {
      const label_vector_Label* l = &labels[i];
      if (l->is_label) {
         if (!l->used && !ma->warnings->no_unused_label) {
            module_analyser_Analyser_warn(ma, l->loc, "unused label '%s'", ast_idx2name(l->name_idx));
         }
      } else {
         module_analyser_Analyser_error(ma, l->loc, "use of undeclared label '%s'", ast_idx2name(l->name_idx));
      }
   }
   module_analyser_Analyser_popCheck(ma);
}

static void module_analyser_Analyser_checkFormatArgument(module_analyser_Analyser* ma, ast_VarDecl* vd, ast_QualType qt, uint32_t idx, ast_FunctionDecl* fd, ast_FormatAttr format_attr)
{
   ast_Decl* d = (ast_Decl*)vd;
   const char* attr_name = "format";
   switch (format_attr) {
   case ast_FormatAttr_None:
      break;
   case ast_FormatAttr_Printf:
      attr_name = "printf_format";
      break;
   case ast_FormatAttr_Scanf:
      attr_name = "scanf_format";
      break;
   }
   if (ast_VarDecl_hasInit(vd)) {
      module_analyser_Analyser_error(ma, ast_VarDecl_getAssignLoc(vd), "%s parameter cannot have default value", attr_name);
      return;
   }
   if (!ast_QualType_isCharPointer(qt)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "%s parameter must have type 'const char*'", attr_name);
      return;
   }
   if (ast_VarDecl_hasAutoAttr(vd)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "%s parameter cannot be an auto-argument", attr_name);
      return;
   }
   if (!ast_FunctionDecl_isVariadic(fd)) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "%s functions must have a variable number of arguments", attr_name);
      return;
   }
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   if (idx != num_params - 1) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "%s parameter must be the last parameter", attr_name);
      return;
   }
}

static bool module_analyser_Analyser_analyseInitExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType, src_loc_SrcLoc assignLoc, bool is_bitfield, bool is_default_param)
{
   ast_Expr* e = *e_ptr;
   if (!is_bitfield) {
      if (ast_Expr_isInitList(e)) {
         return module_analyser_Analyser_analyseInitListExpr(ma, (ast_InitListExpr*)e, expectedType);
      }
      if (ast_Expr_isStringLiteral(e)) {
         ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(expectedType);
         if (at) {
            ast_QualType elem = ast_ArrayType_getElemType(at);
            if (!ast_QualType_isCharCompatible(elem)) {
               module_analyser_Analyser_errorRange(ma, assignLoc, ast_Expr_getRange(e), "cannot initialize array of '%s' with a string literal", ast_QualType_diagName(elem));
               return false;
            }
            ast_QualType st = ast_Expr_getType(e);
            ast_ArrayType* at2 = ast_QualType_getArrayType(st);
            uint32_t rhs_len = ast_ArrayType_getSize(at2);
            if (ast_ArrayType_hasSize(at)) {
               uint32_t lhs_len = ast_ArrayType_getSize(at);
               if (rhs_len > lhs_len) {
                  module_analyser_Analyser_errorRange(ma, assignLoc, ast_Expr_getRange(e), "initializer-string for char array is too long");
                  return false;
               }
            } else {
               ast_ArrayType_setSize(at, rhs_len);
            }
            ast_Expr_setRValue(e);
         } else {
            ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, e_ptr, true, module_analyser_RHS);
            e = *e_ptr;
            if (!conversion_checker_Checker_check(&ma->checker, expectedType, ast_Expr_getType(e), e_ptr, assignLoc)) return false;
         }
         return true;
      }
      if (ast_QualType_isArray(expectedType)) {
         module_analyser_Analyser_error(ma, assignLoc, "array initializer must be an initializer list");
         return false;
      }
   }
   if (ast_Expr_isCall(e) && module_analyser_Analyser_globalScope(ma)) {
      ast_QualType qt = module_analyser_Analyser_analysePureCallExpr(ma, e);
      return true;
   }
   if (module_analyser_Analyser_checkEnumArg(ma, e_ptr, expectedType)) return true;
   ast_QualType res = module_analyser_Analyser_analyseExpr(ma, e_ptr, true, module_analyser_RHS);
   if (ast_QualType_isInvalid(res)) return false;
   e = *e_ptr;
   if (ast_Expr_isCtv(e)) {
      if (is_bitfield) return true;
      if (ast_QualType_isBuiltin(expectedType) && !ast_QualType_isPointer(res)) {
         if (ast_QualType_isBool(expectedType)) return true;
         if (!ctv_analyser_checkRange(ma->diags, expectedType, e)) return false;
         if (ast_QualType_getType(res) != ast_QualType_getType(expectedType)) {
            ast_builder_Builder_insertImplicitCast(ma->builder, ast_ImplicitCastKind_IntegralCast, e_ptr, expectedType);
         }
         return true;
      }
   }
   if (!conversion_checker_Checker_check(&ma->checker, expectedType, res, e_ptr, assignLoc)) return false;
   if (!ma->curFunction && !ast_Expr_isCtv(e)) {
      if (!ast_Expr_isCtc(e)) {
         if (is_default_param) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "default parameter value is not a compile-time value");
         } else {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time constant");
         }
         return false;
      }
      if (ast_QualType_needsCtvInit(expectedType)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time value");
         return false;
      }
   }
   return true;
}

static bool module_analyser_Analyser_checkEnumArg(module_analyser_Analyser* ma, ast_Expr** e_ptr, ast_QualType expectedType)
{
   ast_Expr* e = *e_ptr;
   if (ast_QualType_isEnum(expectedType)) {
      ast_EnumType* et = ast_QualType_getEnum(expectedType);
      ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
      if (ast_Expr_isIdentifier(e)) {
         ast_IdentifierExpr* ie = (ast_IdentifierExpr*)e;
         ast_EnumConstantDecl* ecd = ast_EnumTypeDecl_findConstant(etd, ast_IdentifierExpr_getNameIdx(ie));
         if (ecd) {
            ast_Decl* d = (ast_Decl*)ecd;
            ast_Decl_setUsed(d);
            ast_Expr_setType(e, expectedType);
            ast_IdentifierExpr_setDecl(ie, d);
            ast_IdentifierKind kind = module_analyser_Analyser_setExprFlags(ma, e_ptr, d);
            ast_IdentifierExpr_setKind(ie, kind);
            return true;
         }
      } else if (ast_Expr_getKind(e) == ast_ExprKind_ConditionalOperator) {
         ast_ConditionalOperator* op = (ast_ConditionalOperator*)e;
         module_analyser_Analyser_checkEnumArg(ma, ast_ConditionalOperator_getLHS2(op), expectedType);
         module_analyser_Analyser_checkEnumArg(ma, ast_ConditionalOperator_getRHS2(op), expectedType);
      }
   }
   return false;
}

static bool module_analyser_Analyser_analyseInitListExpr(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(expectedType);
   if (ast_Type_isArrayType(t)) {
      ast_InitListExpr_setIsArray(ile);
      return module_analyser_Analyser_analyseInitListArray(ma, ile, expectedType);
   }
   if (ast_Type_isStructType(t)) {
      return module_analyser_Analyser_analyseInitListStruct(ma, ile, expectedType);
   }
   ast_Expr* e = (ast_Expr*)ile;
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot initialize variable of type '%s' with initializer list", ast_QualType_diagName(expectedType));
   return false;
}

static bool module_analyser_Analyser_analyseArrayDesignatedInit(module_analyser_Analyser* ma, ast_Expr* e, ast_QualType expectedType, bool isEnumIndex, ast_QualType indexType)
{
   ast_ArrayDesignatedInitExpr* ad = (ast_ArrayDesignatedInitExpr*)e;
   ast_QualType qt;
   if (isEnumIndex && module_analyser_Analyser_checkEnumArg(ma, ast_ArrayDesignatedInitExpr_getDesignator2(ad), indexType)) {
      qt = indexType;
   } else {
      qt = module_analyser_Analyser_analyseExpr(ma, ast_ArrayDesignatedInitExpr_getDesignator2(ad), false, module_analyser_RHS);
   }
   if (ast_QualType_isInvalid(qt)) return false;
   ast_Expr* de = ast_ArrayDesignatedInitExpr_getDesignator(ad);
   if (!ast_Expr_isCtv(de)) {
      module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(de), ast_Expr_getRange(de), "array index is not a compile-time value");
      return false;
   }
   ast_Expr* val = ast_ArrayDesignatedInitExpr_getInit(ad);
   if (ast_Expr_isInitList(val)) {
      return module_analyser_Analyser_analyseInitListExpr(ma, (ast_InitListExpr*)val, expectedType);
   }
   bool ok = module_analyser_Analyser_analyseInitExpr(ma, ast_ArrayDesignatedInitExpr_getInit2(ad), expectedType, ast_Expr_getLoc(val), false, false);
   if (!ok) return false;
   val = ast_ArrayDesignatedInitExpr_getInit(ad);
   ast_Expr_copyConstantFlags(e, val);
   ast_Expr_setType(e, expectedType);
   return true;
}

static bool module_analyser_Analyser_analyseInitListArray(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType)
{
   ast_Expr* e = (ast_Expr*)ile;
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   ast_QualType_clearQuals(&expectedType);
   ast_ArrayType* at = ast_QualType_getArrayType(expectedType);
   ast_QualType et = ast_ArrayType_getElemType(at);
   ast_QualType_clearQuals(&et);
   bool ok = true;
   bool ctc = true;
   bool have_designators = false;
   uint32_t current_index = 0;
   for (uint32_t i = 0; i < numValues; i++) {
      ast_Expr* value = values[i];
      if (ast_Expr_isFieldDesignatedInit(value)) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(value), ast_Expr_getRange(value), "field designator cannot initialize an array");
         ok = false;
         continue;
      }
      if (ast_Expr_isArrayDesignatedInit(value)) {
         ok &= module_analyser_Analyser_analyseArrayDesignatedInit(ma, value, et, ast_ArrayType_isEnumIndex(at), ast_ArrayType_getIndexType(at));
         have_designators = true;
      } else {
         ok &= module_analyser_Analyser_analyseInitExpr(ma, &values[i], et, ast_Expr_getLoc(values[i]), false, false);
      }
      ctc &= ast_Expr_isCtc(values[i]);
   }
   current_index = numValues;
   if (ctc) ast_Expr_setCtc(e);
   if (!ok) return false;
   if (have_designators) {
      ast_InitListExpr_setHasDesignators(ile);
      bool has_size = ast_ArrayType_hasSize(at);
      uint32_t array_size = ast_ArrayType_getSize(at);
      init_checker_Checker* checker = module_analyser_Analyser_getInitChecker(ma);
      ok = module_analyser_Analyser_checkArrayDesignators(ma, ile, has_size, &array_size, checker);
      module_analyser_Analyser_putInitChecker(ma, checker);
      if (!has_size) ast_ArrayType_setSize(at, array_size);
   } else {
      if (ast_ArrayType_hasSize(at)) {
         uint32_t arraySize = ast_ArrayType_getSize(at);
         if (current_index > arraySize) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(values[arraySize]), "excess elements in array initializer");
            return false;
         }
      } else {
         ast_ArrayType_setSize(at, numValues);
      }
   }
   ast_Expr_setType(e, expectedType);
   return ok;
}

static bool module_analyser_Analyser_checkArrayDesignators(module_analyser_Analyser* ma, ast_InitListExpr* ile, bool has_size, uint32_t* size, init_checker_Checker* checker)
{
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   bool ok = true;
   uint32_t max_index = 0;
   uint64_t index64 = u64_max;
   for (uint32_t i = 0; i < numValues; i++) {
      src_loc_SrcLoc loc;
      ast_Expr* value = values[i];
      if (ast_Expr_isArrayDesignatedInit(value)) {
         ast_ArrayDesignatedInitExpr* ad = (ast_ArrayDesignatedInitExpr*)value;
         ast_Expr* desig = ast_ArrayDesignatedInitExpr_getDesignator(ad);
         loc = ast_Expr_getLoc(desig);
         ast_Value idx = ast_evalExpr(desig);
         if (!ast_Value_isDecimal(&idx)) {
            module_analyser_Analyser_error(ma, loc, "array designator expression must have integer type");
            return false;
         }
         if (ast_Value_isNegative(&idx)) {
            module_analyser_Analyser_error(ma, loc, "array designator value '%s' is negative", ast_Value_str(&idx));
            return false;
         }
         index64 = ast_Value_as_u64(&idx);
         if (has_size && index64 >= *size) {
            module_analyser_Analyser_error(ma, loc, "array designator index (%lu) exceeds array bounds (%u)", index64, *size);
            return false;
         }
      } else {
         loc = ast_Expr_getLoc(value);
         index64++;
         if (has_size && index64 >= *size) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "excess elements in array initializer");
            return false;
         }
      }
      if (index64 >= u32_max) {
         module_analyser_Analyser_error(ma, loc, "array index %lu is too large", index64);
         return false;
      }
      uint32_t current_index = (uint32_t)index64;
      src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, current_index);
      if (duplicate) {
         module_analyser_Analyser_error(ma, loc, "duplicate initialization of array index");
         module_analyser_Analyser_note(ma, duplicate, "previous initialization is here");
         ok = false;
      } else {
         init_checker_Checker_add(checker, current_index, loc);
      }
      if (current_index > max_index) max_index = current_index;
   }
   if (!has_size) *size = max_index + 1;
   return ok;
}

static void module_analyser_fillFieldInfo(ast_StructTypeDecl* std, module_analyser_FillInfo* fi, uint32_t base_offset)
{
   bool isStruct = ast_StructTypeDecl_isStruct(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   const ast_StructLayout* layout = ast_StructTypeDecl_getLayout(std);
   const uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   for (uint32_t i = 0; i < num_members; i++) {
      ast_Decl* d = members[i];
      ast_FieldInitField* f = &fi->fii->fields[fi->idx];
      f->member_idx = fi->member_idx;
      const ast_StructMemberLayout* ml = &layout->members[i];
      uint32_t member_name = ast_Decl_getNameIdx(d);
      uint32_t offset = base_offset + ml->offset;
      if (member_name == 0) {
         if (ast_Decl_isStructType(d)) {
            ast_StructTypeDecl* sub = (ast_StructTypeDecl*)d;
            module_analyser_fillFieldInfo(sub, fi, offset);
         }
      } else {
         ast_BitFieldLayout* bit_layout = NULL;
         if (ast_Decl_isVariable(d)) {
            ast_VarDecl* vd = (ast_VarDecl*)d;
            bit_layout = ast_VarDecl_getBitfieldLayout(vd);
         }
         f->name_idx = member_name;
         f->offset = offset;
         f->is_bitfield = ml->is_bitfield;
         f->bitfield_offset = ml->bitfield_offset;
         f->bitfield_width = ml->bitfield_width;
         f->bitfield_signed = ml->bitfield_signed;
         f->decl = members[i];
         f->bitfield_base_size = (uint8_t)ml->size;
         if (isStruct) fi->member_idx++;
         fi->idx++;
      }
   }
   if (!isStruct) fi->member_idx++;
}

static const ast_FieldInitInfo* module_analyser_Analyser_getFieldInfo(module_analyser_Analyser* ma, ast_StructTypeDecl* std)
{
   if (ast_StructTypeDecl_hasFieldInfo(std)) return ast_StructTypeDecl_getFieldInfo(std);
   ast_FieldInitInfo* fii = ast_builder_Builder_actOnFieldInitInfo(ma->builder, std);
   module_analyser_FillInfo fi = { .fii = fii };
   module_analyser_fillFieldInfo(std, &fi, 0);
   fii->num_indexes = fi.member_idx + 1;
   return fii;
}

static bool module_analyser_Analyser_analyseStructFieldInit(module_analyser_Analyser* ma, ast_StructTypeDecl* std, ast_InitListExpr* ile, ast_QualType expectedType)
{
   ast_InitListExpr_setHasDesignators(ile);
   const ast_FieldInitInfo* fii = module_analyser_Analyser_getFieldInfo(ma, std);
   module_analyser_StructFieldInitChecker checker; module_analyser_StructFieldInitChecker_init(&checker, fii->num_indexes);
   bool ctc = true;
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   for (uint32_t i = 0; i < numValues; i++) {
      ast_Expr* value = values[i];
      if (ast_Expr_isArrayDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "array designator cannot initialize non-array type '%s'", ast_QualType_diagName(expectedType));
         goto out;
      }
      if (!ast_Expr_isFieldDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "mixing field designators with non-field designators");
         goto out;
      }
      ast_FieldDesignatedInitExpr* fdi = (ast_FieldDesignatedInitExpr*)value;
      uint32_t field_name = ast_FieldDesignatedInitExpr_getField(fdi);
      const ast_FieldInitField* fif = ast_FieldInitInfo_find(fii, field_name);
      if (!fif) {
         module_analyser_Analyser_memberError(ma, field_name, ast_Expr_getLoc(value), std);
         goto out;
      }
      ast_Decl* member = fif->decl;
      ast_FieldDesignatedInitExpr_setMemberInfo(fdi, fif);
      src_loc_SrcLoc prev = module_analyser_StructFieldInitChecker_add(&checker, fif->member_idx, ast_Expr_getLoc(value));
      if (prev) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "duplicate initialization of field '%s'", ast_FieldDesignatedInitExpr_getFieldName(fdi));
         module_analyser_Analyser_note(ma, prev, "previous initialization is here");
         goto out;
      }
      bool ok = module_analyser_Analyser_analyseInitExpr(ma, ast_FieldDesignatedInitExpr_getInit2(fdi), ast_Decl_getType(member), ast_Expr_getLoc(ast_FieldDesignatedInitExpr_getInit(fdi)), fif->is_bitfield, false);
      if (!ok) goto out;
      ast_Expr* inner = ast_FieldDesignatedInitExpr_getInit(fdi);
      ctc &= ast_Expr_isCtc(inner);
      ast_Expr_setType(value, ast_Expr_getType(inner));
      if (fif->is_bitfield && ast_Expr_isCtv(inner)) {
         if (!ctv_analyser_checkBitfield(ma->diags, fif->bitfield_width, fif->bitfield_signed, inner)) return false;
      }
   }
   ast_QualType_clearQuals(&expectedType);
   ast_Expr* e = (ast_Expr*)ile;
   if (ctc) ast_Expr_setCtc(e);
   ast_Expr_setType(e, expectedType);
   module_analyser_StructFieldInitChecker_free(&checker);
   return true;
out:
   module_analyser_StructFieldInitChecker_free(&checker);
   return false;
}

static bool module_analyser_Analyser_analyseInitListStruct(module_analyser_Analyser* ma, ast_InitListExpr* ile, ast_QualType expectedType)
{
   ast_Expr* e = (ast_Expr*)ile;
   uint32_t numValues = ast_InitListExpr_getNumValues(ile);
   ast_Expr** values = ast_InitListExpr_getValues(ile);
   ast_StructType* st = ast_QualType_getStructType(expectedType);
   ast_StructTypeDecl* std = ast_StructType_getDecl(st);
   if (numValues == 0) {
      ast_Expr_setType(e, expectedType);
      ast_Expr_setCtc(e);
      return true;
   }
   const bool haveDesignators = ast_Expr_isFieldDesignatedInit(values[0]);
   if (!haveDesignators && ast_StructTypeDecl_isUnion(std)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(values[0]), "union member initializer needs field designator");
      return false;
   }
   if (haveDesignators) {
      return module_analyser_Analyser_analyseStructFieldInit(ma, std, ile, expectedType);
   }
   bool ctc = true;
   const uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   const ast_StructLayout* layout = ast_StructTypeDecl_getLayout(std);
   uint32_t member_idx = 0;
   for (uint32_t i = 0; i < numValues; i++) {
      ast_Expr* value = values[i];
      const ast_StructMemberLayout* ml = &layout->members[member_idx];
      while (ml->is_bitfield && ml->bitfield_width == 0 && member_idx < num_members) {
         member_idx++;
         ml = &layout->members[member_idx];
      }
      if (member_idx >= num_members) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "excess initializer elements in struct");
         return false;
      }
      if (ast_Expr_isArrayDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "array designator cannot initialize non-array type '%s'", ast_QualType_diagName(expectedType));
         return false;
      }
      if (ast_Expr_isFieldDesignatedInit(value)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(value), "mixing field designators with non-field designators");
         return false;
      }
      ast_Decl_setUsed(members[member_idx]);
      bool ok = module_analyser_Analyser_analyseInitExpr(ma, &values[i], ast_Decl_getType(members[member_idx]), ast_Expr_getLoc(values[i]), ml->is_bitfield, false);
      if (!ok) return false;
      if (ml->is_bitfield && ast_Expr_isCtv(value)) {
         if (!ctv_analyser_checkBitfield(ma->diags, ml->bitfield_width, ml->bitfield_signed, value)) return false;
      }
      ctc &= ast_Expr_isCtc(value);
      member_idx++;
   }
   if (ctc) ast_Expr_setCtc(e);
   ast_QualType_clearQuals(&expectedType);
   ast_Expr_setType(e, expectedType);
   return true;
}

static ast_QualType module_analyser_Analyser_analyseMemberExpr(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_MemberExpr* m = (ast_MemberExpr*)e;
   src_loc_SrcLoc baseLoc = 0;
   ast_ValType valtype = ast_ValType_NValue;
   ast_QualType baseType = ast_QualType_Invalid;
   ast_CallKind ck = ast_CallKind_Invalid;
   uint32_t start = 0;
   if (ast_MemberExpr_hasExpr(m)) {
      ast_Expr* exprBase = ast_MemberExpr_getBaseExpr(m);
      baseLoc = ast_Expr_getLoc(exprBase);
      baseType = module_analyser_Analyser_analyseExpr(ma, &exprBase, false, side);
      if (ast_QualType_isInvalid(baseType)) return ast_QualType_Invalid;
      valtype = ast_Expr_getValType(exprBase);
      start = 1;
   }
   ast_Decl* d = NULL;
   bool is_substruct = false;
   for (uint32_t i = start; i < 2; i++) {
      is_substruct = false;
      uint32_t name_idx = ast_MemberExpr_getNameIdx(m, i);
      src_loc_SrcLoc loc = ast_MemberExpr_getLoc(m, i);
      if (ast_QualType_isInvalid(baseType)) {
         d = scope_Scope_find(ma->scope, name_idx, loc, ma->usedPublic);
         if (!d) {
            ma->has_error = true;
            return ast_QualType_Invalid;
         }
         if (!ast_Decl_isChecked(d)) {
            if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) return ast_QualType_Invalid;
         }
         baseType = ast_Decl_getType(d);
         valtype = module_analyser_decl2valtype(d);
      } else {
         ast_QualType canon = ast_QualType_getCanonicalType(baseType);
         ast_TypeKind kind = module_analyser_Analyser_analyseBaseType(ma, canon);
         bool is_ptr = ast_QualType_isPointer(canon);
         bool inner_const = false;
         bool inner_volatile = false;
         const ast_Type* t = ast_QualType_getTypeOrNil(canon);
         if (is_ptr) {
            ast_PointerType* pt = (ast_PointerType*)t;
            ast_QualType inner = ast_PointerType_getInner(pt);
            inner_const = ast_QualType_isConst(inner);
            inner_volatile = ast_QualType_isVolatile(inner);
            t = ast_QualType_getTypeOrNil(inner);
         }
         switch (kind) {
         case ast_TypeKind_Struct: {
            ast_StructType* st = (ast_StructType*)t;
            ast_StructTypeDecl* std = ast_StructType_getDecl(st);
            d = module_analyser_Analyser_analyseStructMemberAccess(ma, std, name_idx, loc, valtype, side, &ck);
            if (!d) return ast_QualType_Invalid;
            bool is_const = ast_QualType_isConst(baseType);
            bool is_volatile = ast_QualType_isVolatile(baseType);
            baseType = ast_Decl_getType(d);
            is_substruct = ast_Decl_isStructType(d);
            if (is_ptr) {
               is_const = inner_const;
               is_volatile = inner_volatile;
            }
            if (is_ptr && ck != ast_CallKind_Invalid) is_const = is_volatile = false;
            ast_MemberExpr_setConstBase(m, is_const);
            ast_MemberExpr_setVolatileBase(m, is_volatile);
            if (ck == ast_CallKind_Invalid) {
               if (is_const) ast_QualType_setConst(&baseType);
               if (is_volatile) ast_QualType_setVolatile(&baseType);
            }
            break;
         }
         case ast_TypeKind_Enum: {
            ast_EnumType* et = (ast_EnumType*)t;
            ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
            d = (ast_Decl*)etd;
            const char* name = ast_MemberExpr_getMemberName(m);
            if (isupper(name[0]) || name_idx == ma->min_idx || name_idx == ma->max_idx) {
               if (valtype != ast_ValType_NValue) {
                  module_analyser_Analyser_errorRange(ma, baseLoc, ast_MemberExpr_getBaseRange(m), "invalid member reference base (enum constant/variable)");
                  return ast_QualType_Invalid;
               }
               ast_EnumConstantDecl* ecd;
               if (name_idx == ma->min_idx) {
                  ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
                  ecd = constants[0];
               } else if (name_idx == ma->max_idx) {
                  ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(etd);
                  ecd = constants[ast_EnumTypeDecl_getNumConstants(etd) - 1];
               } else {
                  ecd = ast_EnumTypeDecl_findConstant(etd, name_idx);
                  if (!ecd) {
                     module_analyser_Analyser_error(ma, loc, "enum '%s' has no constant '%s'", ast_Decl_getFullName(d), name);
                     return ast_QualType_Invalid;
                  }
               }
               d = (ast_Decl*)ecd;
               if (!ast_Decl_isChecked(d)) {
                  module_analyser_Analyser_error(ma, loc, "circular definition using enum constant '%s'", ast_Decl_getName(d));
                  return ast_QualType_Invalid;
               }
            } else {
               ast_Decl* ef = ast_EnumTypeDecl_findFunction(etd, name_idx);
               if (!ef) {
                  module_analyser_Analyser_error(ma, loc, "enum '%s' has no function '%s'", ast_Decl_getFullName(d), name);
                  return ast_QualType_Invalid;
               }
               ck = (valtype == ast_ValType_NValue) ? ast_CallKind_StaticTypeFunc : ast_CallKind_TypeFunc;
               d = ef;
               baseType = ast_Decl_getType(ef);
               if (!scope_Scope_checkAccess(ma->scope, d, loc)) return ast_QualType_Invalid;
            }
            valtype = ast_ValType_RValue;
            break;
         }
         case ast_TypeKind_Alias:
            ;//assert(0);
            break;
         case ast_TypeKind_Module: {
            ast_ModuleType* mt = (ast_ModuleType*)t;
            d = scope_Scope_findSymbolInModule(ma->scope, ast_ModuleType_getModule(mt), name_idx, loc);
            if (!d) {
               ma->has_error = true;
               return ast_QualType_Invalid;
            }
            if (!ast_Decl_isChecked(d)) {
               if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) return ast_QualType_Invalid;
            }
            baseType = ast_Decl_getType(d);
            valtype = module_analyser_decl2valtype(d);
            break;
         }
         default:
            module_analyser_Analyser_errorRange(ma, loc, ast_MemberExpr_getBaseRange(m), "invalid member reference base");
            return ast_QualType_Invalid;
         }
      }
      baseLoc = loc;
      if (i == 1) {
         if (side & module_analyser_RHS) ast_Decl_setUsed(d);
      } else {
         ast_Decl_setUsed(d);
      }
      ast_MemberExpr_setDecl(m, d, i);
   }
   if (is_substruct) {
      ast_MemberExpr_setKind(m, ast_IdentifierKind_StructMember);
      ast_Expr_setLValue(e);
   } else {
      ast_IdentifierKind kind = module_analyser_Analyser_setExprFlags(ma, e_ptr, d);
      ast_MemberExpr_setKind(m, kind);
   }
   ast_Expr_setType(e, baseType);
   if (ast_Decl_isBitfield(d)) {
      ast_MemberExpr_setBitfield(m);
      if (side == module_analyser_RHS) ast_Expr_setRValue(e);
   } else {
      if (ck == ast_CallKind_Invalid && ast_Decl_isFunction(d)) ck = ast_CallKind_Normal;
      if (ck == ast_CallKind_TypeFunc) ast_MemberExpr_setIsTypeFunc(m);
      if (ck == ast_CallKind_StaticTypeFunc) ast_MemberExpr_setIsStaticTypeFunc(m);
      if (ast_Expr_isCtv(e)) ast_Expr_setRValue(e);
   }
   return baseType;
}

static ast_Decl* module_analyser_Analyser_analyseStructMemberAccess(module_analyser_Analyser* ma, ast_StructTypeDecl* std, uint32_t name_idx, src_loc_SrcLoc loc, ast_ValType valtype, uint32_t side, ast_CallKind* ck)
{
   *ck = ast_CallKind_Invalid;
   ast_Decl* d = module_analyser_Analyser_findStructMember(ma, std, name_idx, loc);
   if (!d) return NULL;
   if (!ast_Decl_isChecked(d)) {
      if (!module_analyser_Analyser_analyseGlobalDecl(ma, d)) return NULL;
   }
   if (ast_Decl_isFunction(d)) {
      ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
      ast_CallKind callkind = ast_FunctionDecl_getCallKind(fd);
      ;//assert(callkind != ast_CallKind_Normal);
      switch (valtype) {
      case ast_ValType_NValue:
         if (callkind != ast_CallKind_StaticTypeFunc) {
         }
         *ck = ast_CallKind_StaticTypeFunc;
         break;
      case ast_ValType_RValue:
         if (callkind == ast_CallKind_StaticTypeFunc) {
            module_analyser_Analyser_error(ma, loc, module_analyser_DiagStaticThoughVar);
            return NULL;
         }
         ;//assert(callkind == ast_CallKind_TypeFunc);
         *ck = ast_CallKind_TypeFunc;
         break;
      case ast_ValType_LValue:
         if (callkind == ast_CallKind_StaticTypeFunc) {
            module_analyser_Analyser_error(ma, loc, module_analyser_DiagStaticThoughVar);
            return NULL;
         }
         ;//assert(callkind == ast_CallKind_TypeFunc);
         *ck = ast_CallKind_TypeFunc;
         break;
      }
      if (!scope_Scope_checkAccess(ma->scope, d, loc)) return NULL;
   } else {
      if (!module_analyser_Analyser_checkOpaque(ma, std, loc)) return NULL;
      if (side && valtype == ast_ValType_NValue) {
         ast_QualType t = ast_Decl_getType(ast_StructTypeDecl_asDecl(std));
         module_analyser_Analyser_error(ma, loc, "member access needs an instantiation of type '%s'", ast_QualType_diagName(t));
         return NULL;
      }
   }
   return d;
}

static ast_TypeKind module_analyser_Analyser_analyseBaseType(module_analyser_Analyser* ma, ast_QualType baseType)
{
   const ast_Type* t = ast_QualType_getTypeOrNil(baseType);
   if (ast_Type_isPointerType(t)) {
      ast_PointerType* pt = (ast_PointerType*)t;
      baseType = ast_PointerType_getInner(pt);
      t = ast_QualType_getTypeOrNil(baseType);
   }
   return ast_Type_getKind(t);
}

static ast_ValType module_analyser_decl2valtype(const ast_Decl* d)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      return ast_ValType_RValue;
   case ast_DeclKind_Import:
   case ast_DeclKind_StructType:
   case ast_DeclKind_EnumType:
   case ast_DeclKind_EnumConstant:
   case ast_DeclKind_FunctionType:
   case ast_DeclKind_AliasType:
      break;
   case ast_DeclKind_Variable:
      return ast_ValType_LValue;
   }
   return ast_ValType_NValue;
}

static ast_Expr* module_analyser_getCondExpr(const ast_Stmt* cond)
{
   if (cond) {
      if (ast_Stmt_isExpr(cond)) return (ast_Expr*)cond;
      if (ast_Stmt_isDecl(cond)) return ast_VarDecl_getInit(ast_DeclStmt_getDecl(((ast_DeclStmt*)(cond)), 0));
   }
   return NULL;
}

static bool module_analyser_Analyser_isNoReturn(module_analyser_Analyser* ma, ast_Expr* e)
{
   if (!ast_Expr_isCall(e)) return false;
   const ast_CallExpr* c = (ast_CallExpr*)e;
   e = ast_CallExpr_getFunc(c);
   ast_QualType qt = ast_Expr_getType(e);
   const ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(qt);
   if (!ft) return false;
   const ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
   return ast_FunctionDecl_hasAttrNoReturn(fd);
}

static module_analyser_FlowBits module_analyser_Analyser_analyseStmt(module_analyser_Analyser* ma, ast_Stmt* s, bool checkEffect)
{
   module_analyser_FlowBits flow = 0;
   if (scope_Scope_isUnreachable(ma->scope)) {
      if (ast_Stmt_getKind(s) != ast_StmtKind_Label && !ma->warnings->no_unreachable_code) {
         module_analyser_Analyser_warn(ma, ast_Stmt_getLoc(s), "unreachable code");
      }
      scope_Scope_setReachable(ma->scope);
   }
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return:
      module_analyser_Analyser_analyseReturnStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      return module_analyser_FlowReturn;
   case ast_StmtKind_Expr: {
      module_analyser_Analyser_analyseExpr(ma, (ast_Expr**)&s, false, 0);
      ast_Expr* e = (ast_Expr*)s;
      if (checkEffect && !ast_Expr_hasEffect(e)) module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "expression without effect");
      if (!ma->has_error && module_analyser_Analyser_isNoReturn(ma, e)) return module_analyser_FlowNoReturn;
      return module_analyser_FlowNext;
   }
   case ast_StmtKind_If:
      flow = module_analyser_Analyser_analyseIfStmt(ma, s);
      break;
   case ast_StmtKind_While:
      flow = module_analyser_Analyser_analyseWhileStmt(ma, s);
      break;
   case ast_StmtKind_For:
      flow = module_analyser_Analyser_analyseForStmt(ma, s);
      break;
   case ast_StmtKind_Switch:
      flow = module_analyser_Analyser_analyseSwitchStmt(ma, s);
      break;
   case ast_StmtKind_Break:
      module_analyser_Analyser_analyseBreakStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      return module_analyser_FlowBreak;
   case ast_StmtKind_Continue:
      module_analyser_Analyser_analyseContinueStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      return module_analyser_FlowContinue;
   case ast_StmtKind_Fallthrough:
      module_analyser_Analyser_analyseFallthroughStmt(ma, s);
      return module_analyser_FlowNext;
   case ast_StmtKind_Label:
      flow = module_analyser_Analyser_analyseLabelStmt(ma, s);
      break;
   case ast_StmtKind_Goto:
      module_analyser_Analyser_analyseGotoStmt(ma, s);
      scope_Scope_setUnreachable(ma->scope);
      return module_analyser_FlowGoto;
   case ast_StmtKind_Compound:
      scope_Scope_enter(ma->scope, scope_Decl);
      flow = module_analyser_Analyser_analyseCompoundStmt(ma, (ast_CompoundStmt*)s);
      scope_Scope_exit(ma->scope, ma->has_error);
      break;
   case ast_StmtKind_Decl:
      module_analyser_Analyser_analyseDeclStmt(ma, s);
      return module_analyser_FlowNext;
   case ast_StmtKind_Asm:
      module_analyser_Analyser_analyseAsmStmt(ma, s);
      return module_analyser_FlowNext;
   case ast_StmtKind_Assert:
      module_analyser_Analyser_analyseAssertStmt(ma, s);
      return module_analyser_FlowNext;
   }
   if (!(flow & module_analyser_FlowNext)) scope_Scope_setUnreachable(ma->scope);
   return flow;
}

static void module_analyser_Analyser_analyseBreakStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   if (!scope_Scope_allowBreak(ma->scope)) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "'break' statement not in loop or switch statement");
   }
}

static void module_analyser_Analyser_analyseContinueStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   if (!scope_Scope_allowContinue(ma->scope)) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "'continue' statement not in loop statement");
   }
}

static void module_analyser_Analyser_analyseFallthroughStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "'fallthrough' statement cannot be used here");
}

static module_analyser_FlowBits module_analyser_Analyser_analyseLabelStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_LabelStmt* ls = (ast_LabelStmt*)s;
   uint32_t name = ast_LabelStmt_getNameIdx(ls);
   label_vector_Label* label = label_vector_LabelVector_find(&ma->labels, name);
   if (label) {
      if (label->is_label) {
         module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "redefinition of label '%s'", ast_LabelStmt_getName(ls));
         module_analyser_Analyser_note(ma, label->loc, "previous definition is here");
      } else {
         label->is_label = true;
         label->stmt = ls;
         ast_LabelStmt_setUsed(ls);
      }
   } else {
      label_vector_Label lab = { .name_idx = name, .loc = ast_Stmt_getLoc(s), .is_label = true, .used = false, .stmt = ls };
      label_vector_LabelVector_add(&ma->labels, lab);
   }
   ast_Stmt* lss = ast_LabelStmt_getStmt(ls);
   if (!lss) return module_analyser_FlowNext;
   return module_analyser_Analyser_analyseStmt(ma, lss, true);
}

static void module_analyser_Analyser_analyseGotoStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_GotoStmt* gs = (ast_GotoStmt*)s;
   uint32_t name = ast_GotoStmt_getNameIdx(gs);
   label_vector_Label* label = label_vector_LabelVector_find(&ma->labels, name);
   if (label) {
      label->used = true;
      if (label->stmt) ast_LabelStmt_setUsed(label->stmt);
   } else {
      label_vector_Label lab = { .name_idx = name, .loc = ast_Stmt_getLoc(s), .is_label = false, .used = true, .stmt = NULL };
      label_vector_LabelVector_add(&ma->labels, lab);
   }
}

static module_analyser_FlowBits module_analyser_Analyser_analyseCompoundStmt(module_analyser_Analyser* ma, ast_CompoundStmt* c)
{
   module_analyser_FlowBits flow = 0;
   module_analyser_FlowBits flow2 = module_analyser_FlowNext;
   uint32_t count = ast_CompoundStmt_getCount(c);
   ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
   for (uint32_t i = 0; i < count; i++) {
      ast_Stmt* s = stmts[i];
      flow2 = module_analyser_Analyser_analyseStmt(ma, s, true);
      flow |= flow2 & (module_analyser_FlowReturn | module_analyser_FlowBreak | module_analyser_FlowContinue | module_analyser_FlowGoto | module_analyser_FlowNoReturn | module_analyser_FlowError);
      if (ma->has_error) return flow;
   }
   return flow | flow2;
}

static ast_QualType module_analyser_Analyser_analyseCondition(module_analyser_Analyser* ma, ast_Stmt** s_ptr, bool check_assign)
{
   ast_Stmt* s = *s_ptr;
   if (ast_Stmt_isDecl(s)) {
      ast_QualType qt = module_analyser_Analyser_analyseDeclStmt(ma, s);
      if (ast_QualType_isValid(qt)) {
         ast_DeclStmt* ds = (ast_DeclStmt*)s;
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, 0);
         if (!ast_VarDecl_getInit(vd)) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(vd)), "variable declaration in condition must have an initializer");
            return ast_QualType_Invalid;
         }
      }
      return qt;
   }
   ;//assert(ast_Stmt_isExpr(s));
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, (ast_Expr**)s_ptr, true, module_analyser_RHS);
   ast_Expr* e = (ast_Expr*)*s_ptr;
   if (ast_QualType_isValid(qt)) conversion_checker_Checker_check(&ma->checker, ast_getBuiltinQT(ast_BuiltinKind_Bool), qt, (ast_Expr**)s_ptr, ast_Expr_getLoc(e));
   e = (ast_Expr*)*s_ptr;
   if (check_assign && ast_Expr_isAssignment(e)) {
      module_analyser_Analyser_warn(ma, ast_Expr_getLoc(e), "using the result of an assignment as a condition without parentheses");
   }
   return qt;
}

static module_analyser_FlowBits module_analyser_Analyser_analyseIfStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   module_analyser_FlowBits flow = module_analyser_FlowNext;
   ast_IfStmt* i = (ast_IfStmt*)s;
   scope_Scope_enter(ma->scope, scope_Decl);
   module_analyser_Analyser_analyseCondition(ma, ast_IfStmt_getCond2(i), true);
   if (ma->has_error) goto done;
   scope_Scope_enter(ma->scope, scope_Decl);
   flow = module_analyser_Analyser_analyseStmt(ma, ast_IfStmt_getThen(i), true);
   scope_Scope_exit(ma->scope, ma->has_error);
   module_analyser_FlowBits flow2 = module_analyser_FlowNext;
   ast_Stmt* else_ = ast_IfStmt_getElse(i);
   if (else_) {
      scope_Scope_enter(ma->scope, scope_Decl);
      flow2 = module_analyser_Analyser_analyseStmt(ma, else_, true);
      scope_Scope_exit(ma->scope, ma->has_error);
   }
   flow |= flow2;
done:
   scope_Scope_exit(ma->scope, ma->has_error);
   return flow;
}

static module_analyser_FlowBits module_analyser_Analyser_analyseForStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   module_analyser_FlowBits flow = module_analyser_FlowNext;
   ast_ForStmt* f = (ast_ForStmt*)s;
   scope_Scope_enter(ma->scope, scope_Break | scope_Continue | scope_Decl | scope_Control);
   ast_Stmt** init = ast_ForStmt_getInit2(f);
   if (init) {
      ast_QualType ct = module_analyser_Analyser_analyseCondition(ma, init, false);
      if (ast_QualType_isInvalid(ct)) goto done;
   }
   ast_Expr** cond = ast_ForStmt_getCond2(f);
   if (cond) {
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, cond, true, module_analyser_RHS);
      if (ast_QualType_isInvalid(qt)) goto done;
      conversion_checker_Checker_check(&ma->checker, ast_getBuiltinQT(ast_BuiltinKind_Bool), qt, cond, ast_Expr_getLoc((*cond)));
      if (ast_Expr_isCtv((*cond))) {
         ast_Value v = ast_evalExpr((*cond));
         if (ast_Value_isZero(&v)) {
         } else {
            flow = 0;
         }
      }
   } else {
      flow = 0;
   }
   ast_Expr** cont = ast_ForStmt_getCont2(f);
   if (cont) {
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, cont, true, module_analyser_RHS);
      if (ast_QualType_isInvalid(qt)) goto done;
   }
   module_analyser_FlowBits flow2 = module_analyser_Analyser_analyseStmt(ma, ast_ForStmt_getBody(f), true);
   flow |= flow2 & (module_analyser_FlowReturn | module_analyser_FlowGoto | module_analyser_FlowNoReturn | module_analyser_FlowError);
   if (flow2 & module_analyser_FlowBreak) flow |= module_analyser_FlowNext;
done:
   scope_Scope_exit(ma->scope, ma->has_error);
   return flow;
}

static module_analyser_FlowBits module_analyser_Analyser_analyseWhileStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   module_analyser_FlowBits flow = module_analyser_FlowNext;
   ast_WhileStmt* w = (ast_WhileStmt*)s;
   scope_Scope_enter(ma->scope, scope_Decl);
   module_analyser_Analyser_analyseCondition(ma, ast_WhileStmt_getCond2(w), true);
   if (ma->has_error) goto done;
   ast_Expr* cond = module_analyser_getCondExpr(ast_WhileStmt_getCond(w));
   if (ast_Expr_isCtv(cond)) {
      ast_Value v = ast_evalExpr(cond);
      if (ast_Value_isZero(&v)) {
      } else {
         flow = 0;
      }
   }
   scope_Scope_enter(ma->scope, scope_Break | scope_Continue | scope_Decl | scope_Control);
   module_analyser_FlowBits flow2 = module_analyser_Analyser_analyseStmt(ma, ast_WhileStmt_getBody(w), true);
   scope_Scope_exit(ma->scope, ma->has_error);
   flow |= flow2 & (module_analyser_FlowReturn | module_analyser_FlowGoto | module_analyser_FlowNoReturn | module_analyser_FlowError);
   if (flow2 & module_analyser_FlowBreak) flow |= module_analyser_FlowNext;
done:
   scope_Scope_exit(ma->scope, ma->has_error);
   return flow;
}

static ast_QualType module_analyser_Analyser_analyseDeclStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_QualType qt = ast_QualType_Invalid;
   ast_DeclStmt* ds = (ast_DeclStmt*)s;
   uint32_t count = ast_DeclStmt_getDeclCount(ds);
   bool has_init = false;
   bool init_err = false;
   for (uint32_t i = 0; i < count; i++) {
      ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, i);
      qt = module_analyser_Analyser_analyseDecl(ma, vd);
      if (i == 0) {
         has_init = ast_VarDecl_hasInit(vd);
      } else {
         if (has_init != ast_VarDecl_hasInit(vd)) init_err = true;
      }
      has_init |= ast_VarDecl_hasInit(vd);
   }
   if (init_err) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "either all declarations must be initialized or none");
   }
   return qt;
}

static ast_QualType module_analyser_Analyser_analyseDecl(module_analyser_Analyser* ma, ast_VarDecl* vd)
{
   ast_Decl* d = (ast_Decl*)vd;
   ast_TypeRef* ref = ast_VarDecl_getTypeRef(vd);
   if (ast_TypeRef_isIncrArray(ref)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "incremental arrays not allowed in function scope");
      return ast_QualType_Invalid;
   }
   ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   if (ast_QualType_isInvalid(res)) return ast_QualType_Invalid;
   ast_Decl_setType(d, res);
   if (ast_QualType_isVoid(res)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "variable has invalid type 'void'");
      return ast_QualType_Invalid;
   }
   if (!ast_AST_isInterface(ast_Decl_getAST(d))) module_analyser_Analyser_checkName(ma, d, false);
   ast_Expr** initExpr = ast_VarDecl_getInit2(vd);
   bool has_init_call = ast_VarDecl_hasInitCall(vd);
   if (!has_init_call && initExpr) {
      module_analyser_Analyser_analyseInitExpr(ma, initExpr, res, ast_VarDecl_getAssignLoc(vd), false, false);
      if (ast_VarDecl_hasLocalQualifier(vd)) {
         ast_Expr* e = ast_VarDecl_getInit(vd);
         if (!ast_Expr_isCtc(e)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time constant");
            return ast_QualType_Invalid;
         }
      }
   } else {
      if (ast_QualType_isConstant(res)) {
         module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "constant variable '%s' must be initialized", ast_Decl_getName(d));
         return ast_QualType_Invalid;
      }
      const ast_ArrayType* at = ast_QualType_getArrayTypeOrNil(res);
      if (at) {
         if (ast_ArrayType_hasSize(at)) {
            if (ast_ArrayType_getSize(at) == 0) {
               module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "only struct members may have array size zero");
               return ast_QualType_Invalid;
            }
         } else {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(d), "array-type variable '%s' needs an explicit size or an initializer", ast_Decl_getName(d));
            return ast_QualType_Invalid;
         }
      }
   }
   ast_Decl_setChecked(d);
   ma->has_error = ma->has_error | scope_Scope_add(ma->scope, d);
   if (has_init_call) {
      ast_Expr* e = *initExpr;
      module_analyser_Analyser_analyseExpr(ma, &e, false, 0);
   }
   return res;
}

static void module_analyser_Analyser_analyseAsmStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_AsmStmt* a = (ast_AsmStmt*)s;
   uint32_t num_exprs = ast_AsmStmt_getNumExprs(a);
   ast_Expr** exprs = ast_AsmStmt_getExprs(a);
   uint32_t num_outputs = ast_AsmStmt_getNumOutputs(a);
   for (uint32_t i = 0; i < num_exprs; i++) {
      bool need_rvalue;
      uint32_t side;
      if (i < num_outputs) {
         need_rvalue = false;
         side = module_analyser_LHS;
      } else {
         need_rvalue = true;
         side = module_analyser_RHS;
      }
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &exprs[i], need_rvalue, side);
      if (ast_QualType_isInvalid(qt)) return;
   }
}

static void module_analyser_Analyser_analyseAssertStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_AssertStmt* a = (ast_AssertStmt*)s;
   ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, ast_AssertStmt_getInner2(a), true, module_analyser_RHS);
   if (ast_QualType_isInvalid(qt)) return;
   ast_Expr* inner = ast_AssertStmt_getInner(a);
   conversion_checker_Checker_check(&ma->checker, ast_getBuiltinQT(ast_BuiltinKind_Bool), qt, ast_AssertStmt_getInner2(a), ast_Expr_getLoc(inner));
}

static void module_analyser_Analyser_analyseReturnStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   ast_ReturnStmt* r = (ast_ReturnStmt*)s;
   ast_Expr** arg = ast_ReturnStmt_getValue2(r);
   if (ast_FunctionDecl_hasReturn(ma->curFunction)) {
      if (!arg) {
         module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s) + 6, "non-void function %s should return a value", ast_Decl_getName(ast_FunctionDecl_asDecl(ma->curFunction)));
         return;
      }
   } else {
      if (arg) {
         ast_Expr* e = ast_ReturnStmt_getValue(r);
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "void function %s should not return a value", ast_Decl_getName(ast_FunctionDecl_asDecl(ma->curFunction)));
         return;
      }
   }
   if (arg) {
      if (!module_analyser_Analyser_analyseInitExpr(ma, arg, ast_FunctionDecl_getRType(ma->curFunction), ast_Expr_getLoc((*arg)), false, false)) return;
      ast_QualType qt = ast_Expr_getType((*arg));
      if (ast_QualType_isPointer(qt)) module_analyser_Analyser_checkReturnAddrOfLocal(ma, *arg);
   }
}

static void module_analyser_Analyser_checkReturnAddrOfLocal(module_analyser_Analyser* ma, ast_Expr* arg)
{
   if (!ast_Expr_isUnaryOp(arg)) return;
   ast_UnaryOperator* uo = (ast_UnaryOperator*)arg;
   ast_Expr* inner = ast_UnaryOperator_getInner(uo);
   if (!ast_Expr_isIdentifier(inner)) return;
   ast_IdentifierExpr* id = (ast_IdentifierExpr*)inner;
   ast_Decl* d = ast_IdentifierExpr_getDecl(id);
   ;//assert(d);
   if (!ast_Decl_isVarDecl(d)) return;
   ast_VarDecl* vd = (ast_VarDecl*)d;
   if ((ast_VarDecl_isLocal(vd) && !ast_VarDecl_hasLocalQualifier(vd)) || ast_VarDecl_isParameter(vd)) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(arg), "function returns address of local variable");
   }
}

static void module_analyser_Analyser_analyseStructType(module_analyser_Analyser* ma, ast_StructTypeDecl* d)
{
   if (ast_StructTypeDecl_isOpaque(d)) {
      ma->checkStack[ma->checkIndex - 1].usedPublic = false;
      ma->usedPublic = false;
   }
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(d);
   name_vector_NameVector names; name_vector_NameVector_init(&names, num_members);
   name_vector_NameVector locs; name_vector_NameVector_init(&locs, num_members);
   module_analyser_Analyser_analyseStructNames(ma, d, &names, &locs);
   name_vector_NameVector_free(&names);
   name_vector_NameVector_free(&locs);
   module_analyser_Analyser_analyseStructMembers(ma, d);
   if (!ma->has_error && ast_StructTypeDecl_getSize(d) == 0 && !ast_Module_isExternal(ma->mod)) {
      ast_Decl* dd = (ast_Decl*)d;
      ast_Decl_dump(dd);
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(dd), "empty structs are only allowed in interface files");
   }
}

static void module_analyser_Analyser_analyseStructMembers(module_analyser_Analyser* ma, ast_StructTypeDecl* d)
{
   uint32_t count = ast_StructTypeDecl_getNumMembers(d);
   ast_Decl** members = ast_StructTypeDecl_getMembers(d);
   bool is_packed = ast_StructTypeDecl_isPacked(d);
   for (uint32_t i = 0; i < count; i++) {
      ast_Decl* member = members[i];
      if (ast_Decl_isVariable(member)) {
         ast_VarDecl* vd = (ast_VarDecl*)member;
         ast_Decl_setCheckInProgress(member);
         module_analyser_Analyser_analyseStructMember(ma, vd);
         ast_Expr* bitfield = ast_VarDecl_getBitfield(vd);
         if (bitfield) {
            ast_QualType qt = ast_Decl_getType(member);
            uint32_t type_width = ast_QualType_getBitFieldWidth(qt, false);
            const char* name = ast_VarDecl_getName(vd);
            if (type_width == 0) {
               if (name) module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field '%s' has invalid type", name);
               else module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "unnamed bit-field has invalid type");
               return;
            }
            ast_QualType qt2 = module_analyser_Analyser_analyseExpr(ma, &bitfield, false, module_analyser_RHS);
            if (ast_QualType_isInvalid(qt2)) return;
            if (!ast_Expr_isCtv(bitfield)) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field size is not a compile-time value");
               return;
            }
            ast_Value value = ast_evalExpr(bitfield);
            if (ast_Value_isZero(&value)) {
               if (name) module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "zero width for bit-field '%s'", name);
               else if (ast_StructTypeDecl_isUnion(d)) module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "zero width bit-field not allowed in union");
            }
            if (ast_Value_isNegative(&value)) {
               if (name) module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field '%s' has negative width", name);
               else module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "unnamed bit-field has negative width");
            }
            uint32_t field_width = ast_Value_as_u32(&value);
            ast_VarDecl_setBitfieldWidth(vd, (uint8_t)field_width);
            uint32_t minimum_type_width = ast_QualType_getBitFieldWidth(qt, true);
            if (ast_QualType_isEnum(qt) && field_width < minimum_type_width) {
               if (name) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "bit-field '%s' has insufficient bits for enum '%s' (need %u bits)", name, ast_QualType_diagName(qt), minimum_type_width);
               } else {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "unnamed bit-field has insufficient bits for enum '%s' (need %u bits)", ast_QualType_diagName(qt), minimum_type_width);
               }
               return;
            }
            if (field_width > type_width) {
               if (name) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "width of bit-field '%s' (%u bits) exceeds the width of its type (%u bit%s)", name, field_width, type_width, type_width > 1 ? "s" : "");
               } else {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(bitfield), ast_Expr_getRange(bitfield), "width of unnamed bit-field (%u bits) exceeds the width of its type (%u bit%s)", field_width, type_width, type_width > 1 ? "s" : "");
               }
               return;
            }
         }
         ast_Decl_setChecked(member);
      } else if (ast_Decl_isStructType(member)) {
         ast_StructTypeDecl* sub = (ast_StructTypeDecl*)member;
         if (is_packed) ast_StructTypeDecl_setPacked(sub);
         module_analyser_Analyser_analyseStructMembers(ma, sub);
         ast_Decl_setChecked(member);
      }
   }
   size_analyser_sizeOfStruct(d);
}

static void module_analyser_Analyser_analyseStructMember(module_analyser_Analyser* ma, ast_VarDecl* v)
{
   ast_TypeRef* ref = ast_VarDecl_getTypeRef(v);
   if (ast_TypeRef_isIncrArray(ref)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "incremental arrays not allowed in as struct/union member");
      return;
   }
   ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   if (ast_QualType_isInvalid(res)) return;
   if (ast_QualType_isArray(res)) {
      ast_ArrayType* at = ast_QualType_getArrayType(res);
      if (!ast_ArrayType_hasSize(at)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array size must be specified for struct/union members");
         return;
      }
   }
   if (ast_QualType_isVoid(res)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "member has invalid type 'void'");
      return;
   }
   ast_Decl_setType(ast_VarDecl_asDecl(v), res);
   if (ma->usedPublic) ast_setTypePublicUsed(res);
}

static void module_analyser_Analyser_analyseStructNames(module_analyser_Analyser* ma, ast_StructTypeDecl* d, name_vector_NameVector* names, name_vector_NameVector* locs)
{
   uint32_t count = ast_StructTypeDecl_getNumMembers(d);
   ast_Decl** members = ast_StructTypeDecl_getMembers(d);
   for (uint32_t i = 0; i < count; i++) {
      ast_Decl* member = members[i];
      uint32_t name_idx = ast_Decl_getNameIdx(member);
      ast_StructTypeDecl* sub = NULL;
      if (ast_Decl_isStructType(member)) sub = (ast_StructTypeDecl*)member;
      if (name_idx == 0) {
         if (ast_Decl_isStructType(member)) {
            module_analyser_Analyser_analyseStructNames(ma, sub, names, locs);
         }
      } else {
         uint32_t old_index;
         if (name_vector_NameVector_find(names, name_idx, &old_index)) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(member), "duplicate struct/union member '%s'", ast_Decl_getName(member));
            module_analyser_Analyser_note(ma, name_vector_NameVector_get(locs, old_index), "previous declaration is here");
            return;
         }
         name_vector_NameVector_add(names, name_idx);
         name_vector_NameVector_add(locs, ast_Decl_getLoc(member));
         if (ast_Decl_isStructType(member)) {
            name_vector_NameVector sub_names; name_vector_NameVector_init(&sub_names, ast_StructTypeDecl_getNumMembers(sub));
            name_vector_NameVector sub_locs; name_vector_NameVector_init(&sub_locs, ast_StructTypeDecl_getNumMembers(sub));
            module_analyser_Analyser_analyseStructNames(ma, sub, &sub_names, &sub_locs);
            name_vector_NameVector_free(&sub_names);
            name_vector_NameVector_free(&sub_locs);
         }
      }
   }
}

static ast_QualType module_analyser_Analyser_analyseSwitchExpr(module_analyser_Analyser* ma, ast_Stmt** s_ptr)
{
   ast_Stmt* s = *s_ptr;
   if (ast_Stmt_isDecl(s)) {
      ast_QualType qt = module_analyser_Analyser_analyseDeclStmt(ma, s);
      if (ast_QualType_isValid(qt)) {
         ast_DeclStmt* ds = (ast_DeclStmt*)s;
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, 0);
         if (!ast_VarDecl_getInit(vd)) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_VarDecl_asDecl(vd)), "variable declaration in switch expression must have an initializer");
            return ast_QualType_Invalid;
         }
      }
      return qt;
   }
   ;//assert(ast_Stmt_isExpr(s));
   return module_analyser_Analyser_analyseExpr(ma, (ast_Expr**)s_ptr, true, module_analyser_RHS);
}

static module_analyser_FlowBits module_analyser_Analyser_analyseSwitchStmt(module_analyser_Analyser* ma, ast_Stmt* s)
{
   module_analyser_FlowBits flow = 0;
   ast_SwitchStmt* sw = (ast_SwitchStmt*)s;
   scope_Scope_enter(ma->scope, scope_Decl);
   bool is_string = false;
   ast_EnumTypeDecl* etd = NULL;
   ast_QualType ct = module_analyser_Analyser_analyseSwitchExpr(ma, ast_SwitchStmt_getCond2(sw));
   if (ast_QualType_isInvalid(ct)) {
      scope_Scope_exit(ma->scope, ma->has_error);
      return module_analyser_FlowNext | module_analyser_FlowError;
   }
   bool isCharPtr = ast_QualType_isCharPointer(ct);
   if (isCharPtr) {
      is_string = true;
      ast_SwitchStmt_setString(sw);
   } else {
      ast_EnumType* et = ast_QualType_getEnumTypeOrNil(ct);
      if (et) etd = ast_EnumType_getDecl(et);
   }
   const uint32_t numCases = ast_SwitchStmt_getNumCases(sw);
   ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
   if (numCases == 0) {
      module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "switch without cases or default");
      scope_Scope_exit(ma->scope, ma->has_error);
      return module_analyser_FlowNext | module_analyser_FlowError;
   }
   ast_SwitchCase* defaultCase = NULL;
   init_checker_Checker* checker = module_analyser_Analyser_getInitChecker(ma);
   for (uint32_t i = 0; i < numCases; i++) {
      ast_SwitchCase* c = cases[i];
      bool is_last = (i + 1 == numCases);
      if (ast_SwitchCase_isDefault(c)) {
         if (defaultCase) {
            module_analyser_Analyser_error(ma, ast_SwitchCase_getLoc(c), "multiple default labels");
            flow |= module_analyser_FlowError;
         } else if (!is_last) {
            module_analyser_Analyser_error(ma, ast_SwitchCase_getLoc(c), "default case must be last in switch");
            flow |= module_analyser_FlowError;
         }
         defaultCase = c;
      }
      scope_Scope_enter(ma->scope, scope_Decl | scope_Break);
      module_analyser_FlowBits flow2 = module_analyser_Analyser_analyseCase(ma, c, checker, etd, is_string, is_last);
      scope_Scope_exit(ma->scope, ma->has_error);
      flow |= flow2 & (module_analyser_FlowReturn | module_analyser_FlowContinue | module_analyser_FlowGoto | module_analyser_FlowNoReturn | module_analyser_FlowError);
      if (flow2 & module_analyser_FlowBreak) flow |= module_analyser_FlowNext;
   }
   scope_Scope_exit(ma->scope, ma->has_error);
   if (!(flow & module_analyser_FlowError) && etd) {
      const uint32_t numConstants = ast_EnumTypeDecl_getNumConstants(etd);
      if (defaultCase) {
         if (init_checker_Checker_getCount(checker) >= numConstants) {
            module_analyser_Analyser_error(ma, ast_SwitchCase_getLoc(defaultCase), "default label in switch which covers all enumeration values");
            flow |= module_analyser_FlowError;
         }
      } else {
         if (init_checker_Checker_getCount(checker) < numConstants) {
            string_buffer_Buf* out = string_buffer_create(128, false, 0);
            uint32_t missing = 0;
            ast_EnumConstantDecl** ecd = ast_EnumTypeDecl_getConstants(etd);
            for (uint32_t i = 0; i < numConstants; i++) {
               ast_Value v = ast_EnumConstantDecl_getValue(ecd[i]);
               if (!init_checker_Checker_find(checker, ast_Value_as_u32(&v))) {
                  if (missing != 0) string_buffer_Buf_add(out, ", ");
                  if (missing >= 3) {
                     string_buffer_Buf_add(out, "...");
                     break;
                  }
                  missing++;
                  string_buffer_Buf_add(out, ast_Decl_getName(ast_EnumConstantDecl_asDecl(ecd[i])));
               }
            }
            if (missing) {
               module_analyser_Analyser_error(ma, ast_Stmt_getLoc(s), "unhandled enumeration value%s: %s", missing > 1 ? "s" : "", string_buffer_Buf_str(out));
               flow |= module_analyser_FlowError;
            }
            string_buffer_Buf_free(out);
         }
      }
   }
   if (!defaultCase) flow |= module_analyser_FlowNext;
   module_analyser_Analyser_putInitChecker(ma, checker);
   return flow;
}

static module_analyser_FlowBits module_analyser_Analyser_analyseCase(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, bool is_string, bool is_last)
{
   module_analyser_FlowBits flow = 0;
   bool is_default = ast_SwitchCase_isDefault(c);
   if (!is_default) {
      if (!module_analyser_Analyser_analyseCaseCondition(ma, c, checker, etd, is_string)) return module_analyser_FlowError;
   }
   const uint32_t count = ast_SwitchCase_getNumStmts(c);
   if (count == 0) {
      ast_SwitchCase_setHasFallthrough(c);
      return module_analyser_FlowNext;
   }
   bool has_decls = false;
   module_analyser_FlowBits flow2 = module_analyser_FlowNext;
   for (uint32_t i = 0; i < count; i++) {
      ast_Stmt* st = ast_SwitchCase_getStmt(c, i);
      if (ast_Stmt_isFallthrough(st) && !is_last) {
         ast_SwitchCase_setHasFallthrough(c);
         if (i + 1 != count) {
            module_analyser_Analyser_error(ma, ast_Stmt_getLoc(st), "'fallthrough' statement must be last statement in case");
            return module_analyser_FlowError;
         }
         continue;
      }
      flow2 = module_analyser_Analyser_analyseStmt(ma, st, true);
      flow |= flow2 & (module_analyser_FlowReturn | module_analyser_FlowBreak | module_analyser_FlowContinue | module_analyser_FlowGoto | module_analyser_FlowNoReturn | module_analyser_FlowError);
      if (ma->has_error) return module_analyser_FlowError;
      if (ast_Stmt_isDecl(st)) has_decls = true;
   }
   flow |= flow2;
   if (has_decls) ast_SwitchCase_setHasDecls(c);
   if (!(flow & module_analyser_FlowNext) || ast_SwitchCase_hasFallthrough(c)) return flow;
   ast_Stmt* last = ast_SwitchCase_getStmt(c, count - 1);
   src_loc_SrcLoc loc = ast_Stmt_getLoc(last);
   if (!loc) loc = ast_SwitchCase_getLoc(c);
   if (is_default) {
      module_analyser_Analyser_error(ma, loc, "no terminating statement (break|return|continue|goto|noreturn-func) at end of default case");
   } else {
      module_analyser_Analyser_error(ma, loc, "no terminating statement (break|fallthrough|goto|return|continue|noreturn-func) at end of case");
   }
   return module_analyser_FlowError;
}

static bool module_analyser_Analyser_analyseCaseCondition(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, bool is_string)
{
   uint32_t num_conds = ast_SwitchCase_getNumConds(c);
   bool res = true;
   for (uint32_t i = 0; i < num_conds; i++) {
      ast_Expr* e = ast_SwitchCase_getCond(c, i);
      src_loc_SrcLoc loc = ast_Expr_getLoc(e);
      if (ast_Expr_isRange(e)) {
         if (is_string) {
            module_analyser_Analyser_error(ma, loc, "case ranges are not allowed for strings");
            res = false;
            continue;
         }
         ast_RangeExpr* re = (ast_RangeExpr*)e;
         ast_Expr* lhs = ast_RangeExpr_getLHS(re);
         ast_Expr* rhs = ast_RangeExpr_getRHS(re);
         uint32_t lhs_index = 0;
         uint32_t rhs_index;
         uint32_t lhs_name_idx = 0;
         uint32_t rhs_name_idx = 0;
         res &= module_analyser_Analyser_analyseCaseExpr(ma, c, checker, etd, is_string, 0, lhs, &lhs_index, &lhs_name_idx);
         res &= module_analyser_Analyser_analyseCaseExpr(ma, c, checker, etd, is_string, 0, rhs, &rhs_index, &rhs_name_idx);
         if (res) {
            if (etd) {
               if (lhs_index > rhs_index) {
                  module_analyser_Analyser_error(ma, loc, "enum constant '%s' does not come after '%s'", ast_idx2name(rhs_name_idx), ast_idx2name(lhs_name_idx));
                  res = false;
                  continue;
               }
               uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(etd);
               for (uint32_t idx = 0; idx < num_constants; idx++) {
                  ast_EnumConstantDecl* ecd = ast_EnumTypeDecl_getConstant(etd, idx);
                  ast_Value v = ast_EnumConstantDecl_getValue(ecd);
                  uint32_t index = ast_Value_as_u32(&v);
                  if (index >= lhs_index && index <= rhs_index) {
                     src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
                     if (duplicate && res) {
                        ast_Decl* d = (ast_Decl*)ecd;
                        module_analyser_Analyser_error(ma, loc, "duplicate case value '%s'", ast_Decl_getName(d));
                        module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                        res = false;
                     }
                     init_checker_Checker_add(checker, index, loc);
                  }
               }
            } else {
               if (lhs_index > rhs_index) {
                  module_analyser_Analyser_error(ma, loc, "case range bounds %u and %u are out of order", lhs_index, rhs_index);
                  res = false;
                  continue;
               }
               src_loc_SrcLoc duplicate = init_checker_Checker_find2(checker, lhs_index, rhs_index);
               if (duplicate) {
                  module_analyser_Analyser_error(ma, loc, "duplicate case value in range");
                  module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                  res = false;
               }
               init_checker_Checker_add2(checker, lhs_index, rhs_index, loc);
            }
         }
      } else {
         uint32_t index;
         uint32_t name_idx;
         res &= module_analyser_Analyser_analyseCaseExpr(ma, c, checker, etd, is_string, loc, e, &index, &name_idx);
      }
   }
   return res;
}

static bool module_analyser_Analyser_analyseCaseExpr(module_analyser_Analyser* ma, ast_SwitchCase* c, init_checker_Checker* checker, ast_EnumTypeDecl* etd, bool is_string, src_loc_SrcLoc loc, ast_Expr* cond, uint32_t* indexp, uint32_t* name_idxp)
{
   uint32_t index = 0;
   if (etd) {
      if (!ast_Expr_isIdentifier(cond)) {
         if (ast_Expr_isMember(cond)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "enum constant may not be prefixed in case statement");
         } else {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "condition is not a constant of enum type '%s'", ast_Decl_getFullName(ast_EnumTypeDecl_asDecl(etd)));
         }
         return false;
      }
      ast_IdentifierExpr* id = (ast_IdentifierExpr*)cond;
      if (!module_analyser_Analyser_checkEnumConstantCase(ma, id, checker, etd, loc, &index, name_idxp)) return false;
   } else {
      ast_Expr* orig = cond;
      ast_QualType qt = module_analyser_Analyser_analyseExpr(ma, &cond, true, module_analyser_RHS);
      if (ast_QualType_isInvalid(qt)) return false;
      ast_Expr_setType(cond, qt);
      if (is_string) {
         if (ast_Expr_isNil(orig)) {
            index = 0;
            *name_idxp = 0;
            if (loc) {
               src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
               if (duplicate) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(cond), ast_Expr_getRange(cond), "duplicate case value nil");
                  module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                  return false;
               }
               init_checker_Checker_add(checker, index, loc);
            }
         } else if (ast_Expr_isStringLiteral(orig)) {
            ast_StringLiteral* lit = (ast_StringLiteral*)orig;
            uint32_t len = ast_StringLiteral_getSize(lit) - 1;
            if (len > 255) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "string switch case string is loo long (max 255 bytes)");
               return false;
            }
            if (memchr(ast_StringLiteral_getText(lit), 0, len)) {
               module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "case string value has embedded null byte");
               return false;
            }
            index = ast_StringLiteral_getTextIndex(lit);
            *name_idxp = 0;
            if (loc) {
               src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
               if (duplicate) {
                  module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(cond), ast_Expr_getRange(cond), "duplicate case string");
                  module_analyser_Analyser_note(ma, duplicate, "previous case is here");
                  return false;
               }
               init_checker_Checker_add(checker, index, loc);
            }
         } else {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "string switch case can only have a string literal or nil as condition");
            return false;
         }
      } else {
         if (!ast_Expr_isCtv(cond)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(cond), "case condition is not compile-time constant");
            return false;
         }
         ast_Value v = ast_evalExpr(cond);
         index = ast_Value_as_u32(&v);
         *name_idxp = 0;
         if (loc) {
            src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
            if (duplicate) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(cond), ast_Expr_getRange(cond), "duplicate case value %u", index);
               module_analyser_Analyser_note(ma, duplicate, "previous case is here");
               return false;
            }
            init_checker_Checker_add(checker, index, loc);
         }
      }
   }
   *indexp = index;
   return true;
}

static bool module_analyser_Analyser_checkEnumConstantCase(module_analyser_Analyser* ma, ast_IdentifierExpr* id, init_checker_Checker* checker, ast_EnumTypeDecl* etd, src_loc_SrcLoc loc, uint32_t* ip, uint32_t* name_idxp)
{
   ast_Expr* e = (ast_Expr*)id;
   *name_idxp = ast_IdentifierExpr_getNameIdx(id);
   ast_EnumConstantDecl* ecd = ast_EnumTypeDecl_findConstant(etd, *name_idxp);
   if (!ecd) {
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "enum '%s' has no constant '%s'", ast_Decl_getFullName(ast_EnumTypeDecl_asDecl(etd)), ast_IdentifierExpr_getName(id));
      return false;
   }
   ast_Decl* d = (ast_Decl*)ecd;
   ast_Decl_setUsed(d);
   ast_QualType qt = ast_Decl_getType(d);
   ast_Expr_setType(e, qt);
   ast_Expr_setCtc(e);
   ast_Expr_setCtv(e);
   ast_Expr_setRValue(e);
   ast_IdentifierExpr_setDecl(id, d);
   ast_IdentifierExpr_setKind(id, ast_IdentifierKind_EnumConstant);
   ast_Value v = ast_EnumConstantDecl_getValue(ecd);
   uint32_t index = ast_Value_as_u32(&v);
   *ip = index;
   if (loc) {
      src_loc_SrcLoc duplicate = init_checker_Checker_find(checker, index);
      if (duplicate) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "duplicate case value '%s'", ast_IdentifierExpr_getName(id));
         module_analyser_Analyser_note(ma, duplicate, "previous case is here");
         return false;
      }
      init_checker_Checker_add(checker, index, loc);
   }
   return true;
}

static void module_analyser_Analyser_analyseFunctionType(module_analyser_Analyser* ma, ast_Decl* d)
{
   ast_FunctionTypeDecl* ftd = (ast_FunctionTypeDecl*)d;
   ast_FunctionDecl* fd = ast_FunctionTypeDecl_getDecl(ftd);
   module_analyser_Analyser_analyseFunction(ma, fd);
}

static void module_analyser_Analyser_analyseAliasType(module_analyser_Analyser* ma, ast_AliasTypeDecl* a)
{
   ast_TypeRef* ref = ast_AliasTypeDecl_getTypeRef(a);
   ast_Decl* d = (ast_Decl*)a;
   ast_QualType res = module_analyser_Analyser_analyseTypeRef(ma, ref);
   if (ast_QualType_isInvalid(res)) return;
   ast_QualType qt = ast_Decl_getType(d);
   ast_Type* at = ast_QualType_getTypeOrNil(qt);
   ast_QualType canon = ast_QualType_getCanonicalType(res);
   ast_QualType_copyQuals(&canon, res);
   ast_Type_setCanonicalType(at, canon);
}

static void module_analyser_Analyser_analyseEnumType(module_analyser_Analyser* ma, ast_EnumTypeDecl* d)
{
   uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(d);
   ast_EnumConstantDecl** constants = ast_EnumTypeDecl_getConstants(d);
   ast_QualType implType = ast_EnumTypeDecl_getImplType(d);
   if (num_constants == 0) {
      module_analyser_Analyser_error(ma, ast_Decl_getLoc(ast_EnumTypeDecl_asDecl(d)), "enum without constants");
      return;
   }
   bool is_regular = true;
   ast_Value value = { };
   ast_Value prev_value;
   for (uint32_t i = 0; i < num_constants; i++) {
      ast_EnumConstantDecl* c = constants[i];
      ast_Decl* ecd = (ast_Decl*)c;
      ast_Decl_setCheckInProgress(ecd);
      ast_EnumConstantDecl_setIndex(c, i);
      ast_Decl* cd = (ast_Decl*)c;
      uint32_t name_idx = ast_Decl_getNameIdx(cd);
      for (uint32_t j = 0; j < i; j++) {
         const ast_Decl* other = ast_EnumConstantDecl_asDecl(constants[j]);
         if (ast_Decl_getNameIdx(other) == name_idx) {
            module_analyser_Analyser_error(ma, ast_Decl_getLoc(cd), "duplicate enum constant '%s'", ast_idx2name(name_idx));
            module_analyser_Analyser_note(ma, ast_Decl_getLoc(other), "previous definition is here");
            return;
         }
      }
      ast_Expr* initval = ast_EnumConstantDecl_getInit(c);
      if (initval) {
         ast_QualType res = module_analyser_Analyser_analyseExpr(ma, ast_EnumConstantDecl_getInit2(c), true, module_analyser_RHS);
         if (ast_QualType_isInvalid(res)) return;
         initval = ast_EnumConstantDecl_getInit(c);
         if (!ast_Expr_isCtv(initval)) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(initval), ast_Expr_getRange(initval), "initializer is not a compile-time value");
            return;
         }
         ast_Value ctv = ast_evalExpr(initval);
         if (value.kind == ast_ValueKind_Error) {
            module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(initval), ast_Expr_getRange(initval), "%s", ctv.error_msg);
            return;
         }
         if (!ctv_analyser_checkTypeRange(ma->diags, implType, &ctv, 0, initval)) return;
         if (i > 0 && ast_Value_is_less(&ctv, &value)) {
            ast_Value_decr(&value);
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(initval), "enum constants need to increase (value %s, previous %s)", ast_Value_str(&ctv), ast_Value_str(&value));
            return;
         }
         value = ctv;
      } else {
         if (!ctv_analyser_checkTypeRange(ma->diags, implType, &value, ast_Decl_getLoc(cd), NULL)) return;
      }
      if (i == 0) {
         if (!ast_Value_isZero(&value)) is_regular = false;
      } else {
         if (!ast_Value_isNext(&value, &prev_value)) is_regular = false;
      }
      prev_value = value;
      ast_EnumConstantDecl_setValue(c, value);
      ast_Decl_setChecked(ecd);
      ast_Value_incr(&value);
   }
   if (is_regular) ast_EnumTypeDecl_setRegular(d);
}

static ast_QualType module_analyser_Analyser_analyseStructMemberTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref)
{
   const ast_Ref* member = ast_TypeRef_getStructMemberType(ref);
   ;//assert(member->decl);
   ;//assert(ast_Decl_isFunction(member->decl));
   ast_FunctionDecl* fd = (ast_FunctionDecl*)member->decl;
   module_analyser_Analyser_analyseFunction(ma, fd);
   if (ma->has_error) return ast_QualType_Invalid;
   return ast_Decl_getType(member->decl);
}

static ast_QualType module_analyser_Analyser_analyseUserTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref)
{
   ;//assert(ma->mod);
   const ast_Ref* user = ast_TypeRef_getUser(ref);
   if (user->decl) return ast_Decl_getType(user->decl);
   const ast_Ref* prefix = ast_TypeRef_getPrefix(ref);
   ast_Decl* d = NULL;
   if (prefix) {
      ast_ImportDecl* i = scope_Scope_findModule(ma->scope, prefix->name_idx, prefix->loc);
      if (!i) {
         ma->has_error = true;
         return ast_QualType_Invalid;
      }
      if (ma->usedPublic) {
         ast_Decl_setUsedPublic(ast_ImportDecl_asDecl(i));
      }
      ast_TypeRef_setPrefix(ref, (ast_Decl*)i);
      ast_Module* mod = ast_ImportDecl_getDest(i);
      d = scope_Scope_findSymbolInModule(ma->scope, mod, user->name_idx, user->loc);
   } else {
      d = scope_Scope_findType(ma->scope, user->name_idx, user->loc, ma->usedPublic);
   }
   if (!d) {
      ma->has_error = true;
      return ast_QualType_Invalid;
   }
   if (ma->usedPublic && !ast_Decl_isPublic(d)) {
      if (scope_Scope_inFunction(ma->scope)) {
         module_analyser_Analyser_error(ma, user->loc, "public inline function using non-public type '%s'", ast_Decl_getFullName(d));
      } else {
         module_analyser_Analyser_error(ma, user->loc, "public declaration using non-public type '%s'", ast_Decl_getFullName(d));
      }
      return ast_QualType_Invalid;
   }
   ast_TypeRef_setUser(ref, d);
   if (!ast_Decl_isTypeDecl(d)) {
      module_analyser_Analyser_error(ma, user->loc, "'%s' is not a type", ast_TypeRef_diagName(ref));
      return ast_QualType_Invalid;
   }
   bool full = !ast_TypeRef_isPointer(ref);
   ast_DeclCheckState state = ast_Decl_getCheckState(d);
   if (full && state == ast_DeclCheckState_InProgress) {
      module_analyser_Analyser_error(ma, user->loc, "circular declaration");
      return ast_QualType_Invalid;
   }
   if (full && state != ast_DeclCheckState_Checked) {
      module_analyser_Analyser_analyseGlobalDecl(ma, d);
   }
   ast_Decl_setUsed(d);
   bool external = (ma->mod != ast_Decl_getModule(d));
   if (external || ma->usedPublic) ast_Decl_setUsedPublic(d);
   return ast_Decl_getType(d);
}

static ast_QualType module_analyser_Analyser_analyseTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref)
{
   ast_QualType base;
   switch (ast_TypeRef_getKind(ref)) {
   case ast_TypeRefKind_Builtin: {
      ast_BuiltinKind kind = ast_TypeRef_getBuiltinKind(ref);
      base = ast_builder_Builder_actOnBuiltinType(ma->builder, kind);
      ;//assert(ast_QualType_isValid(base));
      break;
   }
   case ast_TypeRefKind_Void:
      base = ast_builder_Builder_actOnVoidType(ma->builder);
      ;//assert(ast_QualType_isValid(base));
      break;
   case ast_TypeRefKind_User:
      base = module_analyser_Analyser_analyseUserTypeRef(ma, ref);
      if (ast_QualType_isInvalid(base)) return base;
      if (!ast_QualType_hasCanonicalType(base)) return ast_QualType_Invalid;
      break;
   case ast_TypeRefKind_Function:
      base = module_analyser_Analyser_analyseStructMemberTypeRef(ma, ref);
      if (ast_QualType_isInvalid(base)) return base;
      if (!ast_QualType_hasCanonicalType(base)) return ast_QualType_Invalid;
      break;
   }
   if (ast_TypeRef_isConst(ref)) ast_QualType_setConst(&base);
   if (ast_TypeRef_isVolatile(ref)) ast_QualType_setVolatile(&base);
   ast_QualType resolved = base;
   uint32_t num_ptrs = ast_TypeRef_getNumPointers(ref);
   for (uint32_t i = 0; i < num_ptrs; i++) {
      resolved = ast_builder_Builder_actOnPointerType(ma->builder, resolved);
   }
   if (ast_TypeRef_isUser(ref) && ast_QualType_isStruct(resolved)) {
      ast_StructType* st = ast_QualType_getStructType(resolved);
      const ast_StructTypeDecl* std = ast_StructType_getDecl(st);
      if (ast_StructTypeDecl_isOpaque(std)) {
         const ast_Decl* d = (ast_Decl*)std;
         bool is_external = ma->mod != ast_Decl_getModule(d);
         if (ma->curFunction && ast_FunctionDecl_getInstanceModule(ma->curFunction) == ast_Decl_getModule(d)) {
            is_external = false;
         }
         if (is_external) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "opaque type '%s' used by value", ast_QualType_diagName(resolved));
         } else if (ma->usedPublic) {
            module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "public declaration using opaque type '%s' by value", ast_QualType_diagName(resolved));
         }
      }
   }
   uint32_t num_arrays = ast_TypeRef_getNumArrays(ref);
   for (uint32_t i = num_arrays; i > 0; i--) {
      ast_Expr** sizeExpr_p = ast_TypeRef_getArray2(ref, i - 1);
      ast_Expr* sizeExpr = *sizeExpr_p;
      uint32_t size = 0;
      bool is_enum = false;
      ast_QualType qt = ast_QualType_Invalid;
      if (sizeExpr) {
         qt = module_analyser_Analyser_analyseExpr(ma, sizeExpr_p, false, module_analyser_RHS);
         if (ast_QualType_isInvalid(qt)) return qt;
         sizeExpr = *sizeExpr_p;
         if (ast_Expr_isNValue(sizeExpr)) {
            const ast_EnumType* et = ast_QualType_getEnumTypeOrNil(qt);
            if (!et) {
               module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array size must be an integer or an enum type ('%s')", ast_QualType_diagName(qt));
               return ast_QualType_Invalid;
            }
            const ast_EnumTypeDecl* etd = ast_EnumType_getDecl(et);
            is_enum = true;
            size = ast_EnumTypeDecl_getNumConstants(etd);
            if (!ast_EnumTypeDecl_isRegular(etd)) {
               module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "%s is not a regular enum", ast_QualType_diagName(qt));
               return ast_QualType_Invalid;
            }
         } else {
            qt = module_analyser_Analyser_convertRvalue(ma, sizeExpr_p, qt);
            if (ast_QualType_isInvalid(qt)) return qt;
            sizeExpr = *sizeExpr_p;
            if (!ast_QualType_isInteger(qt)) {
               module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array size has non-integer type '%s'", ast_QualType_diagName(qt));
               return ast_QualType_Invalid;
            }
            if (!ast_Expr_isCtv(sizeExpr)) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(sizeExpr), ast_Expr_getRange(sizeExpr), "array size is not a compile-time value");
               return ast_QualType_Invalid;
            }
            ast_Value value = ast_evalExpr(sizeExpr);
            if (ast_Value_isNegative(&value)) {
               module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(sizeExpr), ast_Expr_getRange(sizeExpr), "array size has negative value '%s'", ast_Value_str(&value));
               return ast_QualType_Invalid;
            }
            size = ast_Value_as_u32(&value);
         }
      }
      if (ast_QualType_isVoid(resolved)) {
         module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array element has invalid type 'void'");
         return ast_QualType_Invalid;
      }
      resolved = ast_builder_Builder_actOnArrayType(ma->builder, resolved, sizeExpr != NULL, size, is_enum, qt);
   }
   if (ast_TypeRef_isIncrArray(ref)) {
      resolved = ast_builder_Builder_actOnIncrementalArrayType(ma->builder, resolved);
   }
   if (ast_TypeRef_isUser(ref)) ast_TypeRef_setDest(ref, ast_QualType_getIndex(base));
   return resolved;
}

static ast_QualType module_analyser_Analyser_analyseIncrTypeRef(module_analyser_Analyser* ma, ast_TypeRef* ref, uint32_t size)
{
   ast_QualType base;
   switch (ast_TypeRef_getKind(ref)) {
   case ast_TypeRefKind_Builtin: {
      ast_BuiltinKind kind = ast_TypeRef_getBuiltinKind(ref);
      base = ast_builder_Builder_actOnBuiltinType(ma->builder, kind);
      ;//assert(ast_QualType_isValid(base));
      break;
   }
   case ast_TypeRefKind_User:
      base = module_analyser_Analyser_analyseUserTypeRef(ma, ref);
      if (ast_QualType_isInvalid(base)) return base;
      ;//assert(ast_QualType_hasCanonicalType(base));
      break;
   default:
      ;//assert(0);
      break;
   }
   if (ast_TypeRef_isConst(ref)) ast_QualType_setConst(&base);
   if (ast_TypeRef_isVolatile(ref)) ast_QualType_setVolatile(&base);
   ast_QualType resolved = base;
   uint32_t num_ptrs = ast_TypeRef_getNumPointers(ref);
   for (uint32_t i = 0; i < num_ptrs; i++) {
      resolved = ast_builder_Builder_actOnPointerType(ma->builder, resolved);
   }
   if (ast_QualType_isVoid(resolved)) {
      module_analyser_Analyser_error(ma, ast_TypeRef_getLoc(ref), "array element has invalid type 'void'");
      return ast_QualType_Invalid;
   }
   resolved = ast_builder_Builder_actOnArrayType(ma->builder, resolved, true, size, false, ast_QualType_Invalid);
   if (ast_TypeRef_isUser(ref)) ast_TypeRef_setDest(ref, ast_QualType_getIndex(base));
   return resolved;
}

static bool module_analyser_Analyser_checkOpaque(module_analyser_Analyser* ma, const ast_StructTypeDecl* std, src_loc_SrcLoc loc)
{
   if (ast_StructTypeDecl_isOpaque(std)) {
      ast_Decl* d = (ast_Decl*)std;
      ast_Module* other = ast_Decl_getModule(d);
      if (other != ma->mod) {
         ast_QualType qt = ast_Decl_getType(d);
         module_analyser_Analyser_error(ma, loc, " cannot dereference opaque struct '%s'", ast_QualType_diagNameBare(qt));
         return false;
      }
   }
   return true;
}

static ast_VarDecl* module_analyser_getVarDecl(const ast_Expr* e)
{
   ast_Decl* d;
   if (ast_Expr_isIdentifier(e)) {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      d = ast_IdentifierExpr_getDecl(i);
   } else {
      ast_MemberExpr* m = (ast_MemberExpr*)e;
      d = ast_MemberExpr_getFullDecl(m);
   }
   if (ast_Decl_isVariable(d)) return (ast_VarDecl*)d;
   return NULL;
}

static ast_QualType module_analyser_Analyser_analyseUnaryOperator(module_analyser_Analyser* ma, ast_Expr** e_ptr, uint32_t side)
{
   ast_Expr* e = *e_ptr;
   ast_UnaryOperator* u = (ast_UnaryOperator*)e;
   bool need_rvalue = true;
   switch (ast_UnaryOperator_getOpcode(u)) {
   case ast_UnaryOpcode_PostInc:
   case ast_UnaryOpcode_PostDec:
   case ast_UnaryOpcode_PreInc:
   case ast_UnaryOpcode_PreDec:
      if (!ma->curFunction) {
         module_analyser_Analyser_errorRange(ma, ast_Expr_getLoc(e), ast_Expr_getRange(e), "initializer element is not a compile-time constant");
         return ast_QualType_Invalid;
      }
      need_rvalue = false;
      side |= module_analyser_LHS;
      break;
   case ast_UnaryOpcode_AddrOf:
      need_rvalue = false;
      side |= module_analyser_LHS;
      break;
   case ast_UnaryOpcode_Deref:
   case ast_UnaryOpcode_Plus:
   case ast_UnaryOpcode_Minus:
   case ast_UnaryOpcode_Not:
   case ast_UnaryOpcode_LNot:
      side |= module_analyser_RHS;
      break;
   }
   ast_QualType t = module_analyser_Analyser_analyseExpr(ma, ast_UnaryOperator_getInner2(u), need_rvalue, side);
   if (ast_QualType_isInvalid(t)) return ast_QualType_Invalid;
   e = *e_ptr;
   ast_Expr* inner = ast_UnaryOperator_getInner(u);
   ast_QualType canon = ast_QualType_getCanonicalType(t);
   if (ast_QualType_isVoid(canon)) goto invalid_type;
   switch (ast_UnaryOperator_getOpcode(u)) {
   case ast_UnaryOpcode_PostInc:
   case ast_UnaryOpcode_PreInc:
      if (!module_analyser_Analyser_checkIncrDecr(ma, inner, t, true, ast_Expr_getLoc(e))) return ast_QualType_Invalid;
      break;
   case ast_UnaryOpcode_PostDec:
   case ast_UnaryOpcode_PreDec:
      if (!module_analyser_Analyser_checkIncrDecr(ma, inner, t, false, ast_Expr_getLoc(e))) return ast_QualType_Invalid;
      break;
   case ast_UnaryOpcode_AddrOf:
      if (!module_analyser_Analyser_getIdentifierKind(ma, inner)) return ast_QualType_Invalid;
      if (ast_QualType_isConst(canon) && (ast_Expr_isIdentifier(inner) || ast_Expr_isMember(inner))) {
         ast_VarDecl* vd = module_analyser_getVarDecl(inner);
         if (vd) ast_VarDecl_setAddrUsed(vd);
      }
      t = ast_builder_Builder_actOnPointerType(ma->builder, canon);
      ast_Expr_copyCtcFlags(e, inner);
      if (ast_Expr_getKind(inner) == ast_ExprKind_ArraySubscript) {
         ast_ArraySubscriptExpr* e1 = (ast_ArraySubscriptExpr*)inner;
         if (ast_Expr_isCtc(ast_ArraySubscriptExpr_getBase(e1)) && ast_Expr_isCtv(ast_ArraySubscriptExpr_getIndex(e1))) ast_Expr_setCtc(e);
      } else if (ast_Expr_getKind(inner) == ast_ExprKind_UnaryOperator) {
         ast_UnaryOperator* e1 = (ast_UnaryOperator*)inner;
         if (ast_UnaryOperator_getOpcode(e1) == ast_UnaryOpcode_Deref) ast_Expr_copyCtcFlags(e, ast_UnaryOperator_getInner(e1));
      }
      if (ast_Expr_isBitfield(inner)) {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot take address of bit-field");
         return ast_QualType_Invalid;
      }
      break;
   case ast_UnaryOpcode_Deref:
      if (ast_QualType_isPointer(t)) {
         ast_Expr_setLValue(e);
         t = ast_QualType_getCanonicalType(t);
         const ast_PointerType* p = ast_QualType_getPointerType(t);
         t = ast_PointerType_getInner(p);
         if (ast_QualType_isVoid(t)) {
            module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot dereference a void pointer");
            return ast_QualType_Invalid;
         }
         break;
      } else {
         module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "indirection requires pointer operand ('%s' invalid)", ast_QualType_diagName(t));
         return ast_QualType_Invalid;
      }
   case ast_UnaryOpcode_Minus: {
      ast_QualType lhs = module_analyser_getMinusType(canon);
      if (!ast_QualType_isValid(lhs)) goto invalid_type;
      ast_Expr_copyConstantFlags(e, inner);
      t = module_analyser_usualUnaryConversions(inner);
      break;
   }
   case ast_UnaryOpcode_Plus:
      if (!ast_QualType_isBuiltin(canon)) goto invalid_type;
      ast_Expr_copyConstantFlags(e, inner);
      t = module_analyser_usualUnaryConversions(inner);
      break;
   case ast_UnaryOpcode_Not:
      if (!ast_QualType_isBuiltin(canon) || ast_QualType_isFloat(canon)) goto invalid_type;
      ast_Expr_copyConstantFlags(e, inner);
      t = module_analyser_usualUnaryConversions(inner);
      break;
   case ast_UnaryOpcode_LNot:
      if (!ast_QualType_isScalar(canon)) goto invalid_type;
      ast_Expr_copyConstantFlags(e, inner);
      return ast_getBuiltinQT(ast_BuiltinKind_Bool);
   }
   return t;
invalid_type:
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "invalid argument type '%s' to unary expression", ast_QualType_diagName(t));
   return ast_QualType_Invalid;
}

static bool module_analyser_Analyser_checkIncrDecr(module_analyser_Analyser* ma, ast_Expr* inner, ast_QualType t, bool is_incr, src_loc_SrcLoc loc)
{
   const char* operand = is_incr ? "increment operand" : "decrement operand";
   if (!module_analyser_Analyser_checkAssignment(ma, inner, t, operand, loc)) return false;
   t = ast_QualType_getCanonicalType(t);
   if (!ast_QualType_isBuiltin(t) && !ast_QualType_isEnum(t) && (!ast_QualType_isPointer(t) || ast_QualType_isVoidPtr(t))) {
      module_analyser_Analyser_error(ma, loc, "cannot %s value of type '%s'", is_incr ? "increment" : "decrement", ast_QualType_diagName(t));
      return false;
   }
   return true;
}

static bool module_analyser_Analyser_getIdentifierKind(module_analyser_Analyser* ma, const ast_Expr* e)
{
   ast_IdentifierKind kind = module_analyser_getInnerExprAddressOf(e);
   const char* arg = "";
   switch (kind) {
   case ast_IdentifierKind_Unresolved: {
      ast_QualType qt = ast_Expr_getType(e);
      module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot take the address of an rvalue of type '%s'", ast_QualType_diagName(qt));
      return false;
   }
   case ast_IdentifierKind_Module:
      arg = "a module";
      break;
   case ast_IdentifierKind_Function:
      arg = "a function";
      break;
   case ast_IdentifierKind_Type:
      arg = "a type";
      break;
   case ast_IdentifierKind_Var:
      return true;
   case ast_IdentifierKind_EnumConstant:
      arg = "an enum constant";
      break;
   case ast_IdentifierKind_StructMember:
      return true;
   case ast_IdentifierKind_Label:
      arg = "a label";
      break;
   }
   module_analyser_Analyser_error(ma, ast_Expr_getLoc(e), "cannot take the address of %s", arg);
   return false;
}

static ast_IdentifierKind module_analyser_getInnerExprAddressOf(const ast_Expr* e)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral:
   case ast_ExprKind_FloatLiteral:
   case ast_ExprKind_BooleanLiteral:
   case ast_ExprKind_CharLiteral:
   case ast_ExprKind_StringLiteral:
   case ast_ExprKind_Nil:
      break;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      return ast_IdentifierExpr_getKind(i);
   }
   case ast_ExprKind_Type:
   case ast_ExprKind_Call:
   case ast_ExprKind_InitList:
   case ast_ExprKind_FieldDesignatedInit:
   case ast_ExprKind_ArrayDesignatedInit:
      break;
   case ast_ExprKind_BinaryOperator:
      break;
   case ast_ExprKind_UnaryOperator: {
      ast_UnaryOperator* e1 = (ast_UnaryOperator*)e;
      if (ast_UnaryOperator_getOpcode(e1) == ast_UnaryOpcode_Deref) {
         return ast_IdentifierKind_Var;
      }
      break;
   }
   case ast_ExprKind_ConditionalOperator:
      break;
   case ast_ExprKind_Builtin:
      break;
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = (ast_ArraySubscriptExpr*)e;
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      if (ast_Expr_getKind(index) != ast_ExprKind_BitOffset) return ast_IdentifierKind_Var;
      break;
   }
   case ast_ExprKind_Member: {
      ast_MemberExpr* m = (ast_MemberExpr*)e;
      return ast_MemberExpr_getKind(m);
   }
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = (ast_ParenExpr*)e;
      return module_analyser_getInnerExprAddressOf(ast_ParenExpr_getInner(p));
   }
   case ast_ExprKind_BitOffset:
      return ast_IdentifierKind_Unresolved;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* c = (ast_ExplicitCastExpr*)e;
      return module_analyser_getInnerExprAddressOf(ast_ExplicitCastExpr_getInner(c));
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* c = (ast_ImplicitCastExpr*)e;
      return module_analyser_getInnerExprAddressOf(ast_ImplicitCastExpr_getInner(c));
   }
   case ast_ExprKind_Range:
      break;
   case ast_ExprKind_NamedArgument: {
      ast_NamedArgument* n = (ast_NamedArgument*)e;
      return module_analyser_getInnerExprAddressOf(ast_NamedArgument_getInner(n));
   }
   case ast_ExprKind_Alternate: {
      ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      return module_analyser_getInnerExprAddressOf(ast_AlternateExpr_getOriginal(n));
   }
   }
   return ast_IdentifierKind_Unresolved;
}

static ast_QualType module_analyser_getMinusType(ast_QualType qt)
{
   if (!ast_QualType_isBuiltin(qt)) return ast_QualType_Invalid;
   ast_BuiltinType* bi = ast_QualType_getBuiltin(qt);
   switch (ast_BuiltinType_getKind(bi)) {
   case ast_BuiltinKind_Char:
   case ast_BuiltinKind_Int8:
   case ast_BuiltinKind_Int16:
   case ast_BuiltinKind_Bool:
      return ast_getBuiltinQT(ast_BuiltinKind_Int32);
   case ast_BuiltinKind_Int32:
   case ast_BuiltinKind_Int64:
      return qt;
   case ast_BuiltinKind_UInt8:
   case ast_BuiltinKind_UInt16:
   case ast_BuiltinKind_UInt32:
      return ast_getBuiltinQT(ast_BuiltinKind_Int32);
   case ast_BuiltinKind_UInt64:
      return ast_getBuiltinQT(ast_BuiltinKind_Int64);
   case ast_BuiltinKind_Float32:
   case ast_BuiltinKind_Float64:
   case ast_BuiltinKind_ISize:
      return qt;
   case ast_BuiltinKind_USize:
      return ast_getBuiltinQT(ast_BuiltinKind_ISize);
   }
   return ast_QualType_Invalid;
}

static void module_analyser_StructFieldInitChecker_init(module_analyser_StructFieldInitChecker* c, uint32_t capacity)
{
   c->inits = calloc(capacity, 4);
}

static void module_analyser_StructFieldInitChecker_free(module_analyser_StructFieldInitChecker* c)
{
   free(c->inits);
}

static src_loc_SrcLoc module_analyser_StructFieldInitChecker_add(module_analyser_StructFieldInitChecker* c, uint32_t idx, src_loc_SrcLoc loc)
{
   if (c->inits[idx]) return c->inits[idx];
   c->inits[idx] = loc;
   return 0;
}


// --- module module_sorter ---
typedef struct module_sorter_ModuleSorter_ module_sorter_ModuleSorter;

struct module_sorter_ModuleSorter_ {
   component_Component* comp;
   uint32_t num_mods;
   ast_Module** modules;
   dsm_sorter_Sorter* dsm;
   uint32_t cur_mod_idx;
};

static void module_sorter_sort(component_Component* c, diagnostics_Diags* diags);
static void module_sorter_ModuleSorter_print(const module_sorter_ModuleSorter* s);
static void module_sorter_ModuleSorter_handleModule(void* arg, ast_Module* mod);
static void module_sorter_ModuleSorter_handleImport(void* arg, ast_ImportDecl* d);
static uint32_t module_sorter_ModuleSorter_mod2idx(const module_sorter_ModuleSorter* s, const ast_Module* mod);

static void module_sorter_sort(component_Component* c, diagnostics_Diags* diags)
{
   module_list_List* mods = component_Component_getModules(c);
   const uint32_t count = module_list_List_length(mods);
   if (count <= 1) return;
   module_sorter_ModuleSorter s;
   s.num_mods = count;
   s.cur_mod_idx = 0;
   s.comp = c;
   ast_Module** orig = module_list_List_get(mods);
   dsm_sorter_Sorter dsm; dsm_sorter_Sorter_init(&dsm, count);
   s.modules = orig;
   s.dsm = &dsm;
   component_Component_visitModules(c, module_sorter_ModuleSorter_handleModule, &s);
   const uint8_t* sorted = dsm_sorter_Sorter_sort(&dsm);
   if (!sorted) {
      diagnostics_Diags_error(diags, 0, "circular dependency between modules");
      module_sorter_ModuleSorter_print(&s);
      exit(-1);
   }
   ast_Module** copy = malloc(count * 8);
   memcpy(copy, orig, count * 8);
   for (uint32_t i = 0; i < count; i++) orig[i] = copy[sorted[i]];
   free(copy);
   dsm_sorter_Sorter_free(&dsm);
}

static void module_sorter_ModuleSorter_print(const module_sorter_ModuleSorter* s)
{
   const uint8_t* array = dsm_sorter_Sorter_get_array(s->dsm);
   printf("                     |");
   for (uint32_t y = 0; y < s->num_mods; y++) {
      printf(" %2u", y);
   }
   printf("\n");
   for (uint32_t y = 0; y < s->num_mods; y++) {
      printf("%16s  %2u |", ast_Module_getName(s->modules[y]), y);
      for (uint32_t x = 0; x < s->num_mods; x++) {
         uint8_t value = array[y * s->num_mods + x];
         printf("  %c", value ? 'X' : ' ');
      }
      printf("\n");
   }
}

static void module_sorter_ModuleSorter_handleModule(void* arg, ast_Module* mod)
{
   module_sorter_ModuleSorter* s = arg;
   ast_Module_visitImports(mod, module_sorter_ModuleSorter_handleImport, arg);
   s->cur_mod_idx++;
}

static void module_sorter_ModuleSorter_handleImport(void* arg, ast_ImportDecl* d)
{
   module_sorter_ModuleSorter* s = arg;
   ast_Module* dest = ast_ImportDecl_getDest(d);
   ;//assert(dest);
   if (!component_Component_hasModule(s->comp, dest)) return;
   uint32_t dest_idx = module_sorter_ModuleSorter_mod2idx(s, dest);
   dsm_sorter_Sorter_add_dep(s->dsm, s->cur_mod_idx, dest_idx);
}

static uint32_t module_sorter_ModuleSorter_mod2idx(const module_sorter_ModuleSorter* s, const ast_Module* mod)
{
   for (uint32_t i = 0; i < s->num_mods; i++) {
      if (s->modules[i] == mod) return i;
   }
   ;//assert(0);
   return 0;
}


// --- module manifest ---

static const yaml_Node* manifest_get_checked(yaml_Parser* parser, const char* path);
static bool manifest_getYamlInfo(yaml_Parser* parser, string_pool_Pool* astPool, string_pool_Pool* auxPool, component_Component* comp, string_list_List* mods);
static bool manifest_parse(source_mgr_SourceMgr* sm, int32_t file_id, string_pool_Pool* astPool, string_pool_Pool* auxPool, component_Component* comp, string_list_List* mods);

static const yaml_Node* manifest_get_checked(yaml_Parser* parser, const char* path)
{
   const yaml_Node* node = yaml_Parser_findNode(parser, path);
   if (!node) {
      fprintf(stderr, "error: missing node %s\n", path);
      exit(-1);
   }
   return node;
}

static bool manifest_getYamlInfo(yaml_Parser* parser, string_pool_Pool* astPool, string_pool_Pool* auxPool, component_Component* comp, string_list_List* mods)
{
   manifest_get_checked(parser, "info.language");
   const yaml_Node* lib_kinds = manifest_get_checked(parser, "info.kinds");
   yaml_Iter iter = yaml_Parser_getNodeChildIter(parser, lib_kinds);
   bool kind_dynamic = false;
   bool kind_static = false;
   bool kind_source = false;
   while (!yaml_Iter_done(&iter)) {
      const char* kind = yaml_Iter_getValue(&iter);
      switch (c2_strswitch(kind, "\007dynamic" "\006static" "\006source")) {
      case 2: // "dynamic"
         kind_dynamic = true;
         break;
      case 3: // "static"
         kind_static = true;
         break;
      case 4: // "source"
         kind_source = true;
         break;
      default:
         fprintf(stderr, "error in manifest: invalid library kind '%s'\n", kind);
         exit(-1);
      }
      yaml_Iter_next(&iter);
   }
   if (!kind_dynamic && !kind_static && !kind_source) {
      fprintf(stderr, "error in manifest: a library must be dynamic static and/or source\n");
      exit(stdlib_EXIT_FAILURE);
   }
   const char* language = yaml_Parser_getScalarValue(parser, "info.language");
   bool is_foreign = (!language || (strcasecmp(language, "c2") && strcasecmp(language, "native")));
   component_Component_setForeign(comp, is_foreign);
   const yaml_Node* modulesNode = manifest_get_checked(parser, "modules");
   component_Component_setKind(comp, kind_static, kind_dynamic, kind_source);
   if (is_foreign && kind_source) {
      fprintf(stderr, "manifest: a source library must have c2 as language\n");
      exit(stdlib_EXIT_FAILURE);
   }
   if (modulesNode) {
      iter = yaml_Parser_getNodeChildIter(parser, modulesNode);
      while (!yaml_Iter_done(&iter)) {
         const char* value = yaml_Iter_getValue(&iter);
         ;//assert(value);
         uint32_t modname = string_pool_Pool_addStr(astPool, value, true);
         string_list_List_add(mods, modname);
         yaml_Iter_next(&iter);
      }
   }
   const yaml_Node* sourcesNode = yaml_Parser_findNode(parser, "sources");
   if (sourcesNode) {
      if (!kind_source) {
         fprintf(stderr, "manifest: sources are only allowed for source library kind\n");
         exit(stdlib_EXIT_FAILURE);
      }
   } else {
      if (kind_source) {
         fprintf(stderr, "manifest: sources are required for source library kind\n");
         exit(stdlib_EXIT_FAILURE);
      }
   }
   if (sourcesNode) {
      iter = yaml_Parser_getNodeChildIter(parser, sourcesNode);
      while (!yaml_Iter_done(&iter)) {
         const char* value = yaml_Iter_getValue(&iter);
         ;//assert(value);
         uint32_t file_idx = string_pool_Pool_addStr(auxPool, value, true);
         component_Component_addFile(comp, file_idx, 0);
         yaml_Iter_next(&iter);
      }
   }
   const char* linkname = yaml_Parser_getScalarValue(parser, "info.linkname");
   if (linkname) component_Component_setLinkName(comp, linkname);
   const yaml_Node* deps = yaml_Parser_findNode(parser, "dependencies");
   if (deps) {
      iter = yaml_Parser_getNodeChildIter(parser, deps);
      while (!yaml_Iter_done(&iter)) {
         uint32_t dep_idx = string_pool_Pool_addStr(auxPool, yaml_Iter_getName(&iter), true);
         component_Component_addDep(comp, dep_idx);
         yaml_Iter_next(&iter);
      }
   }
   return true;
}

static bool manifest_parse(source_mgr_SourceMgr* sm, int32_t file_id, string_pool_Pool* astPool, string_pool_Pool* auxPool, component_Component* comp, string_list_List* mods)
{
   const char* data = source_mgr_SourceMgr_get_content(sm, file_id);
   yaml_Parser* parser = yaml_Parser_create();
   bool ok = yaml_Parser_parse(parser, data);
   if (ok) {
      manifest_getYamlInfo(parser, astPool, auxPool, comp, mods);
   } else {
      console_error("%s: %s", source_mgr_SourceMgr_getFileName(sm, file_id), yaml_Parser_getMessage(parser));
   }
   yaml_Parser_destroy(parser);
   return ok;
}


// --- module plugin_mgr ---
typedef struct plugin_mgr_Plugin_ plugin_mgr_Plugin;
typedef struct plugin_mgr_Mgr_ plugin_mgr_Mgr;

struct plugin_mgr_Plugin_ {
   uint32_t name;
   bool is_global;
   bool is_active;
   void* arg;
   void* handle;
   plugin_info_Plugin* functions;
};

struct plugin_mgr_Mgr_ {
   string_pool_Pool* auxPool;
   bool console_timing;
   bool console_debug;
   bool no_plugins;
   plugin_mgr_Plugin* plugins;
   uint32_t plugin_count;
   uint32_t plugin_max;
   string_list_List paths;
   char error_msg[256];
};

static const char* plugin_mgr_lib_ext = ".so";
static plugin_mgr_Mgr* plugin_mgr_create(string_pool_Pool* auxPool, bool console_timing, bool console_debug, bool no_plugins);
static void plugin_mgr_Mgr_free(plugin_mgr_Mgr* m);
static const char* plugin_mgr_Mgr_getError(const plugin_mgr_Mgr* m);
static void plugin_mgr_Mgr_addPath(plugin_mgr_Mgr* m, uint32_t path);
static void plugin_mgr_Mgr_addPlugin(plugin_mgr_Mgr* m, plugin_mgr_Plugin* p);
static bool plugin_mgr_is_plugin(const dirent* entry);
static void plugin_mgr_Mgr_show(const plugin_mgr_Mgr* m);
static bool plugin_mgr_Mgr_loadPlugin(plugin_mgr_Mgr* m, uint32_t name, uint32_t options, bool is_global);
static bool plugin_mgr_Mgr_loadGlobal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options);
static bool plugin_mgr_Mgr_loadLocal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options);
static bool plugin_mgr_Mgr_find_file(plugin_mgr_Mgr* m, char* fullname, size_t size, const char* filename);
static void plugin_mgr_Mgr_beginTarget(plugin_mgr_Mgr* m, plugin_info_Info* info);
static void plugin_mgr_Mgr_endTarget(plugin_mgr_Mgr* m);
static void plugin_mgr_Mgr_postParse(plugin_mgr_Mgr* m);
static void plugin_mgr_Mgr_postAnalysis(plugin_mgr_Mgr* m);

static plugin_mgr_Mgr* plugin_mgr_create(string_pool_Pool* auxPool, bool console_timing, bool console_debug, bool no_plugins)
{
   plugin_mgr_Mgr* m = calloc(1, 312);
   m->auxPool = auxPool;
   m->console_timing = console_timing;
   m->console_debug = console_debug;
   m->no_plugins = no_plugins;
   string_list_List_init(&m->paths, auxPool);
   return m;
}

static void plugin_mgr_Mgr_free(plugin_mgr_Mgr* m)
{
   for (uint32_t i = m->plugin_count; i != 0; i--) {
      plugin_mgr_Plugin* p = &m->plugins[i - 1];
      console_debug("plugins: unload %s", string_pool_Pool_idx2str(m->auxPool, p->name));
      p->functions->unload(p->arg);
      dlclose(p->handle);
   }
   free(m->plugins);
   string_list_List_free(&m->paths);
   free(m);
}

static const char* plugin_mgr_Mgr_getError(const plugin_mgr_Mgr* m)
{
   return m->error_msg;
}

static void plugin_mgr_Mgr_addPath(plugin_mgr_Mgr* m, uint32_t path)
{
   if (!string_list_List_contains_idx(&m->paths, path)) string_list_List_add(&m->paths, path);
}

static void plugin_mgr_Mgr_addPlugin(plugin_mgr_Mgr* m, plugin_mgr_Plugin* p)
{
   if (m->plugin_count == m->plugin_max) {
      m->plugin_max = m->plugin_max ? m->plugin_max * 2 : 4;
      plugin_mgr_Plugin* plugins2 = malloc(m->plugin_max * 32);
      if (m->plugin_count) {
         memcpy(plugins2, m->plugins, m->plugin_count * 32);
         free(m->plugins);
      }
      m->plugins = plugins2;
   }
   m->plugins[m->plugin_count] = *p;
   m->plugin_count++;
}

static bool plugin_mgr_is_plugin(const dirent* entry)
{
   const char* filename = entry->d_name;
   if (entry->d_type != libc_dirent_DT_REG) return false;
   if (filename[0] == '.') return false;
   return string_utils_endsWith(filename, plugin_mgr_lib_ext);
}

static void plugin_mgr_Mgr_show(const plugin_mgr_Mgr* m)
{
   console_log("Plugins:");
   for (uint32_t i = 0; i < string_list_List_length(&m->paths); i++) {
      const char* path = string_list_List_get(&m->paths, i);
      DIR* dir = opendir(path);
      if (dir == NULL) {
         console_warn("cannot read '%s': %s", path, strerror((*__errno_location())));
         continue;
      }
      {
         dirent* entry;
         while ((entry = readdir(dir))) {
            if (plugin_mgr_is_plugin(entry)) {
               console_log("  %s/%s", path, entry->d_name);
            }
         }
      }
      closedir(dir);
   }
}

static bool plugin_mgr_Mgr_loadPlugin(plugin_mgr_Mgr* m, uint32_t name, uint32_t options, bool is_global)
{
   if (m->no_plugins) return true;
   for (uint32_t i = 0; i < m->plugin_count; i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if (p->name == name) {
         if (!is_global) p->is_active = true;
         return true;
      }
   }
   const char* name_str = string_pool_Pool_idx2str(m->auxPool, name);
   char filename[128];
   snprintf(filename, 128, "lib%s%s", name_str, plugin_mgr_lib_ext);
   char fullname[512];
   if (!plugin_mgr_Mgr_find_file(m, fullname, 512, filename)) {
      snprintf(m->error_msg, 256, "cannot find plugin %s (%s)", name_str, filename);
      return false;
   }
   plugin_mgr_Plugin p = { };
   p.name = name;
   p.is_global = is_global;
   p.is_active = true;
   p.handle = dlopen(fullname, dlfcn_RTLD_NOW | dlfcn_RTLD_LOCAL);
   if (p.handle == NULL) {
      snprintf(m->error_msg, 256, "cannot load plugin %s: %s", fullname, dlerror());
      return false;
   }
   void* handle_symbol = dlsym(p.handle, "plugin_main_handle");
   if (!handle_symbol) {
      snprintf(m->error_msg, 256, "invalid plugin %s: %s", fullname, dlerror());
      dlclose(p.handle);
      return false;
   }
   p.functions = handle_symbol;
   console_debug("plugins: loading %s", fullname);
   p.arg = p.functions->load(string_pool_Pool_idx2str(m->auxPool, options), m->console_timing, m->console_debug);
   if (!p.arg) {
      dlclose(p.handle);
      snprintf(m->error_msg, 256, "plugin %s failed to load", fullname);
      return false;
   }
   plugin_mgr_Mgr_addPlugin(m, &p);
   return true;
}

static bool plugin_mgr_Mgr_loadGlobal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options)
{
   return plugin_mgr_Mgr_loadPlugin(m, name, options, true);
}

static bool plugin_mgr_Mgr_loadLocal(plugin_mgr_Mgr* m, uint32_t name, uint32_t options)
{
   return plugin_mgr_Mgr_loadPlugin(m, name, options, false);
}

static bool plugin_mgr_Mgr_find_file(plugin_mgr_Mgr* m, char* fullname, size_t size, const char* filename)
{
   for (uint32_t i = 0; i < string_list_List_length(&m->paths); i++) {
      if (file_utils_make_path(fullname, size, string_list_List_get(&m->paths, i), filename) && file_utils_is_file(fullname)) return true;
   }
   return false;
}

static void plugin_mgr_Mgr_beginTarget(plugin_mgr_Mgr* m, plugin_info_Info* info)
{
   for (uint32_t i = 0; i < m->plugin_count; i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if (p->is_active) p->functions->init(p->arg, info);
   }
}

static void plugin_mgr_Mgr_endTarget(plugin_mgr_Mgr* m)
{
   for (uint32_t i = 0; i < m->plugin_count; i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      p->is_active = p->is_global;
   }
}

static void plugin_mgr_Mgr_postParse(plugin_mgr_Mgr* m)
{
   for (uint32_t i = 0; i < m->plugin_count; i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if (p->is_active && p->functions->post_parse) p->functions->post_parse(p->arg);
   }
}

static void plugin_mgr_Mgr_postAnalysis(plugin_mgr_Mgr* m)
{
   for (uint32_t i = 0; i < m->plugin_count; i++) {
      plugin_mgr_Plugin* p = &m->plugins[i];
      if (p->is_active && p->functions->post_analysis) p->functions->post_analysis(p->arg);
   }
}


// --- module c_generator ---
typedef struct c_generator_Fragment_ c_generator_Fragment;
typedef struct c_generator_Generator_ c_generator_Generator;
typedef struct c_generator_MemberContext_ c_generator_MemberContext;
typedef struct c_generator_TraceCall_ c_generator_TraceCall;
typedef struct c_generator_TraceCallList_ c_generator_TraceCallList;
typedef struct c_generator_StringList_ c_generator_StringList;

struct c_generator_Fragment_ {
   string_buffer_Buf* buf;
   linked_list_Element list;
};

struct c_generator_TraceCallList_ {
   c_generator_TraceCall* array;
   uint32_t count;
   uint32_t capacity;
};

struct c_generator_StringList_ {
   uint32_t* hash_array;
   uint32_t hash_count;
   uint32_t hash_capacity;
   char** strings;
   uint32_t string_count;
   uint32_t string_capacity;
   const char* last_string;
   uint32_t last_index;
};

struct c_generator_Generator_ {
   string_pool_Pool* astPool;
   string_pool_Pool* auxPool;
   string_buffer_Buf* out;
   const char* target;
   build_target_Kind target_kind;
   const char* results_dir;
   const char* output_dir;
   const char* cgen_dir;
   diagnostics_Diags* diags;
   source_mgr_SourceMgr* sm;
   const build_file_Info* build_info;
   const target_info_Info* targetInfo;
   bool enable_asserts;
   bool fast_build;
   bool asan;
   bool msan;
   bool ubsan;
   bool trace_calls;
   bool no_trace;
   bool cur_external;
   uint32_t need_const_expr;
   ast_FunctionDecl* cur_function;
   const char* mod_name;
   string_list_List imports;
   ast_DeclList decls;
   dep_finder_Finder deps;
   ast_Decl* mainFunc;
   uint32_t varargsName;
   ast_Module* mod;
   string_buffer_Buf* header;
   linked_list_Element free_list;
   linked_list_Element used_list;
   linked_list_Element header_fragments;
   c_generator_TraceCallList calls;
   c_generator_StringList filenames;
   c_generator_StringList funcnames;
};

static const char c_generator_Dir[5] = "cgen";
static const char c_generator_LogFile[10] = "build.log";
static const char* c_generator_builtinType_cnames[14] = {
   "char",
   "int8_t",
   "int16_t",
   "int32_t",
   "int64_t",
   "uint8_t",
   "uint16_t",
   "uint32_t",
   "uint64_t",
   "float",
   "double",
   "ssize_t",
   "size_t",
   "bool"
};
static const char c_generator_Warning_control[999] = "#if defined(__clang__)\n#  pragma clang diagnostic ignored \"-Wincompatible-library-redeclaration\"\n#  pragma clang diagnostic ignored \"-Wunknown-warning-option\"\n#  pragma clang diagnostic ignored \"-Wparentheses-equality\"\n#  pragma clang diagnostic ignored \"-Wsometimes-uninitialized\"\n#  pragma clang diagnostic ignored \"-Wtypedef-redefinition\"\n#  pragma clang diagnostic ignored \"-Wstring-plus-int\"\n#  if (__clang_major__ >= 10)\n#    define fallthrough  __attribute__((fallthrough))\n#  endif\n#elif defined(__GNUC__)\n#  if (__GNUC__ >= 11)\n#    define fallthrough  [[fallthrough]]\n#  elif (__GNUC__ >= 7)\n#    define fallthrough  __attribute__((fallthrough))\n#  endif\n#  pragma GCC diagnostic ignored \"-Wmain\"\n#  if (__GNUC__ >= 10)\n#    pragma GCC diagnostic ignored \"-Wzero-length-bounds\"\n#  endif\n#  if (__GNUC__ >= 7)\n#    pragma GCC diagnostic ignored \"-Wformat-overflow\"\n#    pragma GCC diagnostic ignored \"-Wstringop-overflow\"\n#  endif\n#endif\n\n#ifndef fallthrough\n#  define fallthrough\n#endif\n\n";
static const char c_generator_Include_guard1[40] = "#ifndef EXTERNAL_H\n#define EXTERNAL_H\n\n";
static const char c_generator_C_types[327] = "// --- internally added ---\n#if !defined __STDC_VERSION__ || __STDC_VERSION__ < 202311L\n#define bool _Bool\n#define true 1\n#define false 0\n#endif\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef signed short int16_t;\ntypedef unsigned short uint16_t;\ntypedef signed int int32_t;\ntypedef unsigned int uint32_t;\n";
static const char c_generator_C_defines[75] = "\n#define NULL ((void*)0)\n#define ARRAY_SIZE(x) (sizeof(x)/sizeof((x)[0]))\n";
static const char c_generator_C2_assert[289] = "int dprintf(int fd, const char *format, ...);\nvoid abort(void);\nstatic int c2_assert(const char* filename, int line, const char* funcname, const char* condstr) {\n    dprintf(2, \"%s:%d: function %s: Assertion failed: %s\\n\", filename, line, funcname, condstr);\n    abort();\n    return 0;\n}\n";
static const char c_generator_C2_strswitch[484] = "static int c2_strswitch(const char* s1, const char* s2) {\n    if (!s1) return 0;  // nil\n    if (!*s1) return 1; // \"\"\n    int idx = 2;\n    while (*s2) {\n        unsigned len = *s2++ & 0xFF;\n        for (unsigned i = 0;; i++) {\n            if (i == len) {\n                if (s1[i] == '\\0')\n                    return idx;\n                break;\n            }\n            if (s1[i] != s2[i])\n                break;\n        }\n        s2 += len;\n        idx++;\n    }\n    return idx;\n}\n";
static c_generator_Fragment* c_generator_Fragment_create(void);
static void c_generator_Fragment_clear(c_generator_Fragment* f);
static void c_generator_Fragment_free(c_generator_Fragment* f);
static string_buffer_Buf* c_generator_Generator_getBuf(c_generator_Generator* gen, bool is_public);
static c_generator_Fragment* c_generator_Generator_getFragment(c_generator_Generator* gen);
static void c_generator_Generator_addFragment(c_generator_Generator* gen, c_generator_Fragment* f, bool is_public);
static void c_generator_Generator_freeFragment(c_generator_Generator* gen, c_generator_Fragment* f);
static void c_generator_Generator_emitCtv(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Expr* e);
static void c_generator_Generator_emitCName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d);
static void c_generator_Generator_emitCNameMod(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Decl* d, ast_Module* mod);
static void c_generator_Generator_emitDeclName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d);
static void c_generator_Generator_emitEnumType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static void c_generator_Generator_emitTypePre(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitTypePost(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_genDeclIfNeeded(c_generator_Generator* gen, ast_Decl* d);
static void c_generator_Generator_genTypeIfNeeded(c_generator_Generator* gen, ast_QualType qt, bool full);
static void c_generator_Generator_emitStructMember(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent);
static void c_generator_Generator_emitStruct(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent);
static void c_generator_Generator_emitFunctionType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static bool c_generator_match_type(const char* s, const char* list, const char** sp);
static bool c_generator_is_c_type(const char* s);
static void c_generator_Generator_emitAliasType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static bool c_generator_emitAsDefine(const ast_VarDecl* vd);
static void c_generator_Generator_emitConstExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec);
static void c_generator_Generator_emitGlobalVarDeclCommon(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static bool c_generator_Generator_emitGlobalVarDecl(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d);
static bool c_generator_Generator_emitExprValue(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitSectionAttr(c_generator_Generator* gen, string_buffer_Buf* out, const char* name);
static void c_generator_Generator_emitAutoInit(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_on_public_import_decl(void* arg, ast_ImportDecl* i);
static void c_generator_Generator_on_private_import_decl(void* arg, ast_ImportDecl* i);
static void c_generator_Generator_on_forward_structs(void* arg, ast_Decl* d);
static void c_generator_Generator_emitForwardStructDecl(c_generator_Generator* gen, ast_Decl* d, string_buffer_Buf* out);
static void c_generator_Generator_emitGlobalDecl(c_generator_Generator* gen, ast_Decl* d);
static void c_generator_Generator_flattenFragments(c_generator_Generator* gen);
static void c_generator_Generator_on_decl(void* arg, ast_Decl* d);
static void c_generator_Generator_on_ast_decl(void* arg, ast_AST* a);
static void c_generator_Generator_gen_member_type_func(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out, const char* name);
static void c_generator_Generator_gen_func_proto(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out);
static void c_generator_Generator_emitFuncParams(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out);
static void c_generator_Generator_emitFunction(c_generator_Generator* gen, ast_FunctionDecl* fd);
static void c_generator_Generator_gen_full_func(void* arg, ast_FunctionDecl* fd);
static void c_generator_Generator_gen_full_funcs(void* arg, ast_AST* a);
static void c_generator_Generator_on_interface_import(void* arg, ast_ImportDecl* i);
static void c_generator_Generator_create_interface_imports(void* arg, ast_AST* a);
static void c_generator_Generator_on_interface_decl(void* arg, ast_Decl* d);
static void c_generator_Generator_create_interface_decls(void* arg, ast_AST* a);
static void c_generator_Generator_on_public_ast_imports(void* arg, ast_AST* a);
static void c_generator_Generator_on_private_ast_imports(void* arg, ast_AST* a);
static void c_generator_Generator_on_ast_structs(void* arg, ast_AST* a);
static void c_generator_Generator_decl_mark_generated(void* _arg0, ast_Decl* d);
static void c_generator_Generator_decl_clear_generated(void* _arg0, ast_Decl* d);
static void c_generator_Generator_ast_mark_generated(void* arg, ast_AST* a);
static void c_generator_Generator_ast_clear_generated(void* arg, ast_AST* a);
static void c_generator_Generator_on_header_decl(void* arg, ast_Decl* d);
static void c_generator_Generator_emitHeaderDecl(c_generator_Generator* gen, ast_Decl* d);
static void c_generator_add_gen_warning(string_buffer_Buf* out);
static void c_generator_Generator_generateInterfaceFiles(c_generator_Generator* gen, ast_Module* m);
static void c_generator_Generator_on_module(void* arg, ast_Module* m);
static void c_generator_Generator_write_files(c_generator_Generator* gen);
static void c_generator_Generator_init(c_generator_Generator* gen, string_pool_Pool* astPool, const char* target, build_target_Kind kind, const char* results_dir, const char* output_dir, diagnostics_Diags* diags, source_mgr_SourceMgr* sm, const build_file_Info* build_info, ast_Decl* mainFunc);
static void c_generator_Generator_free(c_generator_Generator* gen);
static void c_generator_Generator_write(c_generator_Generator* gen, const char* output_dir, const char* filename, const string_buffer_Buf* buf);
static void c_generator_generate(string_pool_Pool* astPool, string_pool_Pool* auxPool, const char* target, build_target_Kind kind, const char* output_dir, diagnostics_Diags* diags, source_mgr_SourceMgr* sm, const build_file_Info* build_info, const target_info_Info* targetInfo, component_List* comps, ast_Decl* mainFunc, string_list_List* asm_files, bool enable_asserts, bool fast_build, bool asan, bool msan, bool ubsan, bool test_mode, bool trace_calls);
static void c_generator_build(const char* output_dir);
static void c_generator_Generator_emit_external_header(c_generator_Generator* gen, bool enable_asserts, const char* target);
static void c_generator_Generator_emitCall(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static ast_FunctionDecl* c_generator_get_function(ast_Decl* dest);
struct c_generator_MemberContext_ {
   bool need_dot;
   ast_QualType baseType;
   bool is_local;
};

static void c_generator_Generator_emitExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitExpr2(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec);
static void c_generator_Generator_emitBitOffset(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* base, ast_Expr* index, c_prec_C_Prec prec);
static void c_generator_Generator_emitCast(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt, bool full);
static void c_generator_Generator_emitBinaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec);
static void c_generator_Generator_emitUnaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec);
static void c_generator_emitDotOrArrow(string_buffer_Buf* out, ast_QualType qt);
static void c_generator_Generator_emitMemberDecl(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, c_generator_MemberContext* mc);
static void c_generator_Generator_emitMemberExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_MemberExpr* m, c_generator_MemberContext* mc, bool base_only);
static void c_generator_Generator_emitFieldDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitArrayDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static void c_generator_Generator_emitBuiltinExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e);
static const char c_generator_C2_types_header[671] = "// WARNING: this file is auto-generated by the C2 compiler.\n// Any changes you make might be lost!\n\n#ifndef C2TYPES_H\n#define C2TYPES_H\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define NULL ((void*)0)\n#define offsetof(type, member) __builtin_offsetof(type, member)\n#define to_container(type, member, ptr) ((type *)((char *)(ptr)-offsetof(type, member)))\n\n// NOTE: 64-bit only for now\ntypedef signed char int8_t;\ntypedef unsigned char uint8_t;\ntypedef signed short int int16_t;\ntypedef unsigned short int uint16_t;\ntypedef signed int int32_t;\ntypedef unsigned int uint32_t;\ntypedef signed long int64_t;\ntypedef unsigned long uint64_t;\n\n#ifdef __cplusplus\n}\n#endif\n#endif\n";
static void c_generator_Generator_createMakefile(c_generator_Generator* gen, const char* output_dir, component_List* comps, string_list_List* asm_files, bool enable_asserts, uint32_t libc_name);
static void c_generator_Generator_createExportsFile(c_generator_Generator* gen, const char* output_dir, component_Component* mainComp);
static void c_generator_Generator_generateC2TypesHeader(c_generator_Generator* gen);
static void c_generator_Generator_emitVarDecl(c_generator_Generator* gen, ast_VarDecl* vd, string_buffer_Buf* out, bool emit_init, bool first);
static void c_generator_Generator_emitStmt(c_generator_Generator* gen, ast_Stmt* s, uint32_t indent, bool newline);
static void c_generator_emitAsmPart(string_buffer_Buf* out, bool multi_line, uint32_t indent);
static void c_generator_Generator_emitAsmOperand(c_generator_Generator* gen, uint32_t name, const ast_Expr* c, ast_Expr* e);
static void c_generator_Generator_emitAsmStmt(c_generator_Generator* gen, ast_AsmStmt* a, uint32_t indent);
static void c_generator_Generator_emitSwitchStmt(c_generator_Generator* gen, ast_SwitchStmt* sw, uint32_t indent);
static void c_generator_Generator_emitCase(c_generator_Generator* gen, ast_SwitchCase* c, uint32_t indent, uint32_t* lab);
struct c_generator_TraceCall_ {
   uint8_t filename_idx;
   uint8_t column;
   uint16_t line;
   uint16_t caller_idx;
   uint16_t callee_idx;
};

#define c_generator_HASH_INITIAL 13
#define c_generator_HASH_PRIME 17
#define c_generator_HASH_BUCKETS 256
static uint32_t c_generator_TraceCallList_add(c_generator_TraceCallList* cl, c_generator_TraceCall call);
static void c_generator_TraceCallList_free(c_generator_TraceCallList* cl);
static void c_generator_StringList_free(c_generator_StringList* sl);
static uint32_t c_generator_StringList_length(c_generator_StringList* sl);
static const char* c_generator_StringList_get(const c_generator_StringList* sl, uint32_t i);
static uint32_t c_generator_StringList_add(c_generator_StringList* sl, const char* s, bool check_last);
static uint32_t c_generator_Generator_addCall(c_generator_Generator* gen, const char* funcname, src_loc_SrcLoc loc);
static void c_generator_Generator_writeCalls(c_generator_Generator* gen, string_buffer_Buf* out);
static void c_generator_Generator_writeCallExterns(c_generator_Generator* gen, string_buffer_Buf* out);

static c_generator_Fragment* c_generator_Fragment_create(void)
{
   c_generator_Fragment* f = malloc(24);
   f->buf = string_buffer_create(128, false, 3);
   return f;
}

static void c_generator_Fragment_clear(c_generator_Fragment* f)
{
   string_buffer_Buf_clear(f->buf);
}

static void c_generator_Fragment_free(c_generator_Fragment* f)
{
   string_buffer_Buf_free(f->buf);
   free(f);
}

static string_buffer_Buf* c_generator_Generator_getBuf(c_generator_Generator* gen, bool is_public)
{
   string_buffer_Buf* out = gen->out;
   if (gen->fast_build && (is_public || gen->cur_external)) out = gen->header;
   return out;
}

static c_generator_Fragment* c_generator_Generator_getFragment(c_generator_Generator* gen)
{
   if (linked_list_Element_isEmpty(&gen->free_list)) {
      return c_generator_Fragment_create();
   }
   linked_list_Element* e = linked_list_Element_popFront(&gen->free_list);
   c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
   c_generator_Fragment_clear(f);
   return f;
}

static void c_generator_Generator_addFragment(c_generator_Generator* gen, c_generator_Fragment* f, bool is_public)
{
   if (gen->fast_build && (is_public || gen->cur_external)) {
      linked_list_Element_addTail(&gen->header_fragments, &f->list);
   } else {
      linked_list_Element_addTail(&gen->used_list, &f->list);
   }
}

static void c_generator_Generator_freeFragment(c_generator_Generator* gen, c_generator_Fragment* f)
{
   linked_list_Element_addTail(&gen->free_list, &f->list);
}

static void c_generator_Generator_emitCtv(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Expr* e)
{
   ast_Value val = ast_evalExpr(e);
   string_buffer_Buf_print(out, "%s", ast_Value_str(&val));
}

static void c_generator_Generator_emitCName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d)
{
   c_generator_Generator_emitCNameMod(gen, out, d, gen->mod);
}

static void c_generator_Generator_emitCNameMod(c_generator_Generator* _arg0, string_buffer_Buf* out, const ast_Decl* d, ast_Module* mod)
{
   if (!ast_Decl_getName(d)) return;
   if (ast_Decl_isExternal(d) && ast_Module_isForeign(ast_Decl_getModule(d))) {
      const char* cname = ast_Decl_getCName(d);
      if (cname) {
         string_buffer_Buf_add(out, cname);
         return;
      }
      if (ast_Decl_isFunction(d)) {
         ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
         if (ast_FunctionDecl_isTypeFunc(fd)) goto c2_style;
      }
      ast_QualType qt = ast_Decl_getType(d);
      if (!ast_QualType_isConst(qt)) {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
         return;
      }
   }
c2_style:
   string_buffer_Buf_add(out, ast_Module_getName(mod));
   string_buffer_Buf_add1(out, '_');
   if (ast_Decl_isFunction(d)) {
      ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
      ast_Ref* prefix = ast_FunctionDecl_getPrefix(fd);
      if (prefix) {
         string_buffer_Buf_add(out, ast_idx2name(prefix->name_idx));
         string_buffer_Buf_add1(out, '_');
      }
   }
   if (ast_Decl_isEnumConstant(d)) {
      ast_QualType qt = ast_Decl_getType(d);
      ast_EnumType* et = (ast_EnumType*)ast_QualType_getType(qt);
      string_buffer_Buf_add(out, ast_EnumType_getName(et));
      string_buffer_Buf_add1(out, '_');
   }
   string_buffer_Buf_add(out, ast_Decl_getName(d));
}

static void c_generator_Generator_emitDeclName(c_generator_Generator* gen, string_buffer_Buf* out, const ast_Decl* d)
{
   if (ast_Decl_isVariable(d)) {
      ast_VarDecl* vd = (ast_VarDecl*)d;
      if (!ast_VarDecl_isGlobal(vd)) {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
         return;
      }
   }
   c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
}

static void c_generator_Generator_emitEnumType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_EnumTypeDecl* etd = (ast_EnumTypeDecl*)d;
   string_buffer_Buf_add(out, "typedef ");
   c_generator_Generator_emitTypePre(gen, out, ast_EnumTypeDecl_getImplType(etd));
   string_buffer_Buf_space(out);
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ";\n");
   string_buffer_Buf_add(out, "enum ");
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, " {\n");
   ast_Decl_setGenerated(d);
   uint32_t num_constants = ast_EnumTypeDecl_getNumConstants(etd);
   ast_EnumConstantDecl** decls = ast_EnumTypeDecl_getConstants(etd);
   for (uint32_t i = 0; i < num_constants; i++) {
      ast_EnumConstantDecl* ecd = decls[i];
      string_buffer_Buf_indent(out, 1);
      string_buffer_Buf_add(out, gen->mod_name);
      string_buffer_Buf_add1(out, '_');
      string_buffer_Buf_add(out, ast_Decl_getName(d));
      string_buffer_Buf_add1(out, '_');
      string_buffer_Buf_add(out, ast_Decl_getName(ast_EnumConstantDecl_asDecl(ecd)));
      ast_Expr* ie = ast_EnumConstantDecl_getInit(ecd);
      ast_Decl_setGenerated(ast_EnumConstantDecl_asDecl(ecd));
      if (ie) {
         string_buffer_Buf_add(out, " = ");
         c_generator_Generator_emitExpr(gen, out, ie);
      }
      string_buffer_Buf_add(out, ",\n");
   }
   string_buffer_Buf_add(out, "};\n\n");
}

static void c_generator_Generator_emitTypePre(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   ast_Decl* decl = NULL;
   if (ast_QualType_isConst(qt)) string_buffer_Buf_add(out, "const ");
   if (ast_QualType_isVolatile(qt)) string_buffer_Buf_add(out, "volatile ");
   switch (ast_QualType_getKind(qt)) {
   case ast_TypeKind_Builtin: {
      ast_BuiltinType* bt = (ast_BuiltinType*)ast_QualType_getType(qt);
      string_buffer_Buf_add(out, c_generator_builtinType_cnames[ast_BuiltinType_getKind(bt)]);
      return;
   }
   case ast_TypeKind_Pointer: {
      ast_PointerType* pt = (ast_PointerType*)ast_QualType_getType(qt);
      c_generator_Generator_emitTypePre(gen, out, ast_PointerType_getInner(pt));
      string_buffer_Buf_add1(out, '*');
      return;
   }
   case ast_TypeKind_Array: {
      ast_ArrayType* at = (ast_ArrayType*)ast_QualType_getType(qt);
      c_generator_Generator_emitTypePre(gen, out, ast_ArrayType_getElemType(at));
      return;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = (ast_StructType*)ast_QualType_getType(qt);
      ast_StructTypeDecl* std = ast_StructType_getDecl(st);
      if (ast_StructTypeDecl_hasAttrNoTypeDef(std)) {
         string_buffer_Buf_add(out, ast_StructTypeDecl_isStruct(std) ? "struct " : "union ");
      }
      decl = (ast_Decl*)ast_StructType_getDecl(st);
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = (ast_EnumType*)ast_QualType_getType(qt);
      decl = (ast_Decl*)ast_EnumType_getDecl(et);
      break;
   }
   case ast_TypeKind_Function: {
      ast_FunctionType* ft = (ast_FunctionType*)ast_QualType_getType(qt);
      ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      decl = (ast_Decl*)fd;
      break;
   }
   case ast_TypeKind_Void:
      string_buffer_Buf_add(out, "void");
      return;
   case ast_TypeKind_Alias: {
      ast_AliasType* at = (ast_AliasType*)ast_QualType_getType(qt);
      decl = (ast_Decl*)ast_AliasType_getDecl(at);
      break;
   }
   case ast_TypeKind_Module:
      ;//assert(0);
      return;
   }
   c_generator_Generator_emitCNameMod(gen, out, decl, ast_Decl_getModule(decl));
}

static void c_generator_Generator_emitTypePost(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   if (!ast_QualType_isArray(qt)) return;
   ast_ArrayType* at = (ast_ArrayType*)ast_QualType_getType(qt);
   string_buffer_Buf_add1(out, '[');
   if (ast_ArrayType_hasSize(at)) string_buffer_Buf_print(out, "%u", ast_ArrayType_getSize(at));
   string_buffer_Buf_add1(out, ']');
   c_generator_Generator_emitTypePost(gen, out, ast_ArrayType_getElemType(at));
}

static void c_generator_Generator_genDeclIfNeeded(c_generator_Generator* gen, ast_Decl* d)
{
   if (ast_Decl_isGenerated(d)) return;
   if (ast_Decl_isVariable(d)) {
      ast_VarDecl* vd = (ast_VarDecl*)d;
      if (!ast_VarDecl_isGlobal(vd)) return;
   }
   c_generator_Generator_emitGlobalDecl(gen, d);
}

static void c_generator_Generator_genTypeIfNeeded(c_generator_Generator* gen, ast_QualType qt, bool full)
{
   ast_Decl* d = NULL;
   switch (ast_QualType_getKind(qt)) {
   case ast_TypeKind_Builtin:
   case ast_TypeKind_Void:
      return;
   case ast_TypeKind_Pointer: {
      ast_PointerType* pt = (ast_PointerType*)ast_QualType_getType(qt);
      c_generator_Generator_genTypeIfNeeded(gen, ast_PointerType_getInner(pt), false);
      return;
   }
   case ast_TypeKind_Array: {
      ast_ArrayType* at = (ast_ArrayType*)ast_QualType_getType(qt);
      c_generator_Generator_genTypeIfNeeded(gen, ast_ArrayType_getElemType(at), true);
      return;
   }
   case ast_TypeKind_Struct: {
      ast_StructType* st = (ast_StructType*)ast_QualType_getType(qt);
      if (!full) return;
      d = (ast_Decl*)ast_StructType_getDecl(st);
      break;
   }
   case ast_TypeKind_Enum: {
      ast_EnumType* et = (ast_EnumType*)ast_QualType_getType(qt);
      d = (ast_Decl*)ast_EnumType_getDecl(et);
      break;
   }
   case ast_TypeKind_Function: {
      ast_FunctionType* ft = (ast_FunctionType*)ast_QualType_getType(qt);
      ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      d = (ast_Decl*)fd;
      break;
   }
   case ast_TypeKind_Alias: {
      ast_AliasType* at = (ast_AliasType*)ast_QualType_getType(qt);
      d = (ast_Decl*)ast_AliasType_getDecl(at);
      break;
   }
   case ast_TypeKind_Module:
      ;//assert(0);
      return;
   }
   if (!ast_Decl_isGenerated(d)) c_generator_Generator_emitGlobalDecl(gen, d);
}

static void c_generator_Generator_emitStructMember(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent)
{
   if (ast_Decl_isVariable(d)) {
      string_buffer_Buf_indent(out, indent);
      ast_QualType qt = ast_Decl_getType(d);
      if (ast_QualType_isFunction(qt)) {
         ast_FunctionType* ft = ast_QualType_getFunctionType(qt);
         ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
         if (ast_FunctionDecl_isMemberType(fd)) {
            c_generator_Generator_gen_member_type_func(gen, fd, out, ast_Decl_getName(d));
            string_buffer_Buf_add(out, ";\n");
            return;
         }
      }
      c_generator_Generator_genTypeIfNeeded(gen, qt, true);
      c_generator_Generator_emitTypePre(gen, out, qt);
      string_buffer_Buf_space(out);
      if (ast_Decl_getNameIdx(d)) string_buffer_Buf_add(out, ast_Decl_getName(d));
      c_generator_Generator_emitTypePost(gen, out, qt);
      ast_VarDecl* vd = (ast_VarDecl*)d;
      ast_Expr* bitfield = ast_VarDecl_getBitfield(vd);
      if (bitfield) {
         string_buffer_Buf_add(out, " : ");
         c_generator_Generator_emitCtv(gen, out, bitfield);
      }
      string_buffer_Buf_add(out, ";\n");
   } else {
      ;//assert(ast_Decl_isStructType(d));
      c_generator_Generator_emitStruct(gen, out, d, indent);
   }
}

static void c_generator_Generator_emitStruct(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, uint32_t indent)
{
   ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
   if (ast_StructTypeDecl_isGlobal(std)) {
      if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct ");
      else string_buffer_Buf_add(out, "union ");
      c_generator_Generator_emitCName(gen, out, d);
      if (!ast_StructTypeDecl_hasAttrNoTypeDef(std)) string_buffer_Buf_add1(out, '_');
   } else {
      string_buffer_Buf_indent(out, indent);
      if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct");
      else string_buffer_Buf_add(out, "union");
   }
   string_buffer_Buf_add(out, " {\n");
   uint32_t num_members = ast_StructTypeDecl_getNumMembers(std);
   ast_Decl** members = ast_StructTypeDecl_getMembers(std);
   for (uint32_t i = 0; i < num_members; i++) {
      c_generator_Generator_emitStructMember(gen, out, members[i], indent + 1);
   }
   if (ast_StructTypeDecl_isGlobal(std)) {
      string_buffer_Buf_add1(out, '}');
      if (ast_StructTypeDecl_isPacked(std)) string_buffer_Buf_add(out, " __attribute__((packed))");
      string_buffer_Buf_add(out, ";\n\n");
   } else {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add1(out, '}');
      if (ast_Decl_getNameIdx(d)) {
         string_buffer_Buf_space(out);
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      }
      string_buffer_Buf_add(out, ";\n");
   }
}

static void c_generator_Generator_emitFunctionType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_FunctionTypeDecl* ftd = (ast_FunctionTypeDecl*)d;
   ast_FunctionDecl* fd = ast_FunctionTypeDecl_getDecl(ftd);
   ast_Decl_setGenerated(ast_FunctionDecl_asDecl(fd));
   string_buffer_Buf_add(out, "typedef ");
   c_generator_Generator_emitTypePre(gen, out, ast_FunctionDecl_getRType(fd));
   string_buffer_Buf_add(out, " (*");
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ")(");
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; i < num_params; i++) {
      ast_Decl* arg = (ast_Decl*)params[i];
      if (i != 0) string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitTypePre(gen, out, ast_Decl_getType(arg));
      const char* name = ast_Decl_getName(arg);
      string_buffer_Buf_space(out);
      if (name) string_buffer_Buf_add(out, name);
      else string_buffer_Buf_print(out, "_arg%u", i);
   }
   if (ast_FunctionDecl_isVariadic(fd)) {
      if (num_params) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_add(out, "...");
   }
   if (num_params == 0 && !ast_FunctionDecl_isVariadic(fd)) string_buffer_Buf_add(out, "void");
   string_buffer_Buf_add1(out, ')');
   if (ast_Decl_hasAttrUnused(d)) string_buffer_Buf_add(out, " __attribute__((unused))");
   string_buffer_Buf_add(out, ";\n\n");
}

static bool c_generator_match_type(const char* s, const char* list, const char** sp)
{
   while (*list) {
      size_t len;
      for (len = 0; list[len] && list[len] != ','; len++) continue;

      size_t i;
      for (i = 0; i < len && s[i] == list[i]; i++) continue;

      if (i == len && (s[i] == '\0' || s[i] == ' ')) {
         *sp = s + i;
         return true;
      }
      list += len;
      list += (*list == ',');
   }
   return false;
}

static bool c_generator_is_c_type(const char* s)
{
   for (;;) {
      while (*s == ' ') s++;
      if (!*s) return true;
      if (!c_generator_match_type(s, "const,volatile,unsigned,signed,short,long,_Bool,char,int,float,double,size_t,ssize_t", &s)) break;
   }
   return false;
}

static void c_generator_Generator_emitAliasType(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   const char* cname = ast_Decl_getCName(d);
   if (cname && c_generator_is_c_type(cname)) return;
   ast_QualType qt = ast_Decl_getType(d);
   qt = ast_QualType_getCanonicalType(qt);
   string_buffer_Buf_add(out, "typedef ");
   c_generator_Generator_emitTypePre(gen, out, qt);
   c_generator_Generator_emitTypePost(gen, out, qt);
   string_buffer_Buf_space(out);
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ";\n");
}

static bool c_generator_emitAsDefine(const ast_VarDecl* vd)
{
   const ast_Decl* d = (ast_Decl*)vd;
   ast_QualType qt = ast_Decl_getType(d);
   ast_QualType canon = ast_QualType_getCanonicalType(qt);
   if (ast_VarDecl_isAddrUsed(vd)) return false;
   const ast_Expr* initExpr = ast_VarDecl_getInit(vd);
   if (!initExpr) return false;
   if (ast_QualType_isArray(canon)) {
      ast_ArrayType* at = ast_QualType_getArrayType(canon);
      ast_QualType et = ast_ArrayType_getElemType(at);
      if (!ast_QualType_isBuiltin(et)) return false;
      if (ast_QualType_isVolatile(et)) return false;
      if (!ast_QualType_isConst(et)) return false;
      if (ast_Expr_isStringLiteral(initExpr) && ast_Decl_isExternal(d)) return true;
   } else {
      if (!ast_QualType_isConst(qt)) return false;
      if (ast_QualType_isVolatile(qt)) return false;
      if (ast_QualType_isBuiltin(canon) || ast_QualType_isEnum(canon)) return true;
   }
   return false;
}

static void c_generator_Generator_emitConstExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec)
{
   gen->need_const_expr++;
   c_generator_Generator_emitExpr2(gen, out, e, prec);
   gen->need_const_expr--;
}

static void c_generator_Generator_emitGlobalVarDeclCommon(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   const char* cdef = ast_Decl_getCDef(d);
   if (cdef) {
      string_buffer_Buf_add(out, cdef);
   } else {
      ast_QualType qt = ast_Decl_getType(d);
      c_generator_Generator_emitTypePre(gen, out, qt);
      string_buffer_Buf_space(out);
      c_generator_Generator_emitCName(gen, out, d);
      c_generator_Generator_emitTypePost(gen, out, qt);
   }
   ast_VarDecl* vd = (ast_VarDecl*)d;
   if (ast_VarDecl_hasAttrWeak(vd)) string_buffer_Buf_add(out, " __attribute__((weak))");
   const char* section = ast_Decl_getSection(d);
   if (section) {
      string_buffer_Buf_space(out);
      c_generator_Generator_emitSectionAttr(gen, out, section);
   }
}

static bool c_generator_Generator_emitGlobalVarDecl(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d)
{
   ast_VarDecl* vd = (ast_VarDecl*)d;
   if (c_generator_emitAsDefine(vd)) {
      string_buffer_Buf_add(out, "#define ");
      c_generator_Generator_emitCName(gen, out, d);
      string_buffer_Buf_space(out);
      c_generator_Generator_emitConstExpr(gen, out, ast_VarDecl_getInit(vd), c_prec_C_Prec_Postfix);
      string_buffer_Buf_newline(out);
      return true;
   }
   bool emit_header = gen->fast_build && ast_Decl_isPublic(d);
   if (emit_header) {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      string_buffer_Buf_add(f->buf, "extern ");
      c_generator_Generator_emitGlobalVarDeclCommon(gen, f->buf, d);
      string_buffer_Buf_add(f->buf, ";\n");
      c_generator_Generator_addFragment(gen, f, true);
   }
   if (gen->cur_external) {
      string_buffer_Buf_add(out, "extern ");
      c_generator_Generator_emitGlobalVarDeclCommon(gen, out, d);
      string_buffer_Buf_add(out, ";\n");
      return false;
   }
   if (!ast_Decl_isExternal(d)) {
      if (!ast_Decl_isExported(d) && !emit_header) string_buffer_Buf_add(out, "static ");
      c_generator_Generator_emitGlobalVarDeclCommon(gen, out, d);
      string_buffer_Buf_add(out, " = ");
      ast_Expr* ie = ast_VarDecl_getInit(vd);
      if (ie) {
         c_generator_Generator_emitConstExpr(gen, out, ie, c_prec_C_Prec_Assignment);
      } else {
         c_generator_Generator_emitAutoInit(gen, out, ast_Decl_getType(d));
      }
      string_buffer_Buf_add(out, ";\n");
   }
   return false;
}

static bool c_generator_Generator_emitExprValue(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_Value result = ast_evalExpr(e);
   if (result.kind == ast_ValueKind_Error) {
      diagnostics_Diags_errorRange(gen->diags, ast_Expr_getLoc(e), ast_Expr_getRange(e), "%s", result.error_msg);
      return false;
   }
   string_buffer_Buf_add(out, ast_Value_str(&result));
   return true;
}

static void c_generator_Generator_emitSectionAttr(c_generator_Generator* gen, string_buffer_Buf* out, const char* name)
{
   string_buffer_Buf_print(out, "__attribute__((section(\"%s\")))", name);
}

static void c_generator_Generator_emitAutoInit(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt)
{
   qt = ast_QualType_getCanonicalType(qt);
   if (ast_QualType_isArray(qt) || ast_QualType_isStruct(qt)) {
      string_buffer_Buf_add(out, "{ }");
   } else if (ast_QualType_isPointer(qt)) {
      string_buffer_Buf_add(out, "NULL");
   } else {
      string_buffer_Buf_add1(out, '0');
   }
}

static void c_generator_Generator_on_public_import_decl(void* arg, ast_ImportDecl* i)
{
   c_generator_Generator* gen = arg;
   ast_Decl* d = (ast_Decl*)i;
   if (!ast_Decl_isUsedPublic(d)) return;
   uint32_t name_idx = ast_Decl_getNameIdx(d);
   if (string_list_List_contains_idx(&gen->imports, name_idx)) return;
   string_list_List_add(&gen->imports, name_idx);
   string_buffer_Buf_print(gen->header, "#include \"%s.h\"\n", ast_Decl_getName(d));
}

static void c_generator_Generator_on_private_import_decl(void* arg, ast_ImportDecl* i)
{
   c_generator_Generator* gen = arg;
   ast_Decl* d = (ast_Decl*)i;
   if (ast_Decl_isUsedPublic(d)) return;
   uint32_t name_idx = ast_Decl_getNameIdx(d);
   if (string_list_List_contains_idx(&gen->imports, name_idx)) return;
   string_list_List_add(&gen->imports, name_idx);
   string_buffer_Buf_print(gen->out, "#include \"%s.h\"\n", ast_Decl_getName(d));
}

static void c_generator_Generator_on_forward_structs(void* arg, ast_Decl* d)
{
   c_generator_Generator* gen = arg;
   if (!ast_Decl_isUsed(d)) return;
   if (!ast_Decl_isStructType(d)) return;
   if (gen->cur_external && !ast_Decl_isUsed(d)) return;
   c_generator_Generator_emitForwardStructDecl(gen, d, c_generator_Generator_getBuf(gen, ast_Decl_isPublic(d)));
}

static void c_generator_Generator_emitForwardStructDecl(c_generator_Generator* gen, ast_Decl* d, string_buffer_Buf* out)
{
   ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
   if (ast_StructTypeDecl_hasAttrNoTypeDef(std)) return;
   string_buffer_Buf_add(out, "typedef ");
   if (ast_StructTypeDecl_isStruct(std)) string_buffer_Buf_add(out, "struct");
   else string_buffer_Buf_add(out, "union");
   string_buffer_Buf_space(out);
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, "_ ");
   c_generator_Generator_emitCName(gen, out, d);
   string_buffer_Buf_add(out, ";\n");
}

static void c_generator_Generator_emitGlobalDecl(c_generator_Generator* gen, ast_Decl* d)
{
   ;//assert(!ast_Decl_isGenerated(d));
   if (gen->cur_external && !ast_Decl_isUsed(d)) {
      ast_Decl_setGenerated(d);
      return;
   }
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function: {
      ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
      if (ast_FunctionDecl_isTemplate(fd)) break;
      string_buffer_Buf* out = c_generator_Generator_getBuf(gen, ast_Decl_isPublic(d));
      c_generator_Generator_gen_func_proto(gen, fd, out);
      if (ast_FunctionDecl_isInline(fd)) {
         gen->cur_function = fd;
         ast_Decl_setGenerated(d);
         string_buffer_Buf_newline(out);
         string_buffer_Buf* saved = gen->out;
         gen->out = out;
         c_generator_Generator_emitStmt(gen, (ast_Stmt*)ast_FunctionDecl_getBody(fd), 0, true);
         gen->out = saved;
         string_buffer_Buf_newline(out);
         gen->cur_function = NULL;
      } else {
         string_buffer_Buf_add(out, ";\n");
      }
      break;
   }
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType: {
      ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitStruct(gen, f->buf, d, 0);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d) && !ast_StructTypeDecl_isOpaque(std));
      break;
   }
   case ast_DeclKind_EnumType: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitEnumType(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d));
      break;
   }
   case ast_DeclKind_EnumConstant:
      console_warn("TODO gen enum %d", ast_Decl_isGenerated(d));
      break;
   case ast_DeclKind_FunctionType: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitFunctionType(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d));
      break;
   }
   case ast_DeclKind_AliasType: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      c_generator_Generator_emitAliasType(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, ast_Decl_isPublic(d));
      break;
   }
   case ast_DeclKind_Variable: {
      c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
      bool in_header = c_generator_Generator_emitGlobalVarDecl(gen, f->buf, d);
      c_generator_Generator_addFragment(gen, f, in_header);
      break;
   }
   }
   ast_Decl_setGenerated(d);
   c_generator_Generator_flattenFragments(gen);
}

static void c_generator_Generator_flattenFragments(c_generator_Generator* gen)
{
   while (!linked_list_Element_isEmpty(&gen->used_list)) {
      linked_list_Element* e = linked_list_Element_popFront(&gen->used_list);
      c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
      string_buffer_Buf_add2(gen->out, string_buffer_Buf_data(f->buf), string_buffer_Buf_size(f->buf));
      c_generator_Generator_freeFragment(gen, f);
   }
   if (!gen->fast_build) {
      ;//assert(linked_list_Element_isEmpty(&gen->header_fragments));
   }
   while (!linked_list_Element_isEmpty(&gen->header_fragments)) {
      linked_list_Element* e = linked_list_Element_popFront(&gen->header_fragments);
      c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
      string_buffer_Buf_add2(gen->header, string_buffer_Buf_data(f->buf), string_buffer_Buf_size(f->buf));
      c_generator_Generator_freeFragment(gen, f);
   }
}

static void c_generator_Generator_on_decl(void* arg, ast_Decl* d)
{
   if (ast_Decl_isGenerated(d) || !ast_Decl_isUsed(d)) return;
   c_generator_Generator* gen = arg;
   if (ast_Decl_isImport(d)) {
      if (!gen->fast_build) return;
      ast_ImportDecl* id = (ast_ImportDecl*)d;
      if (gen->cur_external && gen->mod == ast_ImportDecl_getDest(id)) return;
   }
   dep_finder_Finder_check(&gen->deps, d);
   c_generator_Generator_emitGlobalDecl(gen, d);
}

static void c_generator_Generator_on_ast_decl(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_on_decl, arg);
}

static void c_generator_Generator_gen_member_type_func(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out, const char* name)
{
   ast_Decl* d = (ast_Decl*)fd;
   c_generator_Generator_emitTypePre(gen, out, ast_FunctionDecl_getRType(fd));
   string_buffer_Buf_print(out, " (*%s)", name);
   c_generator_Generator_emitFuncParams(gen, fd, out);
}

static void c_generator_Generator_gen_func_proto(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out)
{
   ast_Decl* d = (ast_Decl*)fd;
   if (ast_FunctionDecl_isTemplate(fd)) return;
   const char* section = ast_Decl_getSection(d);
   if (section) {
      c_generator_Generator_emitSectionAttr(gen, out, section);
      string_buffer_Buf_space(out);
   }
   if (ast_FunctionDecl_hasAttrInline(fd)) string_buffer_Buf_add(out, "static inline ");
   if (ast_FunctionDecl_hasAttrWeak(fd)) string_buffer_Buf_add(out, "__attribute__((weak)) ");
   if (ast_FunctionDecl_hasAttrConstructor(fd)) string_buffer_Buf_add(out, "__attribute__((constructor)) ");
   if (ast_FunctionDecl_hasAttrDestructor(fd)) string_buffer_Buf_add(out, "__attribute__((destructor)) ");
   if (ast_FunctionDecl_hasAttrNoReturn(fd)) string_buffer_Buf_add(out, "__attribute__((noreturn)) ");
   uint8_t format_arg;
   {
      ast_FormatAttr format_attr = ast_FunctionDecl_getFormatAttr(fd, &format_arg);
      if (format_attr) {
         string_buffer_Buf_print(out, "__attribute__((__format__(%s, %u, %u))) ", format_attr == ast_FormatAttr_Printf ? "printf" : format_attr == ast_FormatAttr_Scanf ? "scanf" : "", ast_FunctionDecl_getNumParams(fd), ast_FunctionDecl_getNumParams(fd) + 1);
      }
   }
   if (string_buffer_Buf_endsWith(out, ' ')) {
      string_buffer_Buf_trim(out, 1);
      string_buffer_Buf_newline(out);
   }
   if (d == gen->mainFunc) {
      string_buffer_Buf_add(out, "int32_t main");
   } else {
      if (!ast_FunctionDecl_hasAttrInline(fd) && !gen->cur_external && !ast_Decl_isExported(d) && !(gen->fast_build && ast_Decl_isPublic(d))) string_buffer_Buf_add(out, "static ");
      c_generator_Generator_emitTypePre(gen, out, ast_FunctionDecl_getRType(fd));
      string_buffer_Buf_space(out);
      c_generator_Generator_emitCName(gen, out, d);
   }
   c_generator_Generator_emitFuncParams(gen, fd, out);
}

static void c_generator_Generator_emitFuncParams(c_generator_Generator* gen, ast_FunctionDecl* fd, string_buffer_Buf* out)
{
   string_buffer_Buf_lparen(out);
   uint32_t num_params = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** params = ast_FunctionDecl_getParams(fd);
   for (uint32_t i = 0; i < num_params; i++) {
      ast_Decl* argx = (ast_Decl*)params[i];
      if (i != 0) string_buffer_Buf_add(out, ", ");
      ast_QualType qt = ast_Decl_getType(argx);
      if (ast_QualType_isFunction(qt)) {
         ast_FunctionType* ft = ast_QualType_getFunctionType(qt);
         ast_FunctionDecl* fd2 = ast_FunctionType_getDecl(ft);
         if (ast_FunctionDecl_isParam(fd2)) {
            const char* name = ast_Decl_getName(argx);
            char temp[8];
            if (!name) {
               sprintf(temp, "_arg%u", i);
               name = temp;
            }
            c_generator_Generator_gen_member_type_func(gen, fd2, out, name);
            continue;
         }
      }
      c_generator_Generator_emitTypePre(gen, out, qt);
      string_buffer_Buf_space(out);
      const char* name = ast_Decl_getName(argx);
      if (name) string_buffer_Buf_add(out, name);
      else string_buffer_Buf_print(out, "_arg%u", i);
   }
   if (ast_FunctionDecl_isVariadic(fd)) {
      if (num_params) string_buffer_Buf_add(out, ", ");
      string_buffer_Buf_add(out, "...");
   } else {
      if (num_params == 0) string_buffer_Buf_add(out, "void");
   }
   string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitFunction(c_generator_Generator* gen, ast_FunctionDecl* fd)
{
   c_generator_Fragment* f = c_generator_Generator_getFragment(gen);
   string_buffer_Buf* out = f->buf;
   c_generator_Generator_gen_func_proto(gen, fd, out);
   string_buffer_Buf_newline(out);
   string_buffer_Buf* saved = gen->out;
   gen->out = out;
   c_generator_Generator_emitStmt(gen, (ast_Stmt*)ast_FunctionDecl_getBody(fd), 0, true);
   string_buffer_Buf_newline(out);
   gen->out = saved;
   c_generator_Generator_addFragment(gen, f, false);
}

static void c_generator_Generator_gen_full_func(void* arg, ast_FunctionDecl* fd)
{
   if (!ast_Decl_isUsed(ast_FunctionDecl_asDecl(fd))) return;
   if (!ast_FunctionDecl_getBody(fd)) return;
   c_generator_Generator* gen = arg;
   if (ast_FunctionDecl_isTemplate(fd)) return;
   if (ast_FunctionDecl_isInline(fd)) return;
   gen->cur_function = fd;
   c_generator_Generator_emitFunction(gen, fd);
   gen->cur_function = NULL;
   c_generator_Generator_flattenFragments(gen);
}

static void c_generator_Generator_gen_full_funcs(void* arg, ast_AST* a)
{
   ast_AST_visitFunctions(a, c_generator_Generator_gen_full_func, arg);
}

static void c_generator_Generator_on_interface_import(void* arg, ast_ImportDecl* i)
{
   c_generator_Generator* gen = arg;
   ast_Decl* d = (ast_Decl*)i;
   if (!ast_Decl_isUsedPublic(d)) return;
   uint32_t name_idx = ast_Decl_getNameIdx(d);
   if (string_list_List_contains_idx(&gen->imports, name_idx)) return;
   string_list_List_add(&gen->imports, name_idx);
   string_buffer_Buf_print(gen->header, "#include \"%s.h\"\n", ast_Decl_getName(d));
}

static void c_generator_Generator_create_interface_imports(void* arg, ast_AST* a)
{
   ast_AST_visitImports(a, c_generator_Generator_on_interface_import, arg);
}

static void c_generator_Generator_on_interface_decl(void* arg, ast_Decl* d)
{
   c_generator_Generator* gen = arg;
   if (!ast_Decl_isExported(d)) return;
   if (ast_Decl_isImport(d)) return;
   if (ast_Decl_isStructType(d)) {
      c_generator_Generator_emitForwardStructDecl(gen, d, gen->header);
      string_buffer_Buf_newline(gen->header);
      ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
      if (ast_StructTypeDecl_isOpaque(std)) return;
   }
   ast_DeclList_add(&gen->decls, d);
}

static void c_generator_Generator_create_interface_decls(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_on_interface_decl, arg);
}

static void c_generator_Generator_on_public_ast_imports(void* arg, ast_AST* a)
{
   ast_AST_visitImports(a, c_generator_Generator_on_public_import_decl, arg);
}

static void c_generator_Generator_on_private_ast_imports(void* arg, ast_AST* a)
{
   ast_AST_visitImports(a, c_generator_Generator_on_private_import_decl, arg);
}

static void c_generator_Generator_on_ast_structs(void* arg, ast_AST* a)
{
   ast_AST_visitTypeDecls(a, c_generator_Generator_on_forward_structs, arg);
}

static void c_generator_Generator_decl_mark_generated(void* _arg0, ast_Decl* d)
{
   ast_Decl_setGenerated(d);
}

static void c_generator_Generator_decl_clear_generated(void* _arg0, ast_Decl* d)
{
   ast_Decl_clearGenerated(d);
}

static void c_generator_Generator_ast_mark_generated(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_decl_mark_generated, arg);
}

static void c_generator_Generator_ast_clear_generated(void* arg, ast_AST* a)
{
   ast_AST_visitDecls(a, c_generator_Generator_decl_clear_generated, arg);
}

static void c_generator_Generator_on_header_decl(void* arg, ast_Decl* d)
{
   if (ast_Decl_isGenerated(d)) return;
   c_generator_Generator* gen = arg;
   dep_finder_Finder_check(&gen->deps, d);
   c_generator_Generator_emitHeaderDecl(gen, d);
   ast_Decl_setGenerated(d);
}

static void c_generator_Generator_emitHeaderDecl(c_generator_Generator* gen, ast_Decl* d)
{
   string_buffer_Buf* out = gen->header;
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function: {
      ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
      if (ast_FunctionDecl_isTemplate(fd)) break;
      c_generator_Generator_gen_func_proto(gen, fd, out);
      if (ast_FunctionDecl_isInline(fd)) {
         string_buffer_Buf_newline(out);
         c_generator_Generator_emitStmt(gen, (ast_Stmt*)ast_FunctionDecl_getBody(fd), 0, true);
         string_buffer_Buf_newline(out);
      } else {
         string_buffer_Buf_add(out, ";\n");
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_DeclKind_Import:
      ;//assert(0);
      return;
   case ast_DeclKind_StructType:
      c_generator_Generator_emitStruct(gen, out, d, 0);
      break;
   case ast_DeclKind_EnumType:
      c_generator_Generator_emitEnumType(gen, out, d);
      break;
   case ast_DeclKind_EnumConstant:
      ;//assert(0);
      return;
   case ast_DeclKind_FunctionType:
      c_generator_Generator_emitFunctionType(gen, out, d);
      break;
   case ast_DeclKind_AliasType:
      c_generator_Generator_emitAliasType(gen, out, d);
      break;
   case ast_DeclKind_Variable:
      c_generator_Generator_emitGlobalVarDecl(gen, out, d);
      break;
   }
}

static void c_generator_add_gen_warning(string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "// WARNING: this file is auto-generated by the C2 compiler.\n");
   string_buffer_Buf_add(out, "// Any changes you make might be lost!\n\n");
}

static void c_generator_Generator_generateInterfaceFiles(c_generator_Generator* gen, ast_Module* m)
{
   string_list_List_clear(&gen->imports);
   string_buffer_Buf_clear(gen->header);
   ast_DeclList_clear(&gen->decls);
   string_buffer_Buf* hdr = gen->header;
   c_generator_add_gen_warning(hdr);
   char upper_name[32];
   string_utils_toUpper(ast_Module_getName(m), upper_name);
   string_buffer_Buf_print(hdr, "#ifndef %s_H\n", upper_name);
   string_buffer_Buf_print(hdr, "#define %s_H\n\n", upper_name);
   string_buffer_Buf_add(hdr, "#include \"c2types.h\"\n\n");
   string_buffer_Buf_add(hdr, "#ifdef __cplusplus\nextern \"C\" {\n#endif\n");
   gen->cur_external = true;
   ast_Module_visitASTs(m, c_generator_Generator_ast_clear_generated, gen);
   ast_Module_visitASTs(m, c_generator_Generator_create_interface_imports, gen);
   string_buffer_Buf_newline(hdr);
   ast_Module_visitASTs(m, c_generator_Generator_create_interface_decls, gen);
   dep_finder_Finder_init(&gen->deps, m, gen, c_generator_Generator_on_header_decl);
   string_buffer_Buf* saved = gen->out;
   gen->out = hdr;
   for (uint32_t i = 0; i < ast_DeclList_size(&gen->decls); i++) {
      c_generator_Generator_on_header_decl(gen, ast_DeclList_get(&gen->decls, i));
   }
   gen->out = saved;
   string_buffer_Buf_add(hdr, "#ifdef __cplusplus\n}\n#endif\n\n");
   string_buffer_Buf_add(hdr, "#endif\n");
   file_utils_File file; file_utils_File_init_ext(&file, gen->results_dir, ast_Module_getName(m), ".h");
   if (!file_utils_File_write(&file, string_buffer_Buf_data(hdr), string_buffer_Buf_size(hdr))) {
      console_error("cannot write to %s: %s", file.path, file_utils_File_getError(&file));
   }
   gen->cur_external = false;
}

static void c_generator_Generator_on_module(void* arg, ast_Module* m)
{
   if (!ast_Module_isUsed(m)) return;
   c_generator_Generator* gen = arg;
   string_buffer_Buf* out = gen->out;
   gen->mod_name = ast_Module_getName(m);
   gen->mod = m;
   gen->no_trace = !strcmp(gen->mod_name, "c2_trace");
   if (gen->fast_build) {
      string_buffer_Buf_clear(out);
      string_buffer_Buf_clear(gen->header);
      c_generator_add_gen_warning(gen->header);
      char upper_name[32];
      string_utils_toUpper(gen->mod_name, upper_name);
      string_buffer_Buf_print(gen->header, "#ifndef %s_H\n", upper_name);
      string_buffer_Buf_print(gen->header, "#define %s_H\n\n", upper_name);
      string_buffer_Buf_add(gen->header, "#include \"_external.h\"\n\n");
      c_generator_add_gen_warning(out);
   } else {
      string_buffer_Buf_print(out, "\n// --- module %s ---\n", gen->mod_name);
   }
   if (ast_Module_getNameIdx(m) == gen->varargsName) {
      if (gen->fast_build) out = gen->header;
      const char builtin_defs[167] = "// Note: this module is a special case and is custom generated\n#define va_list __builtin_va_list\n#define va_start __builtin_va_start\n#define va_end __builtin_va_end\n\n";
      string_buffer_Buf_add(out, builtin_defs);
      ast_Module_visitASTs(m, c_generator_Generator_ast_mark_generated, arg);
      if (gen->fast_build) c_generator_Generator_write_files(gen);
      return;
   }
   if (gen->fast_build) {
      string_buffer_Buf_print(out, "#include \"%s.h\"\n", gen->mod_name);
      string_list_List_clear(&gen->imports);
      ast_Module_visitASTs(m, c_generator_Generator_on_public_ast_imports, gen);
      string_list_List_clear(&gen->imports);
      ast_Module_visitASTs(m, c_generator_Generator_on_private_ast_imports, gen);
   }
   ast_Module_visitASTs(m, c_generator_Generator_ast_clear_generated, gen);
   ast_Module_visitASTs(m, c_generator_Generator_on_ast_structs, arg);
   string_buffer_Buf_newline(gen->out);
   dep_finder_Finder_init(&gen->deps, m, gen, c_generator_Generator_on_decl);
   ast_Module_visitASTs(m, c_generator_Generator_on_ast_decl, arg);
   string_buffer_Buf_newline(gen->out);
   ast_Module_visitASTs(m, c_generator_Generator_gen_full_funcs, arg);
   if (gen->fast_build) c_generator_Generator_write_files(gen);
   if (ast_Module_isExported(m)) c_generator_Generator_generateInterfaceFiles(gen, m);
}

static void c_generator_Generator_write_files(c_generator_Generator* gen)
{
   ;//assert(gen->fast_build);
   string_buffer_Buf_add(gen->header, "\n#endif\n\n");
   char outfile[64];
   if (!gen->cur_external) {
      sprintf(outfile, "%s.c", gen->mod_name);
      c_generator_Generator_write(gen, gen->cgen_dir, outfile, gen->out);
   }
   sprintf(outfile, "%s.h", gen->mod_name);
   c_generator_Generator_write(gen, gen->cgen_dir, outfile, gen->header);
   string_buffer_Buf_clear(gen->out);
   string_buffer_Buf_clear(gen->header);
}

static void c_generator_Generator_init(c_generator_Generator* gen, string_pool_Pool* astPool, const char* target, build_target_Kind kind, const char* results_dir, const char* output_dir, diagnostics_Diags* diags, source_mgr_SourceMgr* sm, const build_file_Info* build_info, ast_Decl* mainFunc)
{
   memset(gen, 0, 424);
   gen->out = string_buffer_create(256 * 1024, false, 3);
   gen->target = target;
   gen->target_kind = kind;
   gen->results_dir = results_dir;
   gen->output_dir = output_dir;
   gen->diags = diags;
   gen->sm = sm;
   gen->build_info = build_info;
   gen->mainFunc = mainFunc;
   linked_list_Element_init(&gen->free_list);
   linked_list_Element_init(&gen->used_list);
   linked_list_Element_init(&gen->header_fragments);
   gen->header = string_buffer_create(8192, false, 2);
   string_list_List_init(&gen->imports, NULL);
   ast_DeclList_init(&gen->decls);
   gen->astPool = astPool;
   gen->varargsName = string_pool_Pool_addStr(astPool, "varargs", true);
}

static void c_generator_Generator_free(c_generator_Generator* gen)
{
   while (!linked_list_Element_isEmpty(&gen->free_list)) {
      linked_list_Element* e = linked_list_Element_popFront(&gen->free_list);
      c_generator_Fragment* f = to_container(c_generator_Fragment, list, e);
      c_generator_Fragment_free(f);
   }
   string_buffer_Buf_free(gen->out);
   string_buffer_Buf_free(gen->header);
   string_list_List_free(&gen->imports);
   ast_DeclList_free(&gen->decls);
   c_generator_TraceCallList_free(&gen->calls);
   c_generator_StringList_free(&gen->filenames);
   c_generator_StringList_free(&gen->funcnames);
}

static void c_generator_Generator_write(c_generator_Generator* gen, const char* output_dir, const char* filename, const string_buffer_Buf* buf)
{
   file_utils_File file; file_utils_File_init(&file, output_dir, filename);
   if (!file_utils_File_write(&file, string_buffer_Buf_data(buf), string_buffer_Buf_size(buf))) {
      console_error("cannot write to %s: %s", file.path, file_utils_File_getError(&file));
   }
}

static void c_generator_generate(string_pool_Pool* astPool, string_pool_Pool* auxPool, const char* target, build_target_Kind kind, const char* output_dir, diagnostics_Diags* diags, source_mgr_SourceMgr* sm, const build_file_Info* build_info, const target_info_Info* targetInfo, component_List* comps, ast_Decl* mainFunc, string_list_List* asm_files, bool enable_asserts, bool fast_build, bool asan, bool msan, bool ubsan, bool test_mode, bool trace_calls)
{
   char dir[512];
   if (!file_utils_make_path(dir, 512, output_dir, c_generator_Dir) || file_utils_create_path(dir)) {
      console_error("cannot create directory %s: %s", dir, strerror((*__errno_location())));
      return;
   }
   c_generator_Generator gen;
   c_generator_Generator_init(&gen, astPool, target, kind, output_dir, dir, diags, sm, build_info, mainFunc);
   gen.auxPool = auxPool;
   gen.enable_asserts = enable_asserts;
   gen.fast_build = fast_build;
   gen.asan = asan;
   gen.msan = msan;
   gen.ubsan = ubsan;
   gen.trace_calls = trace_calls;
   gen.targetInfo = targetInfo;
   gen.cgen_dir = dir;
   string_buffer_Buf* out = gen.out;
   if (!fast_build) {
      c_generator_add_gen_warning(out);
   }
   c_generator_Generator_emit_external_header(&gen, enable_asserts, target);
   if (fast_build) {
      c_generator_Generator_write(&gen, gen.cgen_dir, "_external.h", gen.out);
      string_buffer_Buf_clear(out);
      gen.cur_external = true;
   }
   component_Component* mainComp = component_List_getLast(comps);
   if (gen.target_kind != build_target_Kind_Executable) {
      c_generator_Generator_generateC2TypesHeader(&gen);
   }
   for (uint32_t i = 0; i < component_List_size(comps) - 1; i++) {
      component_Component* c = component_List_get(comps, i);
      gen.cur_external = component_Component_isExternalLibrary(c);
      component_Component_visitModules(c, c_generator_Generator_on_module, &gen);
   }
   gen.cur_external = false;
   component_Component_visitModules(mainComp, c_generator_Generator_on_module, &gen);
   if (fast_build) {
      if (gen.trace_calls) {
         string_buffer_Buf_clear(gen.out);
         string_buffer_Buf_add(gen.out, "#include \"c2_trace_tables.h\"\n\n");
         c_generator_Generator_writeCalls(&gen, gen.out);
         c_generator_Generator_write(&gen, dir, "c2_trace_tables.c", gen.out);
      }
   } else {
      if (gen.trace_calls) {
         c_generator_Generator_writeCalls(&gen, gen.out);
      }
      c_generator_Generator_write(&gen, dir, "build.c", gen.out);
   }
   uint32_t libc_name = string_pool_Pool_addStr(auxPool, "libc", true);
   c_generator_Generator_createMakefile(&gen, dir, comps, asm_files, enable_asserts, libc_name);
   c_generator_Generator_createExportsFile(&gen, dir, component_List_get(comps, component_List_size(comps) - 1));
   if (component_Component_isLibrary(mainComp)) manifest_writer_write(output_dir, mainComp, constants_manifest_name);
   c_generator_Generator_free(&gen);
}

static void c_generator_build(const char* output_dir)
{
   const char* make = "make";
   char dir[512];
   if (!file_utils_make_path_ext(dir, 512, output_dir, c_generator_Dir, "/")) {
      console_error("cannot launch C compilation: %s", strerror((*__errno_location())));
      return;
   }
   int32_t retval = process_utils_run_args(dir, make, "-j", c_generator_LogFile);
   if (retval != 0) {
      console_error("error during external C compilation");
      console_log("see %s%s for details", dir, c_generator_LogFile);
   }
}

static void c_generator_Generator_emit_external_header(c_generator_Generator* gen, bool enable_asserts, const char* target)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_add(out, c_generator_Include_guard1);
   string_buffer_Buf_add(out, c_generator_Warning_control);
   string_buffer_Buf_add(out, c_generator_C_types);
   if (ast_getWordSize() == 4) {
      string_buffer_Buf_add(out, "typedef signed long long int64_t;\ntypedef unsigned long long uint64_t;\ntypedef signed long ssize_t;\ntypedef unsigned long size_t;\n");
   } else {
      string_buffer_Buf_add(out, "typedef signed long int64_t;\ntypedef unsigned long uint64_t;\ntypedef signed long ssize_t;\ntypedef unsigned long size_t;\n");
   }
   string_buffer_Buf_add(out, c_generator_C_defines);
   string_buffer_Buf_add(out, "#define offsetof(type, member) __builtin_offsetof(type, member)\n");
   string_buffer_Buf_add(out, "#define to_container(type, member, ptr) ((type*)((char*)(ptr) - offsetof(type, member)))\n\n");
   if (enable_asserts) {
      string_buffer_Buf_add(out, c_generator_C2_assert);
   }
   string_buffer_Buf_add(out, c_generator_C2_strswitch);
   if (gen->trace_calls) c_generator_Generator_writeCallExterns(gen, out);
   string_buffer_Buf_add(out, "#endif\n");
}

static void c_generator_Generator_emitCall(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_CallExpr* call = (ast_CallExpr*)e;
   bool is_tf = ast_CallExpr_isTypeFunc(call);
   ast_Decl* dest;
   if (ast_CallExpr_isTemplateCall(call)) {
      ast_Expr* func = ast_CallExpr_getFunc(call);
      ast_QualType qt = ast_Expr_getType(func);
      ast_FunctionType* ft = ast_QualType_getFunctionTypeOrNil(qt);
      ast_FunctionDecl* template_fd = ast_FunctionType_getDecl(ft);
      uint32_t idx = ast_CallExpr_getTemplateIdx(call);
      ast_FunctionDecl* instance = ast_Module_getInstance(gen->mod, template_fd, idx);
      ;//assert(instance);
      dest = ast_FunctionDecl_asDecl(instance);
      if (!ast_Decl_isGenerated(dest)) {
         c_generator_Generator_emitFunction(gen, instance);
         ast_Decl_setGenerated(ast_FunctionDecl_asDecl(instance));
      }
      c_generator_Generator_emitDeclName(gen, out, dest);
      string_buffer_Buf_lparen(out);
   } else {
      ast_Expr* func = ast_CallExpr_getFunc(call);
      if (ast_Expr_isImplicitCast(func)) {
         ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)func;
         func = ast_ImplicitCastExpr_getInner(ic);
      }
      if (is_tf || ast_CallExpr_isStaticTypeFunc(call)) {
         ;//assert(ast_Expr_isMember(func));
         ast_MemberExpr* m = (ast_MemberExpr*)func;
         dest = ast_MemberExpr_getFullDecl(m);
         if (gen->trace_calls && !gen->no_trace) {
            string_buffer_Buf_print(out, "(c2_trace_counts[%u]++, ", c_generator_Generator_addCall(gen, ast_Decl_getFullName(dest), ast_CallExpr_getStartLoc(call)));
            c_generator_Generator_emitCNameMod(gen, out, dest, ast_Decl_getModule(dest));
            string_buffer_Buf_add1(out, ')');
         } else {
            c_generator_Generator_emitCNameMod(gen, out, dest, ast_Decl_getModule(dest));
         }
         string_buffer_Buf_lparen(out);
         if (is_tf) {
            switch (ast_MemberExpr_getConversion(m)) {
            case ast_MemberConversion_None:
               break;
            case ast_MemberConversion_Addr:
               string_buffer_Buf_add1(out, '&');
               break;
            case ast_MemberConversion_Deref:
               string_buffer_Buf_add1(out, '*');
               break;
            }
            c_generator_MemberContext mc = { };
            c_generator_Generator_emitMemberExpr(gen, out, m, &mc, true);
         }
      } else {
         bool no_trace = gen->no_trace;
         if (ast_Expr_isIdentifier(func)) {
            ast_IdentifierExpr* i = (ast_IdentifierExpr*)func;
            const char* name = ast_IdentifierExpr_getName(i);
            if (name && name[0] == 'v' && name[1] == 'a' && name[2] == '_') no_trace = true;
            dest = ast_IdentifierExpr_getDecl(i);
         } else if (ast_Expr_isMember(func)) {
            ast_MemberExpr* m = (ast_MemberExpr*)func;
            dest = ast_MemberExpr_getFullDecl(m);
         } else {
            ast_Expr_dump(func);
            ;//assert(0);
         }
         if (gen->trace_calls && !no_trace) {
            string_buffer_Buf_print(out, "(c2_trace_counts[%u]++, ", c_generator_Generator_addCall(gen, ast_Decl_getFullName(dest), ast_CallExpr_getStartLoc(call)));
            c_generator_Generator_emitExpr(gen, out, func);
            string_buffer_Buf_add1(out, ')');
         } else {
            c_generator_Generator_emitExpr2(gen, out, func, c_prec_C_Prec_Postfix);
         }
         string_buffer_Buf_lparen(out);
      }
   }
   ;//assert(dest);
   bool needs_comma = is_tf;
   uint32_t call_num_args = ast_CallExpr_getNumArgs(call);
   ast_Expr** args = ast_CallExpr_getArgs(call);
   ast_FunctionDecl* fd = c_generator_get_function(dest);
   uint32_t func_num_args = ast_FunctionDecl_getNumParams(fd);
   ast_VarDecl** func_args = ast_FunctionDecl_getParams(fd);
   uint32_t call_index = 0;
   uint32_t func_index = 0;
   if (is_tf) func_index++;
   source_mgr_Location loc;
   if (ast_CallExpr_hasAutoArgs(call)) loc = source_mgr_SourceMgr_locate(gen->sm, ast_Expr_getLoc(e));
   while (1) {
      if (func_index == func_num_args && call_index == call_num_args) break;
      if (func_index < func_num_args) {
         ast_VarDecl* vd = func_args[func_index];
         if (needs_comma) string_buffer_Buf_add(out, ", ");
         if (ast_VarDecl_hasAutoAttr(vd)) {
            if (ast_VarDecl_hasAttrAutoFile(vd)) {
               string_buffer_Buf_print(out, "\"%s\"", loc.filename);
            }
            if (ast_VarDecl_hasAttrAutoLine(vd)) {
               string_buffer_Buf_print(out, "%u", loc.line);
            }
            if (ast_VarDecl_hasAttrAutoFunc(vd)) {
               string_buffer_Buf_print(out, "\"%s\"", ast_Decl_getFullName(ast_FunctionDecl_asDecl(gen->cur_function)));
            }
            needs_comma = true;
            func_index++;
            continue;
         }
         ast_Expr* arg;
         ast_Decl* d = ast_VarDecl_asDecl(vd);
         if (call_index < call_num_args) {
            arg = args[call_index++];
            if (ast_Expr_isNamedArgument(arg)) {
               ast_NamedArgument* n = (ast_NamedArgument*)arg;
               uint32_t arg_name_idx = ast_NamedArgument_getNameIdx(n);
               if (ast_Decl_getNameIdx(d) == arg_name_idx) {
                  arg = ast_NamedArgument_getInner(n);
               } else {
                  call_index--;
                  arg = ast_VarDecl_getInit(vd);
               }
            }
         } else {
            arg = ast_VarDecl_getInit(vd);
         }
         if (ast_Expr_isInitList(arg)) {
            c_generator_Generator_emitCast(gen, out, ast_Decl_getType(d), true);
         }
         c_generator_Generator_emitExpr(gen, out, arg);
         needs_comma = true;
         func_index++;
      } else {
         if (needs_comma) string_buffer_Buf_add(out, ", ");
         c_generator_Generator_emitExpr(gen, out, args[call_index]);
         call_index++;
         needs_comma = true;
      }
   }
   string_buffer_Buf_rparen(out);
}

static ast_FunctionDecl* c_generator_get_function(ast_Decl* dest)
{
   if (ast_Decl_isVariable(dest)) {
      ast_QualType qt = ast_Decl_getType(dest);
      ;//assert(ast_QualType_isFunction(qt));
      ast_FunctionType* ft = ast_QualType_getFunctionType(qt);
      ast_FunctionDecl* fd = ast_FunctionType_getDecl(ft);
      dest = (ast_Decl*)fd;
   }
   ;//assert(ast_Decl_isFunction(dest));
   return (ast_FunctionDecl*)dest;
}

static void c_generator_Generator_emitExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   c_generator_Generator_emitExpr2(gen, out, e, c_prec_C_Prec_Assignment);
}

static void c_generator_Generator_emitExpr2(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec)
{
   switch (ast_Expr_getKind(e)) {
   case ast_ExprKind_IntegerLiteral: {
      ast_IntegerLiteral* i = (ast_IntegerLiteral*)e;
      ast_IntegerLiteral_printLiteral(i, out, true);
      break;
   }
   case ast_ExprKind_FloatLiteral: {
      ast_FloatLiteral* f = (ast_FloatLiteral*)e;
      ast_FloatLiteral_printLiteral(f, out);
      break;
   }
   case ast_ExprKind_BooleanLiteral: {
      ast_BooleanLiteral* b = (ast_BooleanLiteral*)e;
      ast_BooleanLiteral_printLiteral(b, out);
      break;
   }
   case ast_ExprKind_CharLiteral: {
      ast_CharLiteral* c = (ast_CharLiteral*)e;
      ast_CharLiteral_printLiteral(c, out);
      break;
   }
   case ast_ExprKind_StringLiteral: {
      ast_StringLiteral* s = (ast_StringLiteral*)e;
      ast_StringLiteral_printLiteral(s, out);
      break;
   }
   case ast_ExprKind_Nil:
      string_buffer_Buf_add(out, "NULL");
      break;
   case ast_ExprKind_Identifier: {
      ast_IdentifierExpr* i = (ast_IdentifierExpr*)e;
      ast_Decl* d = ast_IdentifierExpr_getDecl(i);
      c_generator_Generator_genDeclIfNeeded(gen, d);
      c_generator_Generator_emitDeclName(gen, out, d);
      break;
   }
   case ast_ExprKind_Type:
      c_generator_Generator_emitTypePre(gen, out, ast_Expr_getType(e));
      c_generator_Generator_emitTypePost(gen, out, ast_Expr_getType(e));
      break;
   case ast_ExprKind_Call:
      if (gen->need_const_expr) c_generator_Generator_emitExprValue(gen, out, e);
      else c_generator_Generator_emitCall(gen, out, e);
      break;
   case ast_ExprKind_InitList: {
      ast_InitListExpr* ile = (ast_InitListExpr*)e;
      string_buffer_Buf_add1(out, '{');
      uint32_t num_values = ast_InitListExpr_getNumValues(ile);
      ast_Expr** values = ast_InitListExpr_getValues(ile);
      bool newlines = false;
      if (num_values > 6) newlines = true;
      if (num_values && ast_Expr_isInitList(values[0])) {
         newlines = true;
      }
      if (newlines) string_buffer_Buf_newline(out);
      else string_buffer_Buf_space(out);
      for (uint32_t i = 0; i < num_values; i++) {
         if (newlines) string_buffer_Buf_indent(out, 1);
         c_generator_Generator_emitExpr(gen, out, values[i]);
         if (i + 1 != num_values) string_buffer_Buf_add1(out, ',');
         if (newlines) string_buffer_Buf_newline(out);
         else string_buffer_Buf_space(out);
      }
      string_buffer_Buf_add1(out, '}');
      break;
   }
   case ast_ExprKind_FieldDesignatedInit:
      c_generator_Generator_emitFieldDesigExpr(gen, out, e);
      break;
   case ast_ExprKind_ArrayDesignatedInit:
      c_generator_Generator_emitArrayDesigExpr(gen, out, e);
      break;
   case ast_ExprKind_BinaryOperator:
      c_generator_Generator_emitBinaryOperator(gen, out, e, prec);
      break;
   case ast_ExprKind_UnaryOperator:
      c_generator_Generator_emitUnaryOperator(gen, out, e, prec);
      break;
   case ast_ExprKind_ConditionalOperator: {
      if (prec > c_prec_C_Prec_Conditional) string_buffer_Buf_lparen(out);
      ast_ConditionalOperator* c = (ast_ConditionalOperator*)e;
      c_generator_Generator_emitExpr2(gen, out, ast_ConditionalOperator_getCond(c), c_prec_C_Prec_LogicalOr);
      string_buffer_Buf_add(out, " ? ");
      c_generator_Generator_emitExpr2(gen, out, ast_ConditionalOperator_getLHS(c), c_prec_C_Prec_Comma);
      string_buffer_Buf_add(out, " : ");
      c_generator_Generator_emitExpr2(gen, out, ast_ConditionalOperator_getRHS(c), c_prec_C_Prec_Conditional);
      if (prec > c_prec_C_Prec_Conditional) string_buffer_Buf_rparen(out);
      break;
   }
   case ast_ExprKind_Builtin:
      c_generator_Generator_emitBuiltinExpr(gen, out, e);
      break;
   case ast_ExprKind_ArraySubscript: {
      ast_ArraySubscriptExpr* a = (ast_ArraySubscriptExpr*)e;
      ast_Expr* index = ast_ArraySubscriptExpr_getIndex(a);
      if (ast_Expr_isBitOffset(index)) {
         c_generator_Generator_emitBitOffset(gen, out, ast_ArraySubscriptExpr_getBase(a), index, prec);
      } else {
         c_generator_Generator_emitExpr2(gen, out, ast_ArraySubscriptExpr_getBase(a), c_prec_C_Prec_Postfix);
         string_buffer_Buf_add1(out, '[');
         c_generator_Generator_emitExpr2(gen, out, index, c_prec_C_Prec_Comma);
         string_buffer_Buf_add1(out, ']');
      }
      break;
   }
   case ast_ExprKind_Member: {
      c_generator_MemberContext mc = { };
      c_generator_Generator_emitMemberExpr(gen, out, (ast_MemberExpr*)e, &mc, false);
      break;
   }
   case ast_ExprKind_Paren: {
      ast_ParenExpr* p = (ast_ParenExpr*)e;
      string_buffer_Buf_lparen(out);
      c_generator_Generator_emitExpr2(gen, out, ast_ParenExpr_getInner(p), c_prec_C_Prec_Comma);
      string_buffer_Buf_rparen(out);
      break;
   }
   case ast_ExprKind_BitOffset:
      ;//assert(0);
      break;
   case ast_ExprKind_ExplicitCast: {
      ast_ExplicitCastExpr* c = (ast_ExplicitCastExpr*)e;
      if (prec > c_prec_C_Prec_Prefix) string_buffer_Buf_lparen(out);
      c_generator_Generator_emitCast(gen, out, ast_ExplicitCastExpr_getDestType(c), false);
      if (ast_ExplicitCastExpr_getCStyle(c)) {
         c_generator_Generator_emitExpr2(gen, out, ast_ExplicitCastExpr_getInner(c), c_prec_C_Prec_Prefix);
      } else {
         string_buffer_Buf_lparen(out);
         c_generator_Generator_emitExpr(gen, out, ast_ExplicitCastExpr_getInner(c));
         string_buffer_Buf_rparen(out);
      }
      if (prec > c_prec_C_Prec_Prefix) string_buffer_Buf_rparen(out);
      break;
   }
   case ast_ExprKind_ImplicitCast: {
      ast_ImplicitCastExpr* i = (ast_ImplicitCastExpr*)e;
      if (ast_ImplicitCastExpr_getKind(i) == ast_ImplicitCastKind_IntegralCast) {
         ast_QualType qt = ast_Expr_getType(e);
         if (ast_QualType_isFloat32(qt)) {
            if (prec > c_prec_C_Prec_Prefix) string_buffer_Buf_lparen(out);
            c_generator_Generator_emitCast(gen, out, qt, false);
            c_generator_Generator_emitExpr2(gen, out, ast_ImplicitCastExpr_getInner(i), c_prec_C_Prec_Prefix);
            if (prec > c_prec_C_Prec_Prefix) string_buffer_Buf_rparen(out);
            break;
         }
      }
      c_generator_Generator_emitExpr2(gen, out, ast_ImplicitCastExpr_getInner(i), prec);
      break;
   }
   case ast_ExprKind_Range: {
      if (prec > c_prec_C_Prec_Assignment) string_buffer_Buf_lparen(out);
      const ast_RangeExpr* b = (ast_RangeExpr*)e;
      c_generator_Generator_emitExpr(gen, out, ast_RangeExpr_getLHS(b));
      string_buffer_Buf_add(out, " ... ");
      c_generator_Generator_emitExpr(gen, out, ast_RangeExpr_getRHS(b));
      if (prec > c_prec_C_Prec_Assignment) string_buffer_Buf_rparen(out);
      return;
   }
   case ast_ExprKind_NamedArgument: {
      ast_NamedArgument* n = (ast_NamedArgument*)e;
      c_generator_Generator_emitExpr(gen, out, ast_NamedArgument_getInner(n));
      break;
   }
   case ast_ExprKind_Alternate: {
      const ast_AlternateExpr* n = (ast_AlternateExpr*)e;
      c_generator_Generator_emitExpr(gen, out, ast_AlternateExpr_getGenerated(n));
      break;
   }
   }
}

static void c_generator_Generator_emitBitOffset(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* base, ast_Expr* index, c_prec_C_Prec prec)
{
   ast_BitOffsetExpr* bo = (ast_BitOffsetExpr*)index;
   string_buffer_Buf_lparen(out);
   string_buffer_Buf_lparen(out);
   c_generator_Generator_emitExpr2(gen, out, base, c_prec_C_Prec_Shift);
   string_buffer_Buf_add(out, ">>");
   c_generator_Generator_emitExpr2(gen, out, ast_BitOffsetExpr_getRHS(bo), c_prec_C_Prec_Additive);
   string_buffer_Buf_rparen(out);
   string_buffer_Buf_add(out, " & ");
   uint64_t mask = 1;
   mask <<= ast_BitOffsetExpr_getWidth(bo);
   mask--;
   string_buffer_Buf_print(out, "0x%lx", mask);
   string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitCast(c_generator_Generator* gen, string_buffer_Buf* out, ast_QualType qt, bool full)
{
   string_buffer_Buf_add1(out, '(');
   c_generator_Generator_emitTypePre(gen, out, qt);
   if (full) c_generator_Generator_emitTypePost(gen, out, qt);
   string_buffer_Buf_add1(out, ')');
}

static void c_generator_Generator_emitBinaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec)
{
   ast_BinaryOperator* b = (ast_BinaryOperator*)e;
   ast_BinaryOpcode opcode = ast_BinaryOperator_getOpcode(b);
   c_prec_C_Prec prec2 = c_prec_C_Prec_table[opcode];
   bool need_paren = prec > prec2;
   if (need_paren) string_buffer_Buf_lparen(out);
   ast_Expr* lhs = ast_BinaryOperator_getLHS(b);
   c_generator_Generator_emitExpr2(gen, out, lhs, prec2);
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_BinaryOperator_getOpcodeStr(b));
   string_buffer_Buf_space(out);
   ast_Expr* rhs = ast_BinaryOperator_getRHS(b);
   if (opcode == ast_BinaryOpcode_Assign && ast_Expr_isInitList(rhs)) {
      c_generator_Generator_emitCast(gen, out, ast_Expr_getType(lhs), true);
   }
   if (prec2 > c_prec_C_Prec_Assignment) prec2++;
   c_generator_Generator_emitExpr2(gen, out, rhs, prec2);
   if (need_paren) string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitUnaryOperator(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e, c_prec_C_Prec prec)
{
   ast_UnaryOperator* u = (ast_UnaryOperator*)e;
   if (ast_UnaryOperator_isBefore(u)) {
      if (prec > c_prec_C_Prec_Prefix) string_buffer_Buf_lparen(out);
      string_buffer_Buf_add(out, ast_UnaryOperator_getOpcodeStr(u));
      c_generator_Generator_emitExpr2(gen, out, ast_UnaryOperator_getInner(u), c_prec_C_Prec_Prefix);
      if (prec > c_prec_C_Prec_Prefix) string_buffer_Buf_rparen(out);
   } else {
      c_generator_Generator_emitExpr2(gen, out, ast_UnaryOperator_getInner(u), c_prec_C_Prec_Postfix);
      string_buffer_Buf_add(out, ast_UnaryOperator_getOpcodeStr(u));
   }
}

static void c_generator_emitDotOrArrow(string_buffer_Buf* out, ast_QualType qt)
{
   if (ast_QualType_isPointer(qt)) string_buffer_Buf_add(out, "->");
   else string_buffer_Buf_add1(out, '.');
}

static void c_generator_Generator_emitMemberDecl(c_generator_Generator* gen, string_buffer_Buf* out, ast_Decl* d, c_generator_MemberContext* mc)
{
   switch (ast_Decl_getKind(d)) {
   case ast_DeclKind_Function:
      if (mc->need_dot) c_generator_emitDotOrArrow(out, mc->baseType);
      mc->baseType = ast_Decl_getType(d);
      c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
      break;
   case ast_DeclKind_Import:
      break;
   case ast_DeclKind_StructType: {
      if (mc->need_dot) c_generator_emitDotOrArrow(out, mc->baseType);
      ast_StructTypeDecl* std = (ast_StructTypeDecl*)d;
      if (!ast_StructTypeDecl_isGlobal(std)) {
         mc->baseType = ast_Decl_getType(d);
         string_buffer_Buf_add(out, ast_Decl_getName(d));
         mc->need_dot = true;
      }
      break;
   }
   case ast_DeclKind_EnumType:
      c_generator_Generator_genDeclIfNeeded(gen, d);
      break;
   case ast_DeclKind_EnumConstant:
      c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
      break;
   case ast_DeclKind_FunctionType:
      ;//assert(0);
      break;
   case ast_DeclKind_AliasType:
      c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
      break;
   case ast_DeclKind_Variable:
      if (mc->need_dot) c_generator_emitDotOrArrow(out, mc->baseType);
      mc->baseType = ast_Decl_getType(d);
      if (mc->is_local) {
         string_buffer_Buf_add(out, ast_Decl_getName(d));
      } else {
         c_generator_Generator_emitDeclName(gen, out, d);
      }
      mc->need_dot = true;
      mc->is_local = true;
      break;
   }
}

static void c_generator_Generator_emitMemberExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_MemberExpr* m, c_generator_MemberContext* mc, bool base_only)
{
   if (ast_MemberExpr_hasExpr(m)) {
      ast_Expr* base = ast_MemberExpr_getBaseExpr(m);
      if (ast_Expr_isMember(base)) {
         ast_MemberExpr* e = (ast_MemberExpr*)base;
         c_generator_Generator_emitMemberExpr(gen, out, e, mc, false);
      } else {
         c_generator_Generator_emitExpr2(gen, out, base, c_prec_C_Prec_Postfix);
         mc->baseType = ast_Expr_getType(base);
         mc->need_dot = true;
      }
   } else {
      c_generator_Generator_emitMemberDecl(gen, out, ast_MemberExpr_getDecl(m, 0), mc);
   }
   if (!base_only) c_generator_Generator_emitMemberDecl(gen, out, ast_MemberExpr_getDecl(m, 1), mc);
}

static void c_generator_Generator_emitFieldDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_FieldDesignatedInitExpr* fdi = (ast_FieldDesignatedInitExpr*)e;
   string_buffer_Buf_add1(out, '.');
   string_buffer_Buf_add(out, ast_FieldDesignatedInitExpr_getFieldName(fdi));
   string_buffer_Buf_add(out, " = ");
   c_generator_Generator_emitExpr(gen, out, ast_FieldDesignatedInitExpr_getInit(fdi));
}

static void c_generator_Generator_emitArrayDesigExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_ArrayDesignatedInitExpr* ad = (ast_ArrayDesignatedInitExpr*)e;
   string_buffer_Buf_add1(out, '[');
   c_generator_Generator_emitExpr(gen, out, ast_ArrayDesignatedInitExpr_getDesignator(ad));
   string_buffer_Buf_add(out, "] = ");
   c_generator_Generator_emitExpr(gen, out, ast_ArrayDesignatedInitExpr_getInit(ad));
}

static void c_generator_Generator_emitBuiltinExpr(c_generator_Generator* gen, string_buffer_Buf* out, ast_Expr* e)
{
   ast_BuiltinExpr* b = (ast_BuiltinExpr*)e;
   switch (ast_BuiltinExpr_getKind(b)) {
   case ast_BuiltinExprKind_Sizeof: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_Elemsof: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_EnumMin: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_EnumMax: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_OffsetOf: {
      ast_Value v = ast_BuiltinExpr_getValue(b);
      string_buffer_Buf_print(out, "%s", ast_Value_str(&v));
      break;
   }
   case ast_BuiltinExprKind_ToContainer:
      string_buffer_Buf_add(out, "to_container(");
      c_generator_Generator_emitExpr(gen, out, ast_BuiltinExpr_getInner(b));
      string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitExpr(gen, out, ast_BuiltinExpr_getToContainerMember(b));
      string_buffer_Buf_add(out, ", ");
      c_generator_Generator_emitExpr(gen, out, ast_BuiltinExpr_getToContainerPointer(b));
      string_buffer_Buf_rparen(out);
      break;
   }
}

static void c_generator_Generator_createMakefile(c_generator_Generator* gen, const char* output_dir, component_List* comps, string_list_List* asm_files, bool enable_asserts, uint32_t libc_name)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, "# This makefile is auto-generated, any modifications will be lost\n\n");
   const char* cc = "gcc";
   const char* cflags = NULL;
   const char* ldflags = "";
   const char* ldflags2 = "";
   const char* asmflags = "";
   if (gen->targetInfo->sys == target_info_System_FreeBSD || gen->targetInfo->sys == target_info_System_OpenBSD) {
      cc = "clang";
   }
   if (gen->build_info) {
      const build_file_Info* info = gen->build_info;
      if (build_file_Info_getCC(info)) cc = build_file_Info_getCC(info);
      if (build_file_Info_getCFlags(info)) cflags = build_file_Info_getCFlags(info);
      if (build_file_Info_getLinkerFlags(info)) ldflags = build_file_Info_getLinkerFlags(info);
      if (build_file_Info_getLdFlags2(info)) ldflags2 = build_file_Info_getLdFlags2(info);
      if (build_file_Info_getAsmFlags(info)) asmflags = build_file_Info_getAsmFlags(info);
   }
   string_buffer_Buf_print(out, "CC=%s\n", cc);
   string_buffer_Buf_add(out, "CFLAGS=-Wall -Wextra -Wno-unused -Wno-switch\n");
   string_buffer_Buf_add(out, "CFLAGS+=-Wno-unused-parameter -Wno-missing-field-initializers -Wno-format-zero-length\n");
   string_buffer_Buf_add(out, "CFLAGS+=-pipe -std=c99 -funsigned-char\n");
   if (gen->fast_build) string_buffer_Buf_add(out, "CFLAGS+=-O0 -g\n");
   else string_buffer_Buf_add(out, "CFLAGS+=-O2 -g\n");
   if (!enable_asserts) string_buffer_Buf_add(out, "CFLAGS+=-DNDEBUG\n");
   if (cflags) string_buffer_Buf_print(out, "CFLAGS+=%s\n", cflags);
   string_buffer_Buf_newline(out);
   string_buffer_Buf_print(out, "ASMFLAGS=%s\n", asmflags ? asmflags : "");
   string_buffer_Buf_print(out, "LDFLAGS=%s\n", ldflags ? ldflags : "");
   string_buffer_Buf_print(out, "LDFLAGS2=%s\n", ldflags2 ? ldflags2 : "");
   string_buffer_Buf_newline(out);
   if (gen->asan) {
      string_buffer_Buf_add(out, "CFLAGS+=-fsanitize=address -D__ASAN__ -O0\n");
      string_buffer_Buf_add(out, "LDFLAGS+=-fsanitize=address\n");
   }
   if (gen->msan) {
      string_buffer_Buf_add(out, "CFLAGS+=-fsanitize=memory -D__MSAN__ -O0\n");
      string_buffer_Buf_add(out, "LDFLAGS+=-fsanitize=memory\n");
   }
   if (gen->ubsan) {
      string_buffer_Buf_add(out, "CFLAGS+=-fsanitize=undefined -D__UBSAN__ -O0\n");
      string_buffer_Buf_add(out, "LDFLAGS+=-fsanitize=undefined\n");
   }
   char target_name[512];
   if (gen->fast_build) {
      string_buffer_Buf_add(out, "objects := ");
      for (uint32_t i = 0; i != component_List_size(comps); i++) {
         component_Component* c = component_List_get(comps, i);
         if (component_Component_isExternalLibrary(c)) continue;
         module_list_List* mods = component_Component_getModules(c);
         for (uint32_t j = 0; j < module_list_List_length(mods); j++) {
            ast_Module* m = module_list_List_at(mods, j);
            if (ast_Module_isUsed(m)) string_buffer_Buf_print(out, " %s.o", ast_Module_getName(m));
         }
      }
      if (gen->trace_calls) {
         string_buffer_Buf_add(out, " c2_trace_tables.o");
      }
      string_buffer_Buf_newline(out);
   } else {
      string_buffer_Buf_add(out, "objects := build.o\n");
   }
   string_buffer_Buf_add(out, "headers := $(wildcard *.h)\n\n");
   string_buffer_Buf_add(out, "%.o: %.c\n");
   string_buffer_Buf_add(out, "\t\t$(CC) $(CFLAGS) -o $@ -c $<\n\n");
   switch (gen->target_kind) {
   case build_target_Kind_Image:
   case build_target_Kind_Executable: {
      strcpy(target_name, gen->target);
      string_buffer_Buf_print(out, "all: ../%s\n\n", target_name);
      string_buffer_Buf_print(out, "../%s: $(objects) $(headers)\n", target_name);
      for (uint32_t i = 0; i < string_list_List_length(asm_files); i++) {
         const char* filename = string_list_List_get(asm_files, i);
         string_buffer_Buf_print(out, "\t\t$(CC) $(ASMFLAGS) -o %s.o -c ../../../%s\n", filename, filename);
      }
      string_buffer_Buf_print(out, "\t\t$(CC) $(LDFLAGS) -o ../%s $(objects)", target_name);
      for (uint32_t i = 0; i < string_list_List_length(asm_files); i++) {
         const char* filename = string_list_List_get(asm_files, i);
         string_buffer_Buf_print(out, " %s.o", filename);
      }
      const char* triplet = target_info_Info_str(gen->targetInfo);
      for (uint32_t i = component_List_size(comps); i != 0; i--) {
         component_Component* c = component_List_get(comps, i - 1);
         if (!component_Component_isExternal(c)) continue;
         const char* linkname = component_Component_getLinkName(c);
         if (gen->targetInfo->sys == target_info_System_FreeBSD || gen->targetInfo->sys == target_info_System_OpenBSD) {
            if (linkname && !strcmp(linkname, "dl")) continue;
         }
         if (component_Component_getKind(c) == component_Kind_ExternalStaticLib) {
            if (component_Component_getNameIdx(c) == libc_name) {
               string_buffer_Buf_add(out, " --static");
            } else {
               if (component_Component_isForeign(c)) {
                  string_buffer_Buf_print(out, " /lib/%s/", triplet);
                  if (linkname) {
                     string_buffer_Buf_print(out, "lib%s.a", linkname);
                  } else {
                     string_buffer_Buf_print(out, "lib%s.a", component_Component_getName(c));
                  }
               } else {
                  string_buffer_Buf_print(out, " %s/lib%s.a", component_Component_getPath(c), component_Component_getName(c));
               }
            }
         } else if (component_Component_getKind(c) == component_Kind_ExternalDynamicLib) {
            if (component_Component_getNameIdx(c) == libc_name) continue;
            if (!component_Component_isForeign(c)) {
               string_buffer_Buf_print(out, " -L%s", component_Component_getPath(c));
            }
            if (linkname) string_buffer_Buf_print(out, " -l%s", linkname);
         }
      }
      string_buffer_Buf_add(out, " $(LDFLAGS2)\n");
      string_buffer_Buf_newline(out);
      break;
   }
   case build_target_Kind_StaticLibrary:
      sprintf(target_name, "lib%s.a", gen->target);
      string_buffer_Buf_print(out, "all: ../%s\n\n", target_name);
      string_buffer_Buf_print(out, "../%s: $(objects) $(headers)\n", target_name);
      string_buffer_Buf_print(out, "\t\tar rcs ../%s $(objects)\n", target_name);
      break;
   case build_target_Kind_DynamicLibrary:
      string_buffer_Buf_add(out, "CFLAGS+=-fPIC\n");
      if (gen->targetInfo->sys == target_info_System_Darwin) {
         sprintf(target_name, "lib%s.dylib", gen->target);
      } else {
         sprintf(target_name, "lib%s.so", gen->target);
      }
      string_buffer_Buf_print(out, "all: ../%s\n\n", target_name);
      string_buffer_Buf_print(out, "../%s: $(objects) $(headers)\n", target_name);
      if (gen->targetInfo->sys == target_info_System_Darwin) {
         string_buffer_Buf_print(out, "\t\t$(CC) $(LDFLAGS) $(objects) -shared -o $$(dirname $$(pwd))/%s $(LDFLAGS2)\n", target_name);
      } else {
         string_buffer_Buf_print(out, "\t\t$(CC) $(LDFLAGS) $(objects) -shared -o ../%s -Wl,-soname,%s.1 -Wl,--version-script=exports.version $(LDFLAGS2)\n", target_name, target_name);
      }
      break;
   case build_target_Kind_SourceLibrary:
      break;
   }
   string_buffer_Buf_newline(out);
   string_buffer_Buf_add(out, "symbols:\n");
   string_buffer_Buf_add(out, "\t\tnm -g");
   if (build_target_has_dynamic(gen->target_kind)) string_buffer_Buf_add(out, " -D");
   string_buffer_Buf_print(out, " -C --defined-only ../%s\n\n", target_name);
   string_buffer_Buf_add(out, "clean:\n");
   string_buffer_Buf_print(out, "\t\trm -f *.o *.a ../%s\n\n", target_name);
   c_generator_Generator_write(gen, output_dir, "Makefile", gen->out);
}

static void c_generator_Generator_createExportsFile(c_generator_Generator* gen, const char* output_dir, component_Component* mainComp)
{
   if (gen->target_kind != build_target_Kind_DynamicLibrary) return;
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, "LIB_1.0 {\n");
   string_buffer_Buf_add(out, "\tglobal:\n");
   module_list_List* mods = component_Component_getModules(mainComp);
   uint32_t count = module_list_List_length(mods);
   for (uint32_t i = 0; i < count; i++) {
      const ast_SymbolTable* symbols = ast_Module_getSymbols(module_list_List_at(mods, i));
      ast_Decl** decls = ast_SymbolTable_getDecls(symbols);
      uint32_t num_symbols = ast_SymbolTable_size(symbols);
      for (uint32_t j = 0; j < num_symbols; j++) {
         ast_Decl* d = decls[j];
         if (!ast_Decl_isExported(d)) continue;
         if (!ast_Decl_isFunction(d) && !ast_Decl_isVariable(d)) continue;
         string_buffer_Buf_add(out, "\t\t");
         c_generator_Generator_emitCNameMod(gen, out, d, ast_Decl_getModule(d));
         string_buffer_Buf_add(out, ";\n");
      }
   }
   string_buffer_Buf_add(out, "\tlocal:\n\t\t*;\n");
   string_buffer_Buf_add(out, "};\n");
   c_generator_Generator_write(gen, output_dir, "exports.version", gen->out);
}

static void c_generator_Generator_generateC2TypesHeader(c_generator_Generator* gen)
{
   string_buffer_Buf* out = gen->header;
   string_buffer_Buf_clear(out);
   string_buffer_Buf_add(out, c_generator_C2_types_header);
   file_utils_File file; file_utils_File_init(&file, gen->results_dir, "c2types.h");
   if (!file_utils_File_write(&file, string_buffer_Buf_data(out), string_buffer_Buf_size(out))) {
      console_error("cannot write to %s: %s", file.path, file_utils_File_getError(&file));
   }
   string_buffer_Buf_clear(out);
}

static void c_generator_Generator_emitVarDecl(c_generator_Generator* gen, ast_VarDecl* vd, string_buffer_Buf* out, bool emit_init, bool first)
{
   ast_Decl* d = (ast_Decl*)vd;
   if (first) {
      if (ast_VarDecl_hasLocalQualifier(vd)) string_buffer_Buf_add(out, "static ");
      c_generator_Generator_emitTypePre(gen, out, ast_Decl_getType(d));
   } else {
      string_buffer_Buf_add1(out, ',');
   }
   string_buffer_Buf_space(out);
   string_buffer_Buf_add(out, ast_Decl_getName(d));
   c_generator_Generator_emitTypePost(gen, out, ast_Decl_getType(d));
   ast_Decl_setGenerated(d);
   ast_Expr* ie = ast_VarDecl_getInit(vd);
   if (ie && emit_init) {
      if (ast_VarDecl_hasInitCall(vd)) {
         ;//assert(first);
         string_buffer_Buf_add(out, "; ");
      } else {
         string_buffer_Buf_add(out, " = ");
      }
      c_generator_Generator_emitExpr(gen, out, ie);
   }
}

static void c_generator_Generator_emitStmt(c_generator_Generator* gen, ast_Stmt* s, uint32_t indent, bool newline)
{
   string_buffer_Buf* out = gen->out;
   if (newline) string_buffer_Buf_indent(out, indent);
   switch (ast_Stmt_getKind(s)) {
   case ast_StmtKind_Return: {
      string_buffer_Buf_add(out, "return");
      ast_ReturnStmt* r = (ast_ReturnStmt*)s;
      ast_Expr* val = ast_ReturnStmt_getValue(r);
      if (val) {
         string_buffer_Buf_space(out);
         if (ast_Expr_isInitList(val)) {
            c_generator_Generator_emitCast(gen, out, ast_FunctionDecl_getRType(gen->cur_function), true);
         }
         c_generator_Generator_emitExpr2(gen, out, val, c_prec_C_Prec_Comma);
      }
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Expr:
      c_generator_Generator_emitExpr(gen, out, (ast_Expr*)s);
      if (newline) string_buffer_Buf_add(out, ";\n");
      break;
   case ast_StmtKind_If: {
      ast_IfStmt* i = (ast_IfStmt*)s;
      ast_Stmt* cond = ast_IfStmt_getCond(i);
      bool is_decl = ast_Stmt_isDecl(cond);
      if (is_decl) {
         string_buffer_Buf_add(out, "{\n");
         indent++;
         c_generator_Generator_emitStmt(gen, cond, indent, true);
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "if (");
         ast_DeclStmt* ds = (ast_DeclStmt*)cond;
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, 0);
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
      } else {
         ;//assert(ast_Stmt_isExpr(cond));
         string_buffer_Buf_add(out, "if (");
         c_generator_Generator_emitExpr(gen, out, (ast_Expr*)cond);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* thenStmt = ast_IfStmt_getThen(i);
      c_generator_Generator_emitStmt(gen, thenStmt, indent, false);
      if (!ast_Stmt_isCompound(thenStmt)) {
         if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
      }
      ast_Stmt* elseStmt = ast_IfStmt_getElse(i);
      if (elseStmt) {
         if (ast_Stmt_isCompound(thenStmt)) {
            string_buffer_Buf_space(out);
         } else {
            if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_newline(out);
            string_buffer_Buf_indent(out, indent);
         }
         string_buffer_Buf_add(out, "else ");
         c_generator_Generator_emitStmt(gen, elseStmt, indent, false);
         if (!ast_Stmt_isCompound(elseStmt)) {
            if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
         }
      }
      if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_newline(out);
      if (is_decl) {
         indent--;
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "}\n");
      }
      break;
   }
   case ast_StmtKind_While: {
      ast_WhileStmt* w = (ast_WhileStmt*)s;
      ast_Stmt* cond = ast_WhileStmt_getCond(w);
      bool is_decl = ast_Stmt_isDecl(cond);
      if (is_decl) {
         string_buffer_Buf_add(out, "{\n");
         indent++;
         ast_DeclStmt* ds = (ast_DeclStmt*)cond;
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, 0);
         string_buffer_Buf_indent(out, indent);
         c_generator_Generator_emitVarDecl(gen, vd, out, false, true);
         string_buffer_Buf_add(out, ";\n");
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "while ((");
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
         string_buffer_Buf_add(out, " = ");
         ast_Expr* ie = ast_VarDecl_getInit(vd);
         ;//assert(ie);
         c_generator_Generator_emitExpr(gen, out, ie);
         string_buffer_Buf_add(out, ")) ");
      } else {
         ;//assert(ast_Stmt_isExpr(cond));
         string_buffer_Buf_add(out, "while (");
         c_generator_Generator_emitExpr(gen, out, (ast_Expr*)cond);
         string_buffer_Buf_add(out, ") ");
      }
      ast_Stmt* body = ast_WhileStmt_getBody(w);
      c_generator_Generator_emitStmt(gen, body, indent, false);
      if (!ast_Stmt_isCompound(body)) {
         if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      if (is_decl) {
         indent--;
         string_buffer_Buf_indent(out, indent);
         string_buffer_Buf_add(out, "}\n");
      }
      break;
   }
   case ast_StmtKind_For: {
      ast_ForStmt* f = (ast_ForStmt*)s;
      string_buffer_Buf_add(out, "for (");
      ast_Stmt* initStmt = ast_ForStmt_getInit(f);
      if (initStmt) {
         c_generator_Generator_emitStmt(gen, initStmt, 0, false);
      }
      string_buffer_Buf_add1(out, ';');
      if (ast_ForStmt_getCond(f)) {
         string_buffer_Buf_space(out);
         c_generator_Generator_emitExpr(gen, out, ast_ForStmt_getCond(f));
      }
      string_buffer_Buf_add1(out, ';');
      ast_Expr* cont = ast_ForStmt_getCont(f);
      if (cont) {
         string_buffer_Buf_space(out);
         c_generator_Generator_emitExpr(gen, out, cont);
      }
      string_buffer_Buf_add(out, ") ");
      ast_Stmt* body = ast_ForStmt_getBody(f);
      c_generator_Generator_emitStmt(gen, body, indent, false);
      if (!ast_Stmt_isCompound(body)) {
         if (!string_buffer_Buf_endsWith(out, '\n')) string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_Switch:
      c_generator_Generator_emitSwitchStmt(gen, (ast_SwitchStmt*)s, indent);
      break;
   case ast_StmtKind_Break:
      string_buffer_Buf_add(out, "break;\n");
      break;
   case ast_StmtKind_Continue:
      string_buffer_Buf_add(out, "continue;\n");
      break;
   case ast_StmtKind_Fallthrough:
      string_buffer_Buf_add(out, "fallthrough;\n");
      break;
   case ast_StmtKind_Label: {
      string_buffer_Buf_unindent(out);
      ast_LabelStmt* ls = (ast_LabelStmt*)s;
      ast_Stmt* stmt = ast_LabelStmt_getStmt(ls);
      string_buffer_Buf_add(out, ast_LabelStmt_getName(ls));
      string_buffer_Buf_add1(out, ':');
      if (!stmt || ast_Stmt_isDecl(stmt)) {
         string_buffer_Buf_add1(out, ';');
      }
      string_buffer_Buf_newline(out);
      if (stmt) {
         c_generator_Generator_emitStmt(gen, stmt, indent, true);
      }
      break;
   }
   case ast_StmtKind_Goto: {
      ast_GotoStmt* g = (ast_GotoStmt*)s;
      string_buffer_Buf_add(out, "goto ");
      string_buffer_Buf_add(out, ast_GotoStmt_getName(g));
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Compound: {
      ast_CompoundStmt* c = (ast_CompoundStmt*)s;
      string_buffer_Buf_add(out, "{\n");
      uint32_t count = ast_CompoundStmt_getCount(c);
      ast_Stmt** stmts = ast_CompoundStmt_getStmts(c);
      for (uint32_t i = 0; i < count; i++) {
         c_generator_Generator_emitStmt(gen, stmts[i], indent + 1, true);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add1(out, '}');
      if (newline) string_buffer_Buf_newline(out);
      break;
   }
   case ast_StmtKind_Decl: {
      ast_DeclStmt* ds = (ast_DeclStmt*)s;
      uint32_t count = ast_DeclStmt_getDeclCount(ds);
      bool first = true;
      for (uint32_t i = 0; i < count; i++) {
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, i);
         c_generator_Generator_emitVarDecl(gen, vd, out, true, first);
         first = false;
      }
      if (newline) string_buffer_Buf_add(out, ";\n");
      break;
   }
   case ast_StmtKind_Asm:
      c_generator_Generator_emitAsmStmt(gen, (ast_AsmStmt*)s, indent);
      break;
   case ast_StmtKind_Assert: {
      if (!gen->enable_asserts) string_buffer_Buf_print(out, ";//assert");
      ast_AssertStmt* a = (ast_AssertStmt*)s;
      string_buffer_Buf_add1(out, '(');
      ast_Expr* inner = ast_AssertStmt_getInner(a);
      c_generator_Generator_emitExpr(gen, out, inner);
      string_buffer_Buf_add1(out, ')');
      if (gen->enable_asserts) {
         source_mgr_Location loc = source_mgr_SourceMgr_locate(gen->sm, ast_Stmt_getLoc(s));
         const char* funcname = ast_Decl_getFullName(ast_FunctionDecl_asDecl(gen->cur_function));
         string_buffer_Buf_print(out, " || c2_assert(\"%s\", %u, \"%s\", \"", loc.filename, loc.line, funcname);
         string_buffer_Buf* str = string_buffer_create(128, false, 0);
         ast_Expr_printLiteral(inner, str);
         string_buffer_Buf_encodeBytes(out, string_buffer_Buf_data(str), string_buffer_Buf_size(str), '"');
         string_buffer_Buf_free(str);
         string_buffer_Buf_add(out, "\")");
      }
      string_buffer_Buf_add(out, ";\n");
      break;
   }
   }
}

static void c_generator_emitAsmPart(string_buffer_Buf* out, bool multi_line, uint32_t indent)
{
   if (multi_line) {
      string_buffer_Buf_newline(out);
      string_buffer_Buf_indent(out, indent);
   } else {
      string_buffer_Buf_space(out);
   }
   string_buffer_Buf_add(out, ": ");
}

static void c_generator_Generator_emitAsmOperand(c_generator_Generator* gen, uint32_t name, const ast_Expr* c, ast_Expr* e)
{
   string_buffer_Buf* out = gen->out;
   if (name) {
      string_buffer_Buf_print(out, "[%s] ", ast_idx2name(name));
   }
   const ast_StringLiteral* cs = (ast_StringLiteral*)c;
   ast_StringLiteral_printLiteral(cs, out);
   string_buffer_Buf_add(out, " (");
   c_generator_Generator_emitExpr(gen, out, e);
   string_buffer_Buf_rparen(out);
}

static void c_generator_Generator_emitAsmStmt(c_generator_Generator* gen, ast_AsmStmt* a, uint32_t indent)
{
   string_buffer_Buf* out = gen->out;
   string_buffer_Buf_add(out, "__asm__ ");
   if (ast_AsmStmt_isVolatile(a)) string_buffer_Buf_add(out, "volatile ");
   string_buffer_Buf_lparen(out);
   ast_StringLiteral* str = ast_AsmStmt_getString(a);
   ast_StringLiteral_printLiteral(str, out);
   uint32_t num_outputs = ast_AsmStmt_getNumOutputs(a);
   uint32_t num_inputs = ast_AsmStmt_getNumInputs(a);
   uint32_t num_clobbers = ast_AsmStmt_getNumClobbers(a);
   bool multi_line = false;
   if ((num_outputs + num_inputs + num_clobbers) > 4 || num_clobbers != 0) multi_line = true;
   if (num_outputs + num_inputs + num_clobbers) {
      uint32_t* names = ast_AsmStmt_getNames(a);
      const ast_Expr** constraints = ast_AsmStmt_getConstraints(a);
      ast_Expr** exprs = ast_AsmStmt_getExprs(a);
      c_generator_emitAsmPart(out, multi_line, indent);
      for (uint32_t i = 0; i < num_outputs; i++) {
         if (i != 0) string_buffer_Buf_add(out, ", ");
         c_generator_Generator_emitAsmOperand(gen, names[i], constraints[i], exprs[i]);
      }
      if (num_inputs | num_clobbers) {
         c_generator_emitAsmPart(out, multi_line, indent);
         for (uint32_t i = 0; i < num_inputs; i++) {
            if (i != 0) string_buffer_Buf_add(out, ", ");
            uint32_t idx = i + num_outputs;
            c_generator_Generator_emitAsmOperand(gen, names[idx], constraints[idx], exprs[idx]);
         }
      }
      if (num_clobbers) {
         ast_Expr** clobbers = ast_AsmStmt_getClobbers(a);
         c_generator_emitAsmPart(out, multi_line, indent);
         for (uint32_t i = 0; i < num_clobbers; i++) {
            if (i != 0) string_buffer_Buf_add(out, ", ");
            ast_StringLiteral* l = (ast_StringLiteral*)clobbers[i];
            ast_StringLiteral_printLiteral(l, out);
         }
      }
   }
   string_buffer_Buf_rparen(out);
   string_buffer_Buf_add(out, ";\n");
}

static void c_generator_Generator_emitSwitchStmt(c_generator_Generator* gen, ast_SwitchStmt* sw, uint32_t indent)
{
   string_buffer_Buf* out = gen->out;
   const uint32_t num_cases = ast_SwitchStmt_getNumCases(sw);
   ast_SwitchCase** cases = ast_SwitchStmt_getCases(sw);
   ast_Stmt* cond = ast_SwitchStmt_getCond(sw);
   bool is_decl = ast_Stmt_isDecl(cond);
   if (is_decl) {
      string_buffer_Buf_add(out, "{\n");
      indent++;
      c_generator_Generator_emitStmt(gen, cond, indent, true);
      string_buffer_Buf_indent(out, indent);
   }
   if (ast_SwitchStmt_isString(sw)) {
      string_buffer_Buf_add(out, "switch (c2_strswitch(");
      if (is_decl) {
         ast_DeclStmt* ds = (ast_DeclStmt*)cond;
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, 0);
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
      } else {
         ;//assert(ast_Stmt_isExpr(cond));
         c_generator_Generator_emitExpr(gen, out, (ast_Expr*)cond);
      }
      string_buffer_Buf_add1(out, ',');
      bool has_s2 = false;
      for (uint32_t i = 0; i < num_cases; i++) {
         ast_SwitchCase* c = cases[i];
         if (ast_SwitchCase_isDefault(c)) continue;
         ast_Expr* e = ast_SwitchCase_getCond(c, 0);
         if (ast_Expr_isImplicitCast(e)) {
            const ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)e;
            e = ast_ImplicitCastExpr_getInner(ic);
         }
         if (ast_Expr_isNil(e)) continue;
         if (ast_Expr_isStringLiteral(e)) {
            ast_StringLiteral* lit = (ast_StringLiteral*)e;
            const char* str = ast_StringLiteral_getText(lit);
            uint32_t slen = (ast_StringLiteral_getSize(lit) - 1) & 0xff;
            if (slen) {
               string_buffer_Buf_print(out, " \"\\%03o", slen);
               string_buffer_Buf_encodeBytes(out, str, slen, '"');
               string_buffer_Buf_add1(out, '"');
               has_s2 = true;
            }
         } else {
            ast_Expr_dump(e);
            ;//assert(0);
         }
      }
      if (!has_s2) string_buffer_Buf_add(out, " \"\"");
      string_buffer_Buf_add(out, ")) {\n");
      uint32_t lab = 2;
      for (uint32_t i = 0; i < num_cases; i++) {
         c_generator_Generator_emitCase(gen, cases[i], indent, &lab);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   } else {
      string_buffer_Buf_add(out, "switch (");
      if (is_decl) {
         ast_DeclStmt* ds = (ast_DeclStmt*)cond;
         ast_VarDecl* vd = ast_DeclStmt_getDecl(ds, 0);
         string_buffer_Buf_add(out, ast_Decl_getName(ast_VarDecl_asDecl(vd)));
      } else {
         ;//assert(ast_Stmt_isExpr(cond));
         c_generator_Generator_emitExpr(gen, out, (ast_Expr*)cond);
      }
      string_buffer_Buf_add(out, ") {\n");
      for (uint32_t i = 0; i < num_cases; i++) {
         c_generator_Generator_emitCase(gen, cases[i], indent, NULL);
      }
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   }
   if (is_decl) {
      indent--;
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   }
}

static void c_generator_Generator_emitCase(c_generator_Generator* gen, ast_SwitchCase* c, uint32_t indent, uint32_t* lab)
{
   string_buffer_Buf* out = gen->out;
   const char* brace = ast_SwitchCase_hasDecls(c) ? " {" : "";
   string_buffer_Buf_indent(out, indent);
   if (ast_SwitchCase_isDefault(c)) {
      string_buffer_Buf_print(out, "default:%s\n", brace);
   } else {
      string_buffer_Buf_add(out, "case ");
      if (lab) {
         ast_Expr* e = ast_SwitchCase_getCond(c, 0);
         if (ast_Expr_isImplicitCast(e)) {
            const ast_ImplicitCastExpr* ic = (ast_ImplicitCastExpr*)e;
            e = ast_ImplicitCastExpr_getInner(ic);
         }
         if (ast_Expr_isNil(e)) {
            string_buffer_Buf_print(out, "0:%s // nil\n", brace);
         } else if (ast_Expr_isStringLiteral(e)) {
            ast_StringLiteral* lit = (ast_StringLiteral*)e;
            const char* str = ast_StringLiteral_getText(lit);
            uint32_t slen = (ast_StringLiteral_getSize(lit) - 1) & 0xff;
            uint32_t num = 1;
            if (slen) {
               num = *lab;
               *lab += 1;
            }
            string_buffer_Buf_print(out, "%u:%s // \"", num, brace);
            string_buffer_Buf_encodeBytes(out, str, slen, '"');
            string_buffer_Buf_add(out, "\"\n");
         } else {
            ast_Expr_dump(e);
            ;//assert(0);
         }
      } else {
         uint32_t num_conds = ast_SwitchCase_getNumConds(c);
         for (uint32_t i = 0; i < num_conds; i++) {
            if (i) {
               string_buffer_Buf_add(out, ":\n");
               string_buffer_Buf_indent(out, indent);
               string_buffer_Buf_add(out, "case ");
            }
            c_generator_Generator_emitExpr(gen, out, ast_SwitchCase_getCond(c, i));
         }
         string_buffer_Buf_print(out, ":%s\n", brace);
      }
   }
   const uint32_t num_stmts = ast_SwitchCase_getNumStmts(c);
   if (num_stmts == 0) {
   } else {
      ast_Stmt** stmts = ast_SwitchCase_getStmts(c);
      for (uint32_t i = 0; i < num_stmts; i++) {
         c_generator_Generator_emitStmt(gen, stmts[i], indent + 1, true);
      }
   }
   if (ast_SwitchCase_hasDecls(c)) {
      string_buffer_Buf_indent(out, indent);
      string_buffer_Buf_add(out, "}\n");
   }
}

static uint32_t c_generator_TraceCallList_add(c_generator_TraceCallList* cl, c_generator_TraceCall call)
{
   if (cl->count >= cl->capacity) {
      cl->capacity += cl->capacity / 2 + 16;
      c_generator_TraceCall* array2 = malloc(cl->capacity * 8);
      if (cl->array) {
         memcpy(array2, cl->array, cl->count * 8);
         free(cl->array);
      }
      cl->array = array2;
   }
   uint32_t index = cl->count++;
   cl->array[index] = call;
   return index;
}

static void c_generator_TraceCallList_free(c_generator_TraceCallList* cl)
{
   if (cl->array) {
      free(cl->array);
      cl->array = NULL;
      cl->count = 0;
      cl->capacity = 0;
   }
}

static void c_generator_StringList_free(c_generator_StringList* sl)
{
   if (sl->strings) {
      for (uint32_t i = 0; i < sl->string_count; i++) {
         free(sl->strings[i]);
      }
      free(sl->strings);
      free(sl->hash_array);
      memset(sl, 0, 48);
   }
}

static uint32_t c_generator_StringList_length(c_generator_StringList* sl)
{
   return sl->string_count;
}

static const char* c_generator_StringList_get(const c_generator_StringList* sl, uint32_t i)
{
   return sl->strings[i];
}

static uint32_t c_generator_StringList_add(c_generator_StringList* sl, const char* s, bool check_last)
{
   if (check_last && s == sl->last_string) return sl->last_index;
   sl->last_string = s;
   uint32_t hash = c_generator_HASH_INITIAL;
   for (uint32_t i = 0; s[i]; i++) {
      hash ^= s[i];
      hash *= c_generator_HASH_PRIME;
   }
   uint32_t bucket = hash % c_generator_HASH_BUCKETS;
   if (sl->hash_array) {
      for (uint32_t i = bucket;; i--) {
         uint32_t ii = sl->hash_array[i];
         uint32_t n = (uint16_t)ii;
         if (!strcmp(sl->strings[n], s)) return sl->last_index = n;
         i = ii >> 16;
         if (i == 0) break;
      }
   }
   if (!sl->hash_capacity) {
      sl->hash_capacity = c_generator_HASH_BUCKETS + 32;
      sl->hash_count = c_generator_HASH_BUCKETS;
      sl->hash_array = calloc(sl->hash_capacity * 4, 1);
   }
   uint32_t slot = sl->string_count;
   if (sl->hash_array[bucket]) {
      if (sl->hash_count >= sl->hash_capacity) {
         sl->hash_capacity += sl->hash_capacity / 2;
         uint32_t* hash_array2 = malloc(sl->hash_capacity * 4);
         memcpy(hash_array2, sl->hash_array, sl->hash_count * 4);
         free(sl->hash_array);
         sl->hash_array = hash_array2;
      }
      uint32_t next = sl->hash_count++;
      sl->hash_array[next] = sl->hash_array[bucket];
      slot |= (next + 1) << 16;
   }
   sl->hash_array[bucket] = slot;
   if (sl->string_count >= sl->string_capacity) {
      sl->string_capacity += sl->string_capacity / 2 + 16;
      char** strings2 = malloc(sl->string_capacity * 8);
      if (sl->strings) {
         memcpy(strings2, sl->strings, sl->string_count * 8);
         free(sl->strings);
      }
      sl->strings = strings2;
   }
   uint32_t index = sl->string_count++;
   sl->strings[index] = strdup(s);
   return sl->last_index = index;
}

static uint32_t c_generator_Generator_addCall(c_generator_Generator* gen, const char* funcname, src_loc_SrcLoc loc)
{
   source_mgr_Location location = source_mgr_SourceMgr_locate(gen->sm, loc);
   c_generator_TraceCall call = { .filename_idx = (uint8_t)c_generator_StringList_add(&gen->filenames, location.filename, true), .column = (uint8_t)location.column, .line = (uint16_t)location.line, .callee_idx = (uint16_t)c_generator_StringList_add(&gen->funcnames, funcname, false), .caller_idx = (uint16_t)(gen->cur_function ? c_generator_StringList_add(&gen->funcnames, ast_Decl_getFullName(ast_FunctionDecl_asDecl(gen->cur_function)), false) : 0) };
   return c_generator_TraceCallList_add(&gen->calls, call);
}

static void c_generator_Generator_writeCalls(c_generator_Generator* gen, string_buffer_Buf* out)
{
   if (!gen->trace_calls) return;
   string_buffer_Buf_add(out, "const char *c2_filenames[] = {\n");
   uint32_t n = c_generator_StringList_length(&gen->filenames);
   for (uint32_t i = 0; i < n; i++) {
      string_buffer_Buf_print(out, "    \"%s\",\n", c_generator_StringList_get(&gen->filenames, i));
   }
   string_buffer_Buf_add(out, "};\n\n");
   string_buffer_Buf_add(out, "c2_func_t c2_func_data[] = {\n");
   n = c_generator_StringList_length(&gen->funcnames);
   for (uint32_t i = 0; i < n; i++) {
      string_buffer_Buf_print(out, "    { 0, 0, 0, \"%s\" },\n", c_generator_StringList_get(&gen->funcnames, i));
   }
   string_buffer_Buf_add(out, "};\n\n");
   string_buffer_Buf_add(out, "c2_trace_t c2_trace_data[] = {\n");
   for (uint32_t i = 0; i < gen->calls.count; i++) {
      string_buffer_Buf_print(out, "    { 0, %d, %d, %d, %d, %d },\n", gen->calls.array[i].filename_idx, gen->calls.array[i].column, gen->calls.array[i].line, gen->calls.array[i].caller_idx, gen->calls.array[i].callee_idx);
   }
   string_buffer_Buf_add(out, "};\n\n");
   string_buffer_Buf_add(out, "uint32_t c2_trace_length = sizeof(c2_trace_data) / sizeof(c2_trace_data[0]);\nuint32_t c2_trace_counts[sizeof(c2_trace_data) / sizeof(c2_trace_data[0])];\n\n");
}

static void c_generator_Generator_writeCallExterns(c_generator_Generator* gen, string_buffer_Buf* out)
{
   string_buffer_Buf_add(out, "extern uint32_t c2_trace_counts[];\n");
}


// --- module generator_utils ---
typedef struct generator_utils_Wrapper_ generator_utils_Wrapper;

struct generator_utils_Wrapper_ {
   ast_visitor_Visitor* visitor;
};

static void generator_utils_clear_used_decl(void* arg, ast_Decl* d);
static void generator_utils_clear_used_mod(void* arg, ast_Module* m);
static bool generator_utils_isEntryPoint(ast_Decl* d);
static void generator_utils_check_exported_decls(void* arg, ast_Decl* d);
static void generator_utils_check_module(void* arg, ast_Module* m);
static void generator_utils_mark_used_decl(void* arg, const ast_Ref* ref);
static void generator_utils_mark_test_mode_decl(void* arg, ast_Decl* d);
static void generator_utils_mark_test_mode_mod(void* arg, ast_Module* m);
static void generator_utils_mark_used(component_Component* mainComp, const module_list_List* allmodules, bool test_mode);

static void generator_utils_clear_used_decl(void* arg, ast_Decl* d)
{
   ast_Decl_clearUsed(d);
}

static void generator_utils_clear_used_mod(void* arg, ast_Module* m)
{
   if (!ast_Module_isUsed(m)) return;
   ast_Module_visitDeclsWithoutImports(m, generator_utils_clear_used_decl, NULL);
}

static bool generator_utils_isEntryPoint(ast_Decl* d)
{
   if (ast_Decl_isExported(d) && ast_Decl_isPublic(d)) return true;
   if (ast_Decl_isFunction(d)) {
      ast_FunctionDecl* fd = (ast_FunctionDecl*)d;
      if (ast_FunctionDecl_hasAttrConstructor(fd) || ast_FunctionDecl_hasAttrDestructor(fd)) return true;
   }
   return false;
}

static void generator_utils_check_exported_decls(void* arg, ast_Decl* d)
{
   if (ast_Decl_isUsed(d)) return;
   if (generator_utils_isEntryPoint(d)) {
      ast_Decl_setUsed(d);
      generator_utils_Wrapper* w = arg;
      ast_visitor_Visitor_handle(w->visitor, d);
   }
}

static void generator_utils_check_module(void* arg, ast_Module* m)
{
   ast_Module_visitDecls(m, generator_utils_check_exported_decls, arg);
}

static void generator_utils_mark_used_decl(void* arg, const ast_Ref* ref)
{
   ast_Decl* d = ref->decl;
   if (ast_Decl_isUsed(d)) return;
   ast_Decl_setUsed(d);
   generator_utils_Wrapper* w = arg;
   ast_visitor_Visitor_handle(w->visitor, d);
}

static void generator_utils_mark_test_mode_decl(void* arg, ast_Decl* d)
{
   ast_Decl_setUsed(d);
}

static void generator_utils_mark_test_mode_mod(void* arg, ast_Module* m)
{
   ast_Module_visitDecls(m, generator_utils_mark_test_mode_decl, arg);
}

static void generator_utils_mark_used(component_Component* mainComp, const module_list_List* allmodules, bool test_mode)
{
   if (test_mode) {
      component_Component_visitModules(mainComp, generator_utils_mark_test_mode_mod, NULL);
      return;
   }
   module_list_List_visit(allmodules, generator_utils_clear_used_mod, NULL);
   generator_utils_Wrapper wrapper = { };
   ast_visitor_Visitor* visitor = ast_visitor_create(&wrapper, generator_utils_mark_used_decl);
   wrapper.visitor = visitor;
   component_Component_visitModules(mainComp, generator_utils_check_module, &wrapper);
   ast_visitor_Visitor_free(visitor);
}


// --- module c2_parser ---
typedef struct c2_parser_Parser_ c2_parser_Parser;

#define c2_parser_MaxLookahead 64
struct c2_parser_Parser_ {
   c2_tokenizer_Tokenizer tokenizer;
   token_Token tok;
   src_loc_SrcLoc prev_loc;
   int32_t file_id;
   uint32_t next_count;
   uint32_t next_head;
   token_Token next[64];
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   string_pool_Pool* pool;
   ast_builder_Builder* builder;
   const string_list_List* features;
   const keywords_Info* kwinfo;
   bool is_interface;
   uint32_t va_list_idx;
   uint32_t varargs_idx;
   uint32_t stdarg_idx;
   attr_AttrRegistry attr_registry;
   stmt_list_List* stmt_lists;
   uint32_t stmt_list_count;
   __jmp_buf_tag jmpbuf;
   char multi_string[65536];
};

#define c2_parser_NumStmtLists 16
static const ast_BuiltinKind c2_parser_Tok2builtin[18] = {
   ast_BuiltinKind_Bool,
   ast_BuiltinKind_Char,
   ast_BuiltinKind_Int8,
   ast_BuiltinKind_Int16,
   ast_BuiltinKind_Int32,
   ast_BuiltinKind_Int64,
   ast_BuiltinKind_UInt8,
   ast_BuiltinKind_UInt16,
   ast_BuiltinKind_UInt32,
   ast_BuiltinKind_UInt64,
   ast_BuiltinKind_UInt8,
   ast_BuiltinKind_UInt16,
   ast_BuiltinKind_UInt32,
   ast_BuiltinKind_UInt64,
   ast_BuiltinKind_ISize,
   ast_BuiltinKind_USize,
   ast_BuiltinKind_Float32,
   ast_BuiltinKind_Float64
};
static c2_parser_Parser* c2_parser_create(source_mgr_SourceMgr* sm, diagnostics_Diags* diags, string_pool_Pool* pool, ast_builder_Builder* builder, const keywords_Info* kwinfo, const string_list_List* features);
static void c2_parser_Parser_free(c2_parser_Parser* p);
static void c2_parser_Parser_parse(c2_parser_Parser* p, int32_t file_id, bool is_interface, bool is_generated);
static void c2_parser_Parser_on_tokenizer_error(void* arg, c2_tokenizer_ErrorLevel level, src_loc_SrcLoc loc, const char* msg);
static void c2_parser_Parser_consumeToken(c2_parser_Parser* p);
static token_Kind c2_parser_Parser_peekToken(c2_parser_Parser* p, uint32_t n);
static token_Kind c2_parser_Parser_peekToken2(c2_parser_Parser* p, uint32_t n, token_Token* tok);
static void c2_parser_Parser_consumeSemicolon(c2_parser_Parser* p, bool need_semi);
static void c2_parser_Parser_expectAndConsume(c2_parser_Parser* p, token_Kind kind);
static void c2_parser_Parser_expect(c2_parser_Parser* p, token_Kind kind);
static void c2_parser_Parser_expectError(c2_parser_Parser* p, token_Kind kind);
static void c2_parser_Parser_expectIdentifier(c2_parser_Parser* p);
__attribute__((noreturn)) __attribute__((__format__(printf, 2, 3)))
static void c2_parser_Parser_error(c2_parser_Parser* p, const char* format, ...);
__attribute__((noreturn)) __attribute__((__format__(printf, 3, 4)))
static void c2_parser_Parser_errorAt(c2_parser_Parser* p, src_loc_SrcLoc loc, const char* format, ...);
static void c2_parser_Parser_parseModule(c2_parser_Parser* p, bool is_interface, bool is_generated);
static void c2_parser_Parser_addImplicitImport(c2_parser_Parser* p, uint32_t mod_name, bool islocal);
static void c2_parser_Parser_parseImports(c2_parser_Parser* p);
static void c2_parser_Parser_parseTopLevel(c2_parser_Parser* p);
static bool c2_parser_findName(const uint32_t* names, uint32_t count, uint32_t name);
static uint32_t c2_parser_Parser_parseOptionalAttributes(c2_parser_Parser* p);
static void c2_parser_Parser_applyAttributes(c2_parser_Parser* p, ast_Decl* d, uint32_t count);
static void c2_parser_Parser_parseFuncDecl(c2_parser_Parser* p, bool is_public);
static bool c2_parser_Parser_parseFunctionParams(c2_parser_Parser* p, ast_DeclList* params, bool is_public, bool accept_default);
static ast_VarDecl* c2_parser_Parser_parseParamDecl(c2_parser_Parser* p, bool is_public, bool accept_default);
static void c2_parser_Parser_parseTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref);
static void c2_parser_Parser_parseOptionalArray(c2_parser_Parser* p, ast_TypeRefHolder* ref);
static void c2_parser_Parser_parseArrayEntry(c2_parser_Parser* p);
static void c2_parser_Parser_parseVarDecl(c2_parser_Parser* p, bool is_public);
static void c2_parser_Parser_parseStaticAssert(c2_parser_Parser* p);
static bool c2_parser_Parser_parseOptionalAccessSpecifier(c2_parser_Parser* p);
static uint32_t c2_parser_Parser_parseOptionalTypeQualifier(c2_parser_Parser* p);
static ast_BuiltinKind c2_parser_tokKindToBuiltinKind(token_Kind kind);
static void c2_parser_Parser_parseSingleTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref);
static void c2_parser_Parser_parseFullTypeIdentifier(c2_parser_Parser* p, ast_TypeRefHolder* ref);
static void c2_parser_Parser_dump_token(c2_parser_Parser* p, const token_Token* tok);
static bool c2_parser_Parser_checkName(c2_parser_Parser* p, uint32_t name_idx, bool is_interface);
static stmt_list_List* c2_parser_Parser_getStmtList(c2_parser_Parser* p);
static void c2_parser_Parser_putStmtList(c2_parser_Parser* p);
static const c2_prec_Prec c2_parser_BinOpPrecLookup[122] = {
   [token_Kind_Comma] = c2_prec_Prec_Comma,
   [token_Kind_Equal] = c2_prec_Prec_Assignment,
   [token_Kind_StarEqual] = c2_prec_Prec_Assignment,
   [token_Kind_SlashEqual] = c2_prec_Prec_Assignment,
   [token_Kind_PercentEqual] = c2_prec_Prec_Assignment,
   [token_Kind_PlusEqual] = c2_prec_Prec_Assignment,
   [token_Kind_MinusEqual] = c2_prec_Prec_Assignment,
   [token_Kind_LessLessEqual] = c2_prec_Prec_Assignment,
   [token_Kind_GreaterGreaterEqual] = c2_prec_Prec_Assignment,
   [token_Kind_AmpEqual] = c2_prec_Prec_Assignment,
   [token_Kind_CaretEqual] = c2_prec_Prec_Assignment,
   [token_Kind_PipeEqual] = c2_prec_Prec_Assignment,
   [token_Kind_Question] = c2_prec_Prec_Conditional,
   [token_Kind_PipePipe] = c2_prec_Prec_LogicalAndOr,
   [token_Kind_AmpAmp] = c2_prec_Prec_LogicalAndOr,
   [token_Kind_ExclaimEqual] = c2_prec_Prec_Relational,
   [token_Kind_EqualEqual] = c2_prec_Prec_Relational,
   [token_Kind_LessEqual] = c2_prec_Prec_Relational,
   [token_Kind_Less] = c2_prec_Prec_Relational,
   [token_Kind_Greater] = c2_prec_Prec_Relational,
   [token_Kind_GreaterEqual] = c2_prec_Prec_Relational,
   [token_Kind_Plus] = c2_prec_Prec_Additive,
   [token_Kind_Minus] = c2_prec_Prec_Additive,
   [token_Kind_Pipe] = c2_prec_Prec_Bitwise,
   [token_Kind_Caret] = c2_prec_Prec_Bitwise,
   [token_Kind_Amp] = c2_prec_Prec_Bitwise,
   [token_Kind_LessLess] = c2_prec_Prec_Shift,
   [token_Kind_GreaterGreater] = c2_prec_Prec_Shift,
   [token_Kind_Percent] = c2_prec_Prec_Multiplicative,
   [token_Kind_Slash] = c2_prec_Prec_Multiplicative,
   [token_Kind_Star] = c2_prec_Prec_Multiplicative
};
static const ast_BinaryOpcode c2_parser_BinOpTokenLookup[122] = {
   [token_Kind_Star] = ast_BinaryOpcode_Multiply,
   [token_Kind_Slash] = ast_BinaryOpcode_Divide,
   [token_Kind_Percent] = ast_BinaryOpcode_Remainder,
   [token_Kind_Plus] = ast_BinaryOpcode_Add,
   [token_Kind_Minus] = ast_BinaryOpcode_Subtract,
   [token_Kind_LessLess] = ast_BinaryOpcode_ShiftLeft,
   [token_Kind_GreaterGreater] = ast_BinaryOpcode_ShiftRight,
   [token_Kind_Less] = ast_BinaryOpcode_LessThan,
   [token_Kind_Greater] = ast_BinaryOpcode_GreaterThan,
   [token_Kind_LessEqual] = ast_BinaryOpcode_LessEqual,
   [token_Kind_GreaterEqual] = ast_BinaryOpcode_GreaterEqual,
   [token_Kind_EqualEqual] = ast_BinaryOpcode_Equal,
   [token_Kind_ExclaimEqual] = ast_BinaryOpcode_NotEqual,
   [token_Kind_Amp] = ast_BinaryOpcode_And,
   [token_Kind_Caret] = ast_BinaryOpcode_Xor,
   [token_Kind_Pipe] = ast_BinaryOpcode_Or,
   [token_Kind_AmpAmp] = ast_BinaryOpcode_LAnd,
   [token_Kind_PipePipe] = ast_BinaryOpcode_LOr,
   [token_Kind_Equal] = ast_BinaryOpcode_Assign,
   [token_Kind_StarEqual] = ast_BinaryOpcode_MulAssign,
   [token_Kind_SlashEqual] = ast_BinaryOpcode_DivAssign,
   [token_Kind_PercentEqual] = ast_BinaryOpcode_RemAssign,
   [token_Kind_PlusEqual] = ast_BinaryOpcode_AddAssign,
   [token_Kind_MinusEqual] = ast_BinaryOpcode_SubAssign,
   [token_Kind_LessLessEqual] = ast_BinaryOpcode_ShlAssign,
   [token_Kind_GreaterGreaterEqual] = ast_BinaryOpcode_ShrAssign,
   [token_Kind_AmpEqual] = ast_BinaryOpcode_AndAssign,
   [token_Kind_CaretEqual] = ast_BinaryOpcode_XorAssign,
   [token_Kind_PipeEqual] = ast_BinaryOpcode_OrAssign
};
static const uint8_t c2_parser_CastExprTokenLookup[122] = {
   [token_Kind_Identifier] = 1,
   [token_Kind_IntegerLiteral] = 2,
   [token_Kind_FloatLiteral] = 3,
   [token_Kind_CharLiteral] = 4,
   [token_Kind_StringLiteral] = 5,
   [token_Kind_LParen] = 6,
   [token_Kind_Star] = 7,
   [token_Kind_Tilde] = 7,
   [token_Kind_Plus] = 7,
   [token_Kind_Minus] = 7,
   [token_Kind_Exclaim] = 7,
   [token_Kind_Amp] = 7,
   [token_Kind_PlusPlus] = 7,
   [token_Kind_MinusMinus] = 7,
   [token_Kind_KW_cast] = 8,
   [token_Kind_KW_elemsof] = 9,
   [token_Kind_KW_enum_min] = 10,
   [token_Kind_KW_enum_max] = 10,
   [token_Kind_KW_false] = 11,
   [token_Kind_KW_true] = 11,
   [token_Kind_KW_nil] = 12,
   [token_Kind_KW_offsetof] = 13,
   [token_Kind_KW_sizeof] = 14,
   [token_Kind_KW_to_container] = 15,
   [token_Kind_KW_bool] = 16,
   [token_Kind_KW_char] = 16,
   [token_Kind_KW_i8] = 16,
   [token_Kind_KW_i16] = 16,
   [token_Kind_KW_i32] = 16,
   [token_Kind_KW_i64] = 16,
   [token_Kind_KW_u8] = 16,
   [token_Kind_KW_u16] = 16,
   [token_Kind_KW_u32] = 16,
   [token_Kind_KW_u64] = 16,
   [token_Kind_KW_isize] = 16,
   [token_Kind_KW_usize] = 16,
   [token_Kind_KW_f32] = 16,
   [token_Kind_KW_f64] = 16
};
static ast_Expr* c2_parser_Parser_parseExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseAssignmentExpression(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseRHSOfBinaryExpression(c2_parser_Parser* p, ast_Expr* lhs, c2_prec_Prec minPrec);
static ast_UnaryOpcode c2_parser_convertTokenToUnaryOpcode(token_Kind kind);
static ast_Expr* c2_parser_Parser_parseCastExpr(c2_parser_Parser* p, bool _arg1, bool _arg2);
static ast_Expr* c2_parser_Parser_parsePostfixExprSuffix(c2_parser_Parser* p, ast_Expr* lhs, bool couldBeTemplateCall);
static ast_Expr* c2_parser_Parser_parseCallExpr(c2_parser_Parser* p, ast_Expr* func);
static ast_Expr* c2_parser_Parser_parseTemplateCallExpr(c2_parser_Parser* p, ast_Expr* func, const ast_TypeRefHolder* ref);
static ast_Expr* c2_parser_Parser_parseImpureMemberExpr(c2_parser_Parser* p, ast_Expr* base);
static ast_Expr* c2_parser_Parser_parsePureMemberExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseStringLiteral(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseParenExpr(c2_parser_Parser* p);
static bool c2_parser_Parser_isTemplateFunctionCall(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseSizeof(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseElemsof(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseInitValue(c2_parser_Parser* p, bool allow_designators);
static ast_Expr* c2_parser_Parser_parseInitList(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseFieldDesignator(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseArrayDesignator(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseExplicitCastExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseEnumMinMax(c2_parser_Parser* p, bool is_min);
static ast_Expr* c2_parser_Parser_parseOffsetOfExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseToContainerExpr(c2_parser_Parser* p);
static ast_Expr* c2_parser_Parser_parseFullIdentifier(c2_parser_Parser* p);
static bool c2_parser_Parser_parseAsType(c2_parser_Parser* p);
static uint32_t c2_parser_Parser_parseAsCastType(c2_parser_Parser* p, uint32_t ahead, token_Kind close_tok);
static ast_Stmt* c2_parser_Parser_parseStmt(c2_parser_Parser* p);
static bool c2_parser_Parser_isTypeSpec(c2_parser_Parser* p);
static uint32_t c2_parser_Parser_skipArray(c2_parser_Parser* p, uint32_t ahead, token_Kind endKind);
static ast_Stmt* c2_parser_Parser_parseDeclOrStmt(c2_parser_Parser* p);
static ast_CompoundStmt* c2_parser_Parser_parseCompoundStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseAsmStmt(c2_parser_Parser* p);
static void c2_parser_Parser_parseAsmOperandsOpt(c2_parser_Parser* p, string_list_List* names, ast_ExprList* constraints, ast_ExprList* exprs);
static ast_Stmt* c2_parser_Parser_parseAssertStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseBreakStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseContinueStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseFallthroughStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseCondition(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseIfStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseReturnStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseForStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseWhileStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseDeclStmt(c2_parser_Parser* p, bool checkSemi, bool allowLocal, bool isCondition);
static ast_Stmt* c2_parser_Parser_parseExprStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseLabelStmt(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseGotoStmt(c2_parser_Parser* p);
static bool c2_parser_Parser_isDeclaration(c2_parser_Parser* p);
static ast_Stmt* c2_parser_Parser_parseSwitchStmt(c2_parser_Parser* p);
static void c2_parser_Parser_parseCaseCondition(c2_parser_Parser* p, expr_list_List* list);
static ast_SwitchCase* c2_parser_Parser_parseCase(c2_parser_Parser* p, bool is_default);
static void c2_parser_Parser_parseTypeDecl(c2_parser_Parser* p, bool is_public);
static void c2_parser_Parser_parseFunctionType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, bool is_public);
static void c2_parser_Parser_parseStructType(c2_parser_Parser* p, bool is_struct, uint32_t name, src_loc_SrcLoc loc, bool is_public);
static void c2_parser_Parser_checkMemberName(c2_parser_Parser* p);
static void c2_parser_Parser_parseStructBlock(c2_parser_Parser* p, ast_DeclList* members, bool is_public);
static void c2_parser_Parser_parseEnumType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, bool is_public);
static void c2_parser_Parser_parseAliasType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, bool is_public);

static c2_parser_Parser* c2_parser_create(source_mgr_SourceMgr* sm, diagnostics_Diags* diags, string_pool_Pool* pool, ast_builder_Builder* builder, const keywords_Info* kwinfo, const string_list_List* features)
{
   c2_parser_Parser* p = calloc(1, 67376);
   p->sm = sm;
   p->diags = diags;
   p->pool = pool;
   p->builder = builder;
   p->features = features;
   p->kwinfo = kwinfo;
   p->va_list_idx = string_pool_Pool_addStr(pool, "va_list", true);
   p->varargs_idx = string_pool_Pool_addStr(pool, "varargs", true);
   p->stdarg_idx = string_pool_Pool_addStr(pool, "stdarg", true);
   attr_AttrRegistry_init(&p->attr_registry, pool);
   p->stmt_lists = malloc(c2_parser_NumStmtLists * 48);
   for (uint32_t i = 0; i < c2_parser_NumStmtLists; i++) {
      stmt_list_List_init(&p->stmt_lists[i]);
   }
   return p;
}

static void c2_parser_Parser_free(c2_parser_Parser* p)
{
   for (uint32_t i = 0; i < c2_parser_NumStmtLists; i++) {
      stmt_list_List_free(&p->stmt_lists[i]);
   }
   free(p->stmt_lists);
   free(p);
}

static void c2_parser_Parser_parse(c2_parser_Parser* p, int32_t file_id, bool is_interface, bool is_generated)
{
   p->file_id = file_id;
   p->is_interface = is_interface;
   string_buffer_Buf* buf = string_buffer_create(1024, false, 0);
   int32_t res = setjmp(&p->jmpbuf);
   if (res == 0) {
      c2_tokenizer_Tokenizer_init(&p->tokenizer, p->pool, buf, source_mgr_SourceMgr_get_content(p->sm, p->file_id), source_mgr_SourceMgr_get_offset(p->sm, p->file_id), p->kwinfo, p->features, c2_parser_Parser_on_tokenizer_error, p, false);
      token_Token_init(&p->tok);
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_parseModule(p, is_interface, is_generated);
      c2_parser_Parser_parseImports(p);
      while (!p->tok.done) {
         c2_parser_Parser_parseTopLevel(p);
      }
   }
   string_buffer_Buf_free(buf);
}

static void c2_parser_Parser_on_tokenizer_error(void* arg, c2_tokenizer_ErrorLevel level, src_loc_SrcLoc loc, const char* msg)
{
   c2_parser_Parser* p = arg;
   switch (level) {
   case c2_tokenizer_ErrorLevel_Note:
      diagnostics_Diags_note(p->diags, loc, "%s", msg);
      break;
   case c2_tokenizer_ErrorLevel_Warning:
      diagnostics_Diags_warn(p->diags, loc, "%s", msg);
      break;
   default:
      diagnostics_Diags_error(p->diags, loc, "%s", msg);
      break;
   }
   if (level == c2_tokenizer_ErrorLevel_FatalError) longjmp(&p->jmpbuf, 1);
}

static void c2_parser_Parser_consumeToken(c2_parser_Parser* p)
{
   p->prev_loc = p->tok.loc + p->tok.len;
   if (p->next_count) {
      p->tok = p->next[p->next_head];
      p->next_head = (p->next_head + 1) % c2_parser_MaxLookahead;
      p->next_count--;
      return;
   }
   c2_tokenizer_Tokenizer_lex(&p->tokenizer, &p->tok);
}

static token_Kind c2_parser_Parser_peekToken(c2_parser_Parser* p, uint32_t n)
{
   ;//assert(n > 0);
   ;//assert(n <= c2_parser_MaxLookahead);
   while (p->next_count < n) {
      const uint32_t slot = (p->next_head + p->next_count) % c2_parser_MaxLookahead;
      c2_tokenizer_Tokenizer_lex(&p->tokenizer, &p->next[slot]);
      p->next_count++;
   }
   uint32_t slot = (p->next_head + n - 1) % c2_parser_MaxLookahead;
   return p->next[slot].kind;
}

static token_Kind c2_parser_Parser_peekToken2(c2_parser_Parser* p, uint32_t n, token_Token* tok)
{
   token_Kind kind = c2_parser_Parser_peekToken(p, n);
   uint32_t slot = (p->next_head + n - 1) % c2_parser_MaxLookahead;
   *tok = p->next[slot];
   return p->next[slot].kind;
}

static void c2_parser_Parser_consumeSemicolon(c2_parser_Parser* p, bool need_semi)
{
   if (need_semi) {
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   } else {
      if (p->tok.kind == token_Kind_Semicolon) {
         diagnostics_Diags_error(p->diags, p->tok.loc, "no semicolon allowed after initializer list");
         c2_parser_Parser_consumeToken(p);
      }
   }
}

static void c2_parser_Parser_expectAndConsume(c2_parser_Parser* p, token_Kind kind)
{
   if (p->tok.kind == kind) {
      c2_parser_Parser_consumeToken(p);
      return;
   }
   c2_parser_Parser_expectError(p, kind);
}

static void c2_parser_Parser_expect(c2_parser_Parser* p, token_Kind kind)
{
   if (p->tok.kind == kind) return;
   c2_parser_Parser_expectError(p, kind);
}

static void c2_parser_Parser_expectError(c2_parser_Parser* p, token_Kind kind)
{
   src_loc_SrcLoc loc = p->prev_loc;
   if (loc) {
      if (kind == token_Kind_Semicolon) {
         diagnostics_Diags_error(p->diags, loc, "expected ';'");
         return;
      }
   } else {
      loc = p->tok.loc;
   }
   c2_parser_Parser_errorAt(p, loc, "expected '%s'", token_Kind_str(kind));
}

static void c2_parser_Parser_expectIdentifier(c2_parser_Parser* p)
{
   if (p->tok.kind == token_Kind_Identifier) return;
   c2_parser_Parser_error(p, "expected identifier");
}

__attribute__((noreturn)) __attribute__((__format__(printf, 2, 3)))
static void c2_parser_Parser_error(c2_parser_Parser* p, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_error2(p->diags, p->tok.loc, format, args);
   va_end(args);
   longjmp(&p->jmpbuf, 1);
}

__attribute__((noreturn)) __attribute__((__format__(printf, 3, 4)))
static void c2_parser_Parser_errorAt(c2_parser_Parser* p, src_loc_SrcLoc loc, const char* format, ...)
{
   va_list args;
   va_start(args, format);
   diagnostics_Diags_error2(p->diags, loc, format, args);
   va_end(args);
   longjmp(&p->jmpbuf, 1);
}

static void c2_parser_Parser_parseModule(c2_parser_Parser* p, bool is_interface, bool is_generated)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_KW_module);
   if (!token_Kind_isBuiltinTypeOrVoid(p->tok.kind)) c2_parser_Parser_expectIdentifier(p);
   const char* modname = string_pool_Pool_idx2str(p->pool, p->tok.name_idx);
   if (!islower(modname[0])) {
      c2_parser_Parser_error(p, "a module name must start with a lower case character");
   }
   ast_builder_Builder_actOnModule(p->builder, p->tok.name_idx, p->tok.loc, source_mgr_SourceMgr_getFileNameIdx(p->sm, p->file_id), is_interface, is_generated);
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
}

static void c2_parser_Parser_addImplicitImport(c2_parser_Parser* p, uint32_t mod_name, bool islocal)
{
   ast_builder_Builder_actOnImport(p->builder, mod_name, 0, 0, 0, islocal);
}

static void c2_parser_Parser_parseImports(c2_parser_Parser* p)
{
   while (p->tok.kind == token_Kind_KW_import) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      uint32_t mod_name = p->tok.name_idx;
      src_loc_SrcLoc mod_loc = p->tok.loc;
      uint32_t alias_name = 0;
      src_loc_SrcLoc alias_loc = 0;
      c2_parser_Parser_consumeToken(p);
      if (p->tok.kind == token_Kind_KW_as) {
         c2_parser_Parser_consumeToken(p);
         c2_parser_Parser_expectIdentifier(p);
         alias_name = p->tok.name_idx;
         alias_loc = p->tok.loc;
         if (!c2_parser_Parser_checkName(p, alias_name, false)) {
            c2_parser_Parser_error(p, "a module name must start with a lower case character");
         }
         c2_parser_Parser_consumeToken(p);
      }
      bool islocal = false;
      if (p->tok.kind == token_Kind_KW_local) {
         c2_parser_Parser_consumeToken(p);
         islocal = true;
      }
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
      if (mod_name != p->stdarg_idx) {
         ast_builder_Builder_actOnImport(p->builder, mod_name, mod_loc, alias_name, alias_loc, islocal);
      }
   }
}

static void c2_parser_Parser_parseTopLevel(c2_parser_Parser* p)
{
   ast_builder_Builder_clearAttributes(p->builder);
   bool is_public = c2_parser_Parser_parseOptionalAccessSpecifier(p);
   switch (p->tok.kind) {
   case token_Kind_KW_assert:
      c2_parser_Parser_error(p, "assert can only be used inside a function");
      break;
   case token_Kind_KW_fn:
      c2_parser_Parser_parseFuncDecl(p, is_public);
      break;
   case token_Kind_KW_import:
      c2_parser_Parser_error(p, "no imports allowed after declarations");
      break;
   case token_Kind_KW_static_assert:
      if (is_public) c2_parser_Parser_error(p, "static_assert cannot be public");
      c2_parser_Parser_parseStaticAssert(p);
      break;
   case token_Kind_KW_type:
      c2_parser_Parser_parseTypeDecl(p, is_public);
      break;
   case token_Kind_Eof:
      break;
   case token_Kind_Identifier:
      if (c2_parser_Parser_peekToken(p, 1) == token_Kind_PlusEqual) {
         if (is_public) c2_parser_Parser_error(p, "incremental array entries cannot be public");
         c2_parser_Parser_parseArrayEntry(p);
         break;
      }
      fallthrough;
   default:
      c2_parser_Parser_parseVarDecl(p, is_public);
      break;
   }
}

static bool c2_parser_findName(const uint32_t* names, uint32_t count, uint32_t name)
{
   for (uint32_t i = 0; i < count; i++) {
      if (names[i] == name) return true;
   }
   return false;
}

static uint32_t c2_parser_Parser_parseOptionalAttributes(c2_parser_Parser* p)
{
   if (p->tok.kind != token_Kind_At) return 0;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   uint32_t dups[24];
   uint32_t num_attrs = 0;
   uint32_t count = 0;
   while (1) {
      c2_parser_Parser_expectIdentifier(p);
      attr_Attr a = { .name = p->tok.name_idx, .kind = attr_AttrRegistry_find(&p->attr_registry, p->tok.name_idx), .value_kind = attr_AttrValueKind_None, .loc = p->tok.loc };
      c2_parser_Parser_consumeToken(p);
      if (p->tok.kind == token_Kind_Equal) {
         c2_parser_Parser_consumeToken(p);
         a.value.loc = p->tok.loc;
         switch (p->tok.kind) {
         case token_Kind_StringLiteral:
            a.value_kind = attr_AttrValueKind_String;
            a.value.text = p->tok.text_idx;
            if (p->tok.text_len == 0) {
               c2_parser_Parser_error(p, "attribute argument cannot be an empty string");
            }
            c2_parser_Parser_consumeToken(p);
            break;
         case token_Kind_IntegerLiteral:
            a.value_kind = attr_AttrValueKind_Number;
            a.value.number = (uint32_t)p->tok.int_value;
            c2_parser_Parser_consumeToken(p);
            break;
         default:
            c2_parser_Parser_error(p, "expected attribute argument");
            break;
         }
      }
      if (c2_parser_findName(dups, num_attrs, a.name)) {
         diagnostics_Diags_error(p->diags, a.loc, "duplicate attribute");
      } else {
         if (num_attrs >= 24) c2_parser_Parser_error(p, "too many attributes");
         dups[num_attrs++] = a.name;
         count += ast_builder_Builder_actOnAttr(p->builder, &a);
      }
      if (p->tok.kind != token_Kind_Comma) break;
      c2_parser_Parser_consumeToken(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return count;
}

static void c2_parser_Parser_applyAttributes(c2_parser_Parser* p, ast_Decl* d, uint32_t count)
{
   if (count) ast_builder_Builder_applyAttributes(p->builder, d, count);
}

static void c2_parser_Parser_parseFuncDecl(c2_parser_Parser* p, bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   ast_TypeRefHolder rtype; ast_TypeRefHolder_init(&rtype);
   c2_parser_Parser_parseTypeSpecifier(p, &rtype);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t func_name = p->tok.name_idx;
   src_loc_SrcLoc func_loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Ref prefix_ref;
   ast_Ref* prefix = NULL;
   if (p->tok.kind == token_Kind_Dot) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      prefix_ref.loc = func_loc;
      prefix_ref.name_idx = func_name;
      prefix_ref.decl = NULL;
      prefix = &prefix_ref;
      func_name = p->tok.name_idx;
      func_loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
   }
   if (!c2_parser_Parser_checkName(p, func_name, p->is_interface)) {
      c2_parser_Parser_errorAt(p, func_loc, "a function name must start with a lower case character");
   }
   ast_DeclList params; ast_DeclList_init(&params);
   bool is_variadic = c2_parser_Parser_parseFunctionParams(p, &params, is_public, true);
   ast_FunctionDecl* f;
   if (p->tok.kind == token_Kind_KW_template) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      uint32_t template_name = p->tok.name_idx;
      src_loc_SrcLoc template_loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      f = ast_builder_Builder_actOnTemplateFunctionDecl(p->builder, func_name, func_loc, is_public, &rtype, template_name, template_loc, (ast_VarDecl**)ast_DeclList_getDecls(&params), ast_DeclList_size(&params), is_variadic);
   } else {
      f = ast_builder_Builder_actOnFunctionDecl(p->builder, func_name, func_loc, is_public, &rtype, prefix, (ast_VarDecl**)ast_DeclList_getDecls(&params), ast_DeclList_size(&params), is_variadic);
   }
   ast_DeclList_free(&params);
   uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
   c2_parser_Parser_applyAttributes(p, (ast_Decl*)f, num_attr);
   if (p->is_interface) {
      if (p->tok.kind == token_Kind_Semicolon) {
         c2_parser_Parser_consumeToken(p);
         return;
      }
      ast_FunctionDecl_setAttrInline(f);
   }
   p->stmt_list_count = 0;
   ast_CompoundStmt* body = c2_parser_Parser_parseCompoundStmt(p);
   ast_builder_Builder_actOnFunctionBody(p->builder, f, body);
}

static bool c2_parser_Parser_parseFunctionParams(c2_parser_Parser* p, ast_DeclList* params, bool is_public, bool accept_default)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   if (p->tok.kind == token_Kind_RParen) {
      c2_parser_Parser_consumeToken(p);
      return false;
   }
   bool is_variadic = false;
   while (p->tok.kind != token_Kind_RParen) {
      ast_VarDecl* decl = c2_parser_Parser_parseParamDecl(p, is_public, accept_default);
      ast_VarDecl_setOffset(decl, params->count);
      ast_DeclList_add(params, ast_VarDecl_asDecl(decl));
      if (p->tok.kind != token_Kind_Comma) break;
      c2_parser_Parser_consumeToken(p);
      if (p->tok.kind == token_Kind_Ellipsis) {
         is_variadic = true;
         c2_parser_Parser_consumeToken(p);
         break;
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return is_variadic;
}

static ast_VarDecl* c2_parser_Parser_parseParamDecl(c2_parser_Parser* p, bool is_public, bool accept_default)
{
   if (p->tok.kind == token_Kind_KW_local) c2_parser_Parser_error(p, "keyword 'local' is not allowed here");
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   if (p->tok.kind == token_Kind_KW_fn) {
      c2_parser_Parser_consumeToken(p);
      ast_TypeRefHolder rtype; ast_TypeRefHolder_init(&rtype);
      c2_parser_Parser_parseSingleTypeSpecifier(p, &rtype);
      ast_DeclList params; ast_DeclList_init(&params);
      bool is_variadic = c2_parser_Parser_parseFunctionParams(p, &params, is_public, false);
      ast_Decl* fd = ast_builder_Builder_actOnFunctionType(p->builder, &rtype, (ast_VarDecl**)ast_DeclList_getDecls(&params), ast_DeclList_size(&params), is_variadic, ast_DefKind_Param);
      ast_DeclList_free(&params);
      ast_TypeRefHolder_setFunction(&ref, (ast_Decl*)fd);
      if (p->tok.kind == token_Kind_LSquare) {
         c2_parser_Parser_error(p, "array types are not allowed here");
      }
   } else {
      c2_parser_Parser_parseTypeSpecifier(p, &ref);
   }
   uint32_t name = 0;
   src_loc_SrcLoc loc = p->tok.loc;
   if (p->tok.kind == token_Kind_Identifier) {
      name = p->tok.name_idx;
      if (!c2_parser_Parser_checkName(p, name, p->is_interface)) {
         c2_parser_Parser_error(p, "a parameter name must start with a lower case character");
      }
      if (p->tok.reserved) {
         diagnostics_Diags_error(p->diags, loc, "reserved word '%s' cannot be used as parameter name", string_pool_Pool_idx2str(p->pool, name));
      }
      c2_parser_Parser_consumeToken(p);
   }
   ast_Expr* initValue = NULL;
   src_loc_SrcLoc assignLoc = 0;
   if (p->tok.kind == token_Kind_Equal) {
      if (!accept_default) c2_parser_Parser_error(p, "default parameter values are not allowed in type definitions");
      assignLoc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      initValue = c2_parser_Parser_parseInitValue(p, false);
   }
   ast_VarDecl* param = ast_builder_Builder_actOnFunctionParam(p->builder, name, loc, is_public, &ref, assignLoc, initValue);
   uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
   c2_parser_Parser_applyAttributes(p, (ast_Decl*)param, num_attr);
   return param;
}

static void c2_parser_Parser_parseTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref)
{
   c2_parser_Parser_parseSingleTypeSpecifier(p, ref);
   c2_parser_Parser_parseOptionalArray(p, ref);
}

static void c2_parser_Parser_parseOptionalArray(c2_parser_Parser* p, ast_TypeRefHolder* ref)
{
   while (p->tok.kind == token_Kind_LSquare) {
      if (ast_TypeRefHolder_getNumArrays(ref) == 3) c2_parser_Parser_error(p, "arrays cannot have more than 3 dimensions");
      if (ast_TypeRefHolder_isIncrArray(ref)) c2_parser_Parser_error(p, "incremental arrays cannot have more than 1 dimension");
      c2_parser_Parser_consumeToken(p);
      if (p->tok.kind == token_Kind_Plus && c2_parser_Parser_peekToken(p, 1) == token_Kind_RSquare) {
         if (ast_TypeRefHolder_isArray(ref)) c2_parser_Parser_error(p, "incremental arrays cannot have more than 1 dimension");
         c2_parser_Parser_consumeToken(p);
         ast_TypeRefHolder_setIncrArray(ref);
      } else {
         ast_Expr* size = NULL;
         if (p->tok.kind != token_Kind_RSquare) size = c2_parser_Parser_parseExpr(p);
         ast_TypeRefHolder_addArray(ref, size);
      }
      c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
   }
}

static void c2_parser_Parser_parseArrayEntry(c2_parser_Parser* p)
{
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_consumeToken(p);
   bool need_semi = (p->tok.kind != token_Kind_LBrace);
   ast_Expr* initValue = c2_parser_Parser_parseInitValue(p, false);
   c2_parser_Parser_consumeSemicolon(p, need_semi);
   ast_builder_Builder_actOnArrayValue(p->builder, name, loc, initValue);
}

static void c2_parser_Parser_parseVarDecl(c2_parser_Parser* p, bool is_public)
{
   if (p->tok.kind == token_Kind_KW_local) c2_parser_Parser_error(p, "keyword 'local' cannot be used at file scope");
   bool need_semi = true;
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref);
   for (;;) {
      c2_parser_Parser_expectIdentifier(p);
      uint32_t name = p->tok.name_idx;
      src_loc_SrcLoc loc = p->tok.loc;
      if (p->tok.reserved) {
         diagnostics_Diags_error(p->diags, loc, "reserved word '%s' cannot be used as variable name", string_pool_Pool_idx2str(p->pool, name));
      }
      c2_parser_Parser_consumeToken(p);
      need_semi = true;
      ast_Expr* initValue = NULL;
      src_loc_SrcLoc assignLoc = 0;
      uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
      switch (p->tok.kind) {
      case token_Kind_Equal:
         assignLoc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         need_semi = (p->tok.kind != token_Kind_LBrace);
         initValue = c2_parser_Parser_parseInitValue(p, false);
         break;
      case token_Kind_Dot:
         c2_parser_Parser_error(p, "global variables cannot have an init call");
         break;
      case token_Kind_LSquare:
         c2_parser_Parser_error(p, "array indices should go after type");
         break;
      default:
         break;
      }
      bool has_embed = ast_builder_Builder_hasEmbedAttr(p->builder);
      ast_Decl* d = ast_builder_Builder_actOnGlobalVarDecl(p->builder, name, loc, is_public, &ref, assignLoc, has_embed, initValue);
      c2_parser_Parser_applyAttributes(p, d, num_attr);
      if (p->tok.kind != token_Kind_Comma) break;
      c2_parser_Parser_consumeToken(p);
      if (ast_TypeRefHolder_isPointer(&ref) || ast_TypeRefHolder_isArray(&ref)) c2_parser_Parser_error(p, "pointer and array variables must be defined separately");
   }
   c2_parser_Parser_consumeSemicolon(p, need_semi);
}

static void c2_parser_Parser_parseStaticAssert(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* lhs = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* rhs = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_builder_Builder_actOnStaticAssert(p->builder, loc, lhs, rhs);
}

static bool c2_parser_Parser_parseOptionalAccessSpecifier(c2_parser_Parser* p)
{
   if (p->tok.kind == token_Kind_KW_public) {
      c2_parser_Parser_consumeToken(p);
      return true;
   }
   return false;
}

static uint32_t c2_parser_Parser_parseOptionalTypeQualifier(c2_parser_Parser* p)
{
   uint32_t qualifiers = 0;
   if (p->tok.kind == token_Kind_KW_const) {
      c2_parser_Parser_consumeToken(p);
      qualifiers |= ast_QualType_Const;
   }
   if (p->tok.kind == token_Kind_KW_volatile) {
      c2_parser_Parser_consumeToken(p);
      qualifiers |= ast_QualType_Volatile;
   }
   return qualifiers;
}

static ast_BuiltinKind c2_parser_tokKindToBuiltinKind(token_Kind kind)
{
   return c2_parser_Tok2builtin[kind - token_Kind_KW_bool];
}

static void c2_parser_Parser_parseSingleTypeSpecifier(c2_parser_Parser* p, ast_TypeRefHolder* ref)
{
   uint32_t type_qualifier = c2_parser_Parser_parseOptionalTypeQualifier(p);
   ast_TypeRefHolder_setQualifiers(ref, type_qualifier);
   token_Kind kind = p->tok.kind;
   if (token_Kind_isBuiltinType(kind)) {
      ast_TypeRefHolder_setBuiltin(ref, c2_parser_tokKindToBuiltinKind(p->tok.kind), p->tok.loc);
      if (kind >= token_Kind_KW_reg8 && kind <= token_Kind_KW_reg64) ast_TypeRefHolder_setVolatile(ref);
      c2_parser_Parser_consumeToken(p);
   } else if (kind == token_Kind_KW_void) {
      ast_TypeRefHolder_setVoid(ref, p->tok.loc);
      c2_parser_Parser_consumeToken(p);
   } else if (kind == token_Kind_Identifier) {
      c2_parser_Parser_parseFullTypeIdentifier(p, ref);
      if (ref->user.name_idx == p->va_list_idx) c2_parser_Parser_addImplicitImport(p, p->varargs_idx, true);
   } else {
      c2_parser_Parser_error(p, "expected type specifier");
   }
   uint32_t depth = 0;
   while (p->tok.kind == token_Kind_Star) {
      depth++;
      if (depth > 3) c2_parser_Parser_error(p, "pointers have a maximum nesting of 3");
      ast_TypeRefHolder_addPointer(ref);
      c2_parser_Parser_consumeToken(p);
   }
}

static void c2_parser_Parser_parseFullTypeIdentifier(c2_parser_Parser* p, ast_TypeRefHolder* ref)
{
   ast_TypeRefHolder_setUser(ref, p->tok.loc, p->tok.name_idx);
   c2_parser_Parser_consumeToken(p);
   if (p->tok.kind == token_Kind_Dot) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      ast_TypeRefHolder_setPrefix(ref, p->tok.loc, p->tok.name_idx);
      c2_parser_Parser_consumeToken(p);
   }
}

static void c2_parser_Parser_dump_token(c2_parser_Parser* p, const token_Token* tok)
{
   string_buffer_Buf* out = p->tokenizer.buf;
   string_buffer_Buf_clear(out);
   if (token_Kind_isKeyword(tok->kind)) string_buffer_Buf_color(out, color_Green);
   string_buffer_Buf_print(out, "%12s", token_Kind_str(tok->kind));
   if (token_Kind_isKeyword(tok->kind)) string_buffer_Buf_color(out, color_Normal);
   char locstr[256];
   source_mgr_SourceMgr_loc2str(p->sm, tok->loc, locstr, 256);
   string_buffer_Buf_print(out, "  %6u %s  ", tok->loc, locstr);
   string_buffer_Buf_color(out, color_Cyan);
   switch (tok->kind) {
   case token_Kind_Identifier:
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(p->pool, tok->name_idx));
      break;
   case token_Kind_IntegerLiteral:
      switch (token_Token_getRadix(tok)) {
      case number_radix_Radix_Default:
         string_buffer_Buf_print(out, "%lu", tok->int_value);
         break;
      case number_radix_Radix_Hex:
         string_buffer_Buf_print(out, "0x%lx", tok->int_value);
         break;
      case number_radix_Radix_Octal:
         string_buffer_Buf_print(out, "0%lo", tok->int_value);
         break;
      case number_radix_Radix_Binary:
         string_buffer_Buf_print(out, "0b%lb", tok->int_value);
         break;
      }
      break;
   case token_Kind_FloatLiteral:
      switch (token_Token_getRadix(tok)) {
      case number_radix_Radix_Hex:
         string_buffer_Buf_print(out, "%a", tok->float_value);
         break;
      default: {
         char buf[32];
         string_buffer_Buf_add(out, ast_ftoa(buf, 32, tok->float_value));
         break;
      }
      }
      if (tok->suffix_F) string_buffer_Buf_add1(out, 'F');
      break;
   case token_Kind_CharLiteral:
      switch (token_Token_getRadix(tok)) {
      case number_radix_Radix_Hex:
         string_buffer_Buf_print(out, "'\\x%02x'", tok->char_value);
         break;
      case number_radix_Radix_Octal:
         string_buffer_Buf_print(out, "'\\%o'", tok->char_value);
         break;
      default: {
         char cc = tok->char_value;
         string_buffer_Buf_add1(out, '\'');
         string_buffer_Buf_encodeBytes(out, &cc, 1, '\'');
         string_buffer_Buf_add1(out, '\'');
         break;
      }
      }
      break;
   case token_Kind_StringLiteral:
      string_buffer_Buf_add1(out, '"');
      string_buffer_Buf_encodeBytes(out, string_pool_Pool_idx2str(p->pool, tok->text_idx), tok->text_len, '"');
      string_buffer_Buf_add1(out, '"');
      string_buffer_Buf_color(out, color_Normal);
      string_buffer_Buf_print(out, " (len %u)", tok->text_len);
      break;
   case token_Kind_LineComment:
      string_buffer_Buf_add(out, "//");
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(p->pool, tok->text_idx));
      break;
   case token_Kind_BlockComment:
      string_buffer_Buf_add(out, "/*");
      string_buffer_Buf_add(out, string_pool_Pool_idx2str(p->pool, tok->text_idx));
      string_buffer_Buf_add(out, "*/");
      break;
   case token_Kind_Error:
      string_buffer_Buf_color(out, color_Red);
      string_buffer_Buf_add(out, p->tokenizer.error_msg);
      break;
   default:
      break;
   }
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_newline(out);
   fputs(string_buffer_Buf_data(out), stdout);
}

static bool c2_parser_Parser_checkName(c2_parser_Parser* p, uint32_t name_idx, bool is_interface)
{
   if (is_interface) return true;
   const char* name = string_pool_Pool_idx2str(p->pool, name_idx);
   return islower(name[0]);
}

static stmt_list_List* c2_parser_Parser_getStmtList(c2_parser_Parser* p)
{
   ;//assert(p->stmt_list_count < c2_parser_NumStmtLists);
   stmt_list_List* l = &p->stmt_lists[p->stmt_list_count++];
   stmt_list_List_clear(l);
   return l;
}

static void c2_parser_Parser_putStmtList(c2_parser_Parser* p)
{
   p->stmt_list_count--;
}

static ast_Expr* c2_parser_Parser_parseExpr(c2_parser_Parser* p)
{
   ast_Expr* lhs = c2_parser_Parser_parseAssignmentExpression(p);
   if (ast_Expr_isInitlistAssignment(lhs)) return lhs;
   return c2_parser_Parser_parseRHSOfBinaryExpression(p, lhs, c2_prec_Prec_Comma);
}

static ast_Expr* c2_parser_Parser_parseAssignmentExpression(c2_parser_Parser* p)
{
   ast_Expr* lhs = c2_parser_Parser_parseCastExpr(p, false, false);
   return c2_parser_Parser_parseRHSOfBinaryExpression(p, lhs, c2_prec_Prec_Assignment);
}

static ast_Expr* c2_parser_Parser_parseRHSOfBinaryExpression(c2_parser_Parser* p, ast_Expr* lhs, c2_prec_Prec minPrec)
{
   c2_prec_Prec nextTokPrec = c2_parser_BinOpPrecLookup[p->tok.kind];
   src_loc_SrcLoc colonLoc = 0;
   while (1) {
      if (nextTokPrec < minPrec) return lhs;
      if (p->tok.kind == token_Kind_Comma) return lhs;
      token_Token opToken = p->tok;
      c2_parser_Parser_consumeToken(p);
      ast_Expr* ternaryMiddle = NULL;
      if (nextTokPrec == c2_prec_Prec_Conditional) {
         if (p->tok.kind == token_Kind_Colon) {
            c2_parser_Parser_error(p, "TODO conditional expr");
         } else {
            ternaryMiddle = c2_parser_Parser_parseExpr(p);
         }
         if (p->tok.kind == token_Kind_Colon) {
            colonLoc = p->tok.loc;
            c2_parser_Parser_consumeToken(p);
         }
      }
      if (p->tok.kind == token_Kind_LBrace && opToken.kind == token_Kind_Equal) {
         ast_Expr* rhs = c2_parser_Parser_parseInitList(p);
         ast_BinaryOpcode opcode = ast_BinaryOpcode_Assign;
         return ast_builder_Builder_actOnBinaryOperator(p->builder, opToken.loc, opcode, lhs, rhs);
      }
      ast_Expr* rhs = c2_parser_Parser_parseCastExpr(p, false, false);
      c2_prec_Prec thisPrec = nextTokPrec;
      nextTokPrec = c2_parser_BinOpPrecLookup[p->tok.kind];
      bool isRightAssoc = (thisPrec == c2_prec_Prec_Conditional || thisPrec == c2_prec_Prec_Assignment);
      if (thisPrec < nextTokPrec || (thisPrec == nextTokPrec && isRightAssoc)) {
         rhs = c2_parser_Parser_parseRHSOfBinaryExpression(p, rhs, (c2_prec_Prec)(thisPrec + !isRightAssoc));
         nextTokPrec = c2_parser_BinOpPrecLookup[p->tok.kind];
      }
      if (ternaryMiddle) {
         lhs = ast_builder_Builder_actOnConditionalOperator(p->builder, opToken.loc, colonLoc, lhs, ternaryMiddle, rhs);
      } else {
         ast_BinaryOpcode opcode = c2_parser_BinOpTokenLookup[opToken.kind];
         lhs = ast_builder_Builder_actOnBinaryOperator(p->builder, opToken.loc, opcode, lhs, rhs);
      }
   }
}

static ast_UnaryOpcode c2_parser_convertTokenToUnaryOpcode(token_Kind kind)
{
   switch (kind) {
   case token_Kind_Exclaim:
      return ast_UnaryOpcode_LNot;
   case token_Kind_Star:
      return ast_UnaryOpcode_Deref;
   case token_Kind_Amp:
      return ast_UnaryOpcode_AddrOf;
   case token_Kind_PlusPlus:
      return ast_UnaryOpcode_PreInc;
   case token_Kind_Plus:
      return ast_UnaryOpcode_Plus;
   case token_Kind_Minus:
      return ast_UnaryOpcode_Minus;
   case token_Kind_MinusMinus:
      return ast_UnaryOpcode_PreDec;
   case token_Kind_Tilde:
      return ast_UnaryOpcode_Not;
   default:
      ;//assert(0);
      break;
   }
   return ast_UnaryOpcode_PreInc;
}

static ast_Expr* c2_parser_Parser_parseCastExpr(c2_parser_Parser* p, bool _arg1, bool _arg2)
{
   token_Kind savedKind = p->tok.kind;
   ast_Expr* res = NULL;
   bool couldBeTemplateCall = false;
   switch (c2_parser_CastExprTokenLookup[savedKind]) {
   case 0:
      c2_parser_Parser_error(p, "expected expression");
      break;
   case 1:
      res = c2_parser_Parser_parsePureMemberExpr(p);
      couldBeTemplateCall = true;
      break;
   case 2: {
      uint64_t val = p->tok.int_value;
      ast_BuiltinKind kind;
      if (val <= i32_max) kind = ast_BuiltinKind_Int32;
      else if (val <= u32_max && token_Token_getRadix(&p->tok) != number_radix_Radix_Default) kind = ast_BuiltinKind_UInt32;
      else if (val <= i64_max) kind = ast_BuiltinKind_Int64;
      else kind = ast_BuiltinKind_UInt64;
      res = ast_builder_Builder_actOnIntegerLiteral(p->builder, p->tok.loc, p->tok.len, p->tok.int_value, token_Token_getRadix(&p->tok), kind);
      c2_parser_Parser_consumeToken(p);
      break;
   }
   case 3: {
      ast_BuiltinKind kind = p->tok.suffix_F ? ast_BuiltinKind_Float32 : ast_BuiltinKind_Float64;
      res = ast_builder_Builder_actOnFloatLiteral(p->builder, p->tok.loc, p->tok.len, p->tok.float_value, token_Token_getRadix(&p->tok), kind);
      c2_parser_Parser_consumeToken(p);
      break;
   }
   case 4:
      res = ast_builder_Builder_actOnCharLiteral(p->builder, p->tok.loc, p->tok.len, p->tok.char_value, token_Token_getRadix(&p->tok));
      c2_parser_Parser_consumeToken(p);
      break;
   case 5:
      res = c2_parser_Parser_parseStringLiteral(p);
      break;
   case 6:
      res = c2_parser_Parser_parseParenExpr(p);
      break;
   case 7: {
      src_loc_SrcLoc loc = p->tok.loc;
      c2_parser_Parser_consumeToken(p);
      bool is_addrof_op = (savedKind == token_Kind_Amp);
      res = c2_parser_Parser_parseCastExpr(p, false, is_addrof_op);
      ast_UnaryOpcode opcode = c2_parser_convertTokenToUnaryOpcode(savedKind);
      return ast_builder_Builder_actOnUnaryOperator(p->builder, loc, opcode, res);
   }
   case 8:
      res = c2_parser_Parser_parseExplicitCastExpr(p);
      break;
   case 9:
      res = c2_parser_Parser_parseElemsof(p);
      break;
   case 10:
      return c2_parser_Parser_parseEnumMinMax(p, savedKind == token_Kind_KW_enum_min);
   case 11:
      res = ast_builder_Builder_actOnBooleanConstant(p->builder, p->tok.loc, savedKind == token_Kind_KW_true);
      c2_parser_Parser_consumeToken(p);
      break;
   case 12:
      res = ast_builder_Builder_actOnNilExpr(p->builder, p->tok.loc);
      c2_parser_Parser_consumeToken(p);
      break;
   case 13:
      return c2_parser_Parser_parseOffsetOfExpr(p);
   case 14:
      return c2_parser_Parser_parseSizeof(p);
   case 15:
      res = c2_parser_Parser_parseToContainerExpr(p);
      break;
   case 16:
      if (c2_parser_Parser_peekToken(p, 1) == token_Kind_Dot) {
         c2_parser_Parser_addImplicitImport(p, p->tok.name_idx, false);
         res = c2_parser_Parser_parsePureMemberExpr(p);
      } else {
         c2_parser_Parser_error(p, "expected expression");
      }
      break;
   }
   return c2_parser_Parser_parsePostfixExprSuffix(p, res, couldBeTemplateCall);
}

static ast_Expr* c2_parser_Parser_parsePostfixExprSuffix(c2_parser_Parser* p, ast_Expr* lhs, bool couldBeTemplateCall)
{
   while (1) {
      switch (p->tok.kind) {
      case token_Kind_Identifier:
         return lhs;
      case token_Kind_LParen:
         lhs = c2_parser_Parser_parseCallExpr(p, lhs);
         break;
      case token_Kind_LSquare: {
         src_loc_SrcLoc loc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* idx = c2_parser_Parser_parseExpr(p);
         if (p->tok.kind == token_Kind_Colon) {
            src_loc_SrcLoc colon_loc = p->tok.loc;
            c2_parser_Parser_consumeToken(p);
            ast_Expr* rhs = c2_parser_Parser_parseExpr(p);
            idx = ast_builder_Builder_actOnBitOffsetExpr(p->builder, colon_loc, idx, rhs);
         }
         uint32_t src_len = p->tok.loc + 1 - loc;
         c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
         lhs = ast_builder_Builder_actOnArraySubscriptExpr(p->builder, loc, src_len, lhs, idx);
         break;
      }
      case token_Kind_Dot:
         lhs = c2_parser_Parser_parseImpureMemberExpr(p, lhs);
         break;
      case token_Kind_PlusPlus:
         lhs = ast_builder_Builder_actOnUnaryOperator(p->builder, p->tok.loc, ast_UnaryOpcode_PostInc, lhs);
         c2_parser_Parser_consumeToken(p);
         break;
      case token_Kind_MinusMinus:
         lhs = ast_builder_Builder_actOnUnaryOperator(p->builder, p->tok.loc, ast_UnaryOpcode_PostDec, lhs);
         c2_parser_Parser_consumeToken(p);
         break;
      case token_Kind_Less:
         if (couldBeTemplateCall && c2_parser_Parser_isTemplateFunctionCall(p)) {
            c2_parser_Parser_consumeToken(p);
            ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
            c2_parser_Parser_parseTypeSpecifier(p, &ref);
            c2_parser_Parser_expectAndConsume(p, token_Kind_Greater);
            if (p->tok.kind != token_Kind_LParen) {
               c2_parser_Parser_error(p, "missing argument list for template function call");
            }
            lhs = c2_parser_Parser_parseTemplateCallExpr(p, lhs, &ref);
            break;
         }
         return lhs;
      default:
         return lhs;
      }
   }
}

static ast_Expr* c2_parser_Parser_parseCallExpr(c2_parser_Parser* p, ast_Expr* func)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_ExprList args; ast_ExprList_init(&args);
   while (p->tok.kind != token_Kind_RParen) {
      if (p->tok.kind == token_Kind_Identifier && c2_parser_Parser_peekToken(p, 1) == token_Kind_Colon) {
         src_loc_SrcLoc nameLoc = p->tok.loc;
         uint32_t name_idx = p->tok.name_idx;
         c2_parser_Parser_consumeToken(p);
         c2_parser_Parser_consumeToken(p);
         ast_Expr* inner = (p->tok.kind == token_Kind_LBrace) ? c2_parser_Parser_parseInitList(p) : c2_parser_Parser_parseExpr(p);
         ast_Expr* arg = ast_builder_Builder_actOnNamedArgument(p->builder, nameLoc, name_idx, inner);
         ast_ExprList_add(&args, arg);
      } else if (p->tok.kind == token_Kind_LBrace) {
         ast_ExprList_add(&args, c2_parser_Parser_parseInitList(p));
      } else {
         ast_ExprList_add(&args, c2_parser_Parser_parseExpr(p));
      }
      if (p->tok.kind != token_Kind_Comma) break;
      c2_parser_Parser_consumeToken(p);
   }
   src_loc_SrcLoc endLoc = p->tok.loc + 1;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   ast_Expr* res = ast_builder_Builder_actOnCallExpr(p->builder, loc, endLoc, func, ast_ExprList_getExprs(&args), ast_ExprList_size(&args));
   ast_ExprList_free(&args);
   return res;
}

static ast_Expr* c2_parser_Parser_parseTemplateCallExpr(c2_parser_Parser* p, ast_Expr* func, const ast_TypeRefHolder* ref)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_ExprList args; ast_ExprList_init(&args);
   while (p->tok.kind != token_Kind_RParen) {
      ast_ExprList_add(&args, c2_parser_Parser_parseExpr(p));
      if (p->tok.kind != token_Kind_Comma) break;
      c2_parser_Parser_consumeToken(p);
   }
   src_loc_SrcLoc endLoc = p->tok.loc + 1;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   ast_Expr* res = ast_builder_Builder_actOnTemplateCallExpr(p->builder, loc, endLoc, func, ast_ExprList_getExprs(&args), ast_ExprList_size(&args), ref);
   ast_ExprList_free(&args);
   return res;
}

static ast_Expr* c2_parser_Parser_parseImpureMemberExpr(c2_parser_Parser* p, ast_Expr* base)
{
   for (;;) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectIdentifier(p);
      base = ast_builder_Builder_actOnMemberExpr(p->builder, base, 0, 0, p->tok.loc, p->tok.name_idx);
      c2_parser_Parser_consumeToken(p);
      if (p->tok.kind != token_Kind_Dot) break;
   }
   return base;
}

static ast_Expr* c2_parser_Parser_parsePureMemberExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   uint32_t name_idx = p->tok.name_idx;
   uint32_t name_len = p->tok.len;
   c2_parser_Parser_consumeToken(p);
   if (p->tok.kind != token_Kind_Dot) return ast_builder_Builder_actOnIdentifier(p->builder, loc, name_idx, name_len);
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   ast_Expr* lhs = ast_builder_Builder_actOnMemberExpr(p->builder, NULL, name_idx, name_len, p->tok.loc, p->tok.name_idx);
   c2_parser_Parser_consumeToken(p);
   if (p->tok.kind != token_Kind_Dot) return lhs;
   return c2_parser_Parser_parseImpureMemberExpr(p, lhs);
}

static ast_Expr* c2_parser_Parser_parseStringLiteral(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   uint32_t src_len = p->tok.len;
   uint32_t idx = p->tok.text_idx;
   uint32_t len = p->tok.text_len;
   c2_parser_Parser_consumeToken(p);
   if (p->tok.kind == token_Kind_StringLiteral) {
      char* tmp = p->multi_string;
      const char* p1 = string_pool_Pool_idx2str(p->pool, idx);
      if (len > constants_MaxMultiString) {
         c2_parser_Parser_error(p, "multi-string literal too long");
      }
      memcpy(tmp, p1, len);
      while (p->tok.kind == token_Kind_StringLiteral) {
         const char* p2 = string_pool_Pool_idx2str(p->pool, p->tok.text_idx);
         size_t len2 = p->tok.text_len;
         if (len + len2 > constants_MaxMultiString) {
            c2_parser_Parser_error(p, "multi-string literal too long");
         }
         memcpy(tmp + len, p2, len2);
         len += len2;
         src_len = p->tok.loc + p->tok.len - loc;
         c2_parser_Parser_consumeToken(p);
      }
      idx = string_pool_Pool_add(p->pool, tmp, len, true);
   }
   return ast_builder_Builder_actOnStringLiteral(p->builder, loc, src_len, idx, len);
}

static ast_Expr* c2_parser_Parser_parseParenExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   if (c2_parser_Parser_parseAsCastType(p, 0, token_Kind_RParen)) {
      ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
      c2_parser_Parser_parseTypeSpecifier(p, &ref);
      c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
      if (p->tok.kind == token_Kind_LBrace) {
         c2_parser_Parser_error(p, "Compound literals are not supported");
      } else {
         if (ast_TypeRefHolder_isArray(&ref)) c2_parser_Parser_error(p, "array types are not allowed here");
         ast_Expr* expr = c2_parser_Parser_parseCastExpr(p, false, false);
         uint32_t src_len = p->prev_loc - loc;
         return ast_builder_Builder_actOnExplicitCast(p->builder, loc, src_len, &ref, expr, true);
      }
   }
   ast_Expr* res = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnParenExpr(p->builder, loc, src_len, res);
}

static bool c2_parser_Parser_isTemplateFunctionCall(c2_parser_Parser* p)
{
   ;//assert(p->tok.kind == token_Kind_Less);
   token_Kind kind = c2_parser_Parser_peekToken(p, 1);
   if (kind != token_Kind_Identifier) {
      if (token_Kind_isQualifier(kind)) return true;
      return token_Kind_isBuiltinTypeOrVoid(kind) && (c2_parser_Parser_peekToken(p, 2) != token_Kind_Dot);
   }
   uint32_t stars = 0;
   for (uint32_t ahead = 2; ahead < 8; ahead++) {
      switch (c2_parser_Parser_peekToken(p, ahead)) {
      case token_Kind_Identifier:
         if (stars) return false;
         break;
      case token_Kind_Star:
         stars++;
         break;
      case token_Kind_Dot:
         break;
      case token_Kind_Greater:
         return c2_parser_Parser_peekToken(p, ahead + 1) == token_Kind_LParen;
      case token_Kind_KW_const:
      case token_Kind_KW_volatile:
         return true;
      default:
         return false;
      }
   }
   return false;
}

static ast_Expr* c2_parser_Parser_parseSizeof(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* res = NULL;
   if (c2_parser_Parser_parseAsType(p)) {
      src_loc_SrcLoc type_loc = p->tok.loc;
      ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
      c2_parser_Parser_parseTypeSpecifier(p, &ref);
      uint32_t src_len = p->prev_loc - type_loc;
      res = ast_builder_Builder_actOnTypeExpr(p->builder, type_loc, src_len, &ref);
   } else {
      res = c2_parser_Parser_parseExpr(p);
   }
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnBuiltinExpr(p->builder, loc, src_len, res, ast_BuiltinExprKind_Sizeof);
}

static ast_Expr* c2_parser_Parser_parseElemsof(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* res = c2_parser_Parser_parseFullIdentifier(p);
   res = c2_parser_Parser_parsePostfixExprSuffix(p, res, false);
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnBuiltinExpr(p->builder, loc, src_len, res, ast_BuiltinExprKind_Elemsof);
}

static ast_Expr* c2_parser_Parser_parseInitValue(c2_parser_Parser* p, bool allow_designators)
{
   switch (p->tok.kind) {
   case token_Kind_LBrace:
      return c2_parser_Parser_parseInitList(p);
   case token_Kind_Dot:
      if (!allow_designators) c2_parser_Parser_error(p, "designator not allowed here");
      return c2_parser_Parser_parseFieldDesignator(p);
   case token_Kind_LSquare:
      if (!allow_designators) c2_parser_Parser_error(p, "designator not allowed here");
      return c2_parser_Parser_parseArrayDesignator(p);
   default:
      break;
   }
   return c2_parser_Parser_parseAssignmentExpression(p);
}

static ast_Expr* c2_parser_Parser_parseInitList(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   ast_ExprList values; ast_ExprList_init(&values);
   while (p->tok.kind != token_Kind_RBrace) {
      ast_Expr* e = c2_parser_Parser_parseInitValue(p, true);
      ast_ExprList_add(&values, e);
      if (p->tok.kind == token_Kind_Comma) {
         c2_parser_Parser_consumeToken(p);
      } else {
         break;
      }
   }
   if (p->tok.kind == token_Kind_LBrace) c2_parser_Parser_expect(p, token_Kind_Comma);
   src_loc_SrcLoc endLoc = p->tok.loc + 1;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_Expr* e = ast_builder_Builder_actOnInitList(p->builder, loc, endLoc, ast_ExprList_getExprs(&values), ast_ExprList_size(&values));
   ast_ExprList_free(&values);
   return e;
}

static ast_Expr* c2_parser_Parser_parseFieldDesignator(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t field = p->tok.name_idx;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Equal);
   ast_Expr* value = c2_parser_Parser_parseInitValue(p, false);
   return ast_builder_Builder_actOnFieldDesignatedInit(p->builder, loc, field, value);
}

static ast_Expr* c2_parser_Parser_parseArrayDesignator(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Expr* designator = c2_parser_Parser_parseAssignmentExpression(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Equal);
   ast_Expr* initValue = c2_parser_Parser_parseInitValue(p, false);
   return ast_builder_Builder_actOnArrayDesignatedInit(p->builder, loc, designator, initValue);
}

static ast_Expr* c2_parser_Parser_parseExplicitCastExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Less);
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Greater);
   if (ast_TypeRefHolder_isArray(&ref)) c2_parser_Parser_error(p, "array types are not allowed here");
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* expr = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnExplicitCast(p->builder, loc, src_len, &ref, expr, false);
}

static ast_Expr* c2_parser_Parser_parseEnumMinMax(c2_parser_Parser* p, bool is_min)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   c2_parser_Parser_expectIdentifier(p);
   ast_Expr* expr = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnBuiltinExpr(p->builder, loc, src_len, expr, is_min ? ast_BuiltinExprKind_EnumMin : ast_BuiltinExprKind_EnumMax);
}

static ast_Expr* c2_parser_Parser_parseOffsetOfExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* structExpr = c2_parser_Parser_parseFullIdentifier(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* member = c2_parser_Parser_parseFullIdentifier(p);
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnOffsetOfExpr(p->builder, loc, src_len, structExpr, member);
}

static ast_Expr* c2_parser_Parser_parseToContainerExpr(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* structExpr = c2_parser_Parser_parseFullIdentifier(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* member = c2_parser_Parser_parseFullIdentifier(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   ast_Expr* pointer = c2_parser_Parser_parseExpr(p);
   uint32_t src_len = p->tok.loc + 1 - loc;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return ast_builder_Builder_actOnToContainerExpr(p->builder, loc, src_len, structExpr, member, pointer);
}

static ast_Expr* c2_parser_Parser_parseFullIdentifier(c2_parser_Parser* p)
{
   c2_parser_Parser_expectIdentifier(p);
   return c2_parser_Parser_parsePureMemberExpr(p);
}

static bool c2_parser_Parser_parseAsType(c2_parser_Parser* p)
{
   token_Kind kind = p->tok.kind;
   if (kind != token_Kind_Identifier) {
      if (token_Kind_isQualifier(kind)) return true;
      return token_Kind_isBuiltinTypeOrVoid(kind) && (c2_parser_Parser_peekToken(p, 1) != token_Kind_Dot);
   }
   token_Token t2 = p->tok;
   uint32_t ahead = 1;
   while (c2_parser_Parser_peekToken(p, ahead) == token_Kind_Dot) {
      if (c2_parser_Parser_peekToken2(p, ahead + 1, &t2) != token_Kind_Identifier) return false;
      ahead += 2;
   }
   int32_t stars = 0;
   for (;; ahead++) {
      switch (c2_parser_Parser_peekToken(p, ahead)) {
      case token_Kind_RParen:
         if (stars) return true;
         return false;
      case token_Kind_LSquare:
         if (stars) return true;
         if (!isupper(*string_pool_Pool_idx2str(p->pool, t2.name_idx))) return false;
         return true;
      case token_Kind_Star:
         if (stars) return true;
         stars++;
         break;
      case token_Kind_Less:
         if (!isupper(*string_pool_Pool_idx2str(p->pool, t2.name_idx))) return false;
         return true;
      case token_Kind_KW_const:
      case token_Kind_KW_volatile:
         return true;
      default:
         return false;
      }
   }
}

static uint32_t c2_parser_Parser_parseAsCastType(c2_parser_Parser* p, uint32_t ahead, token_Kind close_tok)
{
   token_Token t2 = p->tok;
   bool ambiguous = true;
   for (;;) {
      if (ahead) c2_parser_Parser_peekToken2(p, ahead, &t2);
      ahead++;
      token_Kind kind = t2.kind;
      if (token_Kind_isBuiltinTypeOrVoid(kind)) {
         ambiguous = false;
         break;
      }
      if (token_Kind_isQualifier(kind)) {
         ambiguous = false;
         continue;
      }
      if (kind != token_Kind_Identifier) return 0;
      while (c2_parser_Parser_peekToken(p, ahead) == token_Kind_Dot) {
         if (c2_parser_Parser_peekToken2(p, ahead + 1, &t2) != token_Kind_Identifier) return 0;
         ahead += 2;
      }
      break;
   }
   int32_t stars = 0;
   while (1) {
      switch (c2_parser_Parser_peekToken(p, ahead)) {
      case token_Kind_Star:
         if (stars < 0) return 0;
         if (stars > 0) ambiguous = false;
         stars++;
         ahead++;
         break;
      case token_Kind_RParen:
         if (close_tok != token_Kind_RParen) return 0;
         ahead++;
         if (!ambiguous) return ahead;
         switch (c2_parser_Parser_peekToken(p, ahead)) {
         case token_Kind_Identifier:
         case token_Kind_IntegerLiteral:
         case token_Kind_FloatLiteral:
         case token_Kind_CharLiteral:
         case token_Kind_StringLiteral:
         case token_Kind_Tilde:
         case token_Kind_Exclaim:
         case token_Kind_KW_cast:
         case token_Kind_KW_elemsof:
         case token_Kind_KW_enum_min:
         case token_Kind_KW_enum_max:
         case token_Kind_KW_false:
         case token_Kind_KW_true:
         case token_Kind_KW_nil:
         case token_Kind_KW_offsetof:
         case token_Kind_KW_sizeof:
         case token_Kind_KW_to_container:
         case token_Kind_LBrace:
            return ahead;
         case token_Kind_PlusPlus:
         case token_Kind_MinusMinus:
         case token_Kind_LParen:
         case token_Kind_Amp:
         case token_Kind_Plus:
         case token_Kind_Minus:
         case token_Kind_Star:
            if (!isupper(string_pool_Pool_idx2str(p->pool, t2.name_idx)[0])) return 0;
            return ahead;
         default:
            break;
         }
         return 0;
      case token_Kind_LSquare:
         ahead = c2_parser_Parser_skipArray(p, ahead + 1, token_Kind_RSquare);
         if (!ahead) return 0;
         stars = -1;
         break;
      case token_Kind_Less:
         ahead = c2_parser_Parser_parseAsCastType(p, ahead, token_Kind_Greater);
         if (!ahead) return 0;
         stars = 0;
         break;
      case token_Kind_Greater:
         if (close_tok != token_Kind_Greater) return 0;
         ahead++;
         return ahead;
      default:
         return 0;
      }
   }
}

static ast_Stmt* c2_parser_Parser_parseStmt(c2_parser_Parser* p)
{
   switch (p->tok.kind) {
   case token_Kind_Identifier:
      return c2_parser_Parser_parseDeclOrStmt(p);
   case token_Kind_LBrace:
      return (ast_Stmt*)c2_parser_Parser_parseCompoundStmt(p);
   case token_Kind_RBrace:
      c2_parser_Parser_error(p, "expected statement");
      break;
   case token_Kind_KW_asm:
      return c2_parser_Parser_parseAsmStmt(p);
   case token_Kind_KW_assert:
      return c2_parser_Parser_parseAssertStmt(p);
   case token_Kind_KW_break:
      return c2_parser_Parser_parseBreakStmt(p);
   case token_Kind_KW_continue:
      return c2_parser_Parser_parseContinueStmt(p);
   case token_Kind_KW_fallthrough:
      return c2_parser_Parser_parseFallthroughStmt(p);
   case token_Kind_KW_for:
      return c2_parser_Parser_parseForStmt(p);
   case token_Kind_KW_goto:
      return c2_parser_Parser_parseGotoStmt(p);
   case token_Kind_KW_if:
      return c2_parser_Parser_parseIfStmt(p);
   case token_Kind_KW_return:
      return c2_parser_Parser_parseReturnStmt(p);
   case token_Kind_KW_switch:
      return c2_parser_Parser_parseSwitchStmt(p);
   case token_Kind_KW_bool:
   case token_Kind_KW_char:
   case token_Kind_KW_const:
   case token_Kind_KW_i8:
   case token_Kind_KW_i16:
   case token_Kind_KW_i32:
   case token_Kind_KW_i64:
   case token_Kind_KW_isize:
   case token_Kind_KW_f32:
   case token_Kind_KW_f64:
   case token_Kind_KW_local:
   case token_Kind_KW_reg8:
   case token_Kind_KW_reg16:
   case token_Kind_KW_reg32:
   case token_Kind_KW_reg64:
   case token_Kind_KW_u8:
   case token_Kind_KW_u16:
   case token_Kind_KW_u32:
   case token_Kind_KW_u64:
   case token_Kind_KW_usize:
   case token_Kind_KW_volatile:
   case token_Kind_KW_void:
      return c2_parser_Parser_parseDeclStmt(p, true, true, false);
   case token_Kind_KW_while:
      return c2_parser_Parser_parseWhileStmt(p);
   default:
      return c2_parser_Parser_parseExprStmt(p);
   }
   return NULL;
}

static bool c2_parser_Parser_isTypeSpec(c2_parser_Parser* p)
{
   ;//assert(p->tok.kind == token_Kind_Identifier);
   token_Kind kind;
   uint32_t state = 0;
   uint32_t ahead = 1;
   while (1) {
      switch (c2_parser_Parser_peekToken(p, ahead++)) {
      case token_Kind_Identifier:
         if (state == 4) return false;
         state = 4;
         break;
      case token_Kind_LSquare:
         if (state == 4) return false;
         ahead = c2_parser_Parser_skipArray(p, ahead, token_Kind_RSquare);
         state = 3;
         break;
      case token_Kind_Star:
         if (state >= 3) return false;
         state = 2;
         break;
      case token_Kind_Dot:
         if (state == 4) {
            return true;
         }
         if (state == 0) {
            kind = c2_parser_Parser_peekToken(p, ahead++);
            if (kind != token_Kind_Identifier) {
               return false;
            }
            state = 2;
         } else {
            return false;
         }
         break;
      case token_Kind_Equal:
      case token_Kind_Semicolon:
      case token_Kind_Comma:
         return state == 4;
      default:
         return false;
      }
   }
}

static uint32_t c2_parser_Parser_skipArray(c2_parser_Parser* p, uint32_t ahead, token_Kind endKind)
{
   uint32_t depth = 1;
   token_Kind closeKind[8] = { endKind };
   while (depth > 0) {
      token_Token next;
      if (depth >= 8 || ahead >= c2_parser_MaxLookahead) {
         c2_parser_Parser_error(p, "expression too complex");
      }
      switch (c2_parser_Parser_peekToken2(p, ahead++, &next)) {
      case token_Kind_LParen:
         closeKind[depth++] = token_Kind_RParen;
         break;
      case token_Kind_RParen:
         if (closeKind[--depth] != token_Kind_RParen) {
            c2_parser_Parser_errorAt(p, next.loc, "expected ']'");
         }
         break;
      case token_Kind_LSquare:
         closeKind[depth++] = token_Kind_RSquare;
         break;
      case token_Kind_RSquare:
         if (closeKind[--depth] != token_Kind_RSquare) {
            c2_parser_Parser_errorAt(p, next.loc, "expected ')'");
         }
         break;
      case token_Kind_Eof:
         c2_parser_Parser_errorAt(p, next.loc, "unexpected end-of-file");
         break;
      default:
         break;
      }
   }
   return ahead;
}

static ast_Stmt* c2_parser_Parser_parseDeclOrStmt(c2_parser_Parser* p)
{
   ;//assert(p->tok.kind == token_Kind_Identifier);
   bool isDecl = c2_parser_Parser_isTypeSpec(p);
   if (isDecl) {
      return c2_parser_Parser_parseDeclStmt(p, true, true, false);
   }
   token_Kind kind = c2_parser_Parser_peekToken(p, 1);
   if (kind == token_Kind_Colon) return c2_parser_Parser_parseLabelStmt(p);
   return c2_parser_Parser_parseExprStmt(p);
}

static ast_CompoundStmt* c2_parser_Parser_parseCompoundStmt(c2_parser_Parser* p)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   stmt_list_List* stmts = c2_parser_Parser_getStmtList(p);
   while (p->tok.kind != token_Kind_RBrace) {
      stmt_list_List_add(stmts, c2_parser_Parser_parseStmt(p));
   }
   src_loc_SrcLoc endLoc = p->tok.loc + 1;
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_CompoundStmt* s = ast_builder_Builder_actOnCompoundStmt(p->builder, endLoc, stmt_list_List_getData(stmts), stmt_list_List_size(stmts));
   c2_parser_Parser_putStmtList(p);
   return s;
}

static ast_Stmt* c2_parser_Parser_parseAsmStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   uint32_t quals = c2_parser_Parser_parseOptionalTypeQualifier(p);
   bool is_volatile = (quals == ast_QualType_Volatile);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   c2_parser_Parser_expect(p, token_Kind_StringLiteral);
   ast_Expr* str = c2_parser_Parser_parseStringLiteral(p);
   ast_ExprList constraints; ast_ExprList_init(&constraints);
   ast_ExprList exprs; ast_ExprList_init(&exprs);
   ast_ExprList clobbers; ast_ExprList_init(&clobbers);
   if (p->tok.kind == token_Kind_RParen) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
      ast_Stmt* s = ast_builder_Builder_actOnAsmStmt(p->builder, loc, true, is_volatile, 0, 0, NULL, &constraints, &exprs, &clobbers, str);
      ast_ExprList_free(&constraints);
      ast_ExprList_free(&exprs);
      ast_ExprList_free(&clobbers);
      return s;
   }
   string_list_List names; string_list_List_init(&names, p->pool);
   if (p->tok.kind == token_Kind_Colon) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_parseAsmOperandsOpt(p, &names, &constraints, &exprs);
   }
   uint32_t num_outputs = string_list_List_length(&names);
   if (p->tok.kind == token_Kind_Colon) {
      c2_parser_Parser_consumeToken(p);
      c2_parser_Parser_parseAsmOperandsOpt(p, &names, &constraints, &exprs);
   }
   uint32_t num_inputs = string_list_List_length(&names) - num_outputs;
   if (p->tok.kind == token_Kind_Colon) {
      c2_parser_Parser_consumeToken(p);
      if (p->tok.kind != token_Kind_RParen) {
         while (1) {
            c2_parser_Parser_expect(p, token_Kind_StringLiteral);
            ast_Expr* e = c2_parser_Parser_parseStringLiteral(p);
            ast_ExprList_add(&clobbers, e);
            if (p->tok.kind != token_Kind_Comma) break;
            c2_parser_Parser_consumeToken(p);
         }
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_Stmt* s = ast_builder_Builder_actOnAsmStmt(p->builder, loc, false, is_volatile, num_outputs, num_inputs, string_list_List_getData(&names), &constraints, &exprs, &clobbers, str);
   string_list_List_free(&names);
   ast_ExprList_free(&constraints);
   ast_ExprList_free(&exprs);
   ast_ExprList_free(&clobbers);
   return s;
}

static void c2_parser_Parser_parseAsmOperandsOpt(c2_parser_Parser* p, string_list_List* names, ast_ExprList* constraints, ast_ExprList* exprs)
{
   if (p->tok.kind != token_Kind_StringLiteral && p->tok.kind != token_Kind_LSquare) return;
   while (1) {
      if (p->tok.kind == token_Kind_LSquare) {
         c2_parser_Parser_consumeToken(p);
         c2_parser_Parser_expectIdentifier(p);
         uint32_t name = p->tok.name_idx;
         c2_parser_Parser_consumeToken(p);
         string_list_List_add(names, name);
         c2_parser_Parser_expectAndConsume(p, token_Kind_RSquare);
      } else {
         string_list_List_add(names, 0);
      }
      c2_parser_Parser_expect(p, token_Kind_StringLiteral);
      ast_Expr* e = c2_parser_Parser_parseStringLiteral(p);
      ast_ExprList_add(constraints, e);
      c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
      e = c2_parser_Parser_parseExpr(p);
      c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
      ast_ExprList_add(exprs, e);
      if (p->tok.kind != token_Kind_Comma) return;
      c2_parser_Parser_consumeToken(p);
   }
}

static ast_Stmt* c2_parser_Parser_parseAssertStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Expr* inner = c2_parser_Parser_parseExpr(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnAssertStmt(p->builder, loc, inner);
}

static ast_Stmt* c2_parser_Parser_parseBreakStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnBreakStmt(p->builder, loc);
}

static ast_Stmt* c2_parser_Parser_parseContinueStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnContinueStmt(p->builder, loc);
}

static ast_Stmt* c2_parser_Parser_parseFallthroughStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnFallthroughStmt(p->builder, loc);
}

static ast_Stmt* c2_parser_Parser_parseCondition(c2_parser_Parser* p)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Stmt* s;
   if (c2_parser_Parser_isDeclaration(p)) {
      s = c2_parser_Parser_parseDeclStmt(p, false, false, true);
   } else {
      ast_Expr* cond = c2_parser_Parser_parseExpr(p);
      s = ast_Expr_asStmt(cond);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   return s;
}

static ast_Stmt* c2_parser_Parser_parseIfStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Stmt* cond = c2_parser_Parser_parseCondition(p);
   ast_Stmt* then = c2_parser_Parser_parseStmt(p);
   ast_Stmt* else_stmt = NULL;
   if (p->tok.kind == token_Kind_KW_else) {
      c2_parser_Parser_consumeToken(p);
      else_stmt = c2_parser_Parser_parseStmt(p);
   }
   return ast_builder_Builder_actOnIfStmt(p->builder, loc, cond, then, else_stmt);
}

static ast_Stmt* c2_parser_Parser_parseReturnStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Expr* ret = NULL;
   bool need_semi = true;
   if (p->tok.kind != token_Kind_Semicolon) {
      if (p->tok.kind == token_Kind_LBrace) {
         ret = c2_parser_Parser_parseInitList(p);
         need_semi = false;
      } else {
         ret = c2_parser_Parser_parseExpr(p);
      }
   }
   if (need_semi) c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnReturnStmt(p->builder, loc, ret);
}

static ast_Stmt* c2_parser_Parser_parseForStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Stmt* init = NULL;
   if (p->tok.kind != token_Kind_Semicolon) {
      if (c2_parser_Parser_isDeclaration(p)) {
         init = c2_parser_Parser_parseDeclStmt(p, false, false, false);
      } else {
         init = ast_Expr_asStmt(c2_parser_Parser_parseExpr(p));
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_Expr* cond = NULL;
   if (p->tok.kind != token_Kind_Semicolon) {
      cond = c2_parser_Parser_parseExpr(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   ast_Expr* incr = NULL;
   if (p->tok.kind != token_Kind_RParen) {
      incr = c2_parser_Parser_parseExpr(p);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   ast_Stmt* body = c2_parser_Parser_parseStmt(p);
   return ast_builder_Builder_actOnForStmt(p->builder, loc, init, cond, incr, body);
}

static ast_Stmt* c2_parser_Parser_parseWhileStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   ast_Stmt* cond = c2_parser_Parser_parseCondition(p);
   ast_Stmt* then = c2_parser_Parser_parseStmt(p);
   return ast_builder_Builder_actOnWhileStmt(p->builder, loc, cond, then);
}

static ast_Stmt* c2_parser_Parser_parseDeclStmt(c2_parser_Parser* p, bool checkSemi, bool allowLocal, bool isCondition)
{
   ast_VarDecl* decls[15];
   uint32_t num_decls = 0;
   bool has_local = false;
   if (p->tok.kind == token_Kind_KW_local) {
      has_local = true;
      if (!allowLocal) c2_parser_Parser_error(p, "keyword 'local' is not allowed here");
      c2_parser_Parser_consumeToken(p);
   }
   bool need_semi = true;
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref);
   for (;;) {
      c2_parser_Parser_expectIdentifier(p);
      uint32_t name = p->tok.name_idx;
      src_loc_SrcLoc loc = p->tok.loc;
      if (p->tok.reserved) {
         diagnostics_Diags_error(p->diags, loc, "reserved word '%s' cannot be used as variable name", string_pool_Pool_idx2str(p->pool, name));
      }
      c2_parser_Parser_consumeToken(p);
      bool has_init_call = false;
      need_semi = true;
      ast_Expr* initValue = NULL;
      src_loc_SrcLoc assignLoc = 0;
      switch (p->tok.kind) {
      case token_Kind_Equal:
         assignLoc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         initValue = c2_parser_Parser_parseInitValue(p, false);
         need_semi = checkSemi && ast_Expr_needsSemi(initValue);
         break;
      case token_Kind_At:
         c2_parser_Parser_error(p, "local variables cannot have attributes");
         break;
      case token_Kind_Dot:
         if (c2_parser_Parser_peekToken(p, 1) == token_Kind_Identifier && c2_parser_Parser_peekToken(p, 2) == token_Kind_LParen) {
            if (has_local) c2_parser_Parser_error(p, "local qualified variables cannot have an init call");
            if (isCondition) c2_parser_Parser_error(p, "cannot use an init call inside a condition");
            uint32_t name_len = p->tok.len;
            c2_parser_Parser_consumeToken(p);
            ast_Expr* func = ast_builder_Builder_actOnMemberExpr(p->builder, NULL, name, name_len, p->tok.loc, p->tok.name_idx);
            c2_parser_Parser_consumeToken(p);
            initValue = c2_parser_Parser_parseCallExpr(p, func);
            has_init_call = true;
            break;
         }
         break;
      case token_Kind_LSquare:
         c2_parser_Parser_error(p, "array indices should go after type");
         break;
      default:
         break;
      }
      decls[num_decls++] = ast_builder_Builder_actOnVarDecl(p->builder, name, loc, &ref, assignLoc, initValue, has_local, has_init_call);
      if (p->tok.kind != token_Kind_Comma) break;
      c2_parser_Parser_consumeToken(p);
      if (isCondition) c2_parser_Parser_error(p, "cannot define multiple variables in a condition");
      if (ast_TypeRefHolder_isPointer(&ref) || ast_TypeRefHolder_isArray(&ref)) c2_parser_Parser_error(p, "pointer and array variables must be defined separately");
      if (num_decls >= 15) c2_parser_Parser_error(p, "too many variables defined in a single statement");
   }
   if (checkSemi) {
      c2_parser_Parser_consumeSemicolon(p, need_semi);
   }
   return ast_builder_Builder_actOnDeclStmt(p->builder, decls, num_decls);
}

static ast_Stmt* c2_parser_Parser_parseExprStmt(c2_parser_Parser* p)
{
   ast_Expr* e = c2_parser_Parser_parseExpr(p);
   if (ast_Expr_needsSemi(e)) c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_Expr_asStmt(e);
}

static ast_Stmt* c2_parser_Parser_parseLabelStmt(c2_parser_Parser* p)
{
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Colon);
   ast_Stmt* stmt = NULL;
   switch (p->tok.kind) {
   case token_Kind_RBrace:
   case token_Kind_KW_case:
   case token_Kind_KW_default:
   case token_Kind_KW_fallthrough:
      break;
   default:
      stmt = c2_parser_Parser_parseStmt(p);
      break;
   }
   return ast_builder_Builder_actOnLabelStmt(p->builder, name, loc, stmt);
}

static ast_Stmt* c2_parser_Parser_parseGotoStmt(c2_parser_Parser* p)
{
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t name = p->tok.name_idx;
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   return ast_builder_Builder_actOnGotoStmt(p->builder, name, loc);
}

static bool c2_parser_Parser_isDeclaration(c2_parser_Parser* p)
{
   const token_Kind kind = p->tok.kind;
   if (kind == token_Kind_Identifier) return c2_parser_Parser_isTypeSpec(p);
   if (token_Kind_isBuiltinTypeOrVoid(kind)) return true;
   if (kind == token_Kind_KW_local) return true;
   if (token_Kind_isQualifier(kind)) return true;
   return false;
}

static ast_Stmt* c2_parser_Parser_parseSwitchStmt(c2_parser_Parser* p)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LParen);
   ast_Stmt* cond;
   if (c2_parser_Parser_isDeclaration(p)) {
      cond = c2_parser_Parser_parseDeclStmt(p, false, false, true);
   } else {
      ast_Expr* e = c2_parser_Parser_parseExpr(p);
      cond = ast_Expr_asStmt(e);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RParen);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   case_list_List cases; case_list_List_init(&cases);
   bool has_default = false;
   while (p->tok.kind != token_Kind_RBrace) {
      ast_SwitchCase* c = NULL;
      switch (p->tok.kind) {
      case token_Kind_KW_case:
         c = c2_parser_Parser_parseCase(p, false);
         break;
      case token_Kind_KW_default:
         has_default = true;
         c = c2_parser_Parser_parseCase(p, true);
         break;
      default:
         c2_parser_Parser_error(p, "expected 'case' or 'default' keyword");
         break;
      }
      case_list_List_add(&cases, c);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_Stmt* s = ast_builder_Builder_actOnSwitchStmt(p->builder, loc, cond, case_list_List_getData(&cases), case_list_List_size(&cases), has_default);
   case_list_List_free(&cases);
   return s;
}

static void c2_parser_Parser_parseCaseCondition(c2_parser_Parser* p, expr_list_List* list)
{
   for (;;) {
      ast_Expr* e = c2_parser_Parser_parseExpr(p);
      if (p->tok.kind == token_Kind_Ellipsis) {
         src_loc_SrcLoc loc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* e1 = c2_parser_Parser_parseExpr(p);
         e = ast_builder_Builder_actOnRange(p->builder, loc, e, e1);
      }
      expr_list_List_add(list, e);
      if (p->tok.kind == token_Kind_Colon) break;
      c2_parser_Parser_expectAndConsume(p, token_Kind_Comma);
   }
}

static ast_SwitchCase* c2_parser_Parser_parseCase(c2_parser_Parser* p, bool is_default)
{
   src_loc_SrcLoc loc = p->tok.loc;
   c2_parser_Parser_consumeToken(p);
   expr_list_List conds; expr_list_List_init(&conds);
   if (!is_default) {
      c2_parser_Parser_parseCaseCondition(p, &conds);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_Colon);
   stmt_list_List* stmts = c2_parser_Parser_getStmtList(p);
   bool more = true;
   while (more) {
      switch (p->tok.kind) {
      case token_Kind_RBrace:
      case token_Kind_KW_case:
      case token_Kind_KW_default:
         more = false;
         break;
      default:
         stmt_list_List_add(stmts, c2_parser_Parser_parseStmt(p));
         break;
      }
   }
   ast_SwitchCase* s = ast_builder_Builder_actOnCase(p->builder, loc, is_default, expr_list_List_getData(&conds), expr_list_List_size(&conds), stmt_list_List_getData(stmts), stmt_list_List_size(stmts));
   expr_list_List_free(&conds);
   c2_parser_Parser_putStmtList(p);
   return s;
}

static void c2_parser_Parser_parseTypeDecl(c2_parser_Parser* p, bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   c2_parser_Parser_expectIdentifier(p);
   uint32_t type_name = p->tok.name_idx;
   src_loc_SrcLoc type_loc = p->tok.loc;
   const char* name = string_pool_Pool_idx2str(p->pool, type_name);
   if (!isupper(name[0]) && !p->is_interface) c2_parser_Parser_error(p, "a type name must start with an upper case character");
   c2_parser_Parser_consumeToken(p);
   switch (p->tok.kind) {
   case token_Kind_KW_fn:
      c2_parser_Parser_parseFunctionType(p, type_name, type_loc, is_public);
      break;
   case token_Kind_KW_struct:
      c2_parser_Parser_parseStructType(p, true, type_name, type_loc, is_public);
      break;
   case token_Kind_KW_union:
      c2_parser_Parser_parseStructType(p, false, type_name, type_loc, is_public);
      break;
   case token_Kind_KW_enum:
      c2_parser_Parser_parseEnumType(p, type_name, type_loc, is_public);
      break;
   default:
      c2_parser_Parser_parseAliasType(p, type_name, type_loc, is_public);
      break;
   }
}

static void c2_parser_Parser_parseFunctionType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   ast_TypeRefHolder rtype; ast_TypeRefHolder_init(&rtype);
   c2_parser_Parser_parseSingleTypeSpecifier(p, &rtype);
   ast_DeclList params; ast_DeclList_init(&params);
   bool is_variadic = c2_parser_Parser_parseFunctionParams(p, &params, is_public, false);
   ast_Decl* ftd = ast_builder_Builder_actOnFunctionTypeDecl(p->builder, name, loc, is_public, &rtype, (ast_VarDecl**)ast_DeclList_getDecls(&params), ast_DeclList_size(&params), is_variadic);
   uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
   ast_DeclList_free(&params);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   c2_parser_Parser_applyAttributes(p, ftd, num_attr);
}

static void c2_parser_Parser_parseStructType(c2_parser_Parser* p, bool is_struct, uint32_t name, src_loc_SrcLoc loc, bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
   ast_DeclList members; ast_DeclList_init(&members);
   if (p->tok.kind == token_Kind_LBrace) {
      c2_parser_Parser_parseStructBlock(p, &members, is_public);
   } else if (p->tok.kind == token_Kind_Semicolon) {
      if (!p->is_interface) c2_parser_Parser_error(p, "undefined structs are only allowed in interface files");
      if (!ast_builder_Builder_hasOpaqueAttr(p->builder)) c2_parser_Parser_error(p, "undefined structs must have the opaque attribute");
      c2_parser_Parser_consumeToken(p);
   }
   ast_StructTypeDecl* d = ast_builder_Builder_actOnStructType(p->builder, name, loc, is_public, is_struct, true, ast_DeclList_getDecls(&members), ast_DeclList_size(&members));
   ast_DeclList_free(&members);
   c2_parser_Parser_applyAttributes(p, (ast_Decl*)d, num_attr);
}

static void c2_parser_Parser_checkMemberName(c2_parser_Parser* p)
{
   uint32_t name = p->tok.name_idx;
   if (!c2_parser_Parser_checkName(p, name, p->is_interface)) {
      c2_parser_Parser_error(p, "a struct/union member name must start with a lower case character");
   }
   if (p->tok.reserved) {
      diagnostics_Diags_error(p->diags, p->tok.loc, "reserved word '%s' cannot be used as struct/union member name", string_pool_Pool_idx2str(p->pool, name));
   }
}

static void c2_parser_Parser_parseStructBlock(c2_parser_Parser* p, ast_DeclList* members, bool is_public)
{
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   while (1) {
      if (p->tok.kind == token_Kind_RBrace) break;
      if (p->tok.kind == token_Kind_KW_union || p->tok.kind == token_Kind_KW_struct) {
         bool is_struct = p->tok.kind == token_Kind_KW_struct;
         c2_parser_Parser_consumeToken(p);
         uint32_t name = 0;
         src_loc_SrcLoc loc = 0;
         if (p->tok.kind == token_Kind_Identifier) {
            name = p->tok.name_idx;
            loc = p->tok.loc;
            c2_parser_Parser_checkMemberName(p);
            c2_parser_Parser_consumeToken(p);
         }
         ast_DeclList sub_members; ast_DeclList_init(&sub_members);
         c2_parser_Parser_parseStructBlock(p, &sub_members, is_public);
         ast_StructTypeDecl* member = ast_builder_Builder_actOnStructType(p->builder, name, loc, is_public, is_struct, false, ast_DeclList_getDecls(&sub_members), ast_DeclList_size(&sub_members));
         ast_DeclList_free(&sub_members);
         ast_DeclList_add(members, ast_StructTypeDecl_asDecl(member));
         continue;
      }
      if (p->tok.kind == token_Kind_KW_fn) {
         c2_parser_Parser_consumeToken(p);
         ast_TypeRefHolder rtype; ast_TypeRefHolder_init(&rtype);
         c2_parser_Parser_parseSingleTypeSpecifier(p, &rtype);
         ast_DeclList params; ast_DeclList_init(&params);
         bool is_variadic = c2_parser_Parser_parseFunctionParams(p, &params, is_public, false);
         ast_Decl* fd = ast_builder_Builder_actOnFunctionType(p->builder, &rtype, (ast_VarDecl**)ast_DeclList_getDecls(&params), ast_DeclList_size(&params), is_variadic, ast_DefKind_StructMember);
         ast_DeclList_free(&params);
         ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
         ast_TypeRefHolder_setFunction(&ref, (ast_Decl*)fd);
         if (p->tok.kind == token_Kind_LSquare) {
            c2_parser_Parser_error(p, "arrays are not allowed for untyped function type members");
         }
         c2_parser_Parser_expectIdentifier(p);
         uint32_t name = p->tok.name_idx;
         src_loc_SrcLoc loc = p->tok.loc;
         c2_parser_Parser_checkMemberName(p);
         c2_parser_Parser_consumeToken(p);
         ast_VarDecl* member = ast_builder_Builder_actOnStructMember(p->builder, name, loc, is_public, &ref, NULL);
         ast_DeclList_add(members, ast_VarDecl_asDecl(member));
         goto semi_colon;
      }
      ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
      c2_parser_Parser_parseTypeSpecifier(p, &ref);
      for (;;) {
         uint32_t name = 0;
         src_loc_SrcLoc loc;
         if (p->tok.kind == token_Kind_Colon) {
            loc = p->tok.loc;
         } else {
            c2_parser_Parser_expectIdentifier(p);
            name = p->tok.name_idx;
            loc = p->tok.loc;
            c2_parser_Parser_checkMemberName(p);
            c2_parser_Parser_consumeToken(p);
         }
         ast_Expr* bitfield = NULL;
         if (p->tok.kind == token_Kind_Colon) {
            c2_parser_Parser_consumeToken(p);
            bitfield = c2_parser_Parser_parseExpr(p);
         }
         ast_VarDecl* member = ast_builder_Builder_actOnStructMember(p->builder, name, loc, is_public, &ref, bitfield);
         ast_DeclList_add(members, ast_VarDecl_asDecl(member));
         if (p->tok.kind != token_Kind_Comma) break;
         c2_parser_Parser_consumeToken(p);
         if (ast_TypeRefHolder_isPointer(&ref) || ast_TypeRefHolder_isArray(&ref)) c2_parser_Parser_error(p, "pointer and array members must be defined separately");
      }
   semi_colon:
      c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
}

static void c2_parser_Parser_parseEnumType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, bool is_public)
{
   c2_parser_Parser_consumeToken(p);
   switch (p->tok.kind) {
   case token_Kind_KW_char:
   case token_Kind_KW_f32:
   case token_Kind_KW_f64:
      c2_parser_Parser_error(p, "enum type must be an integer");
      break;
   case token_Kind_KW_i8:
   case token_Kind_KW_i16:
   case token_Kind_KW_i32:
   case token_Kind_KW_i64:
   case token_Kind_KW_isize:
      break;
   case token_Kind_KW_reg8:
   case token_Kind_KW_reg16:
   case token_Kind_KW_reg32:
   case token_Kind_KW_reg64:
      c2_parser_Parser_error(p, "enum type must be an integer");
      break;
   case token_Kind_KW_u8:
   case token_Kind_KW_u16:
   case token_Kind_KW_u32:
   case token_Kind_KW_u64:
   case token_Kind_KW_usize:
      break;
   case token_Kind_KW_void:
      c2_parser_Parser_error(p, "enum type must be an integer");
      break;
   default:
      c2_parser_Parser_error(p, "expected enum type specifier");
      break;
   }
   ast_QualType implType = ast_builder_Builder_actOnBuiltinType(p->builder, c2_parser_tokKindToBuiltinKind(p->tok.kind));
   c2_parser_Parser_consumeToken(p);
   uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_LBrace);
   bool is_incr = false;
   ast_DeclList constants; ast_DeclList_init(&constants);
   if (p->tok.kind == token_Kind_Plus) {
      is_incr = true;
      c2_parser_Parser_consumeToken(p);
   } else {
      while (p->tok.kind == token_Kind_Identifier) {
         uint32_t const_name = p->tok.name_idx;
         const char* name_str = string_pool_Pool_idx2str(p->pool, const_name);
         if (islower(name_str[0])) {
            c2_parser_Parser_error(p, "an enum constant name must start with an upper case character");
         }
         src_loc_SrcLoc const_loc = p->tok.loc;
         c2_parser_Parser_consumeToken(p);
         ast_Expr* init_expr = NULL;
         if (p->tok.kind == token_Kind_Equal) {
            c2_parser_Parser_consumeToken(p);
            init_expr = c2_parser_Parser_parseExpr(p);
         }
         ast_EnumConstantDecl* constant = ast_builder_Builder_actOnEnumConstant(p->builder, const_name, const_loc, is_public, init_expr);
         ast_DeclList_add(&constants, ast_EnumConstantDecl_asDecl(constant));
         if (p->tok.kind != token_Kind_Comma) break;
         c2_parser_Parser_consumeToken(p);
      }
      if (ast_DeclList_size(&constants) == 0) {
         c2_parser_Parser_error(p, "enum without constants");
      }
   }
   c2_parser_Parser_expectAndConsume(p, token_Kind_RBrace);
   ast_Decl* d = ast_builder_Builder_actOnEnumType(p->builder, name, loc, is_public, is_incr, implType, (ast_EnumConstantDecl**)ast_DeclList_getDecls(&constants), ast_DeclList_size(&constants));
   ast_DeclList_free(&constants);
   c2_parser_Parser_applyAttributes(p, d, num_attr);
}

static void c2_parser_Parser_parseAliasType(c2_parser_Parser* p, uint32_t name, src_loc_SrcLoc loc, bool is_public)
{
   ast_TypeRefHolder ref; ast_TypeRefHolder_init(&ref);
   c2_parser_Parser_parseTypeSpecifier(p, &ref);
   ast_Decl* d = ast_builder_Builder_actOnAliasType(p->builder, name, loc, is_public, &ref);
   uint32_t num_attr = c2_parser_Parser_parseOptionalAttributes(p);
   c2_parser_Parser_expectAndConsume(p, token_Kind_Semicolon);
   c2_parser_Parser_applyAttributes(p, d, num_attr);
}


// --- module compiler ---
typedef struct compiler_PluginHandler_ compiler_PluginHandler;
typedef struct compiler_Options_ compiler_Options;
typedef struct compiler_Compiler_ compiler_Compiler;

typedef void (*compiler_BeginTargetFn)(void* arg, plugin_info_Info* info);

typedef void (*compiler_PluginFn)(void* arg);

struct compiler_PluginHandler_ {
   compiler_BeginTargetFn start_target;
   compiler_PluginFn after_parsing;
   compiler_PluginFn after_analysis;
   compiler_PluginFn end_target;
   void* arg;
};

struct compiler_Options_ {
   bool bootstrap;
   bool check_only;
   bool print_ast;
   bool print_ast_early;
   bool fast_build;
   bool test_mode;
   bool print_lib_ast;
   bool print_modules;
   bool print_symbols;
   bool print_external_symbols;
   bool print_ast_stats;
   uint8_t print_reports;
   bool show_libs;
   bool print_ir;
   bool print_all_ir;
   bool trace_calls;
   bool asan;
   bool msan;
   bool ubsan;
   const char* libdir;
   const char* target_triple;
};

struct compiler_Compiler_ {
   string_pool_Pool* auxPool;
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   build_file_Info* build_info;
   build_target_Target* target;
   const compiler_Options* opts;
   target_info_Info targetInfo;
   compiler_PluginHandler* pluginHandler;
   ast_context_Context* context;
   string_pool_Pool* astPool;
   ast_builder_Builder* builder;
   attr_handler_Handler* attr_handler;
   module_list_List allmodules;
   component_List components;
   keywords_Info kwinfo;
   c2_parser_Parser* parser;
   module_analyser_Analyser* analyser;
   bool is_image;
   component_Component* mainComp;
   uint32_t main_idx;
   uint32_t libc_name;
   uint32_t c2_name;
   ast_Decl* mainFunc;
   module_list_List parse_queue;
   string_list_List libdirs;
   component_Component* current;
};

static const char compiler_C2_trace[5073] = "/* Copyright 2022-2026 Bas van den Berg, Charlie Gordon\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nmodule c2_trace;\n\nimport c2_trace_tables local;\nimport stdio local;\nimport stdlib local;\nimport string local;\n\nfn bool match_name(const char *name, const char *pattern) {\n    for (;;) {\n        char c1, c2;\n        while ((c1 = *name++) == (c2 = *pattern++)) {\n            if (!c1) return true;\n        }\n        if (c2 == '?') {\n            if (c1) continue;\n            return false;\n        }\n        if (c2 == '*') {\n            c2 = *pattern++;\n            if (!c2 || c2 == ',' || c2 == ';') return true;\n            for (; c1; c1 = *name++) {\n                if (c1 == c2 && match_name(name, pattern)) return true;\n            }\n            return false;\n        }\n        return (!c1 && (c2 == ',' || c2 == ';'));\n    }\n}\n\nfn bool match_pattern(const char *name, const char *pattern) {\n    if (!pattern || !*pattern) return true;\n    for (const char *p = pattern; *p;) {\n        if (match_name(name, p)) return true;\n        char c;\n        while ((c = *p++) != 0 && c != ',' && c != ';') continue;\n        if (c != ',') break;\n    }\n    return false;\n}\n\nfn i32 cmp_funcs(const void *a, const void *b) {\n    const c2_trace_t *aa = a;\n    const c2_trace_t *bb = b;\n    const c2_func_t *fa = &c2_func_data[aa.callee_idx];\n    const c2_func_t *fb = &c2_func_data[bb.callee_idx];\n    if (fa.count != fb.count)\n        return fa.count < fb.count ? 1 : -1;\n    if (fa != fb)\n        return strcmp(fa.funcname, fb.funcname);\n    return (aa.count < bb.count) - (aa.count > bb.count);\n}\n\nfn i32 cmp_calls(const void *a, const void *b) {\n    const c2_trace_t *aa = a;\n    const c2_trace_t *bb = b;\n    return (aa.count < bb.count) - (aa.count > bb.count);\n}\n\nfn void list_calls() @(destructor, unused) {\n    const char *p = getenv(\"C2_TRACE\");\n    const char *pattern = nil;\n    const char *filename = nil;\n    const char *caller = nil;\n    if (!p || !*p) return;\n    u32 min = 1, min2 = 1;\n    i32 pos = 0, mode = 3, fd = 1, indent = 2;\n    for (; *p; p += pos) {\n        for (pos = 0;;) {\n            sscanf(p, \" min%*1[=]%n%u\", &pos, &min);\n            if (pos) break;\n            sscanf(p, \" min2%*1[=]%n%u\", &pos, &min2);\n            if (pos) break;\n            sscanf(p, \" indent%*1[=]%n%u\", &pos, &indent);\n            if (pos) break;\n            sscanf(p, \" mode%*1[=]%n%d\", &pos, &mode);\n            if (pos) break;\n            sscanf(p, \" fd%*1[=]%n%d\", &pos, &fd);\n            if (pos) break;\n            sscanf(p, \" name%*1[=]%n\", &pos);\n            if (pos) { pattern = p + pos; break; }\n            sscanf(p, \" filename%*1[=]%n\", &pos);\n            if (pos) { filename = p + pos; break; }\n            sscanf(p, \" caller%*1[=]%n\", &pos);\n            if (pos) { caller = p + pos; break; }\n            sscanf(p, \"%*[^;=]%*1[=]%n\", &pos);\n            break;\n        }\n        if (!pos) pattern = p;\n        while (p[pos] && p[pos++] != ';') continue;\n    }\n    if (!mode) return;\n    u32 *counts = c2_trace_counts;\n    c2_trace_t* data = c2_trace_data;\n    u32 n = c2_trace_length;\n    for (u32 i = 0; i < n; i++) {\n        c2_trace_t *cp = &data[i];\n        if (match_pattern(c2_func_data[cp.callee_idx].funcname, pattern)\n        &&  match_pattern(c2_filenames[cp.filename_idx], filename)\n        &&  match_pattern(c2_func_data[cp.caller_idx].funcname, caller)) {\n            cp.count = counts[i];\n            c2_func_data[cp.callee_idx].count += counts[i];\n        }\n    }\n    if (mode == 2) {\n        qsort(data, n, sizeof(c2_trace_t), cmp_calls);\n        indent = 0;\n        min2 = min;\n    } else {\n        qsort(data, n, sizeof(c2_trace_t), cmp_funcs);\n    }\n    c2_func_t *last = nil;\n    i32 show = 0;\n    for (u32 i = 0; i < n; i++) {\n        c2_trace_t *cp = &data[i];\n        c2_func_t *func = &c2_func_data[cp.callee_idx];\n        u32 count1 = func.count;\n        u32 count2 = cp.count;\n        if (count1 < min) continue;\n        if (func != last) {\n            show = mode & 2;\n            if (mode & 1) {\n                dprintf(fd, \"%.*s%s: %d call%.*s\\n\", show, \"\\n\",\n                        func.funcname, count1, count1 != 1, \"s\");\n            }\n            last = func;\n        }\n        if (show && count2 >= min2) {\n            dprintf(fd, \"%*s%s:%d:%d: %s: %d call%.*s from %s\\n\",\n                    indent, \"\",\n                    c2_filenames[cp.filename_idx], cp.line, cp.column,\n                    func.funcname, count2, count2 != 1, \"s\",\n                    c2_func_data[cp.caller_idx].funcname);\n        }\n    }\n}\n";
static void compiler_build(string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler);
static component_Kind compiler_target2compKind(build_target_Kind k);
static void compiler_Compiler_build(compiler_Compiler* c, string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler, plugin_info_Info* info);
static void compiler_Compiler_free(compiler_Compiler* c);
static bool compiler_Compiler_parseMainComponent(compiler_Compiler* c);
static component_Component* compiler_Compiler_findModuleComponent(const compiler_Compiler* c, uint32_t name_idx);
static void compiler_Compiler_add_source(void* arg, const char* name, string_buffer_Buf* content);
static bool compiler_Compiler_register_attr(void* arg, uint32_t name, ast_AttrHandlerFn handler, void* arg2);
static void compiler_Compiler_analyseModule(void* arg, ast_Module* m);
static void compiler_Compiler_analyseUsedModule(void* arg, ast_Module* m);
static void compiler_Compiler_findTopModule(void* arg, ast_Module* m);
static void compiler_Compiler_addFeature(compiler_Compiler* c, const char* str, const char* value);
static void compiler_Compiler_addGlobalDefine(compiler_Compiler* c, const char* prefix, const char* tail);
static void compiler_Compiler_addLibPath(void* arg, const char* path, uint32_t len);
static void compiler_Compiler_generate(compiler_Compiler* c, const char* target_name, const char* output_dir);
static void compiler_getNativeTarget(target_info_Info* info);
static bool compiler_fromString(target_info_Info* info, const char* triple);
static component_Kind compiler_convertKind(build_target_Kind kind);
static void compiler_Compiler_createComponent(compiler_Compiler* c, uint32_t name, component_Kind kind);
static void compiler_Compiler_onLib(void* arg, uint32_t name, build_target_Kind kind);
static void compiler_Compiler_load_libs(compiler_Compiler* c);
static void compiler_Compiler_open_lib(compiler_Compiler* c, component_Component* comp);
static bool compiler_Compiler_has_component(const compiler_Compiler* c, uint32_t name);
static bool compiler_Compiler_find_lib(const compiler_Compiler* c, const char* libname, char* libdir, size_t size);
static void compiler_Compiler_parseExternalModule(void* arg, ast_Module* m);
static void compiler_Compiler_parse_lib(compiler_Compiler* c, component_Component* comp);
static void compiler_parseSourceLibFile(void* arg, const char* filename, uint32_t src_loc);
static void compiler_Compiler_parseSourceLibs(compiler_Compiler* c);
static void compiler_Compiler_showAllLibs(compiler_Compiler* c);
static void compiler_Compiler_showLibs(compiler_Compiler* c, string_buffer_Buf* out, const char* dirname, bool show_modules);
static bool compiler_Compiler_analyse(compiler_Compiler* c);
static bool compiler_Compiler_checkDuplicateModules(compiler_Compiler* c);
static bool compiler_Compiler_analyseSourceImports(compiler_Compiler* c);
static void compiler_Compiler_handleModuleImports(void* arg, ast_Module* m);
static void compiler_Compiler_handleImport(void* arg, ast_ImportDecl* id);
static bool compiler_Compiler_check_exports(compiler_Compiler* c);
static void compiler_Compiler_analyse_component(compiler_Compiler* c, component_Component* comp);
static void compiler_Compiler_checkMain(compiler_Compiler* c);
static void compiler_Compiler_checkUnused(void* arg, ast_Module* m);

static void compiler_build(string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler)
{
   compiler_Compiler c = { };
   plugin_info_Info info = { };
   compiler_Compiler_build(&c, auxPool, sm, diags, build_info, target, opts, pluginHandler, &info);
   if (opts->print_reports) {
      source_mgr_SourceMgr_report(c.sm, opts->print_reports > 1);
      ast_context_Context_report(c.context);
      string_pool_Pool_report(c.astPool, "astPool");
      string_pool_Pool_report(c.auxPool, "auxPool");
   }
   diagnostics_Diags_printStatus(diags);
   pluginHandler->end_target(pluginHandler->arg);
   ast_deinit(c.opts->print_ast_stats);
   compiler_Compiler_free(&c);
}

static component_Kind compiler_target2compKind(build_target_Kind k)
{
   switch (k) {
   case build_target_Kind_Image:
      return component_Kind_Image;
   case build_target_Kind_Executable:
      return component_Kind_Executable;
   case build_target_Kind_StaticLibrary:
      return component_Kind_StaticLibrary;
   case build_target_Kind_DynamicLibrary:
      return component_Kind_DynamicLibrary;
   case build_target_Kind_SourceLibrary:
      return component_Kind_SourceLibrary;
   }
   return component_Kind_Executable;
}

static void compiler_Compiler_build(compiler_Compiler* c, string_pool_Pool* auxPool, source_mgr_SourceMgr* sm, diagnostics_Diags* diags, build_file_Info* build_info, build_target_Target* target, const compiler_Options* opts, compiler_PluginHandler* pluginHandler, plugin_info_Info* info)
{
   memset(c, 0, 992);
   c->auxPool = auxPool;
   c->sm = sm;
   c->diags = diags;
   c->build_info = build_info;
   c->target = target;
   c->opts = opts;
   c->pluginHandler = pluginHandler;
   if (opts->bootstrap) build_target_Target_disableWarnings(c->target);
   diagnostics_Diags_setWarningAsError(diags, build_target_Target_getWarnings(target)->are_errors);
   diagnostics_Diags_clear(c->diags);
   c->context = ast_context_create(16 * 1024);
   c->astPool = string_pool_create(128 * 1024, 4096);
   keywords_Info_init(&c->kwinfo, c->astPool);
   c->main_idx = string_pool_Pool_addStr(c->astPool, "main", true);
   uint32_t c2_idx = string_pool_Pool_addStr(c->astPool, "c2", true);
   c->libc_name = string_pool_Pool_addStr(c->auxPool, "libc", true);
   c->c2_name = string_pool_Pool_addStr(c->auxPool, "c2", true);
   module_list_List_init(&c->parse_queue, false, 64);
   c->attr_handler = attr_handler_create(diags, build_target_Target_getWarnings(target));
   c->builder = ast_builder_create(c->context, diags, c->auxPool, c2_idx, c->main_idx, c->attr_handler);
   module_list_List_init(&c->allmodules, false, 128);
   component_List_init(&c->components);
   c->is_image = build_target_Target_getKind(target) == build_target_Kind_Image;
   string_list_List_init(&c->libdirs, c->auxPool);
   const char* target_str = opts->target_triple;
   const char* output_base = constants_output_dir;
   if (c->build_info) {
      const char* output_dir2 = build_file_Info_getOutputDir(c->build_info);
      if (output_dir2) {
         console_debug("using output dir: %s", output_dir2);
         output_base = output_dir2;
      }
   }
   if (!opts->show_libs) string_list_List_add(&c->libdirs, string_pool_Pool_addStr(c->auxPool, output_base, true));
   if (c->build_info) {
      const string_list_List* dirs = build_file_Info_getLibDirs(c->build_info);
      for (uint32_t i = 0; i < string_list_List_length(dirs); i++) {
         string_list_List_add(&c->libdirs, string_list_List_get_idx(dirs, i));
      }
      target_str = build_file_Info_getTarget(c->build_info);
   } else {
      if (c->is_image) {
         console_error("images require a build-file");
         exit(-1);
      }
      if (c->opts->libdir) {
         string_utils_split_paths(c->opts->libdir, c, compiler_Compiler_addLibPath);
      }
      compiler_getNativeTarget(&c->targetInfo);
   }
   if (target_str) {
      if (!compiler_fromString(&c->targetInfo, target_str)) {
         console_error("invalid target triple: %s", target_str);
         exit(-1);
      }
   } else {
      compiler_getNativeTarget(&c->targetInfo);
   }
   console_debug("triple: %s", target_info_Info_str(&c->targetInfo));
   if (opts->bootstrap) compiler_Compiler_addFeature(c, "BOOTSTRAP", "1");
   compiler_Compiler_addGlobalDefine(c, "SYSTEM", target_info_Info_getSystemName(&c->targetInfo));
   compiler_Compiler_addGlobalDefine(c, "ARCH", target_info_Info_getArchName(&c->targetInfo));
   if (c->targetInfo.intWidth == 64) {
      compiler_Compiler_addFeature(c, "ARCH_64BIT", "1");
   } else {
      compiler_Compiler_addFeature(c, "ARCH_32BIT", "1");
   }
   if (opts->asan) compiler_Compiler_addFeature(c, "__ASAN__", "1");
   if (opts->msan) compiler_Compiler_addFeature(c, "__MSAN__", "1");
   if (opts->ubsan) compiler_Compiler_addFeature(c, "__UBSAN__", "1");
   compiler_Compiler_addFeature(c, "USE_NATIVE_CTYPES", "1");
   c->parser = c2_parser_create(sm, diags, c->astPool, c->builder, &c->kwinfo, build_target_Target_getFeatures(target));
   ast_initialize(c->context, c->astPool, c->targetInfo.intWidth / 8, color_useColor());
   c->analyser = module_analyser_create(c->diags, c->context, c->astPool, c->builder, &c->allmodules, build_target_Target_getWarnings(c->target));
   if (opts->show_libs) {
      compiler_Compiler_showAllLibs(c);
      exit(0);
   }
   c->mainComp = component_create(c->context, c->auxPool, build_target_Target_getNameIdx(target), compiler_target2compKind(build_target_Target_getKind(target)));
   if (!build_target_Target_getNoLibC(target) && !build_target_Target_hasLib(c->target, c->libc_name)) component_Component_addDep(c->mainComp, c->libc_name);
   component_List_add(&c->components, c->mainComp);
   component_Component_addDep(c->mainComp, c->c2_name);
   ast_builder_Builder_setComponent(c->builder, c->mainComp);
   if (component_Component_isSourceLib(c->mainComp)) {
      for (uint32_t i = 0; i < build_target_Target_numFiles(c->target); i++) {
         const file_list_File* f = build_target_Target_getFile(c->target, i);
         component_Component_addFile(c->mainComp, f->name, f->loc);
      }
   }
   compiler_Compiler_load_libs(c);
   info->sm = sm;
   info->diags = diags;
   info->target = target;
   info->components = &c->components;
   info->ast_globals = ast_getGlobals();
   info->astPool = c->astPool;
   info->auxPool = c->auxPool;
   info->context = c->context;
   info->builder = c->builder;
   info->addSource = compiler_Compiler_add_source;
   info->register_attr = compiler_Compiler_register_attr;
   info->fn_arg = c;
   strcpy(info->target_name, string_pool_Pool_idx2str(c->auxPool, build_target_Target_getNameIdx(target)));
   if (!file_utils_make_path(info->output_dir, 512, output_base, string_pool_Pool_idx2str(c->auxPool, build_target_Target_getNameIdx(target))) || file_utils_create_path(info->output_dir)) {
      console_error("cannot create directory %s: %s", info->output_dir, strerror((*__errno_location())));
      exit(-1);
   }
   pluginHandler->start_target(pluginHandler->arg, info);
   if (!compiler_Compiler_parseMainComponent(c)) return;
   if (opts->print_ast_early) {
      component_Component_print(c->mainComp, true);
      return;
   }
   ast_builder_Builder_setComponent(c->builder, c->mainComp);
   pluginHandler->after_parsing(pluginHandler->arg);
   compiler_Compiler_parseSourceLibs(c);
   if (!compiler_Compiler_analyse(c)) return;
   if (c->opts->print_modules) {
      for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
         component_Component_printModules(component_List_get(&c->components, i));
      }
      return;
   }
   if (c->opts->print_symbols | c->opts->print_external_symbols) {
      for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
         component_Component_printSymbols(component_List_get(&c->components, i), c->opts->print_external_symbols);
      }
      return;
   }
   if (opts->print_ast) component_Component_print(c->mainComp, true);
   if (c->opts->check_only) return;
   compiler_Compiler_generate(c, info->target_name, info->output_dir);
}

static void compiler_Compiler_free(compiler_Compiler* c)
{
   module_list_List_free(&c->parse_queue);
   component_List_free(&c->components);
   module_analyser_Analyser_free(c->analyser);
   c2_parser_Parser_free(c->parser);
   module_list_List_free(&c->allmodules);
   ast_builder_Builder_free(c->builder);
   attr_handler_Handler_free(c->attr_handler);
   string_pool_Pool_free(c->astPool);
   ast_context_Context_free(c->context);
   string_list_List_free(&c->libdirs);
}

static bool compiler_Compiler_parseMainComponent(compiler_Compiler* c)
{
   console_debug("parsing %s", string_pool_Pool_idx2str(c->auxPool, build_target_Target_getNameIdx(c->target)));
   uint64_t t1_start = utils_now();
   for (uint32_t j = 0; j < build_target_Target_numFiles(c->target); j++) {
      const file_list_File* f = build_target_Target_getFile(c->target, j);
      int32_t file_id = source_mgr_SourceMgr_loadFile(c->sm, string_pool_Pool_idx2str(c->auxPool, f->name), f->loc);
      if (file_id == -1) return false;
      console_debug("parsing %s", source_mgr_SourceMgr_getFileName(c->sm, file_id));
      c2_parser_Parser_parse(c->parser, file_id, false, false);
   }
   if (c->opts->trace_calls) {
      int32_t file_id = source_mgr_SourceMgr_addResource(c->sm, "generator/c2_trace.c2", compiler_C2_trace, 5073 - 1);
      if (file_id == -1) return false;
      console_debug("parsing %s", source_mgr_SourceMgr_getFileName(c->sm, file_id));
      c2_parser_Parser_parse(c->parser, file_id, false, false);
   }
   uint64_t t1_end = utils_now();
   console_log_time("parsing", t1_end - t1_start);
   return diagnostics_Diags_isOk(c->diags);
}

static component_Component* compiler_Compiler_findModuleComponent(const compiler_Compiler* c, uint32_t name_idx)
{
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      module_list_List* mod_list = component_Component_getModules(comp);
      ast_Module** mods = module_list_List_get(mod_list);
      for (uint32_t j = 0; j < module_list_List_length(mod_list); j++) {
         if (ast_Module_getNameIdx(mods[j]) == name_idx) return comp;
      }
   }
   return NULL;
}

static void compiler_Compiler_add_source(void* arg, const char* name, string_buffer_Buf* content)
{
   compiler_Compiler* c = arg;
   uint32_t size;
   void* data = string_buffer_Buf_detach(content, &size);
   int32_t file_id = source_mgr_SourceMgr_addGenerated(c->sm, name, data, size);
   c2_parser_Parser_parse(c->parser, file_id, false, true);
}

static bool compiler_Compiler_register_attr(void* arg, uint32_t name, ast_AttrHandlerFn handler, void* arg2)
{
   compiler_Compiler* c = arg;
   return attr_handler_Handler_register(c->attr_handler, name, handler, arg2);
}

static void compiler_Compiler_analyseModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   console_debug("analysing module %s", ast_Module_getName(m));
   module_analyser_Analyser_check(c->analyser, m);
}

static void compiler_Compiler_analyseUsedModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   if (ast_Module_isUsed(m)) {
      module_analyser_Analyser_check(c->analyser, m);
   }
}

static void compiler_Compiler_findTopModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   if (ast_Module_isUsed(m)) return;
   if (c->mainFunc) return;
   c->mainFunc = module_analyser_Analyser_findMain(c->analyser, m, c->main_idx);
}

static void compiler_Compiler_addFeature(compiler_Compiler* c, const char* str, const char* value)
{
   build_target_Target_addFeature(c->target, string_pool_Pool_addStr(c->auxPool, str, true));
}

static void compiler_Compiler_addGlobalDefine(compiler_Compiler* c, const char* prefix, const char* tail)
{
   char tmp[32];
   snprintf(tmp, 32, "%s_%s", prefix, tail);
   for (size_t i = 0; tmp[i]; i++) {
      uint8_t ch = (uint8_t)tmp[i];
      tmp[i] = (ch == '-') ? '_' : (char)toupper(ch);
   }
   compiler_Compiler_addFeature(c, tmp, "1");
}

static void compiler_Compiler_addLibPath(void* arg, const char* path, uint32_t len)
{
   compiler_Compiler* c = arg;
   uint32_t path_idx = string_pool_Pool_add(c->auxPool, path, len, true);
   string_list_List_add(&c->libdirs, path_idx);
}

static void compiler_Compiler_generate(compiler_Compiler* c, const char* target_name, const char* output_dir)
{
   component_Component* mainComp = component_List_getLast(&c->components);
   generator_utils_mark_used(mainComp, &c->allmodules, c->opts->test_mode);
   if (component_Component_isSourceLib(c->mainComp)) {
      console_error("Source library generator unavailable");
      return;
   }
   if (string_list_List_length(build_target_Target_getExports(c->target))) {
      console_error("C2i generator unavailable");
   }
   switch (build_target_Target_getBackEnd(c->target)) {
   case build_target_BackEndKind_None:
      break;
   case build_target_BackEndKind_C: {
      console_debug("generating C");
      uint64_t gen3 = utils_now();
      string_list_List asm_files;
      string_list_List_init(&asm_files, c->auxPool);
      for (uint32_t i = 0; i < build_target_Target_numAsmFiles(c->target); i++) {
         const file_list_File* file = build_target_Target_getAsmFile(c->target, i);
         string_list_List_add(&asm_files, file->name);
      }
      c_generator_generate(c->astPool, c->auxPool, target_name, build_target_Target_getKind(c->target), output_dir, c->diags, c->sm, c->build_info, &c->targetInfo, &c->components, c->mainFunc, &asm_files, build_target_Target_hasAsserts(c->target), build_target_Target_getFastBuild(c->target) | c->opts->fast_build, c->opts->asan, c->opts->msan, c->opts->ubsan, c->opts->test_mode, c->opts->trace_calls);
      string_list_List_free(&asm_files);
      uint64_t gen4 = utils_now();
      console_log_time("C generation", gen4 - gen3);
      if (!build_target_Target_getNoBuild(c->target) && !c->opts->test_mode) {
         console_debug("building C");
         gen3 = utils_now();
         c_generator_build(output_dir);
         gen4 = utils_now();
         console_log_time("C compilation", gen4 - gen3);
      }
      break;
   }
   case build_target_BackEndKind_IR:
      console_error("IR generator unavailable");
      break;
   }
}

static void compiler_getNativeTarget(target_info_Info* info)
{
   utsname un;
   if (uname(&un) != 0) {
      console_error("error getting system info: %s", strerror((*__errno_location())));
      exit(stdlib_EXIT_FAILURE);
   }
   info->sys = target_info_str2sys(un.sysname);
   switch (info->sys) {
   case target_info_System_Unknown:
      console_error("unsupported system: '%s'", un.sysname);
      exit(stdlib_EXIT_FAILURE);
      break;
   case target_info_System_Linux:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_GNU;
      break;
   case target_info_System_Darwin:
      info->vendor = target_info_Vendor_Apple;
      info->abi = target_info_Abi_MACHO;
      break;
   case target_info_System_Cygwin:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_WIN32;
      break;
   case target_info_System_FreeBSD:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_BSD;
      break;
   case target_info_System_OpenBSD:
      info->vendor = target_info_Vendor_Unknown;
      info->abi = target_info_Abi_BSD;
      break;
   }
   info->arch = target_info_str2arch(un.machine);
   if (info->arch == target_info_Arch_Unknown) {
      console_error("unsupported arch: '%s'", un.machine);
      exit(stdlib_EXIT_FAILURE);
   }
   target_info_Info_init(info);
}

static bool compiler_fromString(target_info_Info* info, const char* triple)
{
   char arch_str[32];
   char vendor_str[32];
   char sys_str[32];
   char abi_str[32];
   uint32_t pos = 0;
   if (sscanf(triple, "%31[^-]-%31[^-]-%31[^-]-%31[^-]%n", arch_str, vendor_str, sys_str, abi_str, &pos) != 4 || triple[pos] != '\0') return false;
   info->arch = target_info_str2arch(arch_str);
   if (info->arch == target_info_Arch_Unknown) {
      console_error("unsupported arch: %s", arch_str);
      return false;
   }
   info->vendor = target_info_str2vendor(vendor_str);
   info->sys = target_info_str2sys(sys_str);
   if (info->sys == target_info_System_Unknown) {
   }
   info->abi = target_info_str2abi(abi_str);
   if (info->abi == target_info_Abi_Unknown) {
      console_error("unsupported ABI: %s", abi_str);
      return false;
   }
   target_info_Info_init(info);
   return true;
}

static component_Kind compiler_convertKind(build_target_Kind kind)
{
   switch (kind) {
   case build_target_Kind_Image:
   case build_target_Kind_Executable:
      ;//assert(0);
      break;
   case build_target_Kind_StaticLibrary:
      return component_Kind_ExternalStaticLib;
   case build_target_Kind_DynamicLibrary:
      return component_Kind_ExternalDynamicLib;
   case build_target_Kind_SourceLibrary:
      return component_Kind_ExternalSourceLib;
   }
   return component_Kind_StaticLibrary;
}

static void compiler_Compiler_createComponent(compiler_Compiler* c, uint32_t name, component_Kind kind)
{
   component_Component* comp = component_create(c->context, c->auxPool, name, kind);
   component_List_add(&c->components, comp);
   if (name != c->c2_name) component_Component_addDep(comp, c->c2_name);
}

static void compiler_Compiler_onLib(void* arg, uint32_t name, build_target_Kind kind)
{
   compiler_Compiler* c = arg;
   if (kind == build_target_Kind_DynamicLibrary && c->is_image) {
      console_error("images cannot use dynamic libraries");
      exit(stdlib_EXIT_FAILURE);
   }
   if (build_target_Target_getNoLibC(c->target) && name == c->libc_name) {
      console_error("cannot use libc and have nolibc");
      exit(stdlib_EXIT_FAILURE);
   }
   component_Component_addDep(c->mainComp, name);
   compiler_Compiler_createComponent(c, name, compiler_convertKind(kind));
}

static void compiler_Compiler_load_libs(compiler_Compiler* c)
{
   compiler_Compiler_createComponent(c, c->c2_name, component_Kind_ExternalDynamicLib);
   build_target_Target_visitLibs(c->target, compiler_Compiler_onLib, c);
   if (!build_target_Target_getNoLibC(c->target)) {
      if (!build_target_Target_hasLib(c->target, c->libc_name)) {
         compiler_Compiler_createComponent(c, c->libc_name, component_Kind_ExternalDynamicLib);
      }
   }
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      if (component_Component_isExternal(comp)) compiler_Compiler_open_lib(c, comp);
   }
   component_sorter_sort(component_List_get_all(&c->components), component_List_size(&c->components), c->diags);
}

static void compiler_Compiler_open_lib(compiler_Compiler* c, component_Component* comp)
{
   const char* libstr = component_Component_getName(comp);
   console_debug("opening lib %s", libstr);
   char libdir[512];
   if (!compiler_Compiler_find_lib(c, libstr, libdir, 512)) {
      console_error("cannot find library '%s'", libstr);
      exit(stdlib_EXIT_FAILURE);
   }
   char fullname[512];
   if (!file_utils_make_path(fullname, 512, libdir, constants_manifest_name)) return;
   int32_t file_id = source_mgr_SourceMgr_loadFile(c->sm, fullname, 0);
   if (file_id == -1) return;
   uint32_t dirname = string_pool_Pool_addStr(c->auxPool, libdir, false);
   component_Component_setPath(comp, dirname);
   string_list_List mods; string_list_List_init(&mods, c->astPool);
   bool ok = manifest_parse(c->sm, file_id, c->astPool, c->auxPool, comp, &mods);
   if (!ok) {
      exit(stdlib_EXIT_FAILURE);
   }
   for (uint32_t i = 0; i < string_list_List_length(&mods); i++) {
      uint32_t mod_name = string_list_List_get_idx(&mods, i);
      ast_Module* m = component_Component_getOrAddModule(comp, mod_name, false);
      ;//assert(m);
      ast_Module_setForeign(m, component_Component_isForeign(comp));
   }
   string_list_List_free(&mods);
   const string_list_List* deps = component_Component_getDeps(comp);
   for (uint32_t i = 0; i < string_list_List_length(deps); i++) {
      uint32_t depname = string_list_List_get_idx(deps, i);
      if (compiler_Compiler_has_component(c, depname)) continue;
      if (build_target_Target_getNoLibC(c->target) && depname == c->libc_name) {
         console_error("cannot use %s since it depends on unused libc", component_Component_getName(comp));
         exit(stdlib_EXIT_FAILURE);
      }
      compiler_Compiler_createComponent(c, depname, component_Kind_ExternalDynamicLib);
   }
}

static bool compiler_Compiler_has_component(const compiler_Compiler* c, uint32_t name)
{
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      const component_Component* comp = component_List_get(&c->components, i);
      if (component_Component_getNameIdx(comp) == name) return true;
   }
   return false;
}

static bool compiler_Compiler_find_lib(const compiler_Compiler* c, const char* libname, char* libdir, size_t size)
{
   for (uint32_t i = 0; i < string_list_List_length(&c->libdirs); i++) {
      const char* dirname = string_list_List_get(&c->libdirs, i);
      if (file_utils_make_path(libdir, size, dirname, libname)) {
         char path[512];
         if (file_utils_make_path(path, 512, libdir, constants_manifest_name) && file_utils_is_file(path)) return true;
      }
   }
   return false;
}

static void compiler_Compiler_parseExternalModule(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   if (!ast_Module_isUsed(m)) return;
   char filename[512];
   if (!file_utils_make_path_ext(filename, 512, component_Component_getPath(c->current), ast_Module_getName(m), ".c2i")) return;
   int32_t file_id = source_mgr_SourceMgr_loadFile(c->sm, filename, 0);
   if (file_id == -1) return;
   ast_Module_setLoaded(m);
   console_debug("parsing %s", filename);
   c2_parser_Parser_parse(c->parser, file_id, true, false);
}

static void compiler_Compiler_parse_lib(compiler_Compiler* c, component_Component* comp)
{
   if (component_Component_isExternalSourceLib(comp)) return;
   console_debug("parsing component %s", component_Component_getName(comp));
   c->current = comp;
   ast_builder_Builder_setComponent(c->builder, comp);
   module_list_List_clear(&c->parse_queue);
   module_list_List* mods = component_Component_getModules(comp);
   for (uint32_t i = 0; i < module_list_List_length(mods); i++) {
      ast_Module* m = module_list_List_at(mods, i);
      if (ast_Module_isUsed(m)) module_list_List_add(&c->parse_queue, m);
   }
   for (uint32_t i = 0; i < module_list_List_length(&c->parse_queue); i++) {
      ast_Module* m = module_list_List_at(&c->parse_queue, i);
      compiler_Compiler_parseExternalModule(c, m);
      ast_Module_visitImports(m, compiler_Compiler_handleImport, c);
   }
}

static void compiler_parseSourceLibFile(void* arg, const char* filename, uint32_t src_loc)
{
   compiler_Compiler* c = arg;
   source_mgr_SourceMgr* sm = c->sm;
   char fullname[512];
   if (!file_utils_make_path(fullname, 512, component_Component_getPath(c->current), filename)) return;
   int32_t file_id = source_mgr_SourceMgr_loadFile(sm, fullname, src_loc);
   if (file_id == -1) return;
   console_debug("parsing %s", fullname);
   c2_parser_Parser_parse(c->parser, file_id, false, false);
}

static void compiler_Compiler_parseSourceLibs(compiler_Compiler* c)
{
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      if (!component_Component_isExternalSourceLib(comp)) continue;
      console_debug("parsing source lib %s", component_Component_getName(comp));
      c->current = comp;
      ast_builder_Builder_setComponent(c->builder, comp);
      component_Component_visitFiles(comp, c, compiler_parseSourceLibFile);
   }
}

static void compiler_Compiler_showAllLibs(compiler_Compiler* c)
{
   string_buffer_Buf* out = string_buffer_create(1024, color_useColor(), 2);
   string_buffer_Buf_add(out, "libraries:\n");
   bool show_modules = false;
   for (uint32_t i = 0; i < string_list_List_length(&c->libdirs); i++) {
      compiler_Compiler_showLibs(c, out, string_list_List_get(&c->libdirs, i), show_modules);
   }
   puts(string_buffer_Buf_data(out));
   string_buffer_Buf_free(out);
}

static void compiler_Compiler_showLibs(compiler_Compiler* c, string_buffer_Buf* out, const char* dirname, bool show_modules)
{
   string_buffer_Buf_indent(out, 1);
   string_buffer_Buf_color(out, color_Blue);
   string_buffer_Buf_add(out, dirname);
   string_buffer_Buf_color(out, color_Normal);
   string_buffer_Buf_newline(out);
   DIR* dir = opendir(dirname);
   if (dir == NULL) {
      console_error("cannot open library dir '%s': %s", dirname, strerror((*__errno_location())));
      return;
   }
   {
      dirent* entry;
      while ((entry = readdir(dir))) {
         char fullname[512];
         const char* name = entry->d_name;
         if (name[0] != '.' && entry->d_type == libc_dirent_DT_DIR) {
            if (!file_utils_make_path3(fullname, 512, dirname, name, constants_manifest_name) || !file_utils_is_file(fullname)) continue;
            string_buffer_Buf_indent(out, 2);
            string_buffer_Buf_print(out, "%-20s", name);
            {
               int32_t file_id = source_mgr_SourceMgr_loadFile(c->sm, fullname, 0);
               if (file_id == -1) return;
               uint32_t name_idx = string_pool_Pool_addStr(c->auxPool, name, true);
               component_Component* comp = component_create(c->context, c->auxPool, name_idx, component_Kind_ExternalStaticLib);
               string_list_List mods; string_list_List_init(&mods, c->auxPool);
               manifest_parse(c->sm, file_id, c->astPool, c->auxPool, comp, &mods);
               component_List_add(&c->components, comp);
               string_list_List_free(&mods);
               string_buffer_Buf_add(out, "  ");
               string_buffer_Buf_color(out, color_Yellow);
               if (component_Component_isAvailableStatic(comp)) {
                  string_buffer_Buf_add(out, "static ");
               } else {
                  string_buffer_Buf_add(out, "       ");
               }
               if (component_Component_isAvailableDynamic(comp)) {
                  string_buffer_Buf_add(out, "dynamic ");
               } else {
                  string_buffer_Buf_add(out, "        ");
               }
               if (component_Component_isAvailableSource(comp)) {
                  string_buffer_Buf_add(out, "source");
               } else {
                  string_buffer_Buf_add(out, "      ");
               }
               const string_list_List* deps = component_Component_getDeps(comp);
               uint32_t num_deps = string_list_List_length(deps);
               if (num_deps) {
                  string_buffer_Buf_add(out, "  ");
                  string_buffer_Buf_color(out, color_Magenta);
                  string_buffer_Buf_add(out, "requires: ");
                  for (uint32_t i = 0; i < num_deps; i++) {
                     if (i != 0) string_buffer_Buf_add(out, ", ");
                     string_buffer_Buf_add(out, string_list_List_get(deps, i));
                  }
               }
               string_buffer_Buf_color(out, color_Normal);
               string_buffer_Buf_newline(out);
            }
         }
      }
   }
   closedir(dir);
}

static bool compiler_Compiler_analyse(compiler_Compiler* c)
{
   uint64_t analysis_start = utils_now();
   if (!compiler_Compiler_checkDuplicateModules(c)) return false;
   if (!compiler_Compiler_analyseSourceImports(c)) return false;
   if (!compiler_Compiler_check_exports(c)) return false;
   for (uint32_t i = component_List_size(&c->components); i != 0; i--) {
      component_Component* comp = component_List_get(&c->components, i - 1);
      if (!component_Component_isExternal(comp)) continue;
      compiler_Compiler_parse_lib(c, comp);
   }
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      console_debug("analysing component %s", component_Component_getName(comp));
      compiler_Compiler_analyse_component(c, comp);
      if (diagnostics_Diags_hasErrors(c->diags)) break;
   }
   if (diagnostics_Diags_hasErrors(c->diags)) {
      if (c->opts->print_ast) component_Component_print(c->mainComp, true);
      return false;
   }
   compiler_Compiler_checkMain(c);
   const warning_flags_Flags* warnings = build_target_Target_getWarnings(c->target);
   if (!warnings->no_unused) {
      component_Component_visitModules(c->mainComp, compiler_Compiler_checkUnused, c);
   }
   uint64_t analysis_end = utils_now();
   console_log_time("analysis", analysis_end - analysis_start);
   if (!diagnostics_Diags_isOk(c->diags)) return false;
   ast_builder_Builder_setComponent(c->builder, c->mainComp);
   c->pluginHandler->after_analysis(c->pluginHandler->arg);
   if (component_Component_isLibrary(c->mainComp) || component_Component_isExternalSourceLib(c->mainComp)) {
   }
   return true;
}

static bool compiler_Compiler_checkDuplicateModules(compiler_Compiler* c)
{
   module_list_List_clear(&c->allmodules);
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      module_list_List* mod_list = component_Component_getModules(comp);
      ast_Module** mods = module_list_List_get(mod_list);
      for (uint32_t j = 0; j < module_list_List_length(mod_list); j++) {
         ast_Module* m = mods[j];
         if (module_list_List_containsName(&c->allmodules, ast_Module_getNameIdx(m))) {
            component_Component* other = compiler_Compiler_findModuleComponent(c, ast_Module_getNameIdx(m));
            ;//assert(other);
            console_error("module '%s' is defined in component %s and %s", ast_Module_getName(m), component_Component_getName(comp), component_Component_getName(other));
            return false;
         }
         module_list_List_add(&c->allmodules, m);
      }
   }
   module_list_List_clear(&c->allmodules);
   return true;
}

static bool compiler_Compiler_analyseSourceImports(compiler_Compiler* c)
{
   console_debug("analysing imports");
   for (uint32_t i = 0; i < component_List_size(&c->components); i++) {
      component_Component* comp = component_List_get(&c->components, i);
      if (!component_Component_hasSources(comp)) continue;
      module_list_List_clear(&c->allmodules);
      module_list_List_addList(&c->allmodules, component_Component_getModules(comp), false);
      string_list_List* deps = component_Component_getDeps(comp);
      uint32_t num_deps = string_list_List_length(deps);
      const uint32_t* dep_names = string_list_List_getData(deps);
      for (uint32_t j = 0; j < num_deps; j++) {
         component_Component* sub = component_List_find(&c->components, dep_names[j]);
         module_list_List_addList(&c->allmodules, component_Component_getModules(sub), component_Component_isExternalSourceLib(sub));
      }
      c->current = comp;
      component_Component_visitModules(comp, compiler_Compiler_handleModuleImports, c);
      if (!diagnostics_Diags_isOk(c->diags)) return false;
   }
   return true;
}

static void compiler_Compiler_handleModuleImports(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   ast_Module_visitImports(m, compiler_Compiler_handleImport, c);
}

static void compiler_Compiler_handleImport(void* arg, ast_ImportDecl* id)
{
   compiler_Compiler* c = arg;
   if (ast_ImportDecl_getDest(id)) return;
   ast_Decl* d = (ast_Decl*)id;
   uint32_t name_idx = ast_Decl_getNameIdx(d);
   ast_Module* m = module_list_List_find(&c->allmodules, name_idx);
   if (!m) {
      component_Component* comp = compiler_Compiler_findModuleComponent(c, name_idx);
      if (comp) {
         if (component_Component_hasDep(c->current, component_Component_getNameIdx(comp))) {
            diagnostics_Diags_error(c->diags, ast_Decl_getLoc(d), "module '%s' is private to component %s", ast_idx2name(name_idx), component_Component_getName(comp));
         } else {
            diagnostics_Diags_error(c->diags, ast_Decl_getLoc(d), "module '%s' is defined in component %s that is not a dependency of component %s", ast_idx2name(name_idx), component_Component_getName(comp), component_Component_getName(c->current));
         }
      } else {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(d), "unknown module: '%s'", ast_idx2name(name_idx));
      }
      return;
   }
   if (component_Component_isExternal(c->current) && !ast_Module_isLoaded(m)) {
      if (component_Component_hasModule(c->current, m)) {
         if (!ast_Module_isUsed(m)) module_list_List_add(&c->parse_queue, m);
      } else {
      }
   }
   ast_ImportDecl_setDest(id, m);
   ast_Module_setUsed(m);
   ast_Decl_setChecked(d);
   ast_Decl_setType(d, ast_QualType_create((ast_Type*)ast_Module_getType(m)));
}

static bool compiler_Compiler_check_exports(compiler_Compiler* c)
{
   const string_list_List* exports = build_target_Target_getExports(c->target);
   if (c->is_image && string_list_List_length(exports)) {
      console_error("images cannot export modules");
      return false;
   }
   for (uint32_t i = 0; i < string_list_List_length(exports); i++) {
      const char* name = string_list_List_get(exports, i);
      uint32_t name_idx = string_pool_Pool_addStr(c->astPool, name, true);
      ast_Module* m = module_list_List_find(&c->allmodules, name_idx);
      if (m) {
         if (ast_Module_isExternal(m)) {
            console_error("cannot export external module %s", name);
            return false;
         }
         ast_Module_setExported(m);
      } else {
         console_error("cannot export %s, no such module", name);
         return false;
      }
   }
   return true;
}

static void compiler_Compiler_analyse_component(compiler_Compiler* c, component_Component* comp)
{
   module_sorter_sort(comp, c->diags);
   if (component_Component_isExternal(comp)) {
      component_Component_visitModules(comp, compiler_Compiler_analyseUsedModule, c);
      if (c->opts->print_lib_ast) component_Component_print(comp, true);
   } else {
      component_Component_visitModules(comp, compiler_Compiler_analyseModule, c);
   }
}

static void compiler_Compiler_checkMain(compiler_Compiler* c)
{
   component_Component_visitModules(c->mainComp, compiler_Compiler_findTopModule, c);
   if (build_target_Target_needsMain(c->target)) {
      if (!c->mainFunc) {
         if (!c->opts->test_mode) diagnostics_Diags_error(c->diags, 0, "no 'main' function found");
         return;
      }
      if (!ast_Decl_isPublic(c->mainFunc)) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "function 'main' should be declared public");
         return;
      }
      ast_FunctionDecl* main = (ast_FunctionDecl*)c->mainFunc;
      if (!ast_FunctionDecl_hasReturn(main)) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "function 'main' should return 'i32'");
         return;
      }
      ast_QualType rtype = ast_FunctionDecl_getRType(main);
      ast_BuiltinType* bi = ast_QualType_getBuiltin(rtype);
      if (!ast_QualType_isBuiltin(rtype) || !ast_BuiltinType_isInt32(bi)) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "function 'main' should return 'i32'");
         return;
      }
   } else {
      if (c->mainFunc) {
         diagnostics_Diags_error(c->diags, ast_Decl_getLoc(c->mainFunc), "libraries cannot have a 'main' function");
      }
   }
}

static void compiler_Compiler_checkUnused(void* arg, ast_Module* m)
{
   compiler_Compiler* c = arg;
   unused_checker_check(c->diags, build_target_Target_getWarnings(c->target), m);
}


// --- module c2c_main ---
typedef struct c2c_main_Options_ c2c_main_Options;
typedef struct c2c_main_ArgumentParser_ c2c_main_ArgumentParser;
typedef struct c2c_main_Context_ c2c_main_Context;

struct c2c_main_Options_ {
   bool log_verbose;
   bool force_warnings;
   bool print_timing;
   bool show_targets;
   bool show_plugins;
   bool no_plugins;
   bool use_ir_backend;
   bool trace_calls;
   const char* build_file;
   const char* other_dir;
   const char* output_name;
   string_list_List targets;
   string_list_List files;
};

struct c2c_main_ArgumentParser_ {
   int32_t cur;
   int32_t argc;
   char** argv;
   const char* prog;
   const char* help;
};

struct c2c_main_Context_ {
   utils_PathInfo path_info;
   string_pool_Pool* auxPool;
   source_mgr_SourceMgr* sm;
   diagnostics_Diags* diags;
   c2c_main_Options opts;
   compiler_Options comp_opts;
   c2recipe_Recipe* recipe;
   build_file_Info* build_info;
   int32_t recipe_id;
   plugin_mgr_Mgr* plugins;
   const build_target_PluginList* pl;
   compiler_PluginHandler pluginHandler;
   uint32_t plugins_feature;
};

static const char c2c_main_Recipe_help[909] = "---- recipe.txt ----\n\nplugin <name> [<plugin-options>]\n\nconfig <options>\n\nset <name>\n   <.c2 files>\nend\n\nexecutable <name>\n   $optional\n   $warnings <no-unused>\n             <no-unused-variable>\n             <no-unused-function>\n             <no-unused-parameter>\n             <no-unused-type>\n             <no-unused-module>\n             <no-unused-import> \n             <no-unused-public>\n             <no-unused-label> \n             <no-unused-enum-constant>\n             <no-unreachable-code>\n             <promote-to-error> \n   $backend [c|ir] <check>\n                   <fast>\n                   <no-build>\n   $nolibc\n   $disable-asserts\n   $config <options>\n   $plugin <name> [<plugin-options>]\n   $use <library-name> dynamic/static/source\n   (set-name)\n   <file1.c2>\n   <file2.c2>\nend\n\nlib <name> dynamic/static\n   $export <module-names>\n   other options same as executable\nend\n\n--------------------\n";
static const char c2c_main_Usage_help[1718] = "Usage: c2c <options> [<targets>]\n       c2c <options> <filenames>\nOptions:\n  -a                print ASTs\n  -A                print Library ASTs\n  -b [file]         use specified build file\n  -d [dir]          change to [dir] first\n  -h                print this help\n  -i                use IR backend\n  -I                use IR backend and print generated IR\n  -m                print modules\n  -o [file]         force the output name for a single target\n  -r                print reports\n  -s                print symbols\n  -S                print library symbols\n  -t                print timings\n  -T                print AST statistics\n  -v                verbose logging\n  -w                enable all warnings (overrides recipe)\n  --asan            generate code with address sanity checks\n  --msan            generate code with memory sanity checks\n  --ubsan           generate code with undefined behavior sanity checks\n  --bootstrap       define BOOTSTRAP feature and disable unused warnings\n  --check           only parse and check\n  --create [name]   create an empty project recipe.txt and main.c2\n  --fast            do fast, un-optimized build\n  --help            print this help\n  --help-recipe     print the recipe syntax\n  --I2              use IR backend and print generated IR (all versions)\n  --noplugins       do not use plugins\n  --showlibs        print available libraries\n  --showplugins     print available plugins\n  --target triple   cross compile for a specified architecture\n  --targets         show available targets in recipe\n  --test            test mode (do not check for main() function)\n  --trace-calls     generate code that traces function calls\n  --version         print version\n";
static void c2c_main_Options_init(c2c_main_Options* opts, string_pool_Pool* pool);
static void c2c_main_Options_free(c2c_main_Options* opts);
static void c2c_main_write_file_or_die(const char* filename, string_buffer_Buf* buf);
static void c2c_main_create_project(const char* name);
static void c2c_main_print_recipe_help(void);
static void c2c_main_print_version(void);
static void c2c_main_ArgumentParser_init(c2c_main_ArgumentParser* ap, int32_t argc, char** argv, const char* prog, const char* help);
static void c2c_main_ArgumentParser_showHelp(c2c_main_ArgumentParser* ap);
static const char* c2c_main_ArgumentParser_getArgument(c2c_main_ArgumentParser* ap);
static const char* c2c_main_ArgumentParser_getOptionArgument(c2c_main_ArgumentParser* ap, const char* option);
__attribute__((noreturn))
static void c2c_main_ArgumentParser_missingArgument(c2c_main_ArgumentParser* ap, const char* option);
__attribute__((noreturn))
static void c2c_main_ArgumentParser_unknownOption(c2c_main_ArgumentParser* ap, const char* option);
static void c2c_main_parse_long_opt(c2c_main_ArgumentParser* ap, const char* arg, compiler_Options* comp_opts, c2c_main_Options* opts);
static void c2c_main_parse_arguments(c2c_main_ArgumentParser* ap, compiler_Options* comp_opts, c2c_main_Options* opts);
static void c2c_main_plugins_start_target(void* arg, plugin_info_Info* info);
static void c2c_main_plugins_after_parsing(void* arg);
static void c2c_main_plugins_after_analysis(void* arg);
static void c2c_main_plugins_end_target(void* arg);
static void c2c_main_Context_init(c2c_main_Context* c);
static void c2c_main_Context_handle_args(c2c_main_Context* c, int32_t argc, char** argv);
static void c2c_main_on_plugin_dir(void* arg, const char* path, uint32_t size);
static void c2c_main_Context_handle_plugins(c2c_main_Context* c);
static bool c2c_main_Context_build_target(c2c_main_Context* c, build_target_Target* target, const char* target_name);
static bool c2c_main_Context_build_targets(c2c_main_Context* c);
static void c2c_main_Context_free(c2c_main_Context* c);
int32_t main(int32_t argc, char** argv);

static void c2c_main_Options_init(c2c_main_Options* opts, string_pool_Pool* pool)
{
   memset(opts, 0, 80);
   string_list_List_init(&opts->targets, pool);
   string_list_List_init(&opts->files, pool);
}

static void c2c_main_Options_free(c2c_main_Options* opts)
{
   string_list_List_free(&opts->targets);
   string_list_List_free(&opts->files);
}

static void c2c_main_write_file_or_die(const char* filename, string_buffer_Buf* buf)
{
   file_utils_File file; file_utils_File_init(&file, "", filename);
   if (!file_utils_File_write(&file, string_buffer_Buf_data(buf), string_buffer_Buf_size(buf))) {
      console_error("c2c: cannot write to %s: %s", file.path, file_utils_File_getError(&file));
      exit(stdlib_EXIT_FAILURE);
   }
}

static void c2c_main_create_project(const char* name)
{
   if (file_utils_path_exists("main.c2") || file_utils_path_exists("recipe.txt")) {
      console_error("c2c: main.c2 and/or recipe.txt already exist");
      exit(stdlib_EXIT_FAILURE);
   }
   string_buffer_Buf* buf = string_buffer_create(4096, false, 2);
   string_buffer_Buf_print(buf, "module %s_main;\n\npublic fn i32 main(i32 argc, char** argv) {\n\n    return 0;\n}\n", name);
   c2c_main_write_file_or_die("main.c2", buf);
   string_buffer_Buf_clear(buf);
   string_buffer_Buf_print(buf, "plugin deps_generator [all-targets files private]\nplugin refs_generator [all-targets]\n\nexecutable %s\n    $warnings no-unused\n    $backend c\n\n    main.c2\nend\n", name);
   c2c_main_write_file_or_die("recipe.txt", buf);
   string_buffer_Buf_free(buf);
   console_log("created new project files");
   exit(stdlib_EXIT_SUCCESS);
}

static void c2c_main_print_recipe_help(void)
{
   console_log(c2c_main_Recipe_help);
}

static void c2c_main_print_version(void)
{
   console_log("version: unknown");
}

static void c2c_main_ArgumentParser_init(c2c_main_ArgumentParser* ap, int32_t argc, char** argv, const char* prog, const char* help)
{
   ap->cur = 1;
   ap->argc = argc;
   ap->argv = argv;
   ap->prog = prog ? prog : argv[0];
   ap->help = help;
}

static void c2c_main_ArgumentParser_showHelp(c2c_main_ArgumentParser* ap)
{
   if (ap->help) console_log("%s", ap->help);
}

static const char* c2c_main_ArgumentParser_getArgument(c2c_main_ArgumentParser* ap)
{
   return ap->cur < ap->argc ? ap->argv[ap->cur++] : NULL;
}

static const char* c2c_main_ArgumentParser_getOptionArgument(c2c_main_ArgumentParser* ap, const char* option)
{
   if (ap->cur < ap->argc) return ap->argv[ap->cur++];
   c2c_main_ArgumentParser_missingArgument(ap, option);
}

__attribute__((noreturn))
static void c2c_main_ArgumentParser_missingArgument(c2c_main_ArgumentParser* ap, const char* option)
{
   console_error("%s: missing argument for option '%s'", ap->prog, option);
   exit(stdlib_EXIT_FAILURE);
}

__attribute__((noreturn))
static void c2c_main_ArgumentParser_unknownOption(c2c_main_ArgumentParser* ap, const char* option)
{
   console_error("%s: unknown option: '%s'", ap->prog, option);
   exit(stdlib_EXIT_FAILURE);
}

static void c2c_main_parse_long_opt(c2c_main_ArgumentParser* ap, const char* arg, compiler_Options* comp_opts, c2c_main_Options* opts)
{
   switch (c2_strswitch(arg + 2, "\002I2" "\011bootstrap" "\005check" "\006create" "\004fast" "\004help" "\013help-recipe" "\011noplugins" "\010showlibs" "\013showplugins" "\006target" "\007targets" "\004test" "\013trace-calls" "\004asan" "\004msan" "\005ubsan" "\007version")) {
   case 2: // "I2"
      opts->use_ir_backend = true;
      comp_opts->print_all_ir = true;
      break;
   case 3: // "bootstrap"
      comp_opts->bootstrap = true;
      break;
   case 4: // "check"
      comp_opts->check_only = true;
      break;
   case 5: // "create"
      c2c_main_create_project(c2c_main_ArgumentParser_getOptionArgument(ap, arg));
      break;
   case 6: // "fast"
      comp_opts->fast_build = true;
      break;
   case 7: // "help"
      c2c_main_ArgumentParser_showHelp(ap);
      exit(stdlib_EXIT_SUCCESS);
   case 8: // "help-recipe"
      c2c_main_print_recipe_help();
      exit(stdlib_EXIT_SUCCESS);
   case 9: // "noplugins"
      opts->no_plugins = true;
      break;
   case 10: // "showlibs"
      comp_opts->show_libs = true;
      break;
   case 11: // "showplugins"
      opts->show_plugins = true;
      break;
   case 12: // "target"
      comp_opts->target_triple = c2c_main_ArgumentParser_getOptionArgument(ap, arg);
      break;
   case 13: // "targets"
      opts->show_targets = true;
      break;
   case 14: // "test"
      comp_opts->test_mode = true;
      break;
   case 15: // "trace-calls"
      opts->trace_calls = true;
      break;
   case 16: // "asan"
      comp_opts->asan = true;
      break;
   case 17: // "msan"
      comp_opts->msan = true;
      break;
   case 18: // "ubsan"
      comp_opts->ubsan = true;
      break;
   case 19: // "version"
      c2c_main_print_version();
      exit(stdlib_EXIT_SUCCESS);
   default:
      c2c_main_ArgumentParser_unknownOption(ap, arg);
   }
}

static void c2c_main_parse_arguments(c2c_main_ArgumentParser* ap, compiler_Options* comp_opts, c2c_main_Options* opts)
{
   {
      const char* arg;
      while ((arg = c2c_main_ArgumentParser_getArgument(ap))) {
         if (arg[0] == '-') {
            if (arg[1] == '-') {
               c2c_main_parse_long_opt(ap, arg, comp_opts, opts);
            } else {
               if (strlen(arg) != 2) c2c_main_ArgumentParser_unknownOption(ap, arg);
               switch (arg[1]) {
               case '0':
                  comp_opts->print_ast_early = true;
                  break;
               case 'A':
                  comp_opts->print_lib_ast = true;
                  break;
               case 'I':
                  opts->use_ir_backend = true;
                  comp_opts->print_ir = true;
                  break;
               case 'S':
                  comp_opts->print_external_symbols = true;
                  break;
               case 'T':
                  comp_opts->print_ast_stats = true;
                  break;
               case 'a':
                  comp_opts->print_ast = true;
                  break;
               case 'b':
                  opts->build_file = c2c_main_ArgumentParser_getOptionArgument(ap, arg);
                  break;
               case 'd':
                  opts->other_dir = c2c_main_ArgumentParser_getOptionArgument(ap, arg);
                  break;
               case '?':
               case 'h':
                  c2c_main_ArgumentParser_showHelp(ap);
                  exit(stdlib_EXIT_SUCCESS);
               case 'i':
                  opts->use_ir_backend = true;
                  break;
               case 'm':
                  comp_opts->print_modules = true;
                  break;
               case 'o':
                  opts->output_name = c2c_main_ArgumentParser_getOptionArgument(ap, arg);
                  break;
               case 'r':
                  comp_opts->print_reports += 1;
                  break;
               case 's':
                  comp_opts->print_symbols = true;
                  break;
               case 't':
                  opts->print_timing = true;
                  break;
               case 'v':
                  opts->log_verbose = true;
                  break;
               case 'w':
                  opts->force_warnings = true;
                  break;
               default:
                  c2c_main_ArgumentParser_unknownOption(ap, arg);
               }
            }
         } else {
            if (string_utils_endsWith(arg, ".c2")) string_list_List_addStr(&opts->files, arg);
            else string_list_List_addStr(&opts->targets, arg);
         }
      }
   }
   uint32_t num_targets = string_list_List_length(&opts->targets);
   uint32_t num_files = string_list_List_length(&opts->files);
   if (num_targets && num_files) {
      console_error("c2c: recipe targets cannot be combined with <files>");
      exit(stdlib_EXIT_FAILURE);
   }
   if (opts->output_name && num_files == 0 && num_targets != 1) {
      console_error("c2c: option -o can only be used for a single target");
      exit(stdlib_EXIT_FAILURE);
   }
}

static void c2c_main_plugins_start_target(void* arg, plugin_info_Info* info)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_beginTarget(plugins, info);
}

static void c2c_main_plugins_after_parsing(void* arg)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_postParse(plugins);
}

static void c2c_main_plugins_after_analysis(void* arg)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_postAnalysis(plugins);
}

static void c2c_main_plugins_end_target(void* arg)
{
   plugin_mgr_Mgr* plugins = arg;
   plugin_mgr_Mgr_endTarget(plugins);
}

static void c2c_main_Context_init(c2c_main_Context* c)
{
   memset(c, 0, 1256);
   c->auxPool = string_pool_create(32 * 1024, 256);
   c->sm = source_mgr_create(c->auxPool);
   c->diags = diagnostics_create(c->sm, color_useColor(), &c->path_info);
   c->recipe = c2recipe_create(c->sm, c->auxPool);
   c2c_main_Options_init(&c->opts, c->auxPool);
   c->recipe_id = -1;
}

static void c2c_main_Context_handle_args(c2c_main_Context* c, int32_t argc, char** argv)
{
   c2c_main_ArgumentParser ap; c2c_main_ArgumentParser_init(&ap, argc, argv, "c2c", c2c_main_Usage_help);
   c2c_main_parse_arguments(&ap, &c->comp_opts, &c->opts);
   console_setTiming(c->opts.print_timing);
   console_setDebug(c->opts.log_verbose);
   if (c->opts.other_dir) {
      if (chdir(c->opts.other_dir)) {
         console_error("c2c: cannot chdir to %s: %s", c->opts.other_dir, strerror((*__errno_location())));
         exit(stdlib_EXIT_FAILURE);
      }
   }
   if (string_list_List_length(&c->opts.files)) {
      const char* basename = file_utils_get_basename(string_list_List_get(&c->opts.files, 0));
      const char* ext = file_utils_get_extension(basename);
      uint32_t target_idx = string_pool_Pool_add(c->auxPool, basename, (uint32_t)(ext - basename), true);
      build_target_BackEndKind backend = build_target_BackEndKind_C;
      if (c->opts.use_ir_backend) backend = build_target_BackEndKind_IR;
      build_target_Target* t = c2recipe_Recipe_addTarget(c->recipe, target_idx, 0, build_target_Kind_Executable);
      build_target_Target_setBackEnd(t, backend);
      for (uint32_t i = 0; i < string_list_List_length(&c->opts.files); i++) build_target_Target_addFile(t, string_list_List_get_idx(&c->opts.files, i), 0);
      build_target_Target_disableWarnings(t);
   } else {
      if (c->opts.use_ir_backend) {
         console_error("c2c: the IR backend is currently experimental and only works on individual files, not recipes");
         exit(stdlib_EXIT_FAILURE);
      }
      if (!utils_findProjectDir(&c->path_info)) {
         console_error("c2c: error: cannot find project root directory\n     c2c requires a %s file in the project root,\n     Use argument -h for c2c usage and a list of available options", constants_recipe_name);
         exit(stdlib_EXIT_FAILURE);
      }
      c->recipe_id = source_mgr_SourceMgr_loadFile(c->sm, constants_recipe_name, 0);
      if (c->recipe_id == -1) exit(stdlib_EXIT_FAILURE);
      if (!c2recipe_Recipe_parse(c->recipe, c->recipe_id)) exit(stdlib_EXIT_FAILURE);
   }
   if (!c->opts.build_file) {
      c->opts.build_file = utils_findBuildFile();
   }
   c->plugins = plugin_mgr_create(c->auxPool, c->opts.print_timing, c->opts.log_verbose, c->opts.no_plugins);
   if (c->opts.build_file) {
      console_log("using build-file %s", c->opts.build_file);
      c->build_info = build_file_parser_parse(c->sm, c->auxPool, c->opts.build_file);
      if (!c->build_info) exit(stdlib_EXIT_FAILURE);
      const string_list_List* plugin_dirs = build_file_Info_getPluginDirs(c->build_info);
      for (uint32_t i = 0; i < string_list_List_length(plugin_dirs); i++) {
         plugin_mgr_Mgr_addPath(c->plugins, string_list_List_get_idx(plugin_dirs, i));
      }
      if (!c->opts.show_plugins) {
         for (uint32_t i = 0; i < build_file_Info_getNumPlugins(c->build_info); i++) {
            const build_file_Plugin* p = build_file_Info_getPlugin(c->build_info, i);
            if (!plugin_mgr_Mgr_loadGlobal(c->plugins, p->name, p->options)) {
               source_mgr_Location loc = source_mgr_SourceMgr_locate(c->sm, p->loc);
               char loc_str[256];
               sprintf(loc_str, "%s:%u:%u", loc.filename, loc.line, loc.column);
               console_error_diag(loc_str, "%s", plugin_mgr_Mgr_getError(c->plugins));
               exit(stdlib_EXIT_FAILURE);
            }
         }
      }
   } else {
      const char* plugin_dir = getenv("C2_PLUGINDIR");
      if (plugin_dir) string_utils_split_paths(plugin_dir, c, c2c_main_on_plugin_dir);
   }
   c->comp_opts.libdir = getenv("C2_LIBDIR");
   if (!c->comp_opts.libdir && !c->opts.build_file) {
      console_warn("environment variable C2_LIBDIR not set!");
   }
}

static void c2c_main_on_plugin_dir(void* arg, const char* path, uint32_t size)
{
   c2c_main_Context* c = arg;
   uint32_t path_idx = string_pool_Pool_add(c->auxPool, path, size, true);
   plugin_mgr_Mgr_addPath(c->plugins, path_idx);
}

static void c2c_main_Context_handle_plugins(c2c_main_Context* c)
{
   if (c->opts.show_plugins) {
      plugin_mgr_Mgr_show(c->plugins);
      exit(stdlib_EXIT_SUCCESS);
   }
   c->pl = c2recipe_Recipe_getPlugins(c->recipe);
   for (uint32_t i = 0; i < build_target_PluginList_size(c->pl); i++) {
      const build_target_Plugin* p = build_target_PluginList_get(c->pl, i);
      if (!plugin_mgr_Mgr_loadGlobal(c->plugins, p->name, p->options)) {
         source_mgr_Location loc = source_mgr_SourceMgr_locate(c->sm, p->loc);
         char loc_str[256];
         sprintf(loc_str, "%s:%u:%u", loc.filename, loc.line, loc.column);
         console_error_diag(loc_str, "%s", plugin_mgr_Mgr_getError(c->plugins));
         exit(stdlib_EXIT_FAILURE);
      }
   }
   c->plugins_feature = string_pool_Pool_addStr(c->auxPool, "C2_PLUGINS", false);
   compiler_PluginHandler pluginHandler = { .start_target = c2c_main_plugins_start_target, .after_parsing = c2c_main_plugins_after_parsing, .after_analysis = c2c_main_plugins_after_analysis, .end_target = c2c_main_plugins_end_target, .arg = c->plugins };
   c->pluginHandler = pluginHandler;
}

static bool c2c_main_Context_build_target(c2c_main_Context* c, build_target_Target* target, const char* target_name)
{
   uint32_t num_errors = diagnostics_Diags_getNumErrors(c->diags);
   if (c->opts.force_warnings) build_target_Target_enableWarnings(target);
   if (c->opts.output_name) {
      console_log("building %s as %s", target_name, c->opts.output_name);
      target_name = c->opts.output_name;
      build_target_Target_setNameIdx(target, string_pool_Pool_addStr(c->auxPool, target_name, true));
   } else {
      console_log("building %s", target_name);
   }
   c->comp_opts.trace_calls = c->opts.trace_calls;
   if (c->opts.trace_calls && build_target_Target_getNoLibC(target)) {
      c->comp_opts.trace_calls = false;
      console_warn("c2c: disabling --trace-calls for nolibc target %s", target_name);
   }
   c->pl = build_target_Target_getPlugins(target);
   for (uint32_t j = 0; j < build_target_PluginList_size(c->pl); j++) {
      const build_target_Plugin* p = build_target_PluginList_get(c->pl, j);
      if (!plugin_mgr_Mgr_loadLocal(c->plugins, p->name, p->options)) {
         source_mgr_Location loc = source_mgr_SourceMgr_locate(c->sm, p->loc);
         char loc_str[256];
         sprintf(loc_str, "%s:%u:%u", loc.filename, loc.line, loc.column);
         console_error_diag(loc_str, "%s", plugin_mgr_Mgr_getError(c->plugins));
         continue;
      }
   }
   if (!c->opts.no_plugins) build_target_Target_addFeature(target, c->plugins_feature);
   if (c->opts.use_ir_backend) build_target_Target_setBackEnd(target, build_target_BackEndKind_IR);
   if (!build_target_Target_hasBackEnd(target) && build_target_Target_getKind(target) != build_target_Kind_SourceLibrary) {
      if (!c->comp_opts.test_mode && !c->comp_opts.check_only) {
         console_error("c2c: no backend for target %s defined in %s", target_name, constants_recipe_name);
         if (c->recipe_id != -1) source_mgr_SourceMgr_clear(c->sm, c->recipe_id);
         return false;
      }
   }
   compiler_build(c->auxPool, c->sm, c->diags, c->build_info, target, &c->comp_opts, &c->pluginHandler);
   if (c->recipe_id != -1) source_mgr_SourceMgr_clear(c->sm, c->recipe_id);
   return diagnostics_Diags_getNumErrors(c->diags) > num_errors;
}

static bool c2c_main_Context_build_targets(c2c_main_Context* c)
{
   bool has_filter = (string_list_List_length(&c->opts.targets) != 0);
   bool hasError = false;
   for (uint32_t i = 0; i < c2recipe_Recipe_numTargets(c->recipe); i++) {
      build_target_Target* target = c2recipe_Recipe_getTarget(c->recipe, i);
      uint32_t target_idx = build_target_Target_getNameIdx(target);
      const char* target_name = string_pool_Pool_idx2str(c->auxPool, target_idx);
      if (has_filter) {
         if (!string_list_List_contains_idx(&c->opts.targets, target_idx)) continue;
         string_list_List_del(&c->opts.targets, target_idx);
      } else {
         if (build_target_Target_getOptional(target)) continue;
      }
      if (c->opts.show_targets) {
         console_log("%s", target_name);
         continue;
      }
      hasError |= c2c_main_Context_build_target(c, target, target_name);
   }
   if (has_filter && string_list_List_length(&c->opts.targets)) {
      for (uint32_t i = 0; i < string_list_List_length(&c->opts.targets); i++) {
         const char* name = string_list_List_get(&c->opts.targets, i);
         console_warn("no such target in %s: %s", constants_recipe_name, name);
      }
   }
   return hasError;
}

static void c2c_main_Context_free(c2c_main_Context* c)
{
   plugin_mgr_Mgr_free(c->plugins);
   if (c->build_info) build_file_Info_free(c->build_info);
   c2recipe_Recipe_free(c->recipe);
   c2c_main_Options_free(&c->opts);
   diagnostics_Diags_free(c->diags);
   source_mgr_SourceMgr_free(c->sm);
   string_pool_Pool_free(c->auxPool);
}

int32_t main(int32_t argc, char** argv)
{
   console_init();
   c2c_main_Context c; c2c_main_Context_init(&c);
   c2c_main_Context_handle_args(&c, argc, argv);
   c2c_main_Context_handle_plugins(&c);
   bool hasError = c2c_main_Context_build_targets(&c);
   c2c_main_Context_free(&c);
   return hasError ? -1 : 0;
}

