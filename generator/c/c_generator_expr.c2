/* Copyright 2022-2026 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c_generator;

import ast local;
import c_prec local;
import string_buffer;

fn void Generator.emitExpr(Generator* gen, string_buffer.Buf* out, Expr* e) {
    gen.emitExpr2(out, e, Assignment);
}

// TODO: use default argument: C_Prec = Assignment
fn void Generator.emitExpr2(Generator* gen, string_buffer.Buf* out, Expr* e, C_Prec prec) {
    switch (e.getKind()) {
    case IntegerLiteral:
        IntegerLiteral* i = (IntegerLiteral*)e;
        i.printLiteral(out, true);
        break;
    case FloatLiteral:
        FloatLiteral* f = (FloatLiteral*)e;
        f.printLiteral(out);
        break;
    case BooleanLiteral:
        BooleanLiteral* b = (BooleanLiteral*)e;
        b.printLiteral(out);
        break;
    case CharLiteral:
        CharLiteral* c = (CharLiteral*)e;
        c.printLiteral(out);
        break;
    case StringLiteral:
        StringLiteral* s = (StringLiteral*)e;
        s.printLiteral(out);
        break;
    case Nil:
        out.add("NULL");
        break;
    case Identifier:
        IdentifierExpr* i = (IdentifierExpr*)e;
        Decl* d = i.getDecl();
        gen.genDeclIfNeeded(d);
        gen.emitDeclName(out, d);
        break;
    case Type:
        gen.emitTypePre(out, e.getType());
        gen.emitTypePost(out, e.getType());
        break;
    case Call:
        if (gen.need_const_expr)
            gen.emitExprValue(out, e);
        else
            gen.emitCall(out, e);
        break;
    case InitList:
        InitListExpr* ile = (InitListExpr*)e;
        out.add1('{');
        u32 num_values = ile.getNumValues();
        Expr** values = ile.getValues();
        bool newlines = false;
        if (num_values > 6) newlines = true;
        if (num_values && values[0].isInitList()) {
            newlines = true;
        }
        if (newlines) out.newline();
        else out.space();
        for (u32 i=0; i<num_values; i++) {
            if (newlines) out.indent(1);
            gen.emitExpr(out, values[i]);
            if (i+1 != num_values) out.add1(',');
            if (newlines) out.newline();
            else out.space();
        }
        out.add1('}');
        break;
    case FieldDesignatedInit:
        gen.emitFieldDesigExpr(out, e);
        break;
    case ArrayDesignatedInit:
        gen.emitArrayDesigExpr(out, e);
        break;
    case BinaryOperator:
        gen.emitBinaryOperator(out, e, prec);
        break;
    case UnaryOperator:
        gen.emitUnaryOperator(out, e, prec);
        break;
    case ConditionalOperator:
        if (prec > Conditional) out.lparen();
        ConditionalOperator* c = (ConditionalOperator*)e;
        gen.emitExpr2(out, c.getCond(), LogicalOr);
        out.add(" ? ");
        gen.emitExpr2(out, c.getLHS(), Comma);
        out.add(" : ");
        gen.emitExpr2(out, c.getRHS(), Conditional);
        if (prec > Conditional) out.rparen();
        break;
    case Builtin:
        gen.emitBuiltinExpr(out, e);
        break;
    case ArraySubscript:
        ArraySubscriptExpr* a = (ArraySubscriptExpr*)e;
        Expr* index = a.getIndex();
        if (index.isBitOffset()) {
            gen.emitBitOffset(out, a.getBase(), index, prec);
        } else {
            gen.emitExpr2(out, a.getBase(), Postfix);
            out.add1('[');
            gen.emitExpr2(out, index, Comma);
            out.add1(']');
        }
        break;
    case Member:
        MemberContext mc = {}
        gen.emitMemberExpr(out, (MemberExpr*)e, &mc);
        break;
    case Paren:
        ParenExpr* p = (ParenExpr*)e;
        out.lparen();
        gen.emitExpr2(out, p.getInner(), Comma);
        out.rparen();
        break;
    case BitOffset:
        // Already handled in ArraySubscript
        assert(0);
        break;
    case ExplicitCast:
        ExplicitCastExpr* c = (ExplicitCastExpr*)e;
        if (prec > Prefix) out.lparen();
        gen.emitCast(out, c.getDestType(), false);
        if (c.getCStyle()) {
            gen.emitExpr2(out, c.getInner(), Prefix);
        } else {
            // TODO remove these parentheses and pass Prefix prec
            out.lparen();
            gen.emitExpr(out, c.getInner());
            out.rparen();
        }
        if (prec > Prefix) out.rparen();
        break;
    case ImplicitCast:
        // TODO some casts might need to be explicit to prevent warnings
        ImplicitCastExpr* i = (ImplicitCastExpr*)e;
        if (i.getKind() == IntegralCast) {
            QualType qt = e.getType();
            if (qt.isFloat32()) {
                if (prec > Prefix) out.lparen();
                gen.emitCast(out, qt, false);
                gen.emitExpr2(out, i.getInner(), Prefix);
                if (prec > Prefix) out.rparen();
                break;
            }
        }
        gen.emitExpr2(out, i.getInner(), prec);
        break;
    case Range:
        if (prec > Assignment) out.lparen();
        const RangeExpr* b = (RangeExpr*)e;
        gen.emitExpr(out, b.getLHS());
        out.add(" ... ");
        gen.emitExpr(out, b.getRHS());
        if (prec > Assignment) out.rparen();
        return;
    case NamedArgument:
        NamedArgument* n = (NamedArgument*)e;
        gen.emitExpr(out, n.getInner());
        break;
    case Alternate:
        const AlternateExpr* n = (AlternateExpr*)e;
        gen.emitExpr(out, n.getGenerated());
        break;
    }
}

fn void Generator.emitBitOffset(Generator* gen, string_buffer.Buf* out, Expr* base, Expr* index, C_Prec prec) {
    // example: a[15:8] -> ((a>>8) & 0xFF)
    BitOffsetExpr* bo = (BitOffsetExpr*)index;
    // TODO use prec to remove these parentheses
    out.lparen();
    out.lparen();  // useless
    gen.emitExpr2(out, base, Shift);
    out.add(">>");
    gen.emitExpr2(out, bo.getRHS(), Additive);
    out.rparen();  // useless
    out.add(" & ");
    u64 mask = 1;
    mask <<= bo.getWidth();
    mask--;
    out.print("0x%x", mask);
    out.rparen();
}

fn void Generator.emitCast(Generator* gen, string_buffer.Buf* out, QualType qt, bool full) {
    out.add1('(');
    gen.emitTypePre(out, qt);
    if (full) gen.emitTypePost(out, qt);
    out.add1(')');
}

fn void Generator.emitBinaryOperator(Generator* gen, string_buffer.Buf* out, Expr* e, C_Prec prec) {
    BinaryOperator* b = (BinaryOperator*)e;
    BinaryOpcode opcode = b.getOpcode();
    C_Prec prec2 = C_Prec_table[opcode];
    bool need_paren = prec > prec2;
    if (need_paren) out.lparen();
    Expr* lhs = b.getLHS();
    gen.emitExpr2(out, lhs, prec2);
    out.space();
    out.add(b.getOpcodeStr());
    out.space();
    Expr* rhs = b.getRHS();
    if (opcode == Assign && rhs.isInitList()) {
        gen.emitCast(out, lhs.getType(), true);
    }
    // enforce left associativity if not assignment
    if (prec2 > Assignment) prec2++;
    gen.emitExpr2(out, rhs, prec2);
    if (need_paren) out.rparen();
}

fn void Generator.emitUnaryOperator(Generator* gen, string_buffer.Buf* out, Expr* e, C_Prec prec) {
    UnaryOperator* u = (UnaryOperator*)e;
    if (u.isBefore()) {
        if (prec > Prefix) out.lparen();
        out.add(u.getOpcodeStr());
        gen.emitExpr2(out, u.getInner(), Prefix);
        if (prec > Prefix) out.rparen();
    } else {
        gen.emitExpr2(out, u.getInner(), Postfix);
        out.add(u.getOpcodeStr());
    }
}

fn void emitDotOrArrow(string_buffer.Buf* out, QualType qt) {
    if (qt.isPointer()) out.add("->");
    else out.add1('.');
}

type MemberContext struct {
    bool need_dot;
    QualType baseType;
    bool is_local;
}

fn void Generator.emitMemberDecl(Generator* gen, string_buffer.Buf* out, Decl* d, MemberContext* mc = nil) {
    switch (d.getKind()) {
    case Function:
        if (mc.need_dot) emitDotOrArrow(out, mc.baseType);
        mc.baseType = d.getType();
        gen.emitCNameMod(out, d, d.getModule());
        break;
    case Import:
        // ignore
        break;
    case StructType:
        // Note: can be substruct here or Type
        if (mc.need_dot) emitDotOrArrow(out, mc.baseType);
        StructTypeDecl* std = (StructTypeDecl*)d;
        // Dont generate anything for Type, will be in prefix
        if (!std.isGlobal()) {
            mc.baseType = d.getType();
            out.add(d.getName());
            mc.need_dot = true;
        }
        break;
    case EnumType:
        // ignore
        gen.genDeclIfNeeded(d);
        break;
    case EnumConstant:
        gen.emitCNameMod(out, d, d.getModule());
        break;
    case FunctionType:
        assert(0);
        break;
    case AliasType:
        gen.emitCNameMod(out, d, d.getModule());
        break;
    case Variable:
        if (mc.need_dot) emitDotOrArrow(out, mc.baseType);
        mc.baseType = d.getType();
        if (mc.is_local) {
            out.add(d.getName());
        } else {
            gen.emitDeclName(out, d);
        }
        mc.need_dot = true;
        mc.is_local = true;
        break;
    }
}

fn void Generator.emitMemberExpr(Generator* gen, string_buffer.Buf* out, MemberExpr* m, MemberContext* mc, bool base_only = false) {
    if (m.hasExpr()) {
        Expr* base = m.getBaseExpr();
        if (base.isIdentifier()) {
            IdentifierExpr* e = (IdentifierExpr*)base;
            gen.emitMemberDecl(out, e.getDecl(), mc);
        } else
        if (base.isMember()) {
            MemberExpr* e = (MemberExpr*)base;
            gen.emitMemberExpr(out, e, mc);
        } else {
            gen.emitExpr2(out, base, Postfix);
            mc.baseType = base.getType();
            mc.need_dot = true;
        }
    } else {
        gen.emitMemberDecl(out, m.getDecl(0), mc);
    }
    // dont switch on final, just generate
    if (!base_only) gen.emitMemberDecl(out, m.getDecl(1), mc);
}

fn void Generator.emitFieldDesigExpr(Generator* gen, string_buffer.Buf* out, Expr* e) {
    // Cannot use printLiteral because expressions need C conversion
    FieldDesignatedInitExpr* fdi = (FieldDesignatedInitExpr*)e;
    out.add1('.');
    out.add(fdi.getFieldName());
    out.add(" = ");
    gen.emitExpr(out, fdi.getInit());
}

fn void Generator.emitArrayDesigExpr(Generator* gen, string_buffer.Buf* out, Expr* e) {
    // Cannot use printLiteral because expressions need C conversion
    ArrayDesignatedInitExpr* ad = (ArrayDesignatedInitExpr*)e;
    out.add1('[');
    gen.emitExpr(out, ad.getDesignator());
    out.add("] = ");
    gen.emitExpr(out, ad.getInit());
}

fn void Generator.emitBuiltinExpr(Generator* gen, string_buffer.Buf* out, Expr* e) {
    BuiltinExpr* b = (BuiltinExpr*)e;
    switch (b.getKind()) {
    case Sizeof:
        Value v = b.getValue();
        out.print("%s", v.str());
/*
        out.add("sizeof(");
        gen.emitExpr(out, b.getInner());
        out.rparen();
*/
        break;
    case Elemsof:
        Value v = b.getValue();
        out.print("%s", v.str());
/*
        // Note: ARRAY_SIZE looks nicer, but doesn't work for elemsof(Enum)
        out.add("ARRAY_SIZE(");
        gen.emitExpr(out, b.getInner());
        out.rparen();
*/
        break;
    case EnumMin:
        Value v = b.getValue();
        out.print("%s", v.str());
        break;
    case EnumMax:
        Value v = b.getValue();
        out.print("%s", v.str());
        break;
    case OffsetOf:
        Value v = b.getValue();
        out.print("%s", v.str());
/*
        out.add("offsetof("); // type, member
        gen.emitExpr(out, b.getInner());
        out.add(", ");
        gen.emitExpr(out, b.getOffsetOfMember());
        out.rparen();
*/
        break;
    case ToContainer:
        out.add("to_container("); // type, member, ptr
        gen.emitExpr(out, b.getInner());
        out.add(", ");
        gen.emitExpr(out, b.getToContainerMember());
        out.add(", ");
        gen.emitExpr(out, b.getToContainerPointer());
        out.rparen();
        break;
    }
}

