/* Copyright 2022-2025 Bas van den Berg
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module c2i_generator;

import ast local;
import string_buffer;

fn void Generator.emitExpr(Generator* gen, string_buffer.Buf* out, const Expr* e) {
    switch (e.getKind()) {
    case IntegerLiteral:
        IntegerLiteral.printLiteral((IntegerLiteral*)e, out, false);
        break;
    case FloatLiteral:
        FloatLiteral.printLiteral((FloatLiteral*)e, out);
        break;
    case BooleanLiteral:
        BooleanLiteral.printLiteral((BooleanLiteral*)e, out);
        break;
    case CharLiteral:
        CharLiteral.printLiteral((CharLiteral*)e, out);
        break;
    case StringLiteral:
        StringLiteral.printLiteral((StringLiteral*)e, out);
        break;
    case Nil:
        out.add("nil");
        break;
    case Identifier:
        // add prefix if external
        const IdentifierExpr* i = (IdentifierExpr*)e;
        Decl* d = i.getDecl();
        if (d.getModule() != gen.mod) {
            out.add(d.getFullName());
        } else {
            out.add(d.getName());
        }
        break;
    case Type:
        // for sizeof/elemsof argument?
        gen.emitTypePre(out, e.getType());
        gen.emitTypePost(out, e.getType());
        break;
    case Call:
        gen.emitCall(out, (CallExpr*)e);
        break;
    case InitList:
        InitListExpr* ile = (InitListExpr*)e;
        out.add1('{');
        u32 num_values = ile.getNumValues();
        Expr** values = ile.getValues();
        bool newlines = false;
        if (num_values > 6) newlines = true;
        if (num_values && values[0].isInitList()) {
            newlines = true;
        }
        if (newlines) out.newline();
        else out.space();
        for (u32 i=0; i<num_values; i++) {
            if (newlines) out.indent(1);
            gen.emitExpr(out, values[i]);
            if (i+1 != num_values) out.add1(',');
            if (newlines) out.newline();
            else out.space();
        }
        out.add1('}');
        break;
    case FieldDesignatedInit:
        gen.emitFieldDesigExpr(out, (FieldDesignatedInitExpr*)e);
        break;
    case ArrayDesignatedInit:
        gen.emitArrayDesigExpr(out, (ArrayDesignatedInitExpr*)e);
        break;
    case BinaryOperator:
        gen.emitBinaryOperator(out, (BinaryOperator*)e);
        break;
    case UnaryOperator:
        gen.emitUnaryOperator(out, (UnaryOperator*)e);
        break;
    case ConditionalOperator:
        ConditionalOperator* c = (ConditionalOperator*)e;
        gen.emitExpr(out, c.getCond());
        out.add(" ? ");
        gen.emitExpr(out, c.getLHS());
        out.add(" : ");
        gen.emitExpr(out, c.getRHS());
        break;
    case Builtin:
        gen.emitBuiltinExpr(out, (BuiltinExpr*)e);
        break;
    case ArraySubscript:
        const ArraySubscriptExpr* a = (ArraySubscriptExpr*)e;
        gen.emitExpr(out, a.getBase());
        out.add1('[');
        gen.emitExpr(out, a.getIndex());
        out.add1(']');
        break;
    case Member:
        gen.emitMemberExpr(out, (MemberExpr*)e);
        break;
    case Paren:
        const ParenExpr* p = (ParenExpr*)e;
        out.lparen();
        gen.emitExpr(out, p.getInner());
        out.rparen();
        break;
    case BitOffset:
        const BitOffsetExpr* bo = (BitOffsetExpr*)e;
        gen.emitExpr(out, bo.getLHS());
        out.add(" : ");
        gen.emitExpr(out, bo.getRHS());
        break;
    case ExplicitCast:
        ExplicitCastExpr* c = (ExplicitCastExpr*)e;
        if (c.getCStyle()) {
            out.add1('(');
            gen.emitTypePre(out, c.getDestType());
            out.add1(')');
            gen.emitExpr(out, c.getInner());
        } else {
            out.add1('(');
            gen.emitTypePre(out, c.getDestType());
            out.add(")(");
            gen.emitExpr(out, c.getInner());
            out.add1(')');
        }
        break;
    case ImplicitCast:
        const ImplicitCastExpr* i = (ImplicitCastExpr*)e;
        gen.emitExpr(out, i.getInner());
        break;
    case Range:
        const RangeExpr* b = (RangeExpr*)e;
        gen.emitExpr(out, b.getLHS());
        out.add(" ... ");
        gen.emitExpr(out, b.getRHS());
        break;
    case NamedArgument:
        NamedArgument.printLiteral((NamedArgument*)e, out);
        break;
    }
}

fn void Generator.emitBinaryOperator(Generator* gen, string_buffer.Buf* out, const BinaryOperator* b) {
    gen.emitExpr(out, b.getLHS());
    out.print(" %s ", b.getOpcodeStr());
    gen.emitExpr(out, b.getRHS());
}

fn void Generator.emitUnaryOperator(Generator* gen, string_buffer.Buf* out, const UnaryOperator* u) {
    if (u.isBefore()) {
        out.add(u.getOpcodeStr());
        gen.emitExpr(out, u.getInner());
    } else {
        gen.emitExpr(out, u.getInner());
        out.add(u.getOpcodeStr());
    }
}

fn void Generator.emitMemberExpr(Generator* gen, string_buffer.Buf* out, const MemberExpr* m) {
    const Expr* base = m.getExprBase();
    if (base) {
        gen.emitExpr(out, base);
    }
    for (u32 i=0; i<m.getNumRefs(); i++) {
        if (i != 0 || base) out.add1('.');
        Ref r = m.getRef(i);
        if (i == 0 && r.decl.getModule() != gen.mod) {
            out.add(r.decl.getFullName());
        } else {
            out.add(r.decl.getName());
        }
    }
}

fn void Generator.emitFieldDesigExpr(Generator* gen, string_buffer.Buf* out, const FieldDesignatedInitExpr* fdi) {
    out.add1('.');
    out.add(fdi.getFieldName());
    out.add(" = ");
    gen.emitExpr(out, fdi.getInit());
}

fn void Generator.emitArrayDesigExpr(Generator* gen, string_buffer.Buf* out, const ArrayDesignatedInitExpr* ad) {
    out.add1('[');
    gen.emitExpr(out, ad.getDesignator());
    out.add("] = ");
    gen.emitExpr(out, ad.getInit());
}

fn void Generator.emitBuiltinExpr(Generator* gen, string_buffer.Buf* out, const BuiltinExpr* b) {
    switch (b.getKind()) {
    case Sizeof:
        out.add("sizeof(");
        gen.emitExpr(out, b.getInner());
        out.rparen();
        break;
    case Elemsof:
    case EnumMin:
    case EnumMax:
    case OffsetOf:
        // TODO: generate c2 source?
        Value v = b.getValue();
        out.print("%s", v.str());
        return;
    case ToContainer:
        out.add("to_container("); // type, member, ptr
        gen.emitExpr(out, b.getInner());
        out.add(", ");
        gen.emitExpr(out, b.getToContainerMember());
        out.add(", ");
        gen.emitExpr(out, b.getToContainerPointer());
        out.rparen();
        break;
    }
}

fn void Generator.emitCall(Generator* gen, string_buffer.Buf* out, const CallExpr* call) {
    // options:
    // - regular (prefix.)name(..)                  -> if external, prefix
    // - struct function a.foo(..)  A.foo(..)       -> if external, prefix
    // - via pointer -> <expr>(..)                  -> ..
    // - template -> not implemented yet

    assert(!call.isTemplateCall()); // TODO

    Expr* func = call.getFunc();
    assert(func.getKind() == ExprKind.ImplicitCast);
    ImplicitCastExpr* ic = (ImplicitCastExpr*)func;
    func = ic.getInner();

    gen.emitExpr(out, func);
    out.lparen();

    // arguments
    u32 num_args = call.getNumArgs();
    Expr** args = ((CallExpr*)call).getArgs();
    for (u32 i=0; i<num_args; i++) {
        if (i != 0) out.add(", ");
        gen.emitExpr(out, args[i]);
    }

    out.rparen();
}
